<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/orange.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/orange.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/orange.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"a-y-1.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="橙的博客">
<meta property="og:url" content="https://a-y-1.github.io/index.html">
<meta property="og:site_name" content="橙的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="橙">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://a-y-1.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>橙的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">橙的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎来到我的博客!(^▽^)</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://a-y-1.github.io/2022/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B004/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/a0.jpg">
      <meta itemprop="name" content="橙">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橙的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B004/" class="post-title-link" itemprop="url">计算机网络自顶向下方法笔记04</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-01 22:07:22" itemprop="dateCreated datePublished" datetime="2022-12-01T22:07:22+08:00">2022-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-13 22:35:46" itemprop="dateModified" datetime="2022-12-13T22:35:46+08:00">2022-12-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p style="text-indent:2em">《计算机网络自顶向下方法》学习笔记04:链路层。</p>
<p style="text-indent:2em">网络层实现的是主机到主机之间的通信。链路层则是解决分组在各段链路上传输的问题。</p>

<h1 id="第五章-链路层"><a href="#第五章-链路层" class="headerlink" title="第五章 链路层"></a>第五章 链路层</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p style="text-indent:2em">在网络中，每一个设备都可以称作是一个<b>节点</b>，包括主机，交换机，WiFi接入点。沿着相邻节点的通信信道称为<b>链路(link)</b>。为了将数据报传输到目的主机，数据包必须经过各段链路传输。链路层主要讨论的就是数据报在链路上传输的问题。在链路层，数据报被添加上首部和尾部(校验位)，被称为<b>帧</b>。链路层主要提供以下的服务，本章也主要介绍以下内容的相关问题：</p>

<ul>
<li>封装成帧：网络层数据报经链路传输之前，需要封装成帧。</li>
<li>链路接入：规定帧在链路上传输的规则(媒体访问控制协议MAC)。</li>
<li>可靠交付：在易于产生高差错率的链路中，可能提供可靠交付服务。由于在运输层也提供了可靠交付的服务，在链路层提供该服务不是必要的，许多链路层协议不提供可靠交付服务。</li>
<li>差错检测和纠正：检测在链路层传输过程中的差错，并可能进行纠错。</li>
</ul>
<p style="text-indent:2em">以上链路层的服务主要在路由器的线路卡或主机的网络适配器中实现的。原来的网络适配器通常是一张卡，可以插入PC的PCI卡槽，现在的网络适配器基本上都综合到了主机的主板。大部分链路层在硬件中实现，但还有一部分在主机CPU的软件实现，因此链路层是整个网络层次中硬件与软件交接的位置。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B004/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://a-y-1.github.io/2022/11/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E5%9B%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/a0.jpg">
      <meta itemprop="name" content="橙">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橙的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E5%9B%9B/" class="post-title-link" itemprop="url">编译原理实验四</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-15 12:30:29" itemprop="dateCreated datePublished" datetime="2022-11-15T12:30:29+08:00">2022-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-15 09:16:44" itemprop="dateModified" datetime="2022-12-15T09:16:44+08:00">2022-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p style="text-indent:2em">cminus-f的词法分析和语法分析部分已经完成，最终得到的是语法分析树。而为了产生目标代码，还需要将语法分析树转为抽象语法树，通过抽象语法分析树生成中间代码(即IR)，最后使用中间代码来进行优化并生成目标代码。在本实验中，只要完成中间表示IR的生成，语法分析树到抽象语法树的转换已经在框架中提供了，而IR代码到目标代码的生成由clang来完成。</p>

<p style="text-indent:2em">生成IR指令的过程为在访问者模式下访问抽象语法树。本次实验要完成的就是访问抽象语法树的相关visit函数，在这些visit函数中要完成IR指令的生成。</p>

<h2 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h2><h3 id="1-使用AST和visit函数生成IR指令"><a href="#1-使用AST和visit函数生成IR指令" class="headerlink" title="1.使用AST和visit函数生成IR指令"></a>1.使用AST和visit函数生成IR指令</h3><p style="text-indent:2em">由于cminus-f的语法还是比lab3中计算器要复杂的多，供参考的抽象语法树的打印代码也还是和生成IR指令由很大差别，在开始编写时存在困难。通过阅读AST的头文件和lab3的visitor.cpp，首先确定了visit函数生成IR指令的过程：</p>

<ul>
<li>visit函数调用当前节点的子节点accept函数，即调用子节点的visit函数</li>
<li>处理当前节点，生成指令</li>
</ul>
<p style="text-indent:2em">若子节点需要向父节点传值，则通过全局变量来实现。在visit节点时还要加入语义分析的部分，判断语义是否正确。</p>

<p style="text-indent:2em">为了进一步弄清楚遍历AST生成IR的过程，在各个visit函数中加入logging信息，也为后续排查错误做好准备。然后首先完成较为简单的表达式处理等部分，通过这个过程逐渐熟悉IR转换和层次关系以及传值的过程，最后完成困难的visit函数。并在实现过程中逐步用简单的cminus程序测试，用logging找到出错的位置，完成逐个函数的设计。</p>

<p style="text-indent:2em">以第一个产生式program->declaration-list为例，首先找到节点的定义，program节点包含一个保存了declaration的vector，因此在visit中要逐个调用这些declaration节点的accept函数。Program只需要产生声明，不需要产生IR，只需要进行语义分析，在语义说明中给出了以下规则：</p>

<ul>
<li>一个程序由一系列声明组成，声明包括了函数声明与变量声明，它们可以以任意顺序排列。</li>
<li>一个程序中至少要有一个声明且最后一个声明必须是 void main(void)形式的函数声明。</li>
</ul>
<p style="text-indent:2em">只需要对第二条进行检查，判断至少有一个声明，且最后一个声明是否是void main(void)形式的函数声明。在Declaration类型的节点中有id和type，进行检查即可，其中type是CminusType类型，在hpp开头枚举。因此Program节点的visit函数如下：</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTProgram &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;Program\n&quot;</span>;</span><br><span class="line">    <span class="comment">//语义检查</span></span><br><span class="line">    <span class="keyword">if</span>(node.declarations.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR: 该程序中没有声明。\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(node.declarations.<span class="built_in">back</span>()-&gt;id==<span class="string">&quot;main&quot;</span>&amp;&amp; node.declarations.<span class="built_in">back</span>()-&gt;type==TYPE_VOID))&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR: 最后一个声明不是void main(void)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//访问declarations子节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> dec: node.declarations)</span><br><span class="line">        dec-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-函数参数的处理"><a href="#2-函数参数的处理" class="headerlink" title="2.函数参数的处理"></a>2.函数参数的处理</h3><p style="text-indent:2em">在编写FunDeclaration和Param的visit函数时，不明确参数具体的处理方法。找到lab3中由clang生成的.ll，对于参数的处理都是先分配空间，然后使用store指令将参数值存入分配好的空间。例如以下程序：</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define i32 @<span class="built_in">callee</span>(i32 %<span class="number">0</span>) #<span class="number">0</span> &#123;</span><br><span class="line">    %<span class="number">2</span> = alloca i32</span><br><span class="line">    store i32 %<span class="number">0</span>, i32* %<span class="number">2</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">但是Param的参数只有id，表示的是源程序中的参数名，对于如何找到这个参数产生了疑惑。重新找到lab3中编写的cpp传参的部分，传参是在函数创建以后，通过Function中的iterator获取得到的。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入callee的BasicBlock中的指令</span></span><br><span class="line">std::vector&lt;Value *&gt; args;                      <span class="comment">//获取函数的形参,通过Function中的iterator</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> arg = callee-&gt;<span class="built_in">arg_begin</span>(); arg != callee-&gt;<span class="built_in">arg_end</span>(); arg++) &#123;</span><br><span class="line">    args.<span class="built_in">push_back</span>(*arg);                       <span class="comment">//* 号运算符是从迭代器中取出迭代器当前指向的元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> mul = builder-&gt;<span class="built_in">create_imul</span>(args[<span class="number">0</span>], <span class="built_in">CONST_INT</span>(<span class="number">110</span>));             <span class="comment">//mul = a*2</span></span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">此处获取参数的部分，是直接按lab3提供的gcd_array.cpp仿照编写的，因为理解不够深入，所以在本实验处理参数时又产生了疑惑。回顾lab3此部分代码后，FunDeclaration中的参数存储的部分就没有问题了。与lab3不同的是，FunDeclaration是逐个调用Param的accept函数，完成存储空间分配的，所以需要一个全局变量在FunDeclaration和Param的visit函数之间传递arg。</p>

<h3 id="3-ASTVar的处理"><a href="#3-ASTVar的处理" class="headerlink" title="3.ASTVar的处理"></a>3.ASTVar的处理</h3><p style="text-indent:2em">根据cminus的语义说明，Var可以是整型变量，浮点变量或数组变量。如果是数组变量，需要判断下标是否为负，如果为负则添加neg_idx_except指令退出程序，否则计算对应元素的地址(gep指令)。如果是数组，则下标可能是个表达式，需要确保表达式的返回结果为整型，然后才能进行取元素的操作。</p>

<p style="text-indent:2em">从上面的语义说明可以理解Var是一种变量。但是下面的赋值语义说明：先找到var代表的变量地址（如果是数组，需要先对下标表达式求值），然后对右侧的表达式进行求值，求值结果将在转换成变量类型后存储在先前找到的地址中。同时，存储在var中的值将作为赋值表达式的求值结果。一开始结合Var节点中含有一个表达式，把这句话错误的理解为了在Var的visit函数内要完成找到地址，求表达式的值并赋值的指令。后来为了进一步理解Var变量的visit函数内要产生什么指令，继续阅读了剩下的产生式，最终找到Var出现的两种情况：</p>

<ul>
<li>expression→var = expression | simple-expression</li>
<li>factor→(expression) | var | call | integer | float</li>
</ul>
<p style="text-indent:2em">这两种情况下对于var的处理是不同的。对于第一种情况，var是赋值表达式的一个组成部分，在访问赋值表达式时，应该访问Var，在全局变量ret中保存Var的地址，然后进行赋值，产生store指令；而第二种情况，应该将Var的值取出保存到ret中，作为因子参与计算表达式的计算。因此访问Var节点时，需要知道是从哪种情况访问的，为此添加一个全局变量ifAssign，如果访问赋值语句，就将该变量置为true，访问Var时返回地址。</p>

<p style="text-indent:2em">解决了以上问题后，就可以根据是否有指向expression的指针判断是否为数组，然后取出相应的值或者地址了。如果是数组，还要对下标进行处理。如果下标为负则终止程序，这可以通过跳转到一个仅含终止指令的exitBasicBlock实现。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ifNegative = builder-&gt;<span class="built_in">create_icmp_lt</span>(idx, <span class="built_in">CONST_INT</span>(<span class="number">0</span>));</span><br><span class="line"><span class="comment">//创建exitBasicBlock和正常继续的BasicBlock</span></span><br><span class="line"><span class="keyword">auto</span> exitBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), node.id + <span class="string">&quot;exit&quot;</span>, func);</span><br><span class="line"><span class="keyword">auto</span> nextBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), node.id + <span class="string">&quot;next&quot;</span>, func);</span><br><span class="line"><span class="comment">//条件跳转指令</span></span><br><span class="line">builder-&gt;<span class="built_in">create_cond_br</span>(ifNegative, exitBB, nextBB);</span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">处理非数组变量比较简单，处理数组变量时又产生了问题，因为数组获取元素地址有两种方式，即lab3中的两种getelementptr，分别需要两个偏移和一个偏移。为了明确如何处理数组，得到数组元素的指针，重新比较两种数组的分配的IR形式：</p>

<ul>
<li>%1  = alloca [10 x i32]</li>
<li>%1 = alloca i32*</li>
</ul>
<p style="text-indent:2em">可以看出，第一种分配的是数组，得到的是指向数组的指针。第二种分配的是指针，这个指针是数组的首地址，返回的值是一个指向指针的指针。因此取元素地址时，使用第一种分配方式，直接对%1使用两个偏移的getelementptr，就得到了元素的地址；使用第二种分配方式，需要先使用load取出指针(数组首地址)，然后使用一个偏移获取元素地址。因此在Var的visit函数中，处理如下：</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> var = scope.<span class="built_in">find</span>(node.id);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	处理非数组，数组下标，检查下标不为负....</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//如果var的值是指向数组的指针，需要两个偏移取地址</span></span><br><span class="line"><span class="keyword">if</span>(var-&gt;<span class="built_in">get_type</span>()-&gt;<span class="built_in">get_pointer_element_type</span>()-&gt;<span class="built_in">is_array_type</span>())</span><br><span class="line">    builder-&gt;<span class="built_in">create_gep</span>(var, &#123; <span class="built_in">CONST_INT</span>(<span class="number">0</span>), idx &#125;);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(var-&gt;<span class="built_in">get_type</span>()-&gt;<span class="built_in">get_pointer_element_type</span>()-&gt;<span class="built_in">is_pointer_type</span>())&#123;</span><br><span class="line">    <span class="comment">//从var中取出数组的起始地址</span></span><br><span class="line">    var = builder-&gt;<span class="built_in">create_load</span>(var);          <span class="comment">//a[]的地址</span></span><br><span class="line">    var = builder-&gt;<span class="built_in">create_gep</span>(var, &#123; idx &#125;);  <span class="comment">//a[idx]的地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ERROR: 变量&quot;</span> &lt;&lt; node.id &lt;&lt; <span class="string">&quot;不是一个数组\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">处理好以上两个问题后，剩下的部分就比较简单了。最终完整的Var的visit函数如下：</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTVar &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;Var\n&quot;</span>;</span><br><span class="line">    <span class="comment">//先在作用域找到变量</span></span><br><span class="line">    <span class="keyword">auto</span> var = scope.<span class="built_in">find</span>(node.id);</span><br><span class="line">    <span class="keyword">if</span>(var==<span class="literal">nullptr</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR: 未声明的变量&quot;</span> &lt;&lt; node.id &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">//处理不是数组的情况</span></span><br><span class="line">    <span class="keyword">if</span>(node.expression==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ifAssign)&#123;                             <span class="comment">//直接返回地址</span></span><br><span class="line">            ret = var;</span><br><span class="line">            ifAssign = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//数组的指针即a[]类型就返回数组的起始地址，否则load取值</span></span><br><span class="line">            <span class="keyword">if</span>(var-&gt;<span class="built_in">get_type</span>()-&gt;<span class="built_in">get_pointer_element_type</span>()-&gt;<span class="built_in">is_array_type</span>())</span><br><span class="line">                ret = builder-&gt;<span class="built_in">create_gep</span>(var, &#123;<span class="built_in">CONST_INT</span>(<span class="number">0</span>), <span class="built_in">CONST_INT</span>(<span class="number">0</span>)&#125;);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ret = builder-&gt;<span class="built_in">create_load</span>(var);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理数组的情况</span></span><br><span class="line">    node.expression-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    Value *idx = ret;                             <span class="comment">//下标</span></span><br><span class="line">    <span class="keyword">if</span>(idx-&gt;<span class="built_in">get_type</span>()-&gt;<span class="built_in">is_float_type</span>())          <span class="comment">//如果为浮点类型，转换为整型</span></span><br><span class="line">        idx = builder-&gt;<span class="built_in">create_fptosi</span>(idx, INT32_Type);</span><br><span class="line">    <span class="keyword">auto</span> func = builder-&gt;<span class="built_in">get_insert_block</span>()-&gt;<span class="built_in">get_parent</span>();</span><br><span class="line">    <span class="keyword">auto</span> ifNegative = builder-&gt;<span class="built_in">create_icmp_lt</span>(idx, <span class="built_in">CONST_INT</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//创建exitBasicBlock和正常继续的BasicBlock</span></span><br><span class="line">    <span class="keyword">auto</span> exitBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), node.id + <span class="string">&quot; exit&quot;</span>, func);</span><br><span class="line">    <span class="keyword">auto</span> nextBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), node.id + <span class="string">&quot; next&quot;</span>, func);</span><br><span class="line">    <span class="comment">//条件跳转指令</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_cond_br</span>(ifNegative, exitBB, nextBB);</span><br><span class="line">    <span class="comment">//向exitBB插入退出程序的指令</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(exitBB);</span><br><span class="line">    <span class="keyword">auto</span> fail = scope.<span class="built_in">find</span>(<span class="string">&quot;neg_idx_except&quot;</span>);               </span><br><span class="line">    builder-&gt;<span class="built_in">create_call</span>(<span class="built_in">static_cast</span>&lt;Function*&gt;(fail), &#123;&#125;); </span><br><span class="line">    builder-&gt;<span class="built_in">create_br</span>(nextBB);</span><br><span class="line">    <span class="comment">//向nextBB插入正常执行的指令</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(nextBB);</span><br><span class="line">    <span class="comment">//如果var的值是指向数组的指针，需要两个偏移取地址</span></span><br><span class="line">    <span class="keyword">if</span>(var-&gt;<span class="built_in">get_type</span>()-&gt;<span class="built_in">get_pointer_element_type</span>()-&gt;<span class="built_in">is_array_type</span>())</span><br><span class="line">        builder-&gt;<span class="built_in">create_gep</span>(var, &#123; <span class="built_in">CONST_INT</span>(<span class="number">0</span>), idx &#125;);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(var-&gt;<span class="built_in">get_type</span>()-&gt;<span class="built_in">get_pointer_element_type</span>()-&gt;<span class="built_in">is_pointer_type</span>())&#123;</span><br><span class="line">        <span class="comment">//从var中取出数组的起始地址</span></span><br><span class="line">        var = builder-&gt;<span class="built_in">create_load</span>(var);          <span class="comment">//a[]的地址</span></span><br><span class="line">        var = builder-&gt;<span class="built_in">create_gep</span>(var, &#123; idx &#125;);  <span class="comment">//a[idx]的地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR: 变量&quot;</span> &lt;&lt; node.id &lt;&lt; <span class="string">&quot;不是一个数组\n&quot;</span>;</span><br><span class="line">    <span class="comment">//判断是赋值还是变量引用</span></span><br><span class="line">    <span class="keyword">if</span>(ifAssign)&#123;                             <span class="comment">//直接返回地址</span></span><br><span class="line">        ret = var;</span><br><span class="line">        ifAssign = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = builder-&gt;<span class="built_in">create_load</span>(var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-表达式顺序错误"><a href="#4-表达式顺序错误" class="headerlink" title="4.表达式顺序错误"></a>4.表达式顺序错误</h3><p style="text-indent:2em">在完成了整个实验后，进行测试，发现无法通过最后一个testcase。打开12.minus查看代码，其中有函数调用和一些基本运算，一开始不确定错误在什么位置，因为此时编译已经没有问题了，只可能是语义处理的问题。经过一些尝试后，改写了lab4_test.py，将运行的结果与正确的结果输出，分别为-39和39，通过这个结果将错误定位到函数调用，然后检查生成的.ll代码，发现函数gcd中有一个减法，操作数的顺序错误。因此找到了加法表达式中创建指令时，传值传反了的错误。additive-expression的产生式为：additive-expression -→ additive-expression addop term | term。生成运算指令时，加法表达式的结果应该在左边，编写时没有注意到这个问题，所以导致了结果的错误。修改后，testcases全部通过。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">if</span>(node.op==OP_PLUS)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ifInt)</span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_iadd</span>(addRes, mulRes);     <span class="comment">//addRes在左!</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_fadd</span>(addRes, mulRes);  </span><br><span class="line">    &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h2 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h2><h3 id="1-全局变量与宏定义"><a href="#1-全局变量与宏定义" class="headerlink" title="1.全局变量与宏定义"></a>1.全局变量与宏定义</h3><p style="text-indent:2em">补充了一个CONST_INT()宏定义获取常量值。INT32_Type和FLOAT_TYPE获取int32和float类型。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONST_INT(num) \</span></span><br><span class="line"><span class="meta">    ConstantInt::get((int)num, module.get())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT32_Type \</span></span><br><span class="line"><span class="meta"> Type::get_int32_type(module.get())      </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLOAT_Type \</span></span><br><span class="line"><span class="meta"> Type::get_float_type(module.get())</span></span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">全局变量ret用于节点返回值。arg用于传递参数。ifAssign表示访问Var节点时，应该返回值还是变量地址。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Value* ret;</span><br><span class="line">Value* arg;</span><br><span class="line"><span class="type">bool</span> ifAssign = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-visit函数"><a href="#2-visit函数" class="headerlink" title="2.visit函数"></a>2.visit函数</h3><h4 id="Program"><a href="#Program" class="headerlink" title="Program"></a><strong>Program</strong></h4><p style="text-indent:2em">检查语义后，逐个访问declarations。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTProgram &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;Program\n&quot;</span>;</span><br><span class="line">    <span class="comment">//语义检查</span></span><br><span class="line">    <span class="keyword">if</span>(node.declarations.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR: 该程序中没有声明。\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(node.declarations.<span class="built_in">back</span>()-&gt;id==<span class="string">&quot;main&quot;</span>&amp;&amp; node.declarations.<span class="built_in">back</span>()-&gt;type==TYPE_VOID))&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR: 最后一个声明不是void main(void)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//访问declarations子节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> dec: node.declarations)</span><br><span class="line">        dec-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Num"><a href="#Num" class="headerlink" title="Num"></a>Num</h4><p style="text-indent:2em">数值节点没有子节点，直接进行处理，根据type确认数值类型，然后将值保存到全局变量value中。根据语义规则，只能有整型和浮点数两个类型。但此处的检查是没有必要的，因为其他数据类型会在词法分析时被识别为标识符，在语法分析时就会产生错误。而VOID类型在变量声明时进行检查，保证变量声明只有整型和浮点型。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTNum &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;Num\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(node.type == TYPE_INT)</span><br><span class="line">        ret = <span class="built_in">CONST_INT</span>(node.i_val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node.type == TYPE_FLOAT)</span><br><span class="line">        ret = <span class="built_in">CONST_FP</span>(node.f_val);</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">//没有子节点，直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="VarDeclaration"><a href="#VarDeclaration" class="headerlink" title="VarDeclaration"></a><strong>VarDeclaration</strong></h4><p style="text-indent:2em">根据节点的定义，节点中包含一个类型和一个指针，还有继承自ASTDeclaration的id。对于变量声明节点的处理，需要产生分配空间的IR，在处理时还要区分数组与一般变量(根据节点的指针是否为空区分)，局部变量与全局变量。并且要把声明的变量放入当前作用域中，保证后续使用可以找到。根据语义规则，全局变量需要初始化为0，数组变量声明时，大小应该大于0。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTVarDeclaration &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;VarDeclaration\n&quot;</span>;</span><br><span class="line">    Type *varType;</span><br><span class="line">    <span class="keyword">if</span>(node.type==TYPE_INT)</span><br><span class="line">        varType = INT32_Type;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node.type==TYPE_FLOAT)</span><br><span class="line">        varType = FLOAT_Type;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        std::cout &lt;&lt;<span class="string">&quot;ERROR: 在变量声明中，只有整型和浮点型可以使用\n&quot;</span>;</span><br><span class="line">    <span class="comment">//对变量进行空间分配</span></span><br><span class="line">    <span class="keyword">if</span>(scope.<span class="built_in">in_global</span>())&#123;           <span class="comment">//全局变量</span></span><br><span class="line">        <span class="keyword">if</span>(node.num==<span class="literal">nullptr</span>)&#123;    <span class="comment">//非数组</span></span><br><span class="line">            <span class="keyword">auto</span> initializer = <span class="built_in">CONST_ZERO</span>(varType);</span><br><span class="line">            <span class="keyword">auto</span> globalVar = GlobalVariable::<span class="built_in">create</span>(node.id, <span class="keyword">module</span>.<span class="built_in">get</span>(), varType, <span class="literal">false</span>, initializer);</span><br><span class="line">            scope.<span class="built_in">push</span>(node.id, globalVar);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.num-&gt;i_val&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">auto</span> *array = ArrayType::<span class="built_in">get</span>(varType, node.num-&gt;i_val);</span><br><span class="line">                <span class="keyword">auto</span> initializer = <span class="built_in">CONST_ZERO</span>(array);</span><br><span class="line">                <span class="keyword">auto</span> globalVar = GlobalVariable::<span class="built_in">create</span>(node.id, <span class="keyword">module</span>.<span class="built_in">get</span>(), array, <span class="literal">false</span>, initializer);</span><br><span class="line">                scope.<span class="built_in">push</span>(node.id, globalVar);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;ERROR: 数组长度必须大于0\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;                          <span class="comment">//局部变量</span></span><br><span class="line">        <span class="keyword">if</span>(node.num==<span class="literal">nullptr</span>)&#123;     <span class="comment">//非数组</span></span><br><span class="line">             <span class="keyword">auto</span> localVar = builder-&gt;<span class="built_in">create_alloca</span>(varType);</span><br><span class="line">             scope.<span class="built_in">push</span>(node.id, localVar);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.num-&gt;i_val&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">auto</span> *array = ArrayType::<span class="built_in">get</span>(varType, node.num-&gt;i_val);</span><br><span class="line">                <span class="keyword">auto</span> localVar = builder-&gt;<span class="built_in">create_alloca</span>(array);</span><br><span class="line">                scope.<span class="built_in">push</span>(node.id, localVar);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;ERROR: 数组长度必须大于0\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FunDeclaration"><a href="#FunDeclaration" class="headerlink" title="FunDeclaration"></a><strong>FunDeclaration</strong></h4><p style="text-indent:2em">FunDeclaration节点包含一个形参列表param和复合语句compound-stmt。需要创建的IR是创建函数和创建函数的第一个BasicBlock的指令，然后处理复合语句。在进入函数时要进入函数作用域，创建函数时要处理参数与返回值。对于每个参数，用全局变量取出实参，调用accept函数进行处理，在Param的visit函数中完成存储空间的分配，并加入到函数作用域当中。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTFunDeclaration &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;FunDeclaration\n&quot;</span>;</span><br><span class="line">    Type *retType;                 <span class="comment">//函数返回类型</span></span><br><span class="line">    std::vector&lt;Type *&gt; paramType; <span class="comment">//参数类型</span></span><br><span class="line">    FunctionType *funType;         <span class="comment">//函数类型</span></span><br><span class="line">    <span class="comment">//语义检查</span></span><br><span class="line">    <span class="keyword">if</span>(node.id==<span class="string">&quot;main&quot;</span> &amp;&amp; node.params.<span class="built_in">size</span>()&gt;<span class="number">0</span>)</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;ERROR: main函数必须为void main(void)形式\n&quot;</span>;</span><br><span class="line">    <span class="comment">//确定函数的返回类型</span></span><br><span class="line">    <span class="keyword">if</span>(node.type==TYPE_INT)</span><br><span class="line">        retType = INT32_Type;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node.type==TYPE_FLOAT)</span><br><span class="line">        retType = FLOAT_Type;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node.type==TYPE_VOID)</span><br><span class="line">        retType = Type::<span class="built_in">get_void_type</span>(<span class="keyword">module</span>.<span class="built_in">get</span>());</span><br><span class="line">    <span class="comment">//确定函数的参数类型</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> param : node.params)&#123;</span><br><span class="line">        <span class="keyword">if</span>(param-&gt;isarray)&#123;       <span class="comment">//参数为数组，则参数为数组的首地址指针</span></span><br><span class="line">            <span class="keyword">if</span>(param-&gt;type==TYPE_INT)</span><br><span class="line">                paramType.<span class="built_in">push_back</span>(Type::<span class="built_in">get_int32_ptr_type</span>(<span class="keyword">module</span>.<span class="built_in">get</span>()));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(param-&gt;type==TYPE_FLOAT)</span><br><span class="line">                paramType.<span class="built_in">push_back</span>(Type::<span class="built_in">get_int32_ptr_type</span>(<span class="keyword">module</span>.<span class="built_in">get</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;                    <span class="comment">//参数为整型或浮点型</span></span><br><span class="line">            <span class="keyword">if</span> (param-&gt;type==TYPE_INT)       </span><br><span class="line">                paramType.<span class="built_in">push_back</span>(INT32_Type);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(param-&gt;type==TYPE_FLOAT)</span><br><span class="line">                paramType.<span class="built_in">push_back</span>(FLOAT_Type);     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建函数</span></span><br><span class="line">    funType = FunctionType::<span class="built_in">get</span>(retType, paramType);</span><br><span class="line">    <span class="keyword">auto</span> func = Function::<span class="built_in">create</span>(funType, node.id, <span class="keyword">module</span>.<span class="built_in">get</span>());</span><br><span class="line">    scope.<span class="built_in">push</span>(node.id, func);   <span class="comment">//将函数加入全局作用域</span></span><br><span class="line">    scope.<span class="built_in">enter</span>();               <span class="comment">//进入函数作用域</span></span><br><span class="line">    <span class="keyword">auto</span> entryBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), node.id + <span class="string">&quot;entry&quot;</span>, func);</span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(entryBB);     <span class="comment">//插入指令</span></span><br><span class="line">    <span class="comment">//visit参数节点</span></span><br><span class="line">    std::vector&lt;Value*&gt; args;    <span class="comment">//存储参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> arg = func-&gt;<span class="built_in">arg_begin</span>();arg != func-&gt;<span class="built_in">arg_end</span>();arg++) &#123;</span><br><span class="line">        args.<span class="built_in">push_back</span>(*arg);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; node.params.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> param = node.params[i];</span><br><span class="line">        arg = args[i];           </span><br><span class="line">        param-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理函数体内的语句</span></span><br><span class="line">    node.compound_stmt-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//如果BasicBlock最后没有终止指令，创建返回指令</span></span><br><span class="line">    <span class="keyword">if</span> (builder-&gt;<span class="built_in">get_insert_block</span>()-&gt;<span class="built_in">get_terminator</span>() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (func-&gt;<span class="built_in">get_return_type</span>()-&gt;<span class="built_in">is_void_type</span>())</span><br><span class="line">            builder-&gt;<span class="built_in">create_void_ret</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (func-&gt;<span class="built_in">get_return_type</span>()-&gt;<span class="built_in">is_float_type</span>())</span><br><span class="line">            builder-&gt;<span class="built_in">create_ret</span>(<span class="built_in">CONST_FP</span>(<span class="number">0.0</span>));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            builder-&gt;<span class="built_in">create_ret</span>(<span class="built_in">CONST_INT</span>(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    scope.<span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Param"><a href="#Param" class="headerlink" title="Param"></a><strong>Param</strong></h4><p style="text-indent:2em">在处理参数时，要为参数分配空间，使参数能够保留在函数的作用域内。在lab3中自行编写.ll文件时直接使用参数，不进行存储，直接使用就可以实现相同的逻辑。但在将cminus转换为IR时，cminus的语义规定了每次函数调用都会产生一组独立内存的参数，因此为参数分配空间，并存入作用域。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTParam &amp;node)</span> </span>&#123;     </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;Param\n&quot;</span>; </span><br><span class="line">    Value* paramP; </span><br><span class="line">    <span class="keyword">if</span> (node.isarray) &#123;          <span class="comment">//数组</span></span><br><span class="line">        <span class="keyword">if</span> (node.type==TYPE_INT)        </span><br><span class="line">            paramP = builder-&gt;<span class="built_in">create_alloca</span>(Type::<span class="built_in">get_int32_ptr_type</span>(<span class="keyword">module</span>.<span class="built_in">get</span>()));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node.type==TYPE_FLOAT) </span><br><span class="line">            paramP = builder-&gt;<span class="built_in">create_alloca</span>(Type::<span class="built_in">get_float_ptr_type</span>(<span class="keyword">module</span>.<span class="built_in">get</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                       <span class="comment">//非数组</span></span><br><span class="line">        <span class="keyword">if</span> (node.type==TYPE_INT)       </span><br><span class="line">            paramP = builder-&gt;<span class="built_in">create_alloca</span>(INT32_Type);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node.type==TYPE_FLOAT)</span><br><span class="line">            paramP = builder-&gt;<span class="built_in">create_alloca</span>(FLOAT_Type);</span><br><span class="line">    &#125;</span><br><span class="line">    builder-&gt;<span class="built_in">create_store</span>(arg, paramP);         <span class="comment">//存储参数</span></span><br><span class="line">    scope.<span class="built_in">push</span>(node.id, paramP);                <span class="comment">//加入作用域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CompoundStmt"><a href="#CompoundStmt" class="headerlink" title="CompoundStmt"></a><strong>CompoundStmt</strong></h4><p style="text-indent:2em">每个函数内部都有一个复合语句，根据ASTCompoundStmt的定义，复合语句由局部声明和一系列语句构成。只需要逐个调用相应的accept函数，不需要产生IR。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTCompoundStmt &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;CompoundStmt\n&quot;</span>;</span><br><span class="line">    <span class="comment">//访问局部声明的节点和语句节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> local_declaration: node.local_declarations)</span><br><span class="line">        local_declaration-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> statement: node.statement_list)</span><br><span class="line">        statement-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ExpressionStmt"><a href="#ExpressionStmt" class="headerlink" title="ExpressionStmt"></a><strong>ExpressionStmt</strong></h4><p style="text-indent:2em">ExpressionStmt对应一条表达式或空，只要表达式存在，就处理该表达式。</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CminusfBuilder::visit</span><span class="params">(ASTExpressionStmt &amp;node)</span> &#123; </span><br><span class="line">    LOG(DEBUG) &lt;&lt; <span class="string">&quot;ExpressionStmt\n&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (node.expression != nullptr)</span><br><span class="line">		node.expression-&gt;accept(*this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SelectionStmt"><a href="#SelectionStmt" class="headerlink" title="SelectionStmt"></a><strong>SelectionStmt</strong></h4><p style="text-indent:2em">SelectionStmt包含一个条件表达式，一个if语句块，还有可能存在的else语句块。先处理表达式，产生条件跳转语句。如果指向else语句块的指针为空，就说明只有if语句。考虑只有if的情况，在执行到if时，应该通过br指令条件跳转到if语句块或if后的部分。如果还有else语句，则通过br指令条件跳转到if语句块或else语句块，然后从这两个语句块的结尾返回或者跳转到ifelse语句之后的部分。因此在SelectionStmt的visit函数中应该至少生成三个BasicBlock，并生成br指令。根据else指针是否为空判断是否需要生成条件判断为false的BasicBlock。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTSelectionStmt &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;SelectionStmt\n&quot;</span>;</span><br><span class="line">    <span class="comment">//处理条件表达式</span></span><br><span class="line">    <span class="keyword">auto</span> func = builder-&gt;<span class="built_in">get_insert_block</span>()-&gt;<span class="built_in">get_parent</span>();</span><br><span class="line">    node.expression-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">auto</span> retType = ret-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    Value* ifExpression;                         <span class="comment">//条件表达式的结果             </span></span><br><span class="line">    <span class="comment">//根据返回类型处理, 生成比较语句</span></span><br><span class="line">    <span class="keyword">if</span>(retType-&gt;<span class="built_in">is_integer_type</span>())</span><br><span class="line">        ifExpression = builder-&gt;<span class="built_in">create_icmp_gt</span>(ret, <span class="built_in">CONST_ZERO</span>(INT32_Type));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ifExpression = builder-&gt;<span class="built_in">create_fcmp_gt</span>(ret, <span class="built_in">CONST_ZERO</span>(FLOAT_Type));</span><br><span class="line">    <span class="comment">//生成BasicBlock</span></span><br><span class="line">    <span class="keyword">auto</span> ifBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), <span class="string">&quot;ifBasicBlock&quot;</span>, func);</span><br><span class="line">    <span class="keyword">auto</span> elseBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), <span class="string">&quot;elseBasicBlock&quot;</span>, func);</span><br><span class="line">    <span class="keyword">auto</span> afterIfBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), <span class="string">&quot;afterIfBasicBlock&quot;</span>, func);</span><br><span class="line">    <span class="comment">//创建br指令</span></span><br><span class="line">    <span class="keyword">if</span>(node.else_statement==<span class="literal">nullptr</span>)             <span class="comment">//没有else</span></span><br><span class="line">        builder-&gt;<span class="built_in">create_cond_br</span>(ifExpression, ifBB, afterIfBB);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        builder-&gt;<span class="built_in">create_cond_br</span>(ifExpression, ifBB, elseBB);</span><br><span class="line">    <span class="comment">//为ifBB添加IR</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(ifBB);</span><br><span class="line">    node.if_statement-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">if</span> (builder-&gt;<span class="built_in">get_insert_block</span>()-&gt;<span class="built_in">get_terminator</span>() == <span class="literal">nullptr</span>)</span><br><span class="line">		builder-&gt;<span class="built_in">create_br</span>(afterIfBB);</span><br><span class="line">    <span class="comment">//为elseBB添加IR</span></span><br><span class="line">    <span class="keyword">if</span>(node.else_statement!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        builder-&gt;<span class="built_in">set_insert_point</span>(elseBB);</span><br><span class="line">        node.else_statement-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">	    <span class="keyword">if</span> (builder-&gt;<span class="built_in">get_insert_block</span>()-&gt;<span class="built_in">get_terminator</span>() == <span class="literal">nullptr</span>)</span><br><span class="line">		builder-&gt;<span class="built_in">create_br</span>(afterIfBB);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        elseBB-&gt;<span class="built_in">erase_from_parent</span>();</span><br><span class="line">    <span class="comment">//后面的语句块的IR在新的BasicBlock中</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(afterIfBB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="IterationStmt"><a href="#IterationStmt" class="headerlink" title="IterationStmt"></a><strong>IterationStmt</strong></h4><p style="text-indent:2em">与if语句类似，while迭代语句也有一个条件表达式，进行条件跳转。可以创建一个用于判断的ifBasicBlock，一个循环的loopBasicBlock，一个while语句后的afterWhileBasicBlock，添加相应的指令。当条件表达式为True时，进行ifBB->loopBB->ifBB的循环跳转。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTIterationStmt &amp;node)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;IterationStmt\n&quot;</span>;</span><br><span class="line">    <span class="comment">//创建BasicBlock</span></span><br><span class="line">    <span class="keyword">auto</span> func = builder-&gt;<span class="built_in">get_insert_block</span>()-&gt;<span class="built_in">get_parent</span>();</span><br><span class="line">    <span class="keyword">auto</span> ifBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), <span class="string">&quot;ifBasicBlock&quot;</span>, func);</span><br><span class="line">    <span class="keyword">auto</span> loopBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), <span class="string">&quot;loopBasicBlock&quot;</span>, func);</span><br><span class="line">    <span class="keyword">auto</span> afterWhileBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), <span class="string">&quot;afterWhileBasicBlock&quot;</span>, func);</span><br><span class="line">    <span class="comment">//跳转到条件表达式判断的BasicBlock</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_br</span>(ifBB);</span><br><span class="line">    <span class="comment">//为ifBB添加IR, 判断条件表达式的结果</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(ifBB);</span><br><span class="line">    node.expression-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">auto</span> retType = ret-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    Value* ifExpression;                         <span class="comment">//条件表达式的结果             </span></span><br><span class="line">    <span class="comment">//根据返回类型处理, 生成比较语句</span></span><br><span class="line">    <span class="keyword">if</span>(retType-&gt;<span class="built_in">is_integer_type</span>())</span><br><span class="line">        ifExpression = builder-&gt;<span class="built_in">create_icmp_gt</span>(ret, <span class="built_in">CONST_ZERO</span>(INT32_Type));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ifExpression = builder-&gt;<span class="built_in">create_fcmp_gt</span>(ret, <span class="built_in">CONST_ZERO</span>(FLOAT_Type));</span><br><span class="line">    <span class="comment">//条件跳转</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_cond_br</span>(ifExpression, loopBB, afterWhileBB);</span><br><span class="line">    <span class="comment">//为loopBB添加IR</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(loopBB);</span><br><span class="line">    node.statement-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (builder-&gt;<span class="built_in">get_insert_block</span>()-&gt;<span class="built_in">get_terminator</span>() == <span class="literal">nullptr</span>)</span><br><span class="line">        builder-&gt;<span class="built_in">create_br</span>(ifBB);</span><br><span class="line">    <span class="comment">//后面的语句块的IR在新的BasicBlock中</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(afterWhileBB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ReturnStmt"><a href="#ReturnStmt" class="headerlink" title="ReturnStmt"></a><strong>ReturnStmt</strong></h4><p style="text-indent:2em">返回语句中有一个表达式计算返回值，如果指向该返回语句的指针为空，说明没有返回值，创建一个void返回IR，否则需要调用该表达式的accept函数，并检查返回类型是否和函数的返回类型相同。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTReturnStmt &amp;node)</span> </span>&#123; </span><br><span class="line">	<span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;ReturnStmt\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(node.expression==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        builder-&gt;<span class="built_in">create_void_ret</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node.expression-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//处理返回值，产生返回的IR</span></span><br><span class="line">    <span class="keyword">auto</span> func = builder-&gt;<span class="built_in">get_insert_block</span>()-&gt;<span class="built_in">get_parent</span>();</span><br><span class="line">    <span class="keyword">auto</span> retType = func-&gt;<span class="built_in">get_return_type</span>();</span><br><span class="line">    <span class="keyword">auto</span> resType = ret-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    <span class="keyword">if</span> (retType-&gt;<span class="built_in">is_integer_type</span>() &amp;&amp; resType-&gt;<span class="built_in">is_float_type</span>())</span><br><span class="line">        ret = builder-&gt;<span class="built_in">create_fptosi</span>(ret, INT32_Type);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(retType-&gt;<span class="built_in">is_float_type</span>() &amp;&amp; resType-&gt;<span class="built_in">is_integer_type</span>())</span><br><span class="line">        ret = builder-&gt;<span class="built_in">create_sitofp</span>(ret, FLOAT_Type);</span><br><span class="line">    builder-&gt;<span class="built_in">create_ret</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Var"><a href="#Var" class="headerlink" title="Var"></a><strong>Var</strong></h4><p style="text-indent:2em">在实验难点中已说明。</p>

<h4 id="AssignExpression"><a href="#AssignExpression" class="headerlink" title="AssignExpression"></a>AssignExpression</h4><p style="text-indent:2em">对于Assign语句，将全局变量ifAssign置为true，调用子节点var的accept函数得到变量的地址，然后计算表达式的值，创建store指令将值存入地址。需要确认表达式结果是否与变量类型相同，如果不同需要将表达式结果转换为和变量相同的类型。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTAssignExpression &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;AssignExpression\n&quot;</span>;</span><br><span class="line">    ifAssign = <span class="literal">true</span>;</span><br><span class="line">    node.var-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">auto</span> varAdd = ret;</span><br><span class="line">    node.expression-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//确认表达式结果类型与变量类型相同，不同则进行转换</span></span><br><span class="line">    <span class="keyword">auto</span> varType = varAdd-&gt;<span class="built_in">get_type</span>()-&gt;<span class="built_in">get_pointer_element_type</span>();</span><br><span class="line">    <span class="keyword">auto</span> valueType = ret-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    Value* value = ret;</span><br><span class="line">    <span class="keyword">if</span>(varType!=valueType)&#123;</span><br><span class="line">        <span class="keyword">if</span>(varType==INT32_Type)</span><br><span class="line">            value = builder-&gt;<span class="built_in">create_fptosi</span>(ret, INT32_Type);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            value = builder-&gt;<span class="built_in">create_sitofp</span>(ret, FLOAT_Type);</span><br><span class="line">    &#125;</span><br><span class="line">    builder-&gt;<span class="built_in">create_store</span>(value, varAdd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SimpleExpression"><a href="#SimpleExpression" class="headerlink" title="SimpleExpression"></a>SimpleExpression</h4><p style="text-indent:2em">简单表达式SimpleExpression是一个加法表达式或两个加法表达式的关系运算。在节点中有两个加法表达式的指针和一个运算符类型为RelOp的运算符op，RelOp是一个枚举类型，包含了所有比较运算符。根据语义，对于该节点的处理，应该先处理加法表达式，将表达式的值保存下来，如果两个表达式指针都不为空，说明为关系运算，再比较两个运算结果，根据结果将表达式的值赋为0或1。进行比较时需要注意两个值的类型，整型和浮点型比较时要将整型转换为浮点型。</p>

<p style="text-indent:2em">具体实现中，应该调用加法表达式的accept函数(如果指针不为空)，暂存结果，对于比较运算，根据op生成icmp或fcmp的指令，最后返回的值就是指令结果。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTSimpleExpression &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;SimpleExpression\n&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> ifInt = <span class="literal">true</span>;                      <span class="comment">//表达式结果类型</span></span><br><span class="line">    Value *resL, *resR;</span><br><span class="line">    Type *resLType, *resRType;</span><br><span class="line">    <span class="comment">//计算两个加法表达式</span></span><br><span class="line">    <span class="keyword">if</span>(node.additive_expression_l!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        node.additive_expression_l-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">        resL = ret;</span><br><span class="line">        resLType = ret-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.additive_expression_r!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        node.additive_expression_r-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">        resR = ret;</span><br><span class="line">        resRType = ret-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果只有一个加法表达式, 直接返回表达式的值</span></span><br><span class="line">    <span class="keyword">if</span>(!(node.additive_expression_l!=<span class="literal">nullptr</span> &amp;&amp; node.additive_expression_r!=<span class="literal">nullptr</span>))&#123;</span><br><span class="line">        ret = (node.additive_expression_l!=<span class="literal">nullptr</span>) ? resL : resR;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果有两个加法表达式, 为关系运算</span></span><br><span class="line">    <span class="comment">//先统一类型</span></span><br><span class="line">    <span class="keyword">if</span>(resLType!=resRType)&#123;</span><br><span class="line">        ifInt = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(resLType-&gt;<span class="built_in">is_float_type</span>())        <span class="comment">//左表达式为浮点型，则右表达式从整型转换为浮点型</span></span><br><span class="line">            resL = builder-&gt;<span class="built_in">create_sitofp</span>(resL, FLOAT_Type);</span><br><span class="line">        <span class="keyword">else</span>								 <span class="comment">//左表达式为整型，转换为浮点型</span></span><br><span class="line">            resR = builder-&gt;<span class="built_in">create_sitofp</span>(resR, FLOAT_Type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据关系运算类型，创建指令</span></span><br><span class="line">    <span class="keyword">switch</span> (node.op)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> OP_LE:</span><br><span class="line">        <span class="keyword">if</span>(ifInt)</span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_icmp_le</span>(resL, resR);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_fcmp_le</span>(resL, resR);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">/*其他运算符......*/</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结果为整型</span></span><br><span class="line">    ret = builder-&gt;<span class="built_in">create_zext</span>(ret, INT32_Type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AdditiveExpression"><a href="#AdditiveExpression" class="headerlink" title="AdditiveExpression"></a>AdditiveExpression</h4><p style="text-indent:2em">加法表达式中包含了一个乘法表达式，一个加法表达式和一个运算符。如果加法表达式指针为空，则表达式的值就是乘法表达式的值，否则分别计算两个表达式，调用相应的accept函数，然后进行根据运算符生成加或减指令。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTAdditiveExpression &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;AdditiveExpression\n&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> ifInt = <span class="literal">true</span>;                        <span class="comment">//两个表达式类型</span></span><br><span class="line">    <span class="comment">//如果只有乘法表达式</span></span><br><span class="line">    <span class="keyword">if</span>(node.additive_expression==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        node.term-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有乘法表达式和加法表达式，创建加法或减法指令</span></span><br><span class="line">    node.additive_expression-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);  <span class="comment">//处理加法表达式</span></span><br><span class="line">    <span class="keyword">auto</span> addRes = ret;</span><br><span class="line">    <span class="keyword">auto</span> addType = addRes-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    node.term-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);                 <span class="comment">//处理乘法表达式</span></span><br><span class="line">    <span class="keyword">auto</span> mulRes = ret;</span><br><span class="line">    <span class="keyword">auto</span> mulType = mulRes-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    <span class="comment">//确认类型相同</span></span><br><span class="line">    <span class="keyword">if</span>(addType!=mulType)&#123;</span><br><span class="line">        ifInt = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(addType-&gt;<span class="built_in">is_float_type</span>())</span><br><span class="line">            mulRes = builder-&gt;<span class="built_in">create_sitofp</span>(mulRes, FLOAT_Type);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            addRes = builder-&gt;<span class="built_in">create_sitofp</span>(addRes, INT32_Type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指令</span></span><br><span class="line">    <span class="keyword">if</span>(node.op==OP_PLUS)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ifInt)</span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_iadd</span>(addRes, mulRes);     <span class="comment">//addRes在左!</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_fadd</span>(addRes, mulRes);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ifInt)</span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_isub</span>(addRes, mulRes);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_fsub</span>(addRes, mulRes);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Term"><a href="#Term" class="headerlink" title="Term"></a>Term</h4><p style="text-indent:2em">乘法表达式由乘法表达式和因子或单独一个因子构成。与加法表达式的处理相同。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTTerm &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;Term\n&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> ifInt = <span class="literal">true</span>;                        <span class="comment">//因子和乘法表达式结果类型</span></span><br><span class="line">    <span class="comment">//如果只有因子</span></span><br><span class="line">    <span class="keyword">if</span>(node.term==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        node.factor-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有乘法表达式和因子，创建乘法或除法指令</span></span><br><span class="line">    node.term-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);                 <span class="comment">//处理乘法表达式</span></span><br><span class="line">    <span class="keyword">auto</span> mulRes = ret;</span><br><span class="line">    <span class="keyword">auto</span> mulType = mulRes-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    node.factor-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);               <span class="comment">//处理因子</span></span><br><span class="line">    <span class="keyword">auto</span> factorRes = ret;</span><br><span class="line">    <span class="keyword">auto</span> factorType = factorRes-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    <span class="comment">//确认类型相同</span></span><br><span class="line">    <span class="keyword">if</span>(factorType!=mulType)&#123;</span><br><span class="line">        ifInt = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(factorType-&gt;<span class="built_in">is_float_type</span>())</span><br><span class="line">            mulRes = builder-&gt;<span class="built_in">create_sitofp</span>(mulRes, FLOAT_Type);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            factorRes = builder-&gt;<span class="built_in">create_sitofp</span>(factorRes, INT32_Type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指令</span></span><br><span class="line">    <span class="keyword">if</span>(node.op==OP_MUL)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ifInt)</span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_imul</span>(mulRes, factorRes);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_fmul</span>(mulRes, factorRes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ifInt)</span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_isdiv</span>(mulRes, factorRes);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_fdiv</span>(mulRes, factorRes);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h4><p style="text-indent:2em">call节点需要创建一条函数调用call指令，从作用域中取出函数，然后根据函数的参数将节点的实参传入，并检查类型是否与函数参数的类型一致，不一致则需要转换为函数的形参类型。创建一个参数列表，将转换好的参数存入列表来调用函数。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTCall &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;Call\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> func = <span class="built_in">static_cast</span>&lt;Function*&gt;(scope.<span class="built_in">find</span>(node.id));</span><br><span class="line">    <span class="keyword">auto</span> paramType = func-&gt;<span class="built_in">get_function_type</span>()-&gt;<span class="built_in">param_begin</span>();</span><br><span class="line">    <span class="keyword">if</span>(func==<span class="literal">nullptr</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR: 函数&quot;</span> &lt;&lt; node.id &lt;&lt; <span class="string">&quot;未定义\n&quot;</span>;</span><br><span class="line">    <span class="comment">//处理参数</span></span><br><span class="line">    Value *temp;</span><br><span class="line">    std::vector&lt;Value*&gt; args;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> arg: node.args)&#123;</span><br><span class="line">        arg-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);                   <span class="comment">//获取参数值</span></span><br><span class="line">        temp = ret;</span><br><span class="line">        <span class="keyword">auto</span> argType = ret-&gt;<span class="built_in">get_type</span>();       <span class="comment">//处理类型</span></span><br><span class="line">        <span class="keyword">if</span>(argType!=*paramType)</span><br><span class="line">            <span class="keyword">if</span>((*paramType)-&gt;<span class="built_in">is_integer_type</span>())</span><br><span class="line">                temp = builder-&gt;<span class="built_in">create_fptosi</span>(ret, INT32_Type);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp = builder-&gt;<span class="built_in">create_sitofp</span>(ret, FLOAT_Type);</span><br><span class="line">        args.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        paramType++;</span><br><span class="line">    &#125;</span><br><span class="line">    builder-&gt;<span class="built_in">create_call</span>(func, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><h3 id="1-结果验证"><a href="#1-结果验证" class="headerlink" title="1.结果验证"></a>1.结果验证</h3><p style="text-indent:2em">在进行测试，改正编写过程中的一些错误后，编译后运行测试程序，所有测试样例都通过。</p>

<p><img src="/2022/11/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E5%9B%9B/image-20221123173758944.png" alt="image-20221123173758944" style="zoom:50%;"></p>
<h3 id="2-总结"><a href="#2-总结" class="headerlink" title="2.总结"></a>2.总结</h3><p style="text-indent:2em">通过本次实验，理解了从抽象语法树产生中间IR的方法，并进行了实现。在实现过程中，对于IR的指令有了进一步的熟悉与理解，掌握了使用C++接口创建不同IR指令的方法，以及在访问者模式下遍历抽象语法树，完成IR生成的过程。在完成实现时阅读了相关的头文件，语义规则，通过整个实验的框架复习了C++中一些概念和方法。经过四次实验，结合课程所学的原理，理解了编译器的词法分析，语法分析，中间代码生成的过程，也学习了相关工具的使用并进行了实践，清楚了编译器工作的每一个部分的原理和相互之间的配合。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://a-y-1.github.io/2022/11/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/a0.jpg">
      <meta itemprop="name" content="橙">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橙的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%89/" class="post-title-link" itemprop="url">编译原理实验三</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-13 10:35:29" itemprop="dateCreated datePublished" datetime="2022-11-13T10:35:29+08:00">2022-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-15 09:12:37" itemprop="dateModified" datetime="2022-12-15T09:12:37+08:00">2022-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题1-cpp与-ll的对应"><a href="#问题1-cpp与-ll的对应" class="headerlink" title="问题1: cpp与.ll的对应"></a>问题1: cpp与.ll的对应</h2><p>请描述你的cpp代码片段和.ll的每个BasicBlock的对应关系。描述中请附上两者代码。</p>
<h3 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h3><p style="text-indent:2em">对应的.ll代码如下：</p>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">define i32 @main() #0 &#123;</span><br><span class="line">    %1 = alloca [10 x i32]    ;int a[10]</span><br><span class="line">    %2 = getelementptr inbounds [10 x i32], [10 x i32]* %1, i32 0, i32 0        ;a[0] addr    </span><br><span class="line">    %3 = getelementptr inbounds [10 x i32], [10 x i32]* %1, i32 0, i32 1        ;a[1] addr</span><br><span class="line">    store i32 10, i32* %2     ;a[0] = 10</span><br><span class="line">    %4 = load i32, i32* %2    ;%4 = a[0]</span><br><span class="line">    %5 = mul i32 %4,2         ;%5 = a[0]*2</span><br><span class="line">    store i32 %5, i32* %3     ;a[1] = %5 = a[0]*2</span><br><span class="line">    %6 = load i32, i32* %3    ;%6 = a[1]</span><br><span class="line">    ret i32 %6                ;return a[1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">这一段程序仅有一个函数，一个BasicBlock。仿照gcd_array.cpp的写法，创建Module和BasicBlock，将.ll中的指令使用IRBuilder插入到BasicBlock的指令链表当中。与.ll中指令的对应关系在以下的cpp代码片段的注释中说明。cpp
代码片段如下：</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BasicBlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Constant.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IRBuilder.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Module.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Type.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG  <span class="comment">// 用于调试信息,大家可以在编译过程中通过&quot; -DDEBUG&quot;来开启这一选项</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_OUTPUT std::cout &lt;&lt; __LINE__ &lt;&lt; std::endl;  <span class="comment">// 输出行号的简单示例</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_OUTPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONST_INT(num) \</span></span><br><span class="line"><span class="meta">    ConstantInt::get(num, module)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONST_FP(num) \</span></span><br><span class="line"><span class="meta">    ConstantFP::get(num, module) <span class="comment">// 得到常数值的表示,方便后面多次用到</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">module</span> = <span class="keyword">new</span> <span class="built_in">Module</span>(<span class="string">&quot;Assign&quot;</span>);                 </span><br><span class="line">    <span class="keyword">auto</span> builder = <span class="keyword">new</span> <span class="built_in">IRBuilder</span>(<span class="literal">nullptr</span>, <span class="keyword">module</span>);                      <span class="comment">//使用IRBuilder创建指令</span></span><br><span class="line">    <span class="comment">//创建函数与BasicBlock</span></span><br><span class="line">    Type *Int32Type = Type::<span class="built_in">get_int32_type</span>(<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">auto</span> mainTy = FunctionType::<span class="built_in">get</span>(Int32Type, &#123;&#125;);                     <span class="comment">//返回值为i32，参数为空</span></span><br><span class="line">    <span class="keyword">auto</span> main = Function::<span class="built_in">create</span>(mainTy, <span class="string">&quot;main&quot;</span>, <span class="keyword">module</span>);            </span><br><span class="line">    <span class="keyword">auto</span> BB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>, <span class="string">&quot;BasicBlock1&quot;</span> , main);</span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(BB);                                      <span class="comment">//设置插入指令的BasicBlock</span></span><br><span class="line">    <span class="comment">//插入.ll中对应的指令</span></span><br><span class="line">    <span class="keyword">auto</span> *arrayType = ArrayType::<span class="built_in">get</span>(Int32Type, <span class="number">10</span>);                    <span class="comment">//数组的类型为[10 x i32]</span></span><br><span class="line">    <span class="keyword">auto</span> a = builder-&gt;<span class="built_in">create_alloca</span>(arrayType);                         <span class="comment">//分配数组</span></span><br><span class="line">    <span class="keyword">auto</span> a0P = builder-&gt;<span class="built_in">create_gep</span>(a, &#123;<span class="built_in">CONST_INT</span>(<span class="number">0</span>), <span class="built_in">CONST_INT</span>(<span class="number">0</span>)&#125;);    <span class="comment">//计算a[0]地址</span></span><br><span class="line">    <span class="keyword">auto</span> a1P = builder-&gt;<span class="built_in">create_gep</span>(a, &#123;<span class="built_in">CONST_INT</span>(<span class="number">0</span>), <span class="built_in">CONST_INT</span>(<span class="number">0</span>)&#125;);    <span class="comment">//计算a[1]地址</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_store</span>(&#123;<span class="built_in">CONST_INT</span>(<span class="number">10</span>)&#125;, a0P);                        <span class="comment">//a[0] = 10</span></span><br><span class="line">    <span class="keyword">auto</span> a0 = builder-&gt;<span class="built_in">create_load</span>(a0P);                                <span class="comment">//取出a[0]</span></span><br><span class="line">    <span class="keyword">auto</span> temp = builder-&gt;<span class="built_in">create_imul</span>(a0, &#123;<span class="built_in">CONST_INT</span>(<span class="number">2</span>)&#125;);               <span class="comment">//a[0]*2</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_store</span>(temp, a1P);                                   <span class="comment">//a1 = a[0]*2</span></span><br><span class="line">    <span class="keyword">auto</span> a1 = builder-&gt;<span class="built_in">create_load</span>(a1P);       </span><br><span class="line">    builder-&gt;<span class="built_in">create_ret</span>(a1);                                            <span class="comment">//return a1 = a[0]*2</span></span><br><span class="line">    <span class="comment">//指令创建结束</span></span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">module</span>-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">module</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">make之后运行程序进行验证，生成的指令和.ll中的指令相同。</p>

<p><img src="/2022/11/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%89/image-20221121113522342.png" alt="image-20221121113522342" style="zoom: 67%;"></p>
<h3 id="fun"><a href="#fun" class="headerlink" title="fun"></a>fun</h3><p style="text-indent:2em">对应的.ll代码如下：</p>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define i32 @callee(i32 %0) #0 &#123;</span><br><span class="line">    %2 = mul i32 %0, 2               ;%2 = a*2</span><br><span class="line">    ret i32 %2</span><br><span class="line">&#125;</span><br><span class="line">define i32 @main() #0 &#123;</span><br><span class="line">    %1 = call i32 @callee(i32 110)   ;%1 = callee(110)</span><br><span class="line">    ret i32 %1                       ;return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">共有两个函数，相应有两个BasicBlock，分别插入指令。与.ll中指令的对应关系在注释中说明，相应的cpp代码如下：</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件和宏定义省略</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">module</span> = <span class="keyword">new</span> <span class="built_in">Module</span>(<span class="string">&quot;fun&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> builder = <span class="keyword">new</span> <span class="built_in">IRBuilder</span>(<span class="literal">nullptr</span>, <span class="keyword">module</span>);</span><br><span class="line">    <span class="comment">//创建callee函数</span></span><br><span class="line">    Type *Int32Type = Type::<span class="built_in">get_int32_type</span>(<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">auto</span> calleeTy = FunctionType::<span class="built_in">get</span>(Int32Type, &#123;Int32Type&#125;);            <span class="comment">//返回值为i32，一个i32类型的参数</span></span><br><span class="line">    <span class="keyword">auto</span> callee = Function::<span class="built_in">create</span>(calleeTy, <span class="string">&quot;callee&quot;</span>, <span class="keyword">module</span>); </span><br><span class="line">    <span class="keyword">auto</span> BB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>, <span class="string">&quot;callee_BasicBlock&quot;</span> , callee);</span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(BB);</span><br><span class="line">    <span class="comment">//插入callee的BasicBlock中的指令</span></span><br><span class="line">    std::vector&lt;Value *&gt; args;                                            <span class="comment">//获取函数的形参,通过Function中的iterator</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> arg = callee-&gt;<span class="built_in">arg_begin</span>(); arg != callee-&gt;<span class="built_in">arg_end</span>(); arg++) &#123;</span><br><span class="line">        args.<span class="built_in">push_back</span>(*arg);                                             <span class="comment">//* 号运算符是从迭代器中取出迭代器当前指向的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> mul = builder-&gt;<span class="built_in">create_imul</span>(args[<span class="number">0</span>], <span class="built_in">CONST_INT</span>(<span class="number">2</span>));             <span class="comment">//mul = a*2</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_ret</span>(mul);</span><br><span class="line">    <span class="comment">//创建main函数</span></span><br><span class="line">    <span class="keyword">auto</span> mainTy = FunctionType::<span class="built_in">get</span>(Int32Type, &#123;&#125;);</span><br><span class="line">    <span class="keyword">auto</span> main = Function::<span class="built_in">create</span>(mainTy, <span class="string">&quot;main&quot;</span>, <span class="keyword">module</span>); </span><br><span class="line">    <span class="keyword">auto</span> BB1 = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>, <span class="string">&quot;main_BasicBlock&quot;</span> , main);</span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(BB1);</span><br><span class="line">    <span class="comment">//插入main的BasicBlock中的指令</span></span><br><span class="line">    <span class="keyword">auto</span> callret = builder-&gt;<span class="built_in">create_call</span>(callee, &#123;<span class="built_in">CONST_INT</span>(<span class="number">110</span>)&#125;);       <span class="comment">//callret = callee(110)</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_ret</span>(callret);                                        <span class="comment">//return callret</span></span><br><span class="line">    <span class="comment">//指令创建结束</span></span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">module</span>-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">module</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">运行程序，生成的指令和.ll中的指令相同。</p>

<p><img src="/2022/11/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%89/image-20221121161232658.png" alt="image-20221121161232658" style="zoom: 67%;"></p>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p style="text-indent:2em">对应的.ll代码如下：</p>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">define i32 @main() #0 &#123;</span><br><span class="line">    %1 = alloca float                    ;%1 = float a addr</span><br><span class="line">    store float 0x40163851E0000000, float* %1</span><br><span class="line">    %2 = load float, float* %1           ;%2 = a</span><br><span class="line">    %3 = fcmp ugt float %2, 1.0          ;a&gt;1   </span><br><span class="line">    br i1 %3, label %4, label %5         ;if(a&gt;1) goto 4 else goto 5</span><br><span class="line">4:</span><br><span class="line">    ret i32 233</span><br><span class="line">5:</span><br><span class="line">    ret i32 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">本段指令有3个BasicBlock，相比与前两个多了fcmp和br跳转指令。相应的.cpp文件如下：</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件和宏定义省略</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">module</span> = <span class="keyword">new</span> <span class="built_in">Module</span>(<span class="string">&quot;if&quot;</span>);                 </span><br><span class="line">    <span class="keyword">auto</span> builder = <span class="keyword">new</span> <span class="built_in">IRBuilder</span>(<span class="literal">nullptr</span>, <span class="keyword">module</span>);                      <span class="comment">//使用IRBuilder创建指令</span></span><br><span class="line">    <span class="comment">//创建main函数</span></span><br><span class="line">    Type *Int32Type = Type::<span class="built_in">get_int32_type</span>(<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">auto</span> mainTy = FunctionType::<span class="built_in">get</span>(Int32Type, &#123;&#125;);                     <span class="comment">//返回值为i32，参数为空</span></span><br><span class="line">    <span class="keyword">auto</span> main = Function::<span class="built_in">create</span>(mainTy, <span class="string">&quot;main&quot;</span>, <span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">auto</span> BBEntry = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>, <span class="string">&quot;entry&quot;</span> , main);</span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(BBEntry); </span><br><span class="line">    <span class="comment">//entryBasicBlock插入指令，对应.ll的BasicBlock0</span></span><br><span class="line">    Type *FloatType = Type::<span class="built_in">get_float_type</span>(<span class="keyword">module</span>);                     <span class="comment">//浮点类型</span></span><br><span class="line">    <span class="keyword">auto</span> aP = builder-&gt;<span class="built_in">create_alloca</span>(FloatType);                        <span class="comment">//为float a分配空间并返回指针</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_store</span>(<span class="built_in">CONST_FP</span>(<span class="number">5.555</span>),aP);                          <span class="comment">//a = 5.555</span></span><br><span class="line">    <span class="keyword">auto</span> a = builder-&gt;<span class="built_in">create_load</span>(aP);                                  <span class="comment">//取出a</span></span><br><span class="line">    <span class="keyword">auto</span> fcmp = builder-&gt;<span class="built_in">create_fcmp_gt</span>(a, <span class="built_in">CONST_FP</span>(<span class="number">1.0</span>));              <span class="comment">//fcmp = if a&gt;1</span></span><br><span class="line">    <span class="comment">//创建true, false对应的BasicBlock</span></span><br><span class="line">    <span class="keyword">auto</span> BBTrue = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>, <span class="string">&quot;true&quot;</span> , main);</span><br><span class="line">    <span class="keyword">auto</span> BBFalse = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>, <span class="string">&quot;false&quot;</span>, main);</span><br><span class="line">    builder-&gt;<span class="built_in">create_cond_br</span>(fcmp, BBTrue, BBFalse);                     <span class="comment">//br跳转指令</span></span><br><span class="line">    <span class="comment">//true和false对应的BasicBlock插入指令，对应.ll的BasicBlock4,5</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(BBTrue);</span><br><span class="line">    builder-&gt;<span class="built_in">create_ret</span>(<span class="built_in">CONST_INT</span>(<span class="number">233</span>));</span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(BBFalse);</span><br><span class="line">    builder-&gt;<span class="built_in">create_ret</span>(<span class="built_in">CONST_INT</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//指令创建结束</span></span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">module</span>-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">module</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">运行程序验证：</p>

<p><img src="/2022/11/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%89/image-20221121171447083.png" alt="image-20221121171447083" style="zoom: 67%;"></p>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p style="text-indent:2em">对应的.ll代码如下：</p>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">define i32 @main() #0 &#123;</span><br><span class="line">    %1 = alloca i32        ;%1 = a addr</span><br><span class="line">    %2 = alloca i32        ;%2 = i addr</span><br><span class="line">    store i32 0, i32* %2   ;i = 0</span><br><span class="line">    store i32 10, i32* %1  ;a = 10</span><br><span class="line">    br label %3             </span><br><span class="line"></span><br><span class="line">;if i&lt;10</span><br><span class="line">3:</span><br><span class="line">    %4 = load i32, i32* %2        ;%4 = i</span><br><span class="line">    %5 = icmp slt i32 %4, 10      ;i &lt; 10?</span><br><span class="line">    br i1 %5, label %6, label %10</span><br><span class="line">    </span><br><span class="line">6:</span><br><span class="line">    %7 = add nsw i32 %4, 1        ;i + 1</span><br><span class="line">    store i32 %7, i32* %2         ;i = i + 1</span><br><span class="line">    %8 = load i32, i32* %1        ;%8 = a</span><br><span class="line">    %9 = add nsw i32 %7, %8       ;%9 = a + i</span><br><span class="line">    store i32 %9, i32* %1         ;a = a + i</span><br><span class="line">    br label %3</span><br><span class="line">    </span><br><span class="line">10:</span><br><span class="line">    ret i32 %9                    ;return a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">以上的.ll程序共有四个BasicBlock，逐个添加指令即可。.cpp中的BasicBlock与.ll的对应在注释中说明。.cpp的代码如下：</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">module</span> = <span class="keyword">new</span> <span class="built_in">Module</span>(<span class="string">&quot;while&quot;</span>);                 </span><br><span class="line">    <span class="keyword">auto</span> builder = <span class="keyword">new</span> <span class="built_in">IRBuilder</span>(<span class="literal">nullptr</span>, <span class="keyword">module</span>);                      <span class="comment">//使用IRBuilder创建指令</span></span><br><span class="line">    <span class="comment">//创建main函数和4个BasicBlock</span></span><br><span class="line">    Type *Int32Type = Type::<span class="built_in">get_int32_type</span>(<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">auto</span> mainTy = FunctionType::<span class="built_in">get</span>(Int32Type, &#123;&#125;);                     <span class="comment">//返回值为i32，参数为空</span></span><br><span class="line">    <span class="keyword">auto</span> main = Function::<span class="built_in">create</span>(mainTy, <span class="string">&quot;main&quot;</span>, <span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">auto</span> BBEntry = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>, <span class="string">&quot;entry&quot;</span> , main);</span><br><span class="line">    <span class="keyword">auto</span> BBWhile = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>, <span class="string">&quot;while&quot;</span> , main);</span><br><span class="line">    <span class="keyword">auto</span> BBTrue = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>, <span class="string">&quot;true&quot;</span> , main);</span><br><span class="line">    <span class="keyword">auto</span> BBFalse = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>, <span class="string">&quot;false&quot;</span> , main);</span><br><span class="line">    <span class="comment">//entryBasicBlock插入指令，即.ll的BasicBlock0</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(BBEntry);</span><br><span class="line">    <span class="keyword">auto</span> aP = builder-&gt;<span class="built_in">create_alloca</span>(Int32Type);                        <span class="comment">//分配a的空间，返回指针aP</span></span><br><span class="line">    <span class="keyword">auto</span> iP = builder-&gt;<span class="built_in">create_alloca</span>(Int32Type);                        <span class="comment">//分配i的空间，返回指针iP</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_store</span>(<span class="built_in">CONST_INT</span>(<span class="number">0</span>), iP);                            <span class="comment">//i = 0</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_store</span>(<span class="built_in">CONST_INT</span>(<span class="number">10</span>), aP);                           <span class="comment">//a = 10</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_br</span>(BBWhile);                                        <span class="comment">//br跳转到while循环的判断BasicBlock</span></span><br><span class="line">    <span class="comment">//whileBasicBlock插入指令，即.ll的BasicBlock3</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(BBWhile);</span><br><span class="line">    <span class="keyword">auto</span> temp = builder-&gt;<span class="built_in">create_load</span>(iP);</span><br><span class="line">    <span class="keyword">auto</span> icmp = builder-&gt;<span class="built_in">create_icmp_lt</span>(temp, <span class="built_in">CONST_INT</span>(<span class="number">10</span>));</span><br><span class="line">    builder-&gt;<span class="built_in">create_cond_br</span>(icmp, BBTrue, BBFalse);                     <span class="comment">//br跳转到True或False的BasicBlock</span></span><br><span class="line">    <span class="comment">//TrueBasicBlock插入指令，即.ll的BasicBlock6</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(BBTrue);</span><br><span class="line">    <span class="keyword">auto</span> newi = builder-&gt;<span class="built_in">create_iadd</span>(temp, <span class="built_in">CONST_INT</span>(<span class="number">1</span>));               <span class="comment">//i + 1</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_store</span>(newi, iP);                                    <span class="comment">//i = i + 1</span></span><br><span class="line">    <span class="keyword">auto</span> a = builder-&gt;<span class="built_in">create_load</span>(aP);</span><br><span class="line">    <span class="keyword">auto</span> newa = builder-&gt;<span class="built_in">create_iadd</span>(newi, a);                          <span class="comment">//a + i</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_store</span>(newa, aP);                                    <span class="comment">//a = a + i</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_br</span>(BBWhile);                                        <span class="comment">//br跳转到while循环的判断BasicBlock</span></span><br><span class="line">    <span class="comment">//FalseBasicBlock插入指令，即.ll的BasicBlock10</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(BBFalse);</span><br><span class="line">    builder-&gt;<span class="built_in">create_ret</span>(newa);                                          <span class="comment">//return a</span></span><br><span class="line">    <span class="comment">//指令创建结束</span></span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">module</span>-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">module</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">运行程序验证：</p>

<p><img src="/2022/11/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%89/image-20221121175730205.png" alt="image-20221121175730205" style="zoom:67%;"></p>
<p style="text-indent:2em">以上的.ll代码和.cpp编译运行后的.ll代码运行后均能产生正确的结果，与原.c程序的逻辑相同.</p>

<h2 id="问题2-Visitor-Pattern"><a href="#问题2-Visitor-Pattern" class="headerlink" title="问题2: Visitor Pattern"></a>问题2: Visitor Pattern</h2><p>请指出visitor.cpp中，<code>treeVisitor.visit(exprRoot)</code>执行时，以下几个Node的遍历序列:numberA、numberB、exprC、exprD、exprE、numberF、exprRoot。<br>序列请按如下格式指明：<br>exprRoot-&gt;numberF-&gt;exprE-&gt;numberA-&gt;exprD</p>
<p style="text-indent:2em">根据visitor.cpp中的内容，每个节点会返回自身的引用，visitor会进行访问该节点，计算该节点的值，计算的方式是访问其左右节点并获取值，然后根据节点的操作类型完成值的计算，然后返回。子节点的值的获取也是相同的，直到访问到数值节点，就直接返回相应的数值。可以看出访问的过程是自顶向下递归访问的过程。main函数中创建的计算树如下：</p>

<p><img src="/2022/11/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%89/image-20221121194007554.png" alt="image-20221121194007554" style="zoom: 50%;"></p>
<p style="text-indent:2em">根据visit()函数中的实现，对于AddSubNode的访问，是先访问右子节点，然后访问左子节点，对于MulDivNode的访问，先访问左子节点，后访问右子节点。因此可以得出visitor.cpp中访问该树的序列为：</p>

<p style="text-indent:2em">exprRoot->numberF->exprE->exprD->numberB->numberA->exprC->numberA->numberB</p>

<h2 id="问题3-getelementptr"><a href="#问题3-getelementptr" class="headerlink" title="问题3: getelementptr"></a>问题3: getelementptr</h2><p>请给出<code>IR.md</code>中提到的两种getelementptr用法的区别,并稍加解释:</p>
<ul>
<li><code>%2 = getelementptr [10 x i32], [10 x i32]* %1, i32 0, i32 %0</code> </li>
<li><code>%2 = getelementptr i32, i32* %1 i32 %0</code> </li>
</ul>
<p>第一种用法：</p>
<p style="text-indent:2em">指针类型为[10 x i32]*，指向的数据类型为[10 x i32]，因此首先用i32 0表示偏移为0，这表示直接取第一个[10 x i32]数组，然后的i32 %0表示在第一个[10 x i32]数组内，偏移%0的元素地址。</p>

<p>第二种用法：</p>
<p style="text-indent:2em">指针类型为i32*，%1表示的是数组的起始地址，偏移量为%0，直接取出了数组偏移%0位置的元素地址。</p>

<p>区别：</p>
<p style="text-indent:2em">在第一种用法中，指针类似于指针数组，首先确定在这个指针数组上的偏移，才能得到一个数组的指针，然后通过偏移找到元素的地址。而在第二种用法中，直接对数组的指针进行偏移，找到元素的地址。</p>

<p style="text-indent:2em">当定义全局数组或结构体时，定义的是指针，例如在给出的gcd_array.c中声明的全局数组x，y，就是[1 x i32]*类型，因此取出元素时使用的是第一种用法。</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局数组x[1]</span></span><br><span class="line">@x = common dso_local global [<span class="number">1</span> x i32] zeroinitializer, align <span class="number">4</span></span><br><span class="line"><span class="comment">//取出元素地址</span></span><br><span class="line">getelementptr inbounds ([<span class="number">1</span> x i32], [<span class="number">1</span> x i32]* @x, i64 <span class="number">0</span>, i64 <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h2><h3 id="1-编写-ll"><a href="#1-编写-ll" class="headerlink" title="1.编写.ll"></a>1.编写.ll</h3><p style="text-indent:2em">在编写if.c对应的.ll时，提示error: floating point constant invalid for type，不能用浮点常量给浮点数赋值。经查询，这是因为浮点数5.55不能用浮点数精确表示，因此不能直接给浮点数赋值。如果是4.0等可以精确表示的数，就可以直接赋值。此处只能使用十六进制的浮点数机器表示进行赋值，为0x40163851E0000000。</p>

<p style="text-indent:2em">编写while.c对应的.ll时注意到，编号顺序必须是连续的，除了if对应的块跳转语句可以出现不连续的编号，其他编号都必须是连续的。因此br语句中的跳转编号应该最后填写。</p>

<p style="text-indent:2em">编写.ll后，与.c源文件产生的.ll文件进行了比较，clang产生的.ll文件中的指令更多，对于值进行了更多的存储和取出的操作，但是逻辑上是和自行编写的.ll指令是相同的。自行编写时，临时变量直接使用寄存器存储，还有一些寄存器值也重复使用，相当于对直接产生的.ll指令优化后的结果。</p>

<h3 id="2-编写cpp"><a href="#2-编写cpp" class="headerlink" title="2.编写cpp"></a>2.编写cpp</h3><p style="text-indent:2em">编写cpp时，由于对接口不熟悉，创建对应的指令有些困难，在经过阅读gcd_array.cpp中创建指令的部分和整体结构，仿照并逐个指令完成assign.cpp后，后三个cpp代码的编写才比较顺利。</p>

<p style="text-indent:2em">创建比较指令时，指令名使用了lightIR中的ugt来表示小于，编译时提示不存在这条指令，从lightIR.h中找到，比较的指令使用的是下面的表示：</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CmpOp</span></span><br><span class="line">    &#123;</span><br><span class="line">        EQ, <span class="comment">// ==</span></span><br><span class="line">        NE, <span class="comment">// !=</span></span><br><span class="line">        GT, <span class="comment">// &gt;</span></span><br><span class="line">        GE, <span class="comment">// &gt;=</span></span><br><span class="line">        LT, <span class="comment">// &lt;</span></span><br><span class="line">        LE  <span class="comment">// &lt;=</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">因此修改相应的比较指令为以下形式：</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fcmp = builder-&gt;<span class="built_in">create_fcmp_gt</span>(a, <span class="built_in">CONST_FP</span>(<span class="number">1.0</span>)); </span><br><span class="line"><span class="keyword">auto</span> icmp = builder-&gt;<span class="built_in">create_icmp_lt</span>(temp, <span class="built_in">CONST_INT</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
<h2 id="实验反馈"><a href="#实验反馈" class="headerlink" title="实验反馈"></a>实验反馈</h2><p style="text-indent:2em">通过本次实验学习了llvm，LightIR相关知识。对于LightIR的接口，文档内容没有特别清晰，通过结合实例和.h文件中的内容才逐渐熟悉。编写.ll文件时，注意到了与clang编译代码的不同，自行编写可以在许多位置直接进行优化，而编译器可能第一步只能生成未优化的代码。对于自行编写的.ll指令，使用C++生成的过程也相对较为简洁。最后通过visitor.cpp了解了访问者模式，对于这种模式比较陌生，但是通过实例理解了其工作原理和访问过程。</p>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://a-y-1.github.io/2022/11/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9ABison/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/a0.jpg">
      <meta itemprop="name" content="橙">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橙的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9ABison/" class="post-title-link" itemprop="url">编译原理实验二：Bison</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-08 09:50:29" itemprop="dateCreated datePublished" datetime="2022-11-08T09:50:29+08:00">2022-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-20 10:53:05" itemprop="dateModified" datetime="2022-11-20T10:53:05+08:00">2022-11-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>1.了解Bision基础知识，如何将文法产生式转换为Bison语句</p>
<p>2.阅读/src/common/SyntaxTree.c，对应头文件 /include/SyntaxTree.h，理解分析树生成的过程。</p>
<p>3.了解Bison与Flex的协同工作过程，理解pass_node函数并改写lab1代码。了解yylval工作原理。</p>
<p>4.补全 src/parser/syntax_analyzer.y 文件和lexical_analyzer.l文件</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/11/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9ABison/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://a-y-1.github.io/2022/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B003/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/a0.jpg">
      <meta itemprop="name" content="橙">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橙的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B003/" class="post-title-link" itemprop="url">计算机网络自顶向下方法笔记03</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-17 17:13:22" itemprop="dateCreated datePublished" datetime="2022-10-17T17:13:22+08:00">2022-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-28 15:42:38" itemprop="dateModified" datetime="2022-11-28T15:42:38+08:00">2022-11-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p style="text-indent:2em">《计算机网络自顶向下方法》学习笔记03:网络层。</p>
<p style="text-indent:2em">网络层提供了主机到主机的通信服务。网络中的每一台主机和路由器都有网络层部分。网络层能够被分解为两部分，数据平面和控制平面。</p>

<h1 id="第四章-网络层：数据平面"><a href="#第四章-网络层：数据平面" class="headerlink" title="第四章 网络层：数据平面"></a>第四章 网络层：数据平面</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p style="text-indent:2em">网络层的任务是取得源主机的报文段，将其封装为数据报，通过路由器的转发，将数据报发送到目的主机的网络层。可以说，网络层的作用就是将分组从一台主机移动到另一台主机。网络层的功能可分为两部分：</p>

<ul>
<li>转发：路由器将输入链路的分组移动到适当的输出链路的路由器本地动作。是数据平面的主要任务。</li>
<li>路由选择：决定分组移动所采用的端到端路径。</li>
</ul>
<p style="text-indent:2em">本章主要讨论的是网络层的<b>转发</b>功能。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B003/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://a-y-1.github.io/2022/10/10/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95V2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/a0.jpg">
      <meta itemprop="name" content="橙">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橙的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/10/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95V2/" class="post-title-link" itemprop="url">刷题记录V2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-10 14:48:29" itemprop="dateCreated datePublished" datetime="2022-10-10T14:48:29+08:00">2022-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-13 22:34:26" itemprop="dateModified" datetime="2022-12-13T22:34:26+08:00">2022-12-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p style="text-indent:2em">算法题目记录。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/10/10/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95V2/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://a-y-1.github.io/2022/10/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7Flex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/a0.jpg">
      <meta itemprop="name" content="橙">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橙的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7Flex/" class="post-title-link" itemprop="url">编译原理实验一：词法分析工具Flex</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-08 14:51:29" itemprop="dateCreated datePublished" datetime="2022-10-08T14:51:29+08:00">2022-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-09 17:39:06" itemprop="dateModified" datetime="2022-10-09T17:39:06+08:00">2022-10-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p style="text-indent:2em">中科大-编译原理实验。实验指导书和文件见https://github.com/A-Y-1/HNU。</p>

<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p style="text-indent:2em">根据cminux-f的词法补全[lexical_analyer.l](../../src/lexer/lexical_analyzer.l)文件，完成词法分析器，能够输出识别出的token，type ,line(刚出现的行数)，pos_start(该行开始位置)，pos_end(结束的位置,不包含)。如：</p>

<p style="text-indent:2em">文本输入：</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">则识别结果应为：</p>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int     280     1       2       5</span><br><span class="line">a       285     1       6       7</span><br><span class="line">;       270     1       7       8</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/10/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7Flex/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://a-y-1.github.io/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B002/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/a0.jpg">
      <meta itemprop="name" content="橙">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橙的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B002/" class="post-title-link" itemprop="url">计算机网络自顶向下方法笔记02</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-19 09:48:22" itemprop="dateCreated datePublished" datetime="2022-09-19T09:48:22+08:00">2022-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-25 15:01:47" itemprop="dateModified" datetime="2022-10-25T15:01:47+08:00">2022-10-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p style="text-indent:2em">《计算机网络自顶向下方法》学习笔记02:运输层。</p>
<p style="text-indent:2em">运输层介于应用层与网络层之间，为应用层提供了直接的通信服务。在应用层时已经介绍了两种运输层协议UDP和TCP，本章主要介绍这两个协议和运输层的原理及实现。</p>

<h1 id="第三章-运输层"><a href="#第三章-运输层" class="headerlink" title="第三章 运输层"></a>第三章 运输层</h1><h2 id="1-概述和运输层服务"><a href="#1-概述和运输层服务" class="headerlink" title="1.概述和运输层服务"></a>1.概述和运输层服务</h2><p style="text-indent:2em">运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信功能。运输层协议是在端系统实现的，将应用程序的报文转换为较小的块，加上运输层首部生成运输层分组，称为<b>报文段</b>，将报文段交给网络层，由网络层发送到目的地。</p>

<p style="text-indent:2em">因特网提供了两种可用的运输层协议：UDP(用户数据报协议)，TCP(传输控制协议)。UDP提供不可靠服务，而TCP提供面向连接的可靠数据传输，还提供拥塞控制。网络层的协议即网际协议IP，提供的是不可靠服务，不确保报文段的交付和按序交付，因此本章主要讨论的一个问题是TCP如何提供<font color="red">可靠数据传输</font>，另一个主要讨论的问题是TCP如何实现<font color="red">拥塞控制</font>。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B002/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://a-y-1.github.io/2022/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B001/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/a0.jpg">
      <meta itemprop="name" content="橙">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橙的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B001/" class="post-title-link" itemprop="url">计算机网络自顶向下方法笔记01</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-11 21:17:29" itemprop="dateCreated datePublished" datetime="2022-09-11T21:17:29+08:00">2022-09-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-25 17:24:36" itemprop="dateModified" datetime="2022-09-25T17:24:36+08:00">2022-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p style="text-indent:2em">《计算机网络自顶向下方法》学习笔记。之前学习过计算机网络微课，已经对计网中的很多概念都有了印象和一定的了解了，这时候再读自顶向下感觉比较轻松了。但是自己还是更喜欢自底向上的方式，因为自顶向下时，尽管只需要知道下层能为上层提供服务，但是对下层的大致了解没有建立，感觉并不够顺畅。这本书没有涉及太多物理层的内容，第一章为概述。从第二章应用层开始，自顶向下讲解计算机网络。以下是阅读笔记。</p>

<h1 id="第二章-应用层"><a href="#第二章-应用层" class="headerlink" title="第二章 应用层"></a>第二章 应用层</h1><p style="text-indent:2em">本章的内容主要是网络应用的相关原理，网络应用的实例(Web，电子邮件，DNS，视频流)，以及简单的网络应用开发(主要学习套接字接口)。</p>

<h2 id="1-应用层协议原理"><a href="#1-应用层协议原理" class="headerlink" title="1.应用层协议原理"></a>1.应用层协议原理</h2><h3 id="1-1-应用程序体系结构"><a href="#1-1-应用程序体系结构" class="headerlink" title="1.1 应用程序体系结构"></a>1.1 应用程序体系结构</h3><ul>
<li>客户服务器体系结构</li>
<li>对等体系结构(P2P)</li>
</ul>
<p style="text-indent:2em">客户-服务器体系结构中，服务器服务来自许多其他客户主机的请求、客户之间不进行通信。服务器通常有确定的地址(IP地址)，客户通过IP地址向服务器请求服务。为了能够处理请求，通常有配备大量主机的数据中心作为虚拟服务器，而不是单独的服务器主机进行服务。</p>

<p style="text-indent:2em">P2P体系结构下，主机之间相互通信，他们被称为对等方。许多流量密集型应用都是P2P体系结构。P2P体系的特性是其具有自扩展性，每个对等方由于请求产生工作负载，同时也分发文件为系统增加服务能力。P2P体系结构不需要庞大的服务器基础设施和带宽，但由于高度非集中式结构，有安全性、性能、可靠性方面的挑战。</p>

<h3 id="1-2-数据通信"><a href="#1-2-数据通信" class="headerlink" title="1.2 数据通信"></a>1.2 数据通信</h3><p style="text-indent:2em">两个不同端系统上的进程，通过报文来通信。网络应用程序由成对的进程组成，他们通过网络相互发送报文。两个进程常被标识为客户与服务器。<b>发起通信的进程被标识为客户，在会话开始时等待联系的进程是服务器。</b></p>

<p style="text-indent:2em">进程是通过称为套接字的软件接口来发送和接收报文的。套接字是应用程序和网络之间的应用程序编程接口。对于套接字，后续有详细的讨论。</p>

<p style="text-indent:2em">两进程间通信，发送分组的进程需要知道接收分组的进程地址。地址由两部分构成：主机地址；主机中接收进程的标识符。这两部分由IP地址和目的地端口号来标识。</p>

<h3 id="1-3-可供应用程序使用的运输服务"><a href="#1-3-可供应用程序使用的运输服务" class="headerlink" title="1.3 可供应用程序使用的运输服务"></a>1.3 可供应用程序使用的运输服务</h3><p style="text-indent:2em">运输层为应用层提供服务，应用程序服务的要求有以下四个方面：</p>

<ul>
<li>可靠数据传输</li>
<li>吞吐量</li>
<li>定时</li>
<li>安全性</li>
</ul>
<h3 id="1-4-因特网提供的运输服务"><a href="#1-4-因特网提供的运输服务" class="headerlink" title="1.4 因特网提供的运输服务"></a>1.4 因特网提供的运输服务</h3><ul>
<li>TCP服务<ul>
<li>面向连接</li>
<li>可靠数据传输</li>
<li>安全性：安全套接字层(SSL)加强了TCP，提供安全服务</li>
</ul>
</li>
<li>UDP服务：仅提供最小服务，无连接，不保证报文到达接收进程。</li>
</ul>
<p style="text-indent:2em">定时和吞吐量是因特网运输协议不能保证的，但通常因特网是可以为时间敏感应用提供满意的服务的。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B001/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://a-y-1.github.io/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/a0.jpg">
      <meta itemprop="name" content="橙">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="橙的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">编译原理笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-07 21:20:29" itemprop="dateCreated datePublished" datetime="2022-09-07T21:20:29+08:00">2022-09-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-24 17:42:47" itemprop="dateModified" datetime="2022-12-24T17:42:47+08:00">2022-12-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p style="text-indent:2em">编译原理学习笔记。参考：</p>

<p>​        编译原理(中科大)：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16h411X7JY?p=1">https://www.bilibili.com/video/BV16h411X7JY?p=1</a></p>
<p>​        编译原理(哈工大)：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1zW411t7YE?p=1">https://www.bilibili.com/video/BV1zW411t7YE?p=1</a></p>
<p style="text-indent:2em">笔记是根据书+网课+本校课程按照理解过程记录，和书或网课的顺序不一致。主要的算法都是来自《现代编译原理：c语言描述》(虎书)，因为与一般学习编译原理用的龙书有差异，将需要注意的情况在下面列出，这些不同主要在语法分析部分，不影响语法分析的算法思想和过程，列出来仅是为了避免在学习过程中产生困惑。</p>

<ul>
<li>自顶向下的语法分析计算了NULLABLE集，FIRST集，FOLLOW集，FIRST_S集，其中的FIRST_S集更常见的说法是SELECT集。</li>
<li>使用算法计算FIRST(N)集时，没有将空串加入FIRST集，这是因为已经计算了NULLABLE集，不需要把空串包含到FIRST集当中了。</li>
<li>在使用虎书的方法计算FIRST集，FOLLOW集中，不包含#符号和$符号，实际这两个符号也只是标记结束，不影响语法分析过程。</li>
</ul>
<h1 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h1><h2 id="1-语言处理器"><a href="#1-语言处理器" class="headerlink" title="1.语言处理器"></a>1.语言处理器</h2><ul>
<li>编译器</li>
<li>解释器</li>
</ul>
<h2 id="2-编译器的结构"><a href="#2-编译器的结构" class="headerlink" title="2.编译器的结构"></a>2.编译器的结构</h2><ul>
<li>词法分析：将语素转换为词法单元</li>
<li>语法分析：使用词法单元创建树形的中间表示，常用语法树。</li>
<li>语义分析：检查源程序是否和语言定义的语义一致，并进行类型检查。</li>
<li>中间代码生成</li>
<li>代码优化</li>
<li>代码生成：以源程序的中间表示形式作为输入，映射到目标语言。</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="橙"
      src="/images/a0.jpg">
  <p class="site-author-name" itemprop="name">橙</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/A-Y-1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;A-Y-1" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">橙</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">178k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:42</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
