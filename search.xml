<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>FastLoad-针对GPU加速访存的SpMV算法</title>
      <link href="/2025/06/06/FastLoad-SpMV/"/>
      <url>/2025/06/06/FastLoad-SpMV/</url>
      
        <content type="html"><![CDATA[<p>偶然看到本科时体系结构课程老师实验室的一篇工作，是GPU上的SpMV，在suitsparse所有矩阵上性能表现优异，发表在TPDS24上，印象深刻，最近有时间阅读，做个仔细的笔记。</p><h1 id="FastLoad-Speeding-Up-Data-Loading-of-Both-Sparse-Matrix-and-Vector-for-SpMV-on-GPUs"><a href="#FastLoad-Speeding-Up-Data-Loading-of-Both-Sparse-Matrix-and-Vector-for-SpMV-on-GPUs" class="headerlink" title="FastLoad: Speeding Up Data Loading of Both Sparse Matrix and Vector for SpMV on GPUs"></a>FastLoad: Speeding Up Data Loading of Both Sparse Matrix and Vector for SpMV on GPUs</h1><h2 id="1-概况"><a href="#1-概况" class="headerlink" title="1 概况"></a>1 概况</h2><p>本篇工作是针对GPU CUDACORE计算SpMV的高性能实现，优化角度主要是负载均衡和加速访存。在<strong>整个suitSparse数据集</strong>上，相较于cuSPARSE，CSR5和TileSpMV有平均2.98x，2.88x，1.22x的加速比。</p><p>负载不均衡和访存不连续是不规则应用在GPU上性能瓶颈的主要原因。有一些研究(例如Eﬀicient Algorithm Design of Optimizing SpMV on GPU)能保证矩阵数据的读取是连续的，并且可在GPU上访存合并，但是对向量x的访问总是不连续的。FastLoad主要是为了解决这个问题设计的算法。</p><p>FastLoad使用CSC作为基本的存储格式，提升性能的主要手段有：</p><ul><li>根据每列的非零元素数量对列进行排序：主要尽可能保证访存可合并</li><li>分块：保证负载尽可能均衡</li></ul><h2 id="2-背景"><a href="#2-背景" class="headerlink" title="2 背景"></a>2 背景</h2><p>FastLoad是基于CSC存储格式设计的。对于CSC格式，一种基本的并行方式是一列被分配给一个warp。这样一个warp对值的访问是连续的。内存合并访问对于GPU计算的性能是非常重要的，所以FastLoad希望对向量x的访问也是可合并访问的，所以有了分块的设计，后面会详细介绍。</p><p>FastLoad为了探索内存合并的性能优化空间，做了一个有趣的假设性实验。一个基本的认识是，CSR格式对于矩阵数据的访问都是可合并的，对于向量x的访问是不连续的，而CSC格式把临时结果写回到向量的时候是无法连续的，如下图所示：</p><p><img src="/2025/06/06/FastLoad-SpMV/image-20250604193321440.png" alt="image-20250604193321440"></p><p>所以FastLoad做了一个实验，按照非零元素对列排序，将宽为32个列的块分配给一个warp，高度则是第一列的非零元素数，这样首先对矩阵数据的访问和对x的访问是连续的，相当于利用了CSC格式的优势。而中间结果是CSC格式，和原矩阵大小应该是完全一样的，在做完这一步之后，将格式转换回CSR格式，做写回的累加，按行写回，这样写回就也是连续的。当然，这只是一个测试访存合并效果的假设实验，因此格式转换的开销没有计入，整体的性能在不计入转换开销的情况下有非常大的提升。</p><p>基于上述实验，FastLoad认为合并访存有足够大的性能提升空间，因此尝试在不做格式转换的情况下合并访存。</p><h2 id="3-算法设计-amp-实现"><a href="#3-算法设计-amp-实现" class="headerlink" title="3 算法设计&amp;实现"></a>3 算法设计&amp;实现</h2><h3 id="3-1-存储结构"><a href="#3-1-存储结构" class="headerlink" title="3.1 存储结构"></a>3.1 存储结构</h3><p>FastLoad是基于CSC格式设计的，但需要额外的辅助数组，因为线程warp每次操作的是2D块，所以对矩阵做2D划分需要额外的数据结构。对于块，需要三个额外的数组，一个是==blkColIdx==，记录每个块的起始列号；==blkLength==则是记录了每个块的长度，虽然默认情况下应该是warp线程数，但是不一定有足够的列，因为块的起始列不是对齐的，和元素有关。最后还有一个==blkHeight==，记录块的高度，这个主要是用于计算每个warp需要迭代几轮算完一个块，一般来说是第一列的非零元素数(对列排完序以后第一列是非零元素最少的)，但是有些列可能到最后元素不够了。</p><p>对于CSC原有的数据结构，colPtr变成blkPtr了记录块的起始位置，值和索引要调整为以块的单位，并且Z字型排布。如下图所示：</p><p><img src="/2025/06/06/FastLoad-SpMV/image-20250604200315679.png" alt="image-20250604200315679"></p><h3 id="3-2-FastLoad-SpMV"><a href="#3-2-FastLoad-SpMV" class="headerlink" title="3.2 FastLoad SpMV"></a>3.2 FastLoad SpMV</h3><p>FastLoad SpMV和上面的假设实验一样，采用两个阶段的SpMV算法，第一个阶段做数据加载和乘法，第二个阶段做累加和写回，但全程都是基于上述的CSC+额外数组的稀疏矩阵存储结构。在计算的时候通过blkColIdx+laneid来定位当前的列，每个warp会迭代blkHeight轮。</p><p>整个算法的第一步是列的排序和块的划分，第二步则是GPU的计算和结果数据的写回。因为每个warp算完的数据可能不是同一行的，所以使用原子加将结果加到对应的结果向量y的位置上，但是原子加随着矩阵的大小增加，效率会很低，所以FastLoad还采用了段求和和前缀和的方式来规约结果。具体而言，根据上图，有一些相邻线程的行索引是相同的，因此可以采用shuffle操作来在warp内实现规约。还有一种可能是warp内的全部元素都是一行的，这种情况下，使用前缀和的方式来求规约结果。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>FastLoad通过2D分块实现了对矩阵元素和向量都连续进行访问，并且取得了相当优秀的性能，代码也进行了开源，这或许是这篇工作能投稿TPDS的原因。主要的优化思路还是最大化合并内存访问。但是在整篇文章中阅读之后还是有些疑惑，FastLoad和background章节介绍的实验还是有差别的，最后写入y的时候应该仍然是无法保证连续的，论文配图中给出的矩阵其实相对来说比较密集了，每个元素在列方向都有相邻的元素，但在实际情况下如果是高稀疏度的矩阵，应该在行上是完全离散的，所以写回时候的性能仍然是个问题。如果只是前面的计算时候访存的合并就带来了这么大的性能提升，感觉应该之前的工作有做过这样的尝试，不过相较于CSR5，确实在格式上访存更加连续了，这是同样2D块划分的优势。最近没有在做SpMV相关的事了，如果后面有机会，还要好好再研究一下这篇工作。</p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近期工作的一些问题记录</title>
      <link href="/2025/05/31/%E8%BF%91%E6%9C%9F%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2025/05/31/%E8%BF%91%E6%9C%9F%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>近期工作的一些问题记录。</p><h2 id="1-包管理"><a href="#1-包管理" class="headerlink" title="1 包管理"></a>1 包管理</h2><p><strong>库的管理搜索</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt list --install | grep </span><br><span class="line">apt search packageKeyWord</span><br><span class="line">whereis libscalapack-openmpi</span><br></pre></td></tr></table></figure><p>默认的动态库搜索路径是/usr/lib和/lib，ls /etc/ld.so.conf.d/可查看链接配置文件，其中可能会有搜索路径配置，例如WSL上 cat /etc/ld.so.conf.d/x86_64-linux-gnu.conf ，有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Multiarch support</span></span><br><span class="line">/usr/local/lib/x86_64-linux-gnu</span><br><span class="line">/lib/x86_64-linux-gnu</span><br><span class="line">/usr/lib/x86_64-linux-gnu</span><br></pre></td></tr></table></figure><p>说明/usr/local/lib/x86_64-linux-gnu也在动态库搜索路径中。</p><p>静态库的默认搜索路径是/usr/local/lib和/lib。和动态库不同，因为动态库是全局的所以分为了/lib和/usr/lib这样系统/用户两个路径，然后通过ld.so.conf以及LD_LIBRARY_PATH补充，而静态库通过-L指定路径。</p><p><strong>mpi的编译器</strong></p><p>mpif90是一个包装器，可以检查mpi指定的底层编译器是哪一个：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mpif90 --showme:command</span><br><span class="line">gfortran</span><br><span class="line">mpif90 --showme:link</span><br><span class="line">-I/usr/lib/x86_64-linux-gnu/openmpi/lib -L/usr/lib/x86_64-linux-gnu/openmpi/lib/fortran/gfortran -lmpi_usempif08 -lmpi_usempi_ignore_tkr -lmpi_mpifh -lmpi -lopen-rte -lopen-pal -lhwloc -levent_core -levent_pthreads -lm -lz</span><br></pre></td></tr></table></figure><p><strong>Scalapack链接</strong></p><p>之前在本地环境是直接apt install了scalapack-openmpi并直接链接了动态库版本，可以直接find_package找到，在集群上有点差别。首先检查module是否提供了软件环境，直接load：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module load mathlib/lapack/gnu/3.8.0</span><br><span class="line">module load mathlib/openblas/gnu/0.3.7</span><br></pre></td></tr></table></figure><p>load之后不一定能链接的上，因为scalapack的.cmake没有被装到cmake能自动查找到的路径，所以需要手动搜索一下.cmake文件在哪里，然后加入到cmakelists当中：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_PREFIX_PATH <span class="string">&quot;/public/software/mathlib/scalapack/GNU/7.2.1&quot;</span> CACHE PATH <span class="string">&quot;Path to ScaLAPACK installation&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="2-进程被kill问题排查"><a href="#2-进程被kill问题排查" class="headerlink" title="2 进程被kill问题排查"></a>2 进程被kill问题排查</h2><p>本地运行DB-SpGEMM进程被kill，定位信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dmesg -T | egrep -i &#x27;killed process&#x27;</span><br><span class="line">[Wed May 21 11:21:39 2025] Out of memory: Killed process 2358 (TRS4example) total-vm:8959856kB, anon-rss:6007352kB, file-rss:0kB, shmem-rss:464kB, UID:1000 pgtables:15864kB oom_score_adj:0是什么意思</span><br></pre></td></tr></table></figure><p>可以确认是OOM导致被kill的，进一步用mallocinfo去确认哪里触发了OOM（valgrind未排查出问题）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">mallinfo2</span> <span class="title">mi_before</span>, <span class="title">mi_after</span>;</span></span><br><span class="line">mi_before = mallinfo2();</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">   mi_after  = mallinfo2();</span><br><span class="line">   <span class="keyword">if</span>(matA.process_grid-&gt;global_rank==<span class="number">0</span>)  <span class="built_in">printf</span>(<span class="string">&quot;I=%d J=%d Heap alloc delta: %zu bytes\n&quot;</span>, I, J, mi_after.uordblks - mi_before.uordblks);</span><br></pre></td></tr></table></figure><p>最终定位到是InverseRootSquare-Matmul一个循环中有一个多层vector的insert导致发生了OOM，程序正常运行的话，从函数返回会正常析构，但计算1024个原子的时候就会在这个循环中OOM导致MPI进程被kill，确认数据块使用完毕后将vector清空就可以了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;().swap( LocalSliceMat[I][J] );</span><br></pre></td></tr></table></figure><h2 id="3-链接问题"><a href="#3-链接问题" class="headerlink" title="3 链接问题"></a>3 链接问题</h2><p>编写的静态库find_package找到了需要使用的blas库，但是静态库不会携带依赖的动态库信息，所以外部链接该库时不会自动链接该blas，但是程序能正常运行，说明有默认的blas库会被加载（或者静态库直接被编译到了静态库中），这导致了性能有极大的问题，但只要在应用编译时显示链接需要的blas库就能解决。</p><p>该问题在测试时没有注意到是因为库的同一工程下的测试程序会因为CMake的目标传播机制，自动完成需要的库的链接：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(BLAS REQUIRED)</span><br><span class="line"><span class="keyword">add_library</span>(dbspgemmTRS4 STATIC ...)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(dbspgemmTRS4 PRIVATE <span class="variable">$&#123;BLAS_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(example PRIVATE dbspgemmTRS4)</span><br></pre></td></tr></table></figure><p>如果单独使用.a，所有需要的动态库都必须明确显示链接。</p><h2 id="4-TSR4-in-NTPoly"><a href="#4-TSR4-in-NTPoly" class="headerlink" title="4 TSR4 in NTPoly"></a>4 TSR4 in NTPoly</h2><p>Input output</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">SUBROUTINE</span></span> TRS4(H, ISQ, trace, K, energy_value_out, chemical_potential_out, solver_parameters_in)</span><br><span class="line">  <span class="keyword">TYPE</span>(Matrix_ps), <span class="keyword">INTENT</span>(<span class="keyword">IN</span>)  :: H           <span class="comment">! 输入哈密顿矩阵</span></span><br><span class="line">  <span class="keyword">TYPE</span>(Matrix_ps), <span class="keyword">INTENT</span>(<span class="keyword">IN</span>) :: ISQ          <span class="comment">! 重叠矩阵的逆平方根</span></span><br><span class="line">  <span class="keyword">REAL</span>(NTREAL), <span class="keyword">INTENT</span>(<span class="keyword">IN</span>) :: trace           <span class="comment">! 密度矩阵的迹（如电子数）</span></span><br><span class="line">  <span class="keyword">TYPE</span>(Matrix_ps), <span class="keyword">INTENT</span>(INOUT) :: K         <span class="comment">! 输出密度矩阵</span></span><br><span class="line">  <span class="keyword">REAL</span>(NTREAL), <span class="keyword">INTENT</span>(<span class="keyword">OUT</span>), <span class="keyword">OPTIONAL</span> :: energy_value_out        <span class="comment">! 系统能量</span></span><br><span class="line">  <span class="keyword">REAL</span>(NTREAL), <span class="keyword">INTENT</span>(<span class="keyword">OUT</span>), <span class="keyword">OPTIONAL</span> :: chemical_potential_out  <span class="comment">! 化学势</span></span><br><span class="line">  <span class="keyword">TYPE</span>(SolverParameters_t), <span class="keyword">INTENT</span>(<span class="keyword">IN</span>), <span class="keyword">OPTIONAL</span> :: solver_parameters_in  <span class="comment">! 求解器参数</span></span><br></pre></td></tr></table></figure><p>initilize</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">!! 处理可选参数</span></span><br><span class="line"><span class="keyword">IF</span> (<span class="built_in">PRESENT</span>(solver_parameters_in)) <span class="keyword">THEN</span></span><br><span class="line">   <span class="keyword">CALL</span> CopySolverParameters(solver_parameters_in, params)</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">   <span class="keyword">CALL</span> ConstructSolverParameters(params)  <span class="comment">! 使用默认参数</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span></span><br></pre></td></tr></table></figure><p>convergence monitor</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">!! 初始化监控器（用于收敛判断）</span></span><br><span class="line"><span class="keyword">CALL</span> ConstructMonitor(params%monitor, automatic_in=params%monitor_convergence, tight_cutoff_in=params%converge_diff)</span><br></pre></td></tr></table></figure><p>相似变换</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">!! 构造空矩阵（K、WH、X_k等）</span></span><br><span class="line"><span class="keyword">CALL</span> ConstructEmptyMatrix(K, H)  <span class="comment">! 初始化密度矩阵K与H同维</span></span><br><span class="line"><span class="keyword">CALL</span> ConstructEmptyMatrix(WH, H) <span class="comment">! 工作哈密顿矩阵</span></span><br><span class="line"><span class="keyword">CALL</span> FillMatrixIdentity(IMat)    <span class="comment">! 构造单位矩阵IMat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!! 相似变换：H → WH = ISQ * H * ISQ^T</span></span><br><span class="line"><span class="keyword">CALL</span> TransposeMatrix(ISQ, ISQT)</span><br><span class="line"><span class="comment">!! A LEFT RIFGHT : RETURN LEFT A RIGHT Remove  small elements </span></span><br><span class="line"><span class="keyword">CALL</span> SimilarityTransform(H, ISQ, ISQT, WH, pool, threshold_in=params%threshold)</span><br></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">!! 负载均衡（优化矩阵分布）</span></span><br><span class="line"><span class="keyword">IF</span> (params%do_load_balancing) <span class="keyword">THEN</span></span><br><span class="line">   <span class="keyword">CALL</span> PermuteMatrix(WH, WH, params%BalancePermutation, memorypool_in=pool)</span><br><span class="line">   <span class="keyword">CALL</span> PermuteMatrix(IMat, IMat, params%BalancePermutation, memorypool_in=pool)</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span></span><br></pre></td></tr></table></figure><p>特征值范围与矩阵初始化X_k</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">!! 计算WH的Gershgorin边界（估计特征值范围[e_min, e_max]）</span></span><br><span class="line"><span class="keyword">CALL</span> GershgorinBounds(WH, e_min, e_max)</span><br><span class="line"></span><br><span class="line"><span class="comment">!! 初始化X_k矩阵</span></span><br><span class="line"><span class="keyword">CALL</span> CopyMatrix(WH, X_k)</span><br><span class="line"><span class="keyword">CALL</span> ScaleMatrix(X_k, -<span class="number">1.0_NTREAL</span>)        <span class="comment">! X_k = -WH</span></span><br><span class="line"><span class="keyword">CALL</span> IncrementMatrix(IMat, X_k, alpha_in=e_max)  <span class="comment">! X_k = I*e_max - WH</span></span><br><span class="line"><span class="keyword">CALL</span> ScaleMatrix(X_k, <span class="number">1.0_NTREAL</span>/(e_max - e_min)) <span class="comment">! X_k = (I*e_max - WH)/(e_max - e_min)</span></span><br></pre></td></tr></table></figure><p>TSR4主循环</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DO</span> II = <span class="number">1</span>, params%max_iterations</span><br><span class="line">   <span class="comment">!! 计算X_k^2 → X_k2</span></span><br><span class="line">   <span class="keyword">CALL</span> MatrixMultiply(X_k, X_k, X_k2, threshold_in=params%threshold, memory_pool_in=pool)</span><br><span class="line"></span><br><span class="line">   <span class="comment">!! 计算Fx_right = 4*X_k - 3*X_k2 和 Gx_right = I - 2*X_k + X_k2</span></span><br><span class="line">   <span class="keyword">CALL</span> CopyMatrix(X_k2, Fx_right)</span><br><span class="line">   <span class="keyword">CALL</span> ScaleMatrix(Fx_right, -<span class="number">3.0_NTREAL</span>)</span><br><span class="line">   <span class="comment">!!Fright = 4X-3X^2</span></span><br><span class="line">   <span class="keyword">CALL</span> IncrementMatrix(X_k, Fx_right, alpha_in=<span class="number">4.0_NTREAL</span>)</span><br><span class="line"><span class="comment">!!Gright = I-2X+X^2</span></span><br><span class="line">   <span class="keyword">CALL</span> CopyMatrix(IMat, Gx_right)</span><br><span class="line">   <span class="keyword">CALL</span> IncrementMatrix(X_k, Gx_right, alpha_in=-<span class="number">2.0_NTREAL</span>)</span><br><span class="line">   <span class="keyword">CALL</span> IncrementMatrix(X_k2, Gx_right)</span><br><span class="line"></span><br><span class="line">   <span class="comment">!! 计算迹：trace_fx = Tr(X_k2 * Fx_right), trace_gx = Tr(X_k2 * Gx_right)</span></span><br><span class="line">   <span class="comment">!! Frobenius内积</span></span><br><span class="line">   <span class="keyword">CALL</span> DotMatrix(X_k2, Fx_right, trace_fx)</span><br><span class="line">   <span class="keyword">CALL</span> DotMatrix(X_k2, Gx_right, trace_gx)</span><br><span class="line"></span><br><span class="line">   <span class="comment">!! 计算sigma（调整参数）</span></span><br><span class="line">   <span class="keyword">IF</span> (<span class="built_in">ABS</span>(trace_gx) &lt; <span class="number">1.0e-14_NTREAL</span>) <span class="keyword">THEN</span></span><br><span class="line">      sigma_array(II) = <span class="number">0.5</span>*(sigma_max - sigma_min)</span><br><span class="line">   <span class="keyword">ELSE</span></span><br><span class="line">      sigma_array(II) = (trace - trace_fx)/trace_gx  <span class="comment">! 公式：σ = (Tr - Tr_fx)/Tr_gx</span></span><br><span class="line">   <span class="keyword">END</span> <span class="keyword">IF</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">!! 根据sigma更新X_k</span></span><br><span class="line">   <span class="keyword">IF</span> (sigma_array(II) &gt; sigma_max) <span class="keyword">THEN</span></span><br><span class="line">      <span class="keyword">CALL</span> CopyMatrix(X_k, TempMat)</span><br><span class="line">      <span class="keyword">CALL</span> ScaleMatrix(TempMat, <span class="number">2.0_NTREAL</span>)</span><br><span class="line">      <span class="comment">!!TempMat = 2X-X^2</span></span><br><span class="line">      <span class="keyword">CALL</span> IncrementMatrix(X_k2, TempMat, alpha_in=-<span class="number">1.0_NTREAL</span>)</span><br><span class="line">   <span class="keyword">ELSE</span> <span class="keyword">IF</span> (sigma_array(II) &lt; sigma_min) <span class="keyword">THEN</span></span><br><span class="line">   <span class="comment">!!TempMat = X^2</span></span><br><span class="line">      <span class="keyword">CALL</span> CopyMatrix(X_k2, TempMat)</span><br><span class="line">   <span class="keyword">ELSE</span></span><br><span class="line">      <span class="comment">!!TempMat = F(X) + γG(X)</span></span><br><span class="line">      <span class="keyword">CALL</span> ScaleMatrix(Gx_right, sigma_array(II))</span><br><span class="line">      <span class="keyword">CALL</span> IncrementMatrix(Fx_right, Gx_right)</span><br><span class="line">      <span class="keyword">CALL</span> MatrixMultiply(X_k2, Gx_right, TempMat, threshold_in=params%threshold, memory_pool_in=pool)</span><br><span class="line">   <span class="keyword">END</span> <span class="keyword">IF</span></span><br><span class="line">   <span class="keyword">CALL</span> IncrementMatrix(TempMat, X_k, alpha_in=-<span class="number">1.0_NTREAL</span>)</span><br><span class="line">   <span class="keyword">CALL</span> CopyMatrix(TempMat, X_k)</span><br><span class="line"></span><br><span class="line">   <span class="comment">!! 计算能量并检查收敛 Tr=(Xk WH)</span></span><br><span class="line">   <span class="keyword">CALL</span> DotMatrix(X_k, WH, energy_value)</span><br><span class="line">   <span class="keyword">CALL</span> AppendValue(params%monitor, energy_value - energy_value_old)</span><br><span class="line">   <span class="keyword">IF</span> (CheckConverged(params%monitor, params%be_verbose)) <span class="keyword">EXIT</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">DO</span></span><br></pre></td></tr></table></figure><p>反变换与化学势计算</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">!! 逆负载均衡置换</span></span><br><span class="line"><span class="keyword">IF</span> (params%do_load_balancing) <span class="keyword">THEN</span></span><br><span class="line">   <span class="keyword">CALL</span> UndoPermuteMatrix(X_k, X_k, params%BalancePermutation, memorypool_in=pool)</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!! 反变换：K = ISQT * X_k * ISQ</span></span><br><span class="line"><span class="keyword">CALL</span> SimilarityTransform(X_k, ISQT, ISQ, K, pool, threshold_in=params%threshold)</span><br><span class="line"></span><br><span class="line">  <span class="comment">!! Compute The Chemical Potential</span></span><br><span class="line">  <span class="keyword">IF</span> (<span class="built_in">PRESENT</span>(chemical_potential_out)) <span class="keyword">THEN</span></span><br><span class="line">     interval_a = <span class="number">0.0_NTREAL</span></span><br><span class="line">     interval_b = <span class="number">1.0_NTREAL</span></span><br><span class="line">     midpoint = <span class="number">0.0_NTREAL</span></span><br><span class="line">     midpoints: <span class="keyword">DO</span> II = <span class="number">1</span>, params%max_iterations</span><br><span class="line">        midpoint = (interval_b - interval_a) / <span class="number">2.0_NTREAL</span> + interval_a</span><br><span class="line">        zero_value = midpoint</span><br><span class="line">        <span class="comment">!! Compute polynomial function at the guess point.</span></span><br><span class="line">        polynomial: <span class="keyword">DO</span> JJ = <span class="number">1</span>, total_iterations</span><br><span class="line">           <span class="keyword">IF</span> (sigma_array(JJ) .GT. sigma_max) <span class="keyword">THEN</span></span><br><span class="line">              zero_value = <span class="number">2.0_NTREAL</span> * zero_value - zero_value*zero_value</span><br><span class="line">           <span class="keyword">ELSE</span> <span class="keyword">IF</span> (sigma_array(JJ) .LT. sigma_min) <span class="keyword">THEN</span></span><br><span class="line">              zero_value = zero_value * zero_value</span><br><span class="line">           <span class="keyword">ELSE</span></span><br><span class="line">              tempfx = (zero_value * zero_value) * &amp;</span><br><span class="line">                   &amp; (<span class="number">4.0_NTREAL</span> * zero_value - &amp;</span><br><span class="line">                   &amp;  <span class="number">3.0_NTREAL</span> * zero_value * zero_value)</span><br><span class="line">              tempgx = (zero_value*zero_value) * (<span class="number">1.0_NTREAL</span> - zero_value) &amp;</span><br><span class="line">                   &amp; * (<span class="number">1.0_NTREAL</span> - zero_value)</span><br><span class="line">              zero_value = tempfx + sigma_array(JJ) * tempgx</span><br><span class="line">           <span class="keyword">END</span> <span class="keyword">IF</span></span><br><span class="line">        <span class="keyword">END</span> <span class="keyword">DO</span> polynomial</span><br><span class="line">        <span class="comment">!! Change bracketing.</span></span><br><span class="line">        <span class="keyword">IF</span> (zero_value .LT. <span class="number">0.5_NTREAL</span>) <span class="keyword">THEN</span></span><br><span class="line">           interval_a = midpoint</span><br><span class="line">        <span class="keyword">ELSE</span></span><br><span class="line">           interval_b = midpoint</span><br><span class="line">        <span class="keyword">END</span> <span class="keyword">IF</span></span><br><span class="line">        <span class="comment">!! Check convergence.</span></span><br><span class="line">        <span class="keyword">IF</span> (<span class="built_in">ABS</span>(zero_value-<span class="number">0.5_NTREAL</span>) .LT. params%converge_diff) <span class="keyword">THEN</span></span><br><span class="line">           <span class="keyword">EXIT</span></span><br><span class="line">        <span class="keyword">END</span> <span class="keyword">IF</span></span><br><span class="line">     <span class="keyword">END</span> <span class="keyword">DO</span> midpoints</span><br><span class="line">     <span class="comment">!! Undo scaling.</span></span><br><span class="line">     chemical_potential_out = e_max + (e_min - e_max) * midpoint</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">IF</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-逆平方根实现"><a href="#5-逆平方根实现" class="headerlink" title="5 逆平方根实现"></a>5 逆平方根实现</h2><p><a href="https://github.com/william-dawson/NTPoly/wiki/Matrix-Square-Root#overview">NTPoly wiki</a>给出的Inverse Suare Root的实现方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ComputeSqrt</span>(<span class="params">InputMatrix</span>):</span><br><span class="line">  matrix_dimension = InputMatrix.shape[<span class="number">0</span>]</span><br><span class="line">  identity_matrix = identity(matrix_dimension)</span><br><span class="line"></span><br><span class="line">  min_val, max_val = Helper.EigenCircle(InputMatrix)</span><br><span class="line">  lamda = <span class="number">1</span>/max_val</span><br><span class="line"></span><br><span class="line">  Yk = InputMatrix.copy()</span><br><span class="line">  Zk = identity_matrix.copy()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">1000</span>):</span><br><span class="line">    Xk = lamda*Yk.dot(Zk)</span><br><span class="line">    Tk = <span class="number">0.5</span>*(<span class="number">3.0</span>*identity_matrix - Xk)</span><br><span class="line">    Ykplusone = Tk.dot(Yk)</span><br><span class="line">    norm_value = norm(Yk - Ykplusone)</span><br><span class="line">    Zk = Zk.dot(Tk)</span><br><span class="line">    Yk = Ykplusone.copy()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (norm_value &lt; <span class="number">1e-10</span>):</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">  return_mat = sqrt(lamda)*Yk</span><br><span class="line">  inverse_return_mat = sqrt(lamda)*Zk</span><br></pre></td></tr></table></figure><p>根据NTPOLY的调用链，norm计算的是列和范数，即每一列所有的绝对值进行累加，得到每列的L1范数，然后获取所有列的最大L1范数，作为判断是否收敛的标准。</p><h2 id="6-Transformat"><a href="#6-Transformat" class="headerlink" title="6 Transformat"></a>6 Transformat</h2><p>对于12000*12000的矩阵，分发时间占比最大。</p><h3 id="6-1-SCALAPACK-2-DBSpGEMM"><a href="#6-1-SCALAPACK-2-DBSpGEMM" class="headerlink" title="6.1 SCALAPACK 2 DBSpGEMM"></a>6.1 SCALAPACK 2 DBSpGEMM</h3><h4 id="6-1-1-接口说明"><a href="#6-1-1-接口说明" class="headerlink" title="6.1.1 接口说明"></a>6.1.1 接口说明</h4><p>首先要有一个scalapack的ictxt和desc。</p><p>转换的第一步是根据矩阵形状获取对齐保证进程均分矩阵的虚拟矩阵大小，然后根据这个建立DB-SpGEMM的进程网格：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> target_block_size = atoi(argv[<span class="number">3</span>]), total_blocks, aligned_mtx_size;</span><br><span class="line">ProcessGrid pg;</span><br></pre></td></tr></table></figure><p>获取填充矩阵整体大小的函数为getBlocks：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getBlocks</span><span class="params">(<span class="type">int</span> N, <span class="comment">//原矩阵大小</span></span></span><br><span class="line"><span class="params">               <span class="type">int</span> process_rows,<span class="comment">//进程网格参数</span></span></span><br><span class="line"><span class="params">               <span class="type">int</span> process_columns,</span></span><br><span class="line"><span class="params">               <span class="type">int</span> spgemm_block_size, <span class="comment">//SpGEMM计算的块大小</span></span></span><br><span class="line"><span class="params">               <span class="type">int</span> &amp;aligned_mtx_size, <span class="comment">//对齐的矩阵大小，输出</span></span></span><br><span class="line"><span class="params">               <span class="type">int</span> &amp;total_blocks)</span>;<span class="comment">//对齐的矩阵的总块数，输出</span></span><br></pre></td></tr></table></figure><p>使用getBlocks获取的对齐后的矩阵大小来创建进程网格，并构造一个空矩阵用于转换，为了支持slcie&gt;1的场景，nproc_row <em> nproc_col </em> slice必须与总进程数相同，nproc_row和nproc_col在支持slice=1后，可以与原网格不同。目前场景下，转换前后的网格暂时必须保持完全一致。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pg.ConstructProcessGrid(MPI_COMM_WORLD, nproc_row, nproc_col, <span class="number">1</span>, total_blocks);</span><br><span class="line">DistBlockMat <span class="title function_">distblockmat</span><span class="params">(aligned_mtx_size, &amp;pg)</span>;</span><br></pre></td></tr></table></figure><p>格式转换函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">formatTransform</span><span class="params">(<span class="type">int</span> ictxt, <span class="comment">//scalapack进程上下文</span></span></span><br><span class="line"><span class="params">                     <span class="type">int</span> *desc_origin , <span class="comment">//原始矩阵描述符</span></span></span><br><span class="line"><span class="params">                     <span class="type">double</span> *local_origin, <span class="comment">//原始矩阵数据</span></span></span><br><span class="line"><span class="params">                     <span class="type">int</span> myrow, <span class="type">int</span> mycol,  <span class="comment">//scalapack进程网格中的坐标</span></span></span><br><span class="line"><span class="params">                     <span class="type">int</span> spgemm_block_size,<span class="comment">//spgemm的块大小</span></span></span><br><span class="line"><span class="params">                     <span class="type">int</span> slice, <span class="comment">//进程slice数 (冗余参数)</span></span></span><br><span class="line"><span class="params">                     ProcessGrid *pg, <span class="comment">//spgemm进程网格</span></span></span><br><span class="line"><span class="params">                     DistBlockMat &amp;distblockmat, <span class="comment">//spgemm矩阵存储格式 预分配空间</span></span></span><br><span class="line"><span class="params">                     <span class="type">int</span> total_blocks)</span>;<span class="comment">//对齐后的矩阵总块数</span></span><br></pre></td></tr></table></figure><h4 id="6-1-2-实现"><a href="#6-1-2-实现" class="headerlink" title="6.1.2 实现"></a>6.1.2 实现</h4><p>formatTransform内部会创建一个scalapack网格来完成矩阵数据的分发，这个网格对应的矩阵大小是原矩阵大小，但是进程块的行数列数是按照SpGEMM的格式计算的对齐可均分的大小，部分进程将得到不完整的块或没有数据块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//create new desc for DB-SpGEMM 1 slice </span></span><br><span class="line">    <span class="type">int</span> desc_trans[<span class="number">9</span>], trans_rows, trans_cols, mtx_size, info, ZERO = <span class="number">0</span>, ONE = <span class="number">1</span>;</span><br><span class="line">    mtx_size = desc_origin[<span class="number">3</span>];</span><br><span class="line">    trans_rows = pg-&gt;num_block_rows * spgemm_block_size;</span><br><span class="line">    trans_cols = pg-&gt;num_block_columns * spgemm_block_size;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mtx_size = %d trans_rows= %d transcols=%d process(%d %d) \n&quot;</span>, mtx_size, trans_rows, trans_cols, myrow, mycol);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    descinit_(desc_trans, &amp;mtx_size, &amp;mtx_size, &amp;trans_rows, &amp;trans_cols, &amp;ZERO, &amp;ZERO, &amp;ictxt, &amp;trans_rows, &amp;info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//allocate memory for blocks</span></span><br><span class="line">    <span class="type">double</span> *local_buffer = (<span class="type">double</span> *)<span class="built_in">calloc</span>(trans_rows * trans_cols, <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">    <span class="type">int</span> ia = <span class="number">1</span>, ja = <span class="number">1</span>, ib = <span class="number">1</span>, jb = <span class="number">1</span>; </span><br><span class="line">    pdgemr2d_(&amp;mtx_size, &amp;mtx_size, local_origin, &amp;ia, &amp;ja, desc_origin, local_buffer, &amp;ib, &amp;jb, desc_trans, &amp;ictxt);</span><br></pre></td></tr></table></figure><p>得到的数据先进行转置，从而将列主序调整至行主序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//local transpose to row major</span></span><br><span class="line"><span class="keyword">if</span>(pg-&gt;num_block_rows==pg-&gt;num_block_columns)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;trans_rows;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(local_buffer[i*trans_cols+ j], local_buffer[j*trans_rows + i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="type">double</span> *transpose_buffer = (<span class="type">double</span> *)<span class="built_in">calloc</span>(trans_rows * trans_cols, <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;trans_rows;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;trans_cols;j++)&#123;</span><br><span class="line">            transpose_buffer[i*trans_cols + j] = local_buffer[j*trans_rows+i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(local_buffer);</span><br><span class="line">    local_buffer = transpose_buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时得到的是稠密的完整的DB-SpGEMM可处理的矩阵块，将其进行稀疏性检查，将含有非零元的块加入矩阵当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//transform dense matrix to sparse block matrix for DB-SpGEMM</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pg-&gt;num_block_rows;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;pg-&gt;num_block_columns;j++)&#123;</span><br><span class="line">        <span class="type">int</span> block_offset = i*pg-&gt;num_block_columns*spgemm_block_size*spgemm_block_size + j*spgemm_block_size;</span><br><span class="line">        <span class="type">bool</span> nnz = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;spgemm_block_size&amp;&amp;!nnz;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;spgemm_block_size&amp;&amp;!nnz;l++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(local_buffer[block_offset + k*trans_cols + l] != <span class="number">0</span>)&#123;</span><br><span class="line">                    nnz = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nnz)&#123;</span><br><span class="line">            <span class="comment">//copy block to distblockmat</span></span><br><span class="line">            distblockmat.local_data[i][j].resize(spgemm_block_size*spgemm_block_size);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;spgemm_block_size;k++)&#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(distblockmat.local_data[i][j].data() + k*spgemm_block_size, </span><br><span class="line">                    local_buffer + block_offset + k*trans_cols, spgemm_block_size*<span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ScalapackTest</title>
      <link href="/2025/04/20/ScalapackTest/"/>
      <url>/2025/04/20/ScalapackTest/</url>
      
        <content type="html"><![CDATA[<p>近期的工作需要熟悉scalapack的数据格式，做个简单记录。</p><p>采用了直接通过apt安装的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libscalapack-openmpi-dev</span><br></pre></td></tr></table></figure><p>如果是编译安装，可以指定：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_INSTALL_PREFIX=/local \</span><br><span class="line">      -DBUILD_SHARED_LIBS=<span class="keyword">ON</span> \</span><br><span class="line">      -DCMAKE_EXPORT_PACKAGE_REGISTRY=<span class="keyword">ON</span> \</span><br><span class="line">      -DCMAKE_INSTALL_LIBDIR=lib \</span><br><span class="line">      -DCMAKE_INSTALL_INCLUDEDIR=<span class="keyword">include</span> \</span><br><span class="line">      ..</span><br></pre></td></tr></table></figure><p>简单编写的测试程序的cmake，注意到直接链接<code>`$SCALAPACK_LIBRARIES</code>会失败。这个包的.cmake没配置这个变量，也没有头文件和相应的头文件路径变量，链接的时候直接链接<code>scalapack-openmpi</code>就可以了。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">project</span>(ScalapackTest LANGUAGES C)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(MPI REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(ScaLAPACK REQUIRED)  </span><br><span class="line"><span class="keyword">if</span>(ScaLAPACK_FOUND)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;ScaLAPACK found at: $&#123;ScaLAPACK_DIR&#125;&quot;</span>)  <span class="comment"># 配置文件路径</span></span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;ScaLAPACK libraries: $&#123;SCALAPACK_LIBRARIES&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;ScaLAPACK include dirs: $&#123;ScaLAPACK_INCLUDE_DIRS&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置C++标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(test_scalapack src/test_scalapack.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(test_scalapack PRIVATE</span><br><span class="line">    scalapack-openmpi</span><br><span class="line">    MPI::MPI_C</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(test_scalapack PRIVATE <span class="variable">$&#123;MPI_CXX_INCLUDE_DIRS&#125;</span>)</span><br></pre></td></tr></table></figure><p>简单的测试程序主要是为了理解scalapack的数据规格，调用简单选择了矩阵乘，其接口如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">pdgemm_</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">char</span> *transa, <span class="type">char</span> *transb, <span class="type">int</span> *m, <span class="type">int</span> *n, <span class="type">int</span> *k,</span></span><br><span class="line"><span class="params">    <span class="type">double</span> *alpha, <span class="type">double</span> *a, <span class="type">int</span> *ia, <span class="type">int</span> *ja, <span class="type">int</span> *desca,</span></span><br><span class="line"><span class="params">    <span class="type">double</span> *b, <span class="type">int</span> *ib, <span class="type">int</span> *jb, <span class="type">int</span> *descb,</span></span><br><span class="line"><span class="params">    <span class="type">double</span> *beta, <span class="type">double</span> *c, <span class="type">int</span> *ic, <span class="type">int</span> *jc, <span class="type">int</span> *descc</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure></p><p>由于scalapack底层是fortran实现，所以首先要注意数据的起始索引是1。scalapack中，是否转置等是以char的方式传入，用<code>N</code>表示转置，<code>T</code>表示转置，<code>C</code>表示共轭转置。<code>ia</code>，<code>ja</code>等变量表示的是子矩阵在全局矩阵中的起始行列索引，索引从<strong>1</strong>开始。<code>desc</code>是数组，指向包含矩阵全局分布信息的描述符。</p><h3 id="进程网格与矩阵描述符"><a href="#进程网格与矩阵描述符" class="headerlink" title="进程网格与矩阵描述符"></a>进程网格与矩阵描述符</h3><p>scalapack通过内部的BLACS来管理进程网格和通信。通常情况下进入程序需要创建一个BLACS进程通信上下文，使用以下接口来创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Cblacs_get</span><span class="params">(<span class="type">int</span> *context, <span class="type">int</span> *scope, <span class="type">int</span> *ictxt)</span>;</span><br></pre></td></tr></table></figure><p>第一个参数表示初始上下文标识符，<strong>-1</strong>表示创建新的上下文。第二个参数表示关联通信域，<strong>0</strong>表示默认的MPI_COMM_WORLD，最后一个参数用于返回新创建的上下文句柄。</p><p>创建上下文后，用以下接口创建进程网格，第二个参数用于控制进程分布的顺序，可以取<code>Row</code>和<code>Col</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Cblacs_gridinit</span><span class="params">(<span class="type">int</span> *ictxt, <span class="type">char</span> *order, <span class="type">int</span> nprow, <span class="type">int</span> npcol)</span>;</span><br></pre></td></tr></table></figure><p><code>Cblacs_gridinfo</code>接口用来获取当前进程在进程网格中的信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Cblacs_gridinfo</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> ictxt,        <span class="comment">// 输入：BLACS上下文句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> *nprow,       <span class="comment">// 输出：进程网格行数</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> *npcol,       <span class="comment">// 输出：进程网格列数</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> *myrow,       <span class="comment">// 输出：当前进程行坐标</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> *mycol        <span class="comment">// 输出：当前进程列坐标</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>上述三个接口可以创建和获取进程网格的信息，接下来就要设置矩阵的划分信息了，首先获取本地维度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">numroc_</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> *n,           <span class="comment">// 全局维度（行或列）</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> *nb,          <span class="comment">// 块大小（行或列）</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> *iproc,       <span class="comment">// 当前进程在网格中的坐标（行或列）</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> *isrcproc,    <span class="comment">// 起始进程坐标（通常为0）</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> *nprocs       <span class="comment">// 进程网格中该方向的总进程数</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>有了本地维度之后，需要初始化矩阵描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">descinit_</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> *desc,        <span class="comment">// 输出：9元素描述符数组</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> *m,           <span class="comment">// 全局矩阵行数</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> *n,           <span class="comment">// 全局矩阵列数</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> *mb,          <span class="comment">// 行块大小</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> *nb,          <span class="comment">// 列块大小</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> *irsrc,       <span class="comment">// 起始进程的行坐标（通常为0）</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> *icsrc,       <span class="comment">// 起始进程的列坐标（通常为0）</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> *ictxt,       <span class="comment">// BLACS进程网格上下文</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> *lld,         <span class="comment">// 本地矩阵的行维度（由numroc_计算）</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> *info         <span class="comment">// 输出：错误状态码（0表示成功）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>之后就可以用矩阵描述符传入计算接口来完成分布式计算了，scalapack的设计中，矩阵描述符和网格等信息和矩阵本身的存储都是分离的，所以要独立分配local_row*local_col的空间作为本地的矩阵数据存储空间，传入计算函数，需要注意大小和创建网格以及创建描述符时一致，并注意资源释放，要分别释放矩阵数据和进程网格，进程网格通过下面的接口释放：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cblacs_gridexit(<span class="type">int</span> *ictxt);</span><br></pre></td></tr></table></figure><h3 id="矩阵乘接口调用"><a href="#矩阵乘接口调用" class="headerlink" title="矩阵乘接口调用"></a>矩阵乘接口调用</h3><p>以下是利用上面所述接口创建矩阵并调用scalapack矩阵乘的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mpi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ScaLAPACK函数声明（Fortran接口）</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">pdgemm_</span><span class="params">(<span class="type">char</span> *transa, <span class="type">char</span> *transb, <span class="type">int</span> *m, <span class="type">int</span> *n, <span class="type">int</span> *k,</span></span><br><span class="line"><span class="params">                    <span class="type">double</span> *alpha, <span class="type">double</span> *a, <span class="type">int</span> *ia, <span class="type">int</span> *ja, <span class="type">int</span> *desca,</span></span><br><span class="line"><span class="params">                    <span class="type">double</span> *b, <span class="type">int</span> *ib, <span class="type">int</span> *jb, <span class="type">int</span> *descb,</span></span><br><span class="line"><span class="params">                    <span class="type">double</span> *beta, <span class="type">double</span> *c, <span class="type">int</span> *ic, <span class="type">int</span> *jc, <span class="type">int</span> *descc)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">descinit_</span><span class="params">(<span class="type">int</span> *desc, <span class="type">int</span> *m, <span class="type">int</span> *n, <span class="type">int</span> *mb, <span class="type">int</span> *nb,</span></span><br><span class="line"><span class="params">                     <span class="type">int</span> *irsrc, <span class="type">int</span> *icsrc, <span class="type">int</span> *ictxt, <span class="type">int</span> *lld, <span class="type">int</span> *info)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">numroc_</span><span class="params">(<span class="type">int</span> *n, <span class="type">int</span> *nb, <span class="type">int</span> *iproc, <span class="type">int</span> *isrcproc, <span class="type">int</span> *nprocs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    MPI_Init(&amp;argc, &amp;argv);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 基本参数设置</span></span><br><span class="line">    <span class="type">int</span> ZERO = <span class="number">0</span>, ONE = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> N = <span class="number">1024</span>;          <span class="comment">// 全局矩阵维度</span></span><br><span class="line">    <span class="type">int</span> BLOCK_SIZE = <span class="number">64</span>;   <span class="comment">// 块划分大小</span></span><br><span class="line">    <span class="type">int</span> NPROW = <span class="number">2</span>, NPCOL = <span class="number">2</span>; <span class="comment">// 2x2进程网格</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MPI进程信息</span></span><br><span class="line">    <span class="type">int</span> myrank, nprocs;</span><br><span class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;myrank);</span><br><span class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;nprocs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BLACS进程网格初始化</span></span><br><span class="line">    <span class="type">int</span> ictxt, myrow, mycol;</span><br><span class="line">    Cblacs_get(<span class="number">-1</span>, <span class="number">0</span>, &amp;ictxt);</span><br><span class="line">    Cblacs_gridinit(&amp;ictxt, <span class="string">&quot;Row&quot;</span>, NPROW, NPCOL);</span><br><span class="line">    Cblacs_gridinfo(ictxt, &amp;NPROW, &amp;NPCOL, &amp;myrow, &amp;mycol);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算本地矩阵维度</span></span><br><span class="line">    <span class="type">int</span> local_rows = numroc_(&amp;N, &amp;BLOCK_SIZE, &amp;myrow, &amp;ZERO, &amp;NPROW);</span><br><span class="line">    <span class="type">int</span> local_cols = numroc_(&amp;N, &amp;BLOCK_SIZE, &amp;mycol, &amp;ZERO, &amp;NPCOL);</span><br><span class="line">    local_rows = (local_rows &gt; <span class="number">0</span>) ? local_rows : <span class="number">1</span>;</span><br><span class="line">    local_cols = (local_cols &gt; <span class="number">0</span>) ? local_cols : <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;local_rows=%d, local_cols=%d\n&quot;</span>, local_rows, local_cols);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩阵描述符初始化[6,7]</span></span><br><span class="line">    <span class="type">int</span> descA[<span class="number">9</span>], descB[<span class="number">9</span>], descC[<span class="number">9</span>];</span><br><span class="line">    <span class="type">int</span> info;</span><br><span class="line">    descinit_(descA, &amp;N, &amp;N, &amp;BLOCK_SIZE, &amp;BLOCK_SIZE, &amp;ZERO, &amp;ZERO, </span><br><span class="line">             &amp;ictxt, &amp;local_rows, &amp;info);</span><br><span class="line">    descinit_(descB, &amp;N, &amp;N, &amp;BLOCK_SIZE, &amp;BLOCK_SIZE, &amp;ZERO, &amp;ZERO,</span><br><span class="line">             &amp;ictxt, &amp;local_rows, &amp;info);</span><br><span class="line">    descinit_(descC, &amp;N, &amp;N, &amp;BLOCK_SIZE, &amp;BLOCK_SIZE, &amp;ZERO, &amp;ZERO,</span><br><span class="line">             &amp;ictxt, &amp;local_rows, &amp;info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配本地矩阵内存（列优先存储）</span></span><br><span class="line">    <span class="type">double</span> *A = (<span class="type">double</span>*)<span class="built_in">malloc</span>(local_rows * local_cols * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">    <span class="type">double</span> *B = (<span class="type">double</span>*)<span class="built_in">malloc</span>(local_rows * local_cols * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">    <span class="type">double</span> *C = (<span class="type">double</span>*)<span class="built_in">calloc</span>(local_rows * local_cols, <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化本地矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;local_rows*local_cols; i++) &#123;</span><br><span class="line">        A[i] = (<span class="type">double</span>)rand() / RAND_MAX;</span><br><span class="line">        B[i] = (<span class="type">double</span>)rand() / RAND_MAX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行矩阵乘法 C = A*B </span></span><br><span class="line">    <span class="type">char</span> trans = <span class="string">&#x27;N&#x27;</span>;  <span class="comment">// 不转置</span></span><br><span class="line">    <span class="type">double</span> alpha = <span class="number">1.0</span>, beta = <span class="number">0.0</span>;</span><br><span class="line">    pdgemm_(&amp;trans, &amp;trans, &amp;N, &amp;N, &amp;N, &amp;alpha,</span><br><span class="line">           A, &amp;ONE, &amp;ONE, descA,</span><br><span class="line">           B, &amp;ONE, &amp;ONE, descB,</span><br><span class="line">           &amp;beta, C, &amp;ONE, &amp;ONE, descC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 资源释放</span></span><br><span class="line">    <span class="built_in">free</span>(A); <span class="built_in">free</span>(B); <span class="built_in">free</span>(C);</span><br><span class="line">    Cblacs_gridexit(ictxt);</span><br><span class="line">    MPI_Finalize();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2D循环块存储"><a href="#2D循环块存储" class="headerlink" title="2D循环块存储"></a>2D循环块存储</h3><p>scalapack存储矩阵的方式是2D块循环，前面的测试代码只是简单了解下scalapack怎么使用，并没有体现数据的存储，因为数据都是直接随机生成的。接下来用一个测试程序看看2D块循环。</p><p>首先可以通过文档中的例子理解2D块循环的存储方式，下图是一个5x5矩阵划分为2x2矩阵块并存放到2x2进程网格上的示意。每个进程持有的行/列起始索引的差值都是BLOCKSIZE*nprocs，所有的自己负责的块统一按照列有限的顺序存储，这里需要注意的是本地存储不是按照块存储的，而是按照列来存储的，例如图中的划分后的矩阵，0号进程所持有的数据是顺序的a11 a21 a51 a12 a22 a52 a15 a25 a55，而不是按照划分的2x2块存储。</p><p><img src="/2025/04/20/ScalapackTest/image-20250420155004342.png" alt="image-20250420155004342"></p><p>scalapack提供了一个矩阵重分发函数，我们使用这个函数来测试2D块循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">pdgemr2d_</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> *m, <span class="type">int</span> *n,              <span class="comment">// 全局矩阵维度</span></span></span><br><span class="line"><span class="params">    <span class="type">double</span> *a, <span class="type">int</span> *ia, <span class="type">int</span> *ja, <span class="comment">// 源矩阵描述（连续存储）</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> *desca,                  <span class="comment">// 源矩阵描述符（描述连续布局）</span></span></span><br><span class="line"><span class="params">    <span class="type">double</span> *b, <span class="type">int</span> *ib, <span class="type">int</span> *jb, <span class="comment">// 目标矩阵描述（块循环存储）</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> *descb,                  <span class="comment">// 目标矩阵描述符（需预先初始化块循环参数）</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> *ictxt                   <span class="comment">// BLACS上下文</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>这个函数会把原矩阵描述符描述的矩阵分发到新的描述符中的各个进程。所以可以先在单进程上准备一个完整的矩阵，然后进行分发，检查各个进程上获取的2D块循环的数据是否和上面的描述是一致的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mpi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Cblacs_get</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>*)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Cblacs_gridinit</span><span class="params">(<span class="type">int</span>*, <span class="type">const</span> <span class="type">char</span>*, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Cblacs_gridinfo</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>*, <span class="type">int</span>*, <span class="type">int</span>*, <span class="type">int</span>*)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Cblacs_gridexit</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Cblacs_exit</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">numroc_</span><span class="params">(<span class="type">int</span>*, <span class="type">int</span>*, <span class="type">int</span>*, <span class="type">int</span>*, <span class="type">int</span>*)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">descinit_</span><span class="params">(<span class="type">int</span>*, <span class="type">int</span>*, <span class="type">int</span>*, <span class="type">int</span>*, <span class="type">int</span>*, <span class="type">int</span>*, <span class="type">int</span>*, <span class="type">int</span>*, <span class="type">int</span>*, <span class="type">int</span>*)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">pdgemr2d_</span><span class="params">(<span class="type">int</span>*, <span class="type">int</span>*, <span class="type">double</span>*, <span class="type">int</span>*, <span class="type">int</span>*, <span class="type">int</span>*, <span class="type">double</span>*, <span class="type">int</span>*, <span class="type">int</span>*, <span class="type">int</span>*, <span class="type">int</span>*)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    MPI_Init(&amp;argc, &amp;argv);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ============== 基础参数设置 ==============</span></span><br><span class="line">    <span class="type">int</span> N = <span class="number">8</span>;          <span class="comment">// 全局矩阵维度</span></span><br><span class="line">    <span class="type">int</span> BLOCK_SIZE = <span class="number">2</span>;   <span class="comment">// 块循环分块大小</span></span><br><span class="line">    <span class="type">int</span> NPROW = <span class="number">2</span>, NPCOL = <span class="number">2</span>; <span class="comment">// 2x2进程网格</span></span><br><span class="line">    <span class="type">int</span> ZERO = <span class="number">0</span>, ONE = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============== MPI进程信息 ==============</span></span><br><span class="line">    <span class="type">int</span> myrank, nprocs;</span><br><span class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;myrank);</span><br><span class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;nprocs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============== BLACS进程网格初始化 ==============</span></span><br><span class="line">    <span class="type">int</span> ictxt, myrow, mycol;</span><br><span class="line">    Cblacs_get(<span class="number">-1</span>, <span class="number">0</span>, &amp;ictxt);</span><br><span class="line">    Cblacs_gridinit(&amp;ictxt, <span class="string">&quot;Row&quot;</span>, NPROW, NPCOL);</span><br><span class="line">    Cblacs_gridinfo(ictxt, &amp;NPROW, &amp;NPCOL, &amp;myrow, &amp;mycol);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============== 本地矩阵维度计算 ==============</span></span><br><span class="line">    <span class="type">int</span> local_rows = numroc_(&amp;N, &amp;BLOCK_SIZE, &amp;myrow, &amp;ZERO, &amp;NPROW);</span><br><span class="line">    <span class="type">int</span> local_cols = numroc_(&amp;N, &amp;BLOCK_SIZE, &amp;mycol, &amp;ZERO, &amp;NPCOL);</span><br><span class="line">    local_rows = (local_rows &gt; <span class="number">0</span>) ? local_rows : <span class="number">1</span>;</span><br><span class="line">    local_cols = (local_cols &gt; <span class="number">0</span>) ? local_cols : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============== 矩阵描述符初始化 ==============</span></span><br><span class="line">    <span class="type">int</span> descA[<span class="number">9</span>], descB[<span class="number">9</span>], info;</span><br><span class="line">    <span class="type">int</span> lda = N; </span><br><span class="line">    descinit_(descA, &amp;N, &amp;N, &amp;N, &amp;N, &amp;ZERO, &amp;ZERO, &amp;ictxt, &amp;lda, &amp;info);</span><br><span class="line">    descinit_(descB, &amp;N, &amp;N, &amp;BLOCK_SIZE, &amp;BLOCK_SIZE, </span><br><span class="line">             &amp;ZERO, &amp;ZERO, &amp;ictxt, &amp;local_rows, &amp;info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============== 数据分配与初始化 ==============</span></span><br><span class="line">    <span class="type">double</span> *global_A = <span class="literal">NULL</span>, *distributed_B = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (myrank == <span class="number">0</span>) &#123;</span><br><span class="line">        global_A = (<span class="type">double</span>*)<span class="built_in">malloc</span>(N * N * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N*N; i++) &#123;</span><br><span class="line">            global_A[i] = i; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-----------------------------------------------------------\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lf &quot;</span>, global_A[j * N + i]);  <span class="comment">// 按列优先打印</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-----------------------------------------------------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    distributed_B = (<span class="type">double</span>*)<span class="built_in">calloc</span>(local_rows * local_cols, <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============== 调用pdgemr2d分发数据 ==============</span></span><br><span class="line">    <span class="type">int</span> ia = <span class="number">1</span>, ja = <span class="number">1</span>, ib = <span class="number">1</span>, jb = <span class="number">1</span>; <span class="comment">// 基于1的索引</span></span><br><span class="line">    pdgemr2d_(&amp;N, &amp;N, global_A, &amp;ia, &amp;ja, descA, </span><br><span class="line">             distributed_B, &amp;ib, &amp;jb, descB, &amp;ictxt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============== 基础验证 ==============</span></span><br><span class="line">    <span class="keyword">if</span> (myrow == <span class="number">0</span> &amp;&amp; mycol == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;local_cols*local_rows;i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, distributed_B[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============== 资源清理 ==============</span></span><br><span class="line">    <span class="keyword">if</span> (myrank == <span class="number">0</span>) <span class="built_in">free</span>(global_A);</span><br><span class="line">    <span class="built_in">free</span>(distributed_B);</span><br><span class="line">    Cblacs_gridexit(ictxt);</span><br><span class="line">    MPI_Finalize();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下，红框标出了进程0持有的块，下面按照顺序输出了进程0的矩阵存储，显然是先将所有数据拼到一块，然后再按列存储，而不是按块存储。</p><p><img src="/2025/04/20/ScalapackTest/image-20250420160323232.png" alt="image-20250420160323232"></p><p>这种2D块存储的方式是为了将块划分的足够小，这样对于对角矩阵等局部稠密的矩阵能够尽可能每个进程的负载均衡。要将其转为一般的稀疏矩阵格式也可以通过上述的分发接口实现，首先固定块的大小让每个进程只持有一个块的数据，然后再重分发，在进程内部调整为稀疏格式。但是对于不对齐或者无法均分的情况，还要额外做个填充。</p>]]></content>
      
      
      <categories>
          
          <category> 高性能计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICT鲲鹏性能挑战赛复盘</title>
      <link href="/2025/03/24/ICT%E9%B2%B2%E9%B9%8F%E6%80%A7%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B%E5%A4%8D%E7%9B%98/"/>
      <url>/2025/03/24/ICT%E9%B2%B2%E9%B9%8F%E6%80%A7%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p> ICT鲲鹏HPC性能挑战赛赛后复盘，虽然拿到了一等奖，但是犯的错误很多，有必要进行复盘。</p><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>Hypre求解优化。核心优化是使用了粗化策略，使求解网格规模更小，以及调整其他配置，在setup时间和solve时间取得均衡。赛后与其他队伍交流发现在编译配置上还有其他可优化的内容，没有发现的原因是后期走入了读热点优化的误区，热点部分并没有优化空间，另外配置的一些测试赛前没有仔细整理，导致有忽略的内容。</p><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>实现SME求解HGEMM。优化方法如下，<code>有一些提升</code>指的是相对于整体性能，有可见的超过<strong>10%</strong>GFlops的提升。</p><ul><li>线程并行：最外层，GOTO算法的线程并行策略是内层分块，但是经过我们赛前自行实测和赛中测试及其他原因，外层内层差别不大，不是限制性能的主要原因。</li><li>分块策略：GOTO算法的6层分块，单次计算的矩阵块(对N、K、M维各切分一次后)包括A块+B块+C块使用了1/2 的L2 Cache，SME单次计算的micro Kernel的数据量4/5 L1 Cache，计算数据不超过Cache大小是大幅度影响性能的最关键因素。</li><li>向量化打包：由于SME计算的读取连续性，数据需要打包为Z/N型的块，在此过程中数据不连续，采用了SVE的zip指令等来做打包，性能有一些提升。</li><li>SME计算：一次计算了一块A×两块B，用了两个ZA tile同时计算，因为最内部的计算是沿着K方向进行的，ZA tile的累积有顺序，所以不这么做是无法利用所有ZA tile的，使用后性能有一些提升。</li></ul><p>优化空间/比赛中犯的重大错误：</p><ul><li>一开始由于习惯行主序，把分块按行主序写了，实际上后面采取的打包和计算顺序，都是列主序更友好的。最后修改了一个kernel到列主序，有一定的性能提升，一开始就全都采用列主序比较好，或者采用行主序，但是分块划分的顺序可以进行调整，让打包和写回能尽量顺着存储方向移动。猜测改正这一点性能会有一些提升。</li><li>错误的使用了ZA tile的数量：由于实现的是FP16×FP16的矩阵乘法，错误认为ZA tile只有两个可用，但是实际上实现的FP16×FP16使用的是SMEFP16FP32，也即输入为FP16，输出为FP32，那么累积计算结果使用的ZA tile应该是FP32的大小，所以应该是4个，这应该是导致我们第二题没有拿到第一的关键原因，因为使用4个ZA tile可以一次计算4个C的块，同时读取使用两行组A，两行组B，更好得进行数据重用和利用寄存器。这也是比赛中犯的最大错误和最大遗憾，虽然不影响结果，但还是觉得没有做到完美，不该犯这种错😭。</li></ul><p>只用了两块ZA tile，假设mc，nc为2*SVL(寄存器长度)：</p><p><img src="/2025/03/24/ICT%E9%B2%B2%E9%B9%8F%E6%80%A7%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B%E5%A4%8D%E7%9B%98/image-20250324200411826.png" alt="image-20250324200411826"></p><p>最后还有比赛中没遇到的一个问题，就是其他队伍提到了编译SME会有错误，但是我们按照测试框架编译测试代码是没有问题的，怀疑可能是我们是在给定软件包外独立安装了编译器编译，所以没遇到这个问题，无法再去弄明白了。</p>]]></content>
      
      
      <categories>
          
          <category> 高性能计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>未添加static导致的编译优化问题</title>
      <link href="/2025/03/18/%E6%9C%AA%E6%B7%BB%E5%8A%A0static%E5%AF%BC%E8%87%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/"/>
      <url>/2025/03/18/%E6%9C%AA%E6%B7%BB%E5%8A%A0static%E5%AF%BC%E8%87%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在某个比赛调试程序时遇到的未添加static导致的编译优化问题，起因是和队友分别负责了具有相似结构仅针对数据规模特化的两份代码的编写。但性能差别较大。测试环境为：</p><ul><li>kunpeng单NUMA node</li><li>bisheng编译器</li></ul><p>经排查发现有两个原因导致了性能的差距：</p><ul><li>全局变量作用域为源代码文件但未加static</li><li>静态全局变量是否为常值</li></ul><p>第一个问题是调试时发现对于作用域为源代码文件的全局变量，添加static的性能明显提升，应该是限定无外部链接性后编译器做了一些优化。</p><p>第二个问题是一个循环中使用了静态全局变量作为循环边界条件，包含该循环的函数会被频繁调用，两个静态全局变量值是相同的，都可以作为循环变量边界，但性能差别很大：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> nr = <span class="number">8</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> snr = <span class="number">8</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(...)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nr;j++)&#123;<span class="comment">//snr性能更好</span></span><br><span class="line">            <span class="comment">//process</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用snr的相较于nr有3x的加速比，原因是nr在外层函数调用中曾有过一次赋值，而snr仅有文件顶部这一次赋值，所以导致了这个位置编译器所作的展开等优化策略不同。实际上这里的nr和snr都是和机器向量寄存器长度相关的，考虑到最终比赛的机器向量寄存器位数未知，我在最外层函数入口获取向量寄存器长度，再赋值nr，队友直接默认为256bit，这个差别导致编译器对该循环做的优化不同。该问题还与具体计算有关，因为这个函数是核心kernel，反复调用，而计算部分又因为没有比赛机器的指令集使用了标量模拟计算指令，使编译器能做的优化空间很大，才产生了这个问题。</p>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenFFT-SME-FFT算法在支持SME指令集的CPU上的实现</title>
      <link href="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenFFT-SME-An-Effcient-Outer-Product-Pattern-FFT-Library-on-ARM-SME-CPUs"><a href="#OpenFFT-SME-An-Effcient-Outer-Product-Pattern-FFT-Library-on-ARM-SME-CPUs" class="headerlink" title="OpenFFT-SME: An Effcient Outer Product Pattern FFT Library on ARM SME CPUs"></a>OpenFFT-SME: An Effcient Outer Product Pattern FFT Library on ARM SME CPUs</h1><p>本篇文章来自IPDPS24，介绍了OpenFFT，一个使用ARM SME指令加速FFT运算的FFT运算库。OpenFFT SME在ARM SME CPU上的性能优于矢量化方法，与FFTW相比，在双精度下实现了3.60倍（2的幂）和4.14倍（非2的幂次）的加速，单精度下的加速为4.38倍（2的幂次）和7.02倍（非2的幂次）。</p><h2 id="1-ARM-SME指令集"><a href="#1-ARM-SME指令集" class="headerlink" title="1 ARM SME指令集"></a>1 ARM SME指令集</h2><p>矩阵乘法是人工智能负载或科学计算等多领域应用的常用计算模式，有许多加速器都是针对矩阵运算提出的，包括NVIDIA的 Tensor Core，Inter AMX。ARM的可扩展矩阵运算指令集(SME)通过提供向量外积指令来有效实现矩阵乘法，SME基于SVE构建，针对矩阵工作负载，还引入了ZA矩阵寄存器来存储矩阵数据，以及在寄存器和存储器之间加载、存储和传输矩阵的指令。</p><p>SME 引入了 Streaming SVE 模式，高吞吐处理数据，大多数SME指令都仅在该模式下使用。在Steaming SVE模式，有Z0-Z31向量寄存器，和15个Predicate寄存器。</p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/bVbAY5" alt="5.png" style="zoom: 80%;"></p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/2024-08-15_4130_ARM2799_3_Scalable_Matrix_p1.webp" alt="Streaming mode registers" style="zoom: 50%;"></p><p>SME 新引入的 ZA array是一个二维正方形数组，大小是 SVL x SVL。行和列的长度和Zn寄存器一致。ZA array的每一行都可以当成一个SVL长度的向量来访问。而ZA array又可划分为ZA tile，ZA tile的宽度是SVL，ZA可分成多少个可用的ZA tile由元素数据类型大小决定，例如SVL是32字节，则ZA Array是32×32的，对于8bit的数据，只有一个ZA tile，对于16bit的数据，一行可存储16个数据，因此ZA tile是16×16的，ZA可分成两个ZA tile。同理，32bit的数据一行可存储8个，ZA可被划分为4个ZA tile。</p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250313150959309.png" alt="image-20250313150959309" style="zoom: 80%;"></p><p>SME增加了一些新指令以及操作ZA的指令，包括：</p><ul><li>矩阵外积累加/减：FMOPA、UMOPA等，SVE2向量寄存器作为外积运算输入，ZA保存结果</li><li>SVE向量与ZA行列加法运算指令</li><li>ZA tile的清零</li><li>SVE向量存入或取出ZA tile的行或列的指令</li></ul><p>假设SVL=128bit，存储FP32的向量进行SME外积运算如图所示：</p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/2024-08-16_3613751670-667e5f923c64.webp" alt="FMOPA and FMOPS" style="zoom: 50%;"></p><p>更多内容可以阅读ARM文档以及参考链接。</p><h2 id="2-快速傅里叶算法-FFT"><a href="#2-快速傅里叶算法-FFT" class="headerlink" title="2 快速傅里叶算法(FFT)"></a>2 快速傅里叶算法(FFT)</h2><a href="/2025/02/28/FFT-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/" title="FFT-快速傅里叶变换">点击这里查看这篇文章</a><h2 id="3-OpenFFT-SME"><a href="#3-OpenFFT-SME" class="headerlink" title="3 OpenFFT-SME"></a>3 OpenFFT-SME</h2><p>FFT中的蝴蝶运算本质上是矩阵向量乘法，因此ARM SME可以通过利用其外积指令来有效地加速FFT。通过自然地将蝴蝶映射到外积运算，ARM SME并行化了Cooley-Tukey FFT的计算。此外，本篇的工作还利用了旋转因子的对称和周期性质来优化计算。核心工作是：</p><ul><li>实现了基于SME的FFT外积算法，并利用对称性减少外积计算</li><li>讨论了FFT优化的矩阵化和向量化技术，为其他算法在ARM SME上的移植提供了重要的参考价值。</li></ul><h3 id="3-1-外积计算的FFT算法"><a href="#3-1-外积计算的FFT算法" class="headerlink" title="3.1 外积计算的FFT算法"></a>3.1 外积计算的FFT算法</h3><p>蝶形算法是Cooley-TukeyFFT算法的核心，优化蝶形算法是最关键的部分。因此本篇首先提出了一个外积计算FFT蝶形运算的方式，以及通过对称性减少外积计算量。</p><h4 id="3-1-1-矩阵化运算"><a href="#3-1-1-矩阵化运算" class="headerlink" title="3.1.1 矩阵化运算"></a>3.1.1 矩阵化运算</h4><p>蝶形计算的本质是<strong>DFT矩阵与输入向量之间的乘法</strong>。即：</p><script type="math/tex; mode=display">y=Wx</script><p>y和x是长度为<strong>r</strong>的复数向量，r为FFT算法的基。为了充分利用ARM SME的矩阵乘计算能力，并行计算多组蝶形计算：</p><script type="math/tex; mode=display">Y=WX</script><p>Y和X是r×b的矩阵，b是并行计算的蝶形运算数量。</p><p>由于ARM SME只支持实数外积指令，所以首先要做的是将复数计算转换为一个可被计算的等价表示，我们将上式的矩阵乘使用外积形式表示：</p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250325171611348.png" alt="image-20250325171611348" style="zoom:67%;"></p><p>其中<strong>$w_i$</strong>是W的第i列，$x_i^T$是X的第i行。设$w_i=a_i+b_ij$以及$x_i=c_i+d_ij$，则蝴蝶计算可表示为：</p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250325172018306.png" alt="image-20250325172018306" style="zoom:67%;"></p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250325191406755.png" alt="image-20250325191406755" style="zoom: 67%;"></p><blockquote><p>[!IMPORTANT]</p><p>后续的内容均以i表示DFT矩阵的第i列，而k则用来表示行</p></blockquote><h4 id="3-1-2-Symmetric-reduce"><a href="#3-1-2-Symmetric-reduce" class="headerlink" title="3.1.2 Symmetric-reduce"></a>3.1.2 Symmetric-reduce</h4><p>DFT矩阵具有固有的对称性，可以利用对称性提高计算效率。如图e所示，$w_i$和$w_{r-i}$是关于实轴对称的，所以有</p><script type="math/tex; mode=display">a_i=a_{r-i}\\b_i=-b_{r-i}</script><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250325172543759.png" alt="image-20250325172543759" style="zoom:67%;"></p><p>在DFT矩阵中，对称性如图a所示，相同颜色的列表示对称。</p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250325172842489.png" alt="image-20250325172842489" style="zoom:80%;"></p><p>因为$b_0、b_{r/2}$是0，所以有：</p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250325185826045.png" alt="image-20250325185826045" style="zoom: 67%;"></p><p>r为奇数时类似。通过对称性，可以将外积计算从4r减少到2r，只需要预先对输入向量进行一些加减运算。文章中称这样减少计算为<strong>Symmetric-reduce</strong>。</p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250326105057083.png" alt="image-20250326105057083" style="zoom:67%;"></p><h4 id="3-1-3-Periodic-reduce"><a href="#3-1-3-Periodic-reduce" class="headerlink" title="3.1.3 Periodic-reduce"></a>3.1.3 Periodic-reduce</h4><p>本节提出了r=2m的reduce模式，称之为<strong>periodic-reduce</strong>，利用了DFT矩阵的垂直周期性。对于偶数长度的向量或偶数行的矩阵，作者采用<strong>b(bottom)</strong>表示每行的前半部分，<strong>t(top)</strong>表示每行的后半部分。</p><p>根据旋转因子的定义，有如下的性质，上标中的i表示W的第i列，k则表示行。这个性质表示的是，对于偶数列，旋转因子在行方向上是上半下半完全相同的，而对于奇数列，上半下半的对应位置元素刚好相差$\frac r2$，是相反数。</p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250325194640164.png" alt="image-20250325194640164" style="zoom:67%;"></p><p>图b展现了上面的对称性，蓝色列是奇数列，上半下半完全相同，粉色列上半下半值相反。</p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250325195244150.png" alt="image-20250325195244150" style="zoom:67%;"></p><p>把原来的外积计算也划分为上半和下半块，有：</p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250325200542581.png" alt="image-20250325200542581" style="zoom:67%;"></p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250325201048678.png" alt="image-20250325201048678" style="zoom:80%;"></p><p>这样就把原来的外积计算转换为了W的上半和下半部分分别和X进行外积，再对外积计算划分为奇数和偶数部分，对于上半部分：</p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250325201703505.png" alt="image-20250325201703505"></p><p>下半部分：</p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250325201740668.png" alt="image-20250325201740668"></p><p>外积是一个累加操作，可以很自然的把两部分分开，对应Y的累加层：</p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250325202116218.png" alt="image-20250325202116218" style="zoom:67%;"></p><p>这样就将Y=WX的外积计算通过划分为两部分，利用了周期性减少了内存访问，非常巧妙：</p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250325202211884.png" alt="image-20250325202211884"></p><p>通过上述等式，计算可以分为两步，首先计算外积的偶数和奇数部分获取矩阵E和O，然后通过对Y的上半及下半分别采用加法和减法合并，从而减少了外积的内存访问。</p><p>上述的两种方法是正交的，因此可以在使用Periodic的基础上在行内使用Symmetric-reduce。并且还可以发现，偶数列的W和$\frac r2$的DFT是等价的，所以可以转换为$\frac r2$的DFT蝶形计算，因此矩阵E的计算可以递归分解，直到r是奇数。</p><h4 id="3-1-4-向量寄存器重用"><a href="#3-1-4-向量寄存器重用" class="headerlink" title="3.1.4 向量寄存器重用"></a>3.1.4 向量寄存器重用</h4><p>利用上面的对称性，论文提出了向量寄存器重用模式。</p><p>根据图e的对称特性，<strong>当r=2m时</strong>，可以总结出如下的对称性，从而能进行寄存器复用，可以对照图c理解。为了方便记忆，可以记为<strong>水平方向上的寄存器重用</strong>。</p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250326115659437.png" alt="image-20250326115659437" style="zoom: 67%;"></p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250326115452939.png" alt="image-20250326115452939"></p><p>从周期性的角度，如果r是4m+4，则可以提出如下的性质，即<strong>对于不同的列，列内有关于r/4的对称性</strong>，可参考图e和d。例如对于第一列，$W_8^1=a+bi$，而$W_8^3=b-ai$。从而可以做到外积寄存器重用。可记为<strong>垂直方向上的寄存器重用</strong>。</p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250326111906032.png" alt="image-20250326111906032" style="zoom:50%;"></p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250326112101360.png" alt="image-20250326112101360"></p><h4 id="3-1-5-外积计算模式"><a href="#3-1-5-外积计算模式" class="headerlink" title="3.1.5 外积计算模式"></a>3.1.5 外积计算模式</h4><p>根据上述的对称性，论文提出了优化后的外积模式。</p><ul><li>r为奇数：只使用Symmetric-reduce</li><li>r为偶数：如果r小于vl，只使用Symmetric-reduce，否则同时使用两种对称性</li></ul><p>计算数量的约减如表1所示：</p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250326112831762.png" alt="image-20250326112831762" style="zoom:67%;"></p><p>按照表中的顺序，5种case的计算量为：</p><ul><li>case basic：r/vl完成外积，共r组，实部虚部需要4次计算</li><li>case 1：在basic的基础上，通过行方向的对称性减少了一半的外积计算，引入了c和d的四种(r/2-1)的加法运算</li><li>case 2：case 1的基础上，减少了一个加法</li><li>case 3：在case 2的基础上，可以做列上的对称性缩减计算，外积计算长度减半，加上向量寄存器重用，实部虚部可复用，计算量再次减半，外积计算递归约减为了OP(r/2)以及引入的ADD(r/2)</li><li>case 4：和case2一致，只是外积计算需要多次完成</li></ul><h4 id="3-1-6-外积FFT-Kernel"><a href="#3-1-6-外积FFT-Kernel" class="headerlink" title="3.1.6 外积FFT Kernel"></a>3.1.6 外积FFT Kernel</h4><p>本节中，作者首先提出了基本实现，然后讨论了优化后的外积模式的实现问题，最后介绍了在kernel中的软件流水线优化。</p><p><strong>基本实现</strong></p><p>图2显示了外积模式蝶形计算的基本实现，将蝶形计算视为矩阵化运算一节已说明的实部虚部分离的外积公式。Z0，Z1，Z2，Z3都是向量寄存器，分别从DFT矩阵的实部和虚部加载数据，然后执行fmopa指令，累加到输出的实部与虚部的ZA0和ZA1寄存器。</p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250325172018306.png" alt="image-20250325172018306" style="zoom:67%;"></p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250326143823255.png" alt="image-20250326143823255"></p><p><strong>优化实现</strong></p><p>优化实现是根据外积计算模式一节所展示的4中case分别实现的，根据r和向量寄存器长度vl，采用不同的优化实现。如图3所示。</p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250326144148158.png" alt="image-20250326144148158"></p><p>虽然在上面已经有了描述，此处还是再次说明每种情况采用哪种情况：</p><ul><li>$r\leq vl$：这个case中，每个向量寄存器都足够完成一列元素的加载，进行外积计算，所以仅使用水平方向的对称性Symmetric reduce来减少计算，以radix=8为例，列向量关于$w_4$对称，$w_0$和$w_4$直接进行外积计算，而$w_7、w_6、w_5$不需要进行外积计算。与基本实现相比，该模式使用了四个延迟更低，吞吐量更高的fadd/fdub替换了外积乘积。并且fadd/和fsub之间并没有数据依赖性。当r=2m时，还可以使用寄存器重用的方式，将DFT矩阵的列$i$转换到$\frac r2 - i$列，对实部使用[0,1,0,…,1]的掩码取负，对虚部使用[1,0,1,…,0]的掩码取负，以对应他们关于$\frac r4$的实部[1,-1,1…,-1]的关系，虚部[-1,1,-1…,1]的关系。</li><li>$r\ge vl，r=2m$：这种情况可以使用垂直方向的Periodic reduce，所以第一步就是将DFT矩阵分解为奇数和偶数的部分。然后分别进行外积计算，在这个过程中可以利用水平方向寄存器重用，如果r=4m+4而且r$\gt 2vl$，可以只读取前$\frac r4$的寄存器行，根据式21来计算。</li><li>$r \gt vl， r=2m+1$：r是奇数，垂直方向上只可使用寄存器重用，水平方向上可以采用Symmtric reduce，但是r是奇数所以不能采用水平方向的寄存器重用。</li></ul><p><strong>软件流水线优化</strong></p><p>在作者的实现当中，完全展开了图2中的循环(1)和(2)，只在循环(3)上做循环。当前面描述的约减模式不能使用时，可能会因为SME的高延迟和低吞吐，以及数据的依赖导致相当大的流水线停顿。</p><p>为了解决这个问题，每次循环时存储上一次迭代的结果，再为下一次迭代加载数据并执行计算，将结果存储与迭代加载计算交错，隐藏存储和移动指令的延迟，增强指令并行性。</p><h3 id="3-2-EVALUATION"><a href="#3-2-EVALUATION" class="headerlink" title="3.2 EVALUATION"></a>3.2 EVALUATION</h3><p>基于上述内核，本节对实现的OpenFFT-SME进行了性能评估。实验在GEM 5上进行。baseline为FFTE和FFTW，FFTE支持SVE但仅限于双精度，FFTW性能强大但只支持NEON向量化。OpenFFT为单精度和双精度都实现了基为3-16的内核，并未双精度专门实现了基为32和64的内核。</p><p>对维度为1，长度为N的FFT进行测量，性能指标为GFLOPC，将执行时间替换为周期，因为模拟器只能测量周期。</p><p>图4比较了FFTE，FFTW，OpenFFT的性能：</p><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250326160123787.png" alt="image-20250326160123787"></p><ul><li>这些库都表现出类似的性能趋势，数据足以驻留在缓存中时，性能随数据规模提高，当FFT规模超出缓存大小时，性能降低。</li><li>OpenFFT展现出了显著的优越性能，下表给出了加速比：</li></ul><p><img src="/2025/03/13/OpenFFT-SME-FFT%E7%AE%97%E6%B3%95%E5%9C%A8%E6%94%AF%E6%8C%81SME%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84CPU%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20250326160328986.png" alt="image-20250326160328986"></p><ul><li><p>FFTW在一些小尺寸点上的显著更高的性能可能是由于特定的优化。</p></li><li><p>与向量化相比，矩阵化通过外积更好地处理稠密计算。然而，主要用于向量化的乘法和加法指令由于其轻量级性质而具有更高的计算优化潜力，所以SME没有实现ARM SME外积指令的理想性能优势。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFT-快速傅里叶变换</title>
      <link href="/2025/02/28/FFT-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
      <url>/2025/02/28/FFT-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>快速傅里叶变换是离散傅里叶变换（DFT）的快速算法。若x(n)是一个长度为M的有限长序列，则x(n)的N点DFT如下，式中$W_N=e^{-j\frac{2\pi}{N}}$。其计算可表示为矩阵乘向量$X=Fx$。</p><script type="math/tex; mode=display">X(k)=\sum_{n=0}^{N-1}x(n)W_N^{kn}=\sum_{n=0}^{N-1} x(n) \cdot e^{-j \frac{2\pi}{N} k n},k=0,1,\ldots,N-1</script><script type="math/tex; mode=display">F =\begin{bmatrix}1 & 1 & 1 & \cdots & 1 \\1 & W_N & W_N^2 & \cdots & W_N^{N-1} \\1 & W_N^2 & W_N^4 & \cdots & W_N^{2(N-1)} \\\vdots & \vdots & \vdots & \ddots & \vdots \\1 & W_N^{N-1} & W_N^{2(N-1)} & \cdots & W_N^{(N-1)(N-1)}\end{bmatrix}</script><p>$W_N^{nk}$会均匀的分布复平面的单位圆上，具有一定的周期性。</p><ul><li>$b = rN + a$，则$ W_N^{rN} = e^{-j2\pi r} = 1$，$<br>  W_N^{b} = W_N^{rN} \cdot W_N^{a} = W_N^{a} $</li><li>$b=ra$，且N可被r整除，则$W_N^b=e^{-jra\frac{2\pi}{N}}=e^{-ja\frac{2\pi r}{N}}=W^a_{\frac{N}{r}}$</li><li>$b=\frac{N}{2}+rN+a$，N为偶数，则$W_N^{b}=-W_N^a$</li></ul><h2 id="Radix-2-FFT"><a href="#Radix-2-FFT" class="headerlink" title="Radix-2 FFT"></a>Radix-2 FFT</h2><p>DFT算法的时间复杂度为$O(n^2)$，而Cooley Tuky算法将时间复杂度降低到$O(nlogn)$，本节讨论的是基为2的Cooley Tuky快速傅里叶变换。radix-2 FFT又分时域抽取(<strong>DIT-FFT</strong>)和频域抽取(<strong>DIF-FFT</strong>)。</p><h3 id="1-DIT-FFT-时域抽取"><a href="#1-DIT-FFT-时域抽取" class="headerlink" title="1 DIT-FFT(时域抽取)"></a>1 DIT-FFT(时域抽取)</h3><p>设$N=2^m$，可以将序列x(n)按照奇偶分为两个$\frac{N}{2}$的子序列。可以将其拆解为：</p><script type="math/tex; mode=display">\begin{cases}x_1(r) = x(2r) & r = 0,1,\cdots,\frac{N}{2}-1 \\x_2(r) = x(2r+1) & r = 0,1,\cdots,\frac{N}{2}-1 \end{cases}</script><p>原序列的DFT可表示为：</p><script type="math/tex; mode=display">X(k) = \sum_{r=0}^{\frac{N}{2}-1} x_1(r) W_N^{2rk} + W_N^k \sum_{r=0}^{\frac{N}{2}-1} x_2(r) W_N^{2rk}</script><p>根据周期性的第二条，可将两项转为：</p><script type="math/tex; mode=display">X(k) = \underbrace{\sum_{r=0}^{\frac{N}{2}-1} x_1(r) W_{N/2}^{rk}}_{X_1(k)} + W_N^k \underbrace{\sum_{r=0}^{\frac{N}{2}-1} x_2(r) W_{N/2}^{rk}}_{X_2(k)}</script><p>$X_1(k)和X_2(k)$分别为两个子序列的$\frac{N}{2}$FFT，而由于周期性第三条，可以表示$X(k)$为：</p><script type="math/tex; mode=display">X(k) = X_1(k) + W_N^k X_2(k), \quad k = 0, 1, \ldots, \frac{N}{2}-1</script><script type="math/tex; mode=display">X\left(k + \frac{N}{2}\right) = X_1(k) - W_N^k X_2(k), \quad k = 0, 1, \ldots, \frac{N}{2}-1</script><p>所以奇偶序列中对应位置的值会通过以上两式产生相应的两个值，即蝶形运算：</p><p><img src="/2025/02/28/FFT-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20250228185103823.png" alt="image-20250228185103823" style="zoom:80%;"></p><p>对于一个8点DFT，时域分解由两组$\frac{N}{2}$DFT合并完成：</p><p><img src="/2025/02/28/FFT-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20250228185202485.png" alt="image-20250228185202485" width="60%"></p><p>构建$X_1$和$X_2$可以递归进行分解，从而得到二次时域分解抽取运算：</p><p><img src="/2025/02/28/FFT-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20250228185926242.png" alt="image-20250228185926242" width="75%/"></p><p>只要N是2的幂次，就可以递归分解，直到单个值的DFT就是其本身，对于上述8点DFT，最后的分解结果运算图为：</p><p><img src="/2025/02/28/FFT-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20250228190124489.png" alt="image-20250228190124489" width="80%/"></p><p>图中的输入不是顺序排列，但是是有规律的，后续会继续讨论。还可以注意到$W^k_{\frac{N}{m}}$利用了周期性2变换为了$W^{mk}_N$。图中的数组A用于存放输入序列和每级运算结果，后续的编程方法的讨论会用到。</p><h3 id="2-DIT-FFT的运算规律及编程思想"><a href="#2-DIT-FFT的运算规律及编程思想" class="headerlink" title="2 DIT-FFT的运算规律及编程思想"></a>2 DIT-FFT的运算规律及编程思想</h3><h4 id="1-原位计算"><a href="#1-原位计算" class="headerlink" title="1.原位计算"></a>1.原位计算</h4><p>由图4.2.4，$N=2^M$点的FFT进行M次运算，每级运算为$\frac{N}2$个蝶形运算，同一级的输入只对本次蝶形运算有用，而且每个蝶形的输入输出在同一条线上，因此计算完一个蝶形后，可以直接将输出数据存储到输入位置，进行原位计算，节省内存空间。</p><h4 id="2-旋转因子的规律"><a href="#2-旋转因子的规律" class="headerlink" title="2.旋转因子的规律"></a>2.旋转因子的规律</h4><p>蝶形计算需要乘旋转因子$W_N^p$，对于图4.2.4，从左到右用L表示运算级数且<strong>从1开始</strong>，则$N=2^L$，$p$是从0开始的序列，且长度为$2^{L-1}$，</p><script type="math/tex; mode=display">W_N^p = W_{2^L}^J \quad J = 0,\ 1,\ 2,\ \cdots,\ 2^{L-1} - 1</script><p>因为</p><script type="math/tex; mode=display">2^L = 2^M \times 2^{L-M} = N \cdot 2^{L-M}</script><p>所以</p><script type="math/tex; mode=display">W_N^p = W_{N\cdot 2^{L-M}}^{J} = W_N^{J \cdot 2^{M-L}} \quad J = 0,\ 1,\ 2,\ \cdots,\ 2^{L-1} - 1</script><p>这就是图4.2.4对于$W^k_{\frac{N}{m}}$变换的数学描述。</p><h4 id="3-蝶形运算规律"><a href="#3-蝶形运算规律" class="headerlink" title="3.蝶形运算规律"></a>3.蝶形运算规律</h4><p>对于图4.2.4一个蝶形运算轮次的前后，一个A由上一级的两个A运算得到，假设B表示两个输入数据之间的距离，则蝶形运算可表示为：</p><script type="math/tex; mode=display">A_L(J) \leftarrow A_{L-1}(J) + A_{L-1}(J + B)W_N^p</script><script type="math/tex; mode=display">A_L(J + B) \leftarrow A_{L-1}(J) - A_{L-1}(J + B)W_N^p</script><p>式中：</p><script type="math/tex; mode=display">p = J \cdot 2^{M-L} \quad (J = 0,\ 1,\ \ldots,\ 2^{L-1} - 1;\ L = 1,\ 2,\ \ldots,\ M)</script><p>第L级中，每个鲽形的两个输入距离$B=2^{L-1}$个点，每级刚好也是有B个旋转因子，每个旋转因子对应间隔为$2^L$个点的$2^{M-L}$个蝶形。</p><h4 id="4-运算"><a href="#4-运算" class="headerlink" title="4.运算"></a>4.运算</h4><p>根据上述的运算规律，可以从输入的第一级开始，逐级完成计算，共进行M级运算。每次求出B个不同的旋转因子，并计算完他对应的$2^{M-L}$个蝶形。所以最终的程序包含三个循环，最外层为输入层级，第二层为旋转因子，共B个(记为迭代J)，第三层为旋转因子对应的不同蝶形(记为迭代k)，共$2^{M-L}$个，间隔为$2^L$，对应$A(J<em>2^{kL})$和$A(J</em>2^{kL}+B)$。</p><p>剩下的唯一问题就是将输入序列x(n)进行排序，使他们的排序符合奇偶抽取。</p><h4 id="5-倒序"><a href="#5-倒序" class="headerlink" title="5.倒序"></a>5.倒序</h4><p>由于$N=2^M$，所以输入序列的顺序数可以用M位二进制表示，抽取相当于从最低位起每次取一位按照奇偶分组，该分组可以找出规律发现其二进制表示相当于顺序数的二进制位倒序，即位置在001的是x(100)的值。而生成倒序数数列的过程，为了方便表示，可以用J表示当前倒序数的十进制数值，对于$N=2^M$，最高位的十进制权值为N/2，向右的每位权值依次除2，所以按照顺序，每次下一个数都是当前倒序数最高位+1，相当于十进制运算J+N/2，如果最高位是0则得到下一个数，如果是1则要转为0(J-N/2)，向次高位进位，相当于J+N/4，依次类推，直到无进位，就得到了下一个倒序数。</p><p>得到了倒序数后，将原数组中的输入序列重新排列，由于第一个序列值和最后一个序列值不需要重排(000 111)，所以从A(I=1)开始，到A(N-2)，倒序数初值为N/2，计算出一个倒序数J时，就与默认顺序I比较，I=J时不需要交换，I不等于J时，A(I)和A(J)交换，避免重复调换，只对I&lt;J的情况调换。</p><p><img src="/2025/02/28/FFT-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20250303115159714.png" alt="image-20250303115159714" width="50%"></p><h4 id="6-实现"><a href="#6-实现" class="headerlink" title="6.实现"></a>6.实现</h4><p>以下是对上述算法的一个实现，与上述程序框图完全一致。使用FFTW提供的复数类型，并对相同的输入数据计算检验了正确性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fftw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compute_twiddle_factor</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> N, fftw_complex &amp;W)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> theta = <span class="number">2.0</span> * M_PI * p / N;  <span class="comment">// 计算角度</span></span><br><span class="line">    W[<span class="number">0</span>] = std::<span class="built_in">cos</span>(theta);              </span><br><span class="line">    W[<span class="number">1</span>] = -std::<span class="built_in">sin</span>(theta);              </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">complex_multiply</span><span class="params">(<span class="type">const</span> fftw_complex&amp; a, <span class="type">const</span> fftw_complex&amp; b, fftw_complex&amp; result)</span> </span>&#123;</span><br><span class="line">    result[<span class="number">0</span>] = a[<span class="number">0</span>] * b[<span class="number">0</span>] - a[<span class="number">1</span>] * b[<span class="number">1</span>];  </span><br><span class="line">    result[<span class="number">1</span>] = a[<span class="number">0</span>] * b[<span class="number">1</span>] + a[<span class="number">1</span>] * b[<span class="number">0</span>];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">complex_add</span><span class="params">(<span class="type">const</span> fftw_complex&amp; a, <span class="type">const</span> fftw_complex&amp; b, fftw_complex&amp; result)</span> </span>&#123;</span><br><span class="line">    result[<span class="number">0</span>] = a[<span class="number">0</span>] + b[<span class="number">0</span>];  </span><br><span class="line">    result[<span class="number">1</span>] = a[<span class="number">1</span>] + b[<span class="number">1</span>];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">complex_subtract</span><span class="params">(<span class="type">const</span> fftw_complex&amp; a, <span class="type">const</span> fftw_complex&amp; b, fftw_complex&amp; result)</span> </span>&#123;</span><br><span class="line">    result[<span class="number">0</span>] = a[<span class="number">0</span>] - b[<span class="number">0</span>];  </span><br><span class="line">    result[<span class="number">1</span>] = a[<span class="number">1</span>] - b[<span class="number">1</span>];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">reverse</span><span class="params">(fftw_complex *x, <span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> LH = N/<span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> j = LH;</span><br><span class="line">  <span class="type">int</span> N1 = N<span class="number">-2</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N<span class="number">-2</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">      <span class="type">double</span> tmp_re = x[i][<span class="number">0</span>];</span><br><span class="line">      <span class="type">double</span> tmp_im = x[i][<span class="number">1</span>];</span><br><span class="line">      x[i][<span class="number">0</span>] = x[j][<span class="number">0</span>];</span><br><span class="line">      x[i][<span class="number">1</span>] = x[j][<span class="number">1</span>];</span><br><span class="line">      x[j][<span class="number">0</span>] = tmp_re;</span><br><span class="line">      x[j][<span class="number">1</span>] = tmp_im;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k = LH;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;=k)&#123;</span><br><span class="line">      j = j-k;</span><br><span class="line">      k = k/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    j = j+k;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fftKernel</span><span class="params">(fftw_complex *x, <span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> M = std::<span class="built_in">log2</span>(N);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> L=<span class="number">1</span>;L&lt;=M;L++)&#123;</span><br><span class="line">    <span class="type">int</span> B = (<span class="type">int</span>)std::<span class="built_in">pow</span>(<span class="number">2</span>, L<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> J=<span class="number">0</span>;J&lt;B;J++)&#123;</span><br><span class="line">      <span class="type">int</span> p = J*(<span class="number">1</span>&lt;&lt;(M-L));</span><br><span class="line">      fftw_complex Wnp;</span><br><span class="line">      <span class="built_in">compute_twiddle_factor</span>(p, N, Wnp);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> K=J;K&lt;N;K+=(<span class="type">int</span>)std::<span class="built_in">pow</span>(<span class="number">2</span>,L))&#123;</span><br><span class="line">        fftw_complex WB;</span><br><span class="line">        <span class="built_in">complex_multiply</span>(x[K+B], Wnp, WB);</span><br><span class="line">        fftw_complex out1;</span><br><span class="line">        <span class="built_in">complex_add</span>(x[K], WB, out1);      <span class="comment">// 计算 A + WB</span></span><br><span class="line">        <span class="built_in">complex_subtract</span>(x[K], WB, x[K+B]); <span class="comment">// 计算 A - WB</span></span><br><span class="line">        x[K][<span class="number">0</span>] = out1[<span class="number">0</span>];</span><br><span class="line">        x[K][<span class="number">1</span>] = out1[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//x[K+B][0] = out2[0];</span></span><br><span class="line">        <span class="comment">//x[K+B][1] = out2[1];</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFFT</span><span class="params">(fftw_complex* x, <span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">  <span class="built_in">reverse</span>(x, N);</span><br><span class="line">  <span class="built_in">fftKernel</span>(x, N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这是一个简单实现，性能差距与FFTW库的差别很大，计算8192*16的1D FFT，FFTW仅需要2ms，而上面这个实现需要25ms。</p><h3 id="3-DIF-FFT-频域抽取"><a href="#3-DIF-FFT-频域抽取" class="headerlink" title="3 DIF-FFT(频域抽取)"></a>3 DIF-FFT(频域抽取)</h3><p>频域抽取DIF-FFT是另一种常用的快速算法，这种算法中，同样将原序列分为两个子序列，但直接前后分开：</p><script type="math/tex; mode=display">X(k) = \text{DFT}[x(n)] = \sum_{n=0}^{N-1} x(n) \cdot W_N^{kn}</script><p>其中：</p><script type="math/tex; mode=display"> X(k) = \text{DFT}[x(n)] = \sum_{n=0}^{N-1} x(n) W_N^{kn} \\ = \sum_{n=0}^{N/2-1} x(n) W_N^{kn} + \sum_{n=N/2}^{N-1} x(n) W_N^{kn} \\ = \sum_{n=0}^{N/2-1} x(n) W_N^{kn} + \sum_{n=0}^{N/2-1} x\left(n + \frac{N}{2}\right) W_N^{k\left(n+\frac{N}{2}\right)} \\ = \sum_{n=0}^{N/2-1} \left[ x(n) + W_N^{kN/2} x\left(n + \frac{N}{2}\right) \right] W_N^{kn} \\</script><p>根据k取奇数或偶数，可以设：</p><script type="math/tex; mode=display">\begin{aligned}x_1(n) &= x(n) + x\left(n + \frac{N}{2}\right) \\x_2(n) &= \left[x(n) - x\left(n + \frac{N}{2}\right)\right] W_N^n\end{aligned}</script><p>其中 $n = 0, 1, 2, \ldots, \frac{N}{2} - 1$。可得：</p><script type="math/tex; mode=display">\begin{aligned}X(2m) &= \sum_{n=0}^{N/2-1} x_1(n) W_{N/2}^{nm} \\X(2m+1) &= \sum_{n=0}^{N/2-1} x_2(n) W_{N/2}^{nm}\end{aligned}</script><p>偶数部分的X值是x1序列的N/2点DFT，奇数部分的值是x2序列的N/2点DFT，而x1和x2序列的值来源于蝶形计算：</p><p><img src="/2025/02/28/FFT-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20250318153733625.png" alt="image-20250318153733625" style="zoom: 67%;"></p><p>而N/2的FFT可以用同样的方式分解为蝶形运算，直到最后的两点DFT：</p><p><img src="/2025/02/28/FFT-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20250318154040000.png" alt="image-20250318154040000" style="zoom: 67%;"></p><p>DIF-FFT算法和DIT-FFT算法类似，运算次数也相同，但是DIF-FFT算法输出为倒序排列，需要对输出进行重新排序。蝶形运算上也稍有不同，DIT-FFT先乘后加减(A+CB、A-CB)，DIT-FFT则是先加减后相乘。</p><h2 id="Radix-4-FFT"><a href="#Radix-4-FFT" class="headerlink" title="Radix-4 FFT"></a>Radix-4 FFT</h2><p>不同基数的FFT算法的运算效率不同，实际中最常用的是基2FFT、基4FFT，分裂基FFT和DHT。在基rFFT中，基4FFT算法效率与基8FFT很接近，但是实现更简单，判断开销少。</p><h3 id="1-DIT-FFT"><a href="#1-DIT-FFT" class="headerlink" title="1 DIT-FFT"></a>1 DIT-FFT</h3><p>与基2FFT类似，首先将输入序列进行划分，抽取分为四份：</p><script type="math/tex; mode=display">\begin{align*}x_1[n] &= x[4n] \\x_2[n] &= x[4n+1] \\x_3[n] &= x[4n+2] \\x_4[n] &= x[4n+3]\end{align*}</script><p>则x(n)的DFT可以表示为：</p><script type="math/tex; mode=display">\begin{flalign}&X(k) = \sum_{n=0}^{N-1}x(n)W_N^{nk} \\ =&\sum_{n=0}^{\frac N4-1}x(4n)W_{N}^{4nk} +\sum_{n=0}^{\frac N4-1}x(4n+1)W_{N}^{(4n+1)k} +\sum_{n=0}^{\frac N4-1}x(4n+2)W_{N}^{(4n+2)k} +\sum_{n=0}^{\frac N4-1}x(4n+3)W_{N}^{(4n+3)k} \\=&\sum_{n=0}^{\frac N4-1}x(4n)W_{\frac N4}^{nk} +\sum_{n=0}^{\frac N4-1}x(4n+1)W_{\frac N4}^{nk}W_{N}^{k}+\sum_{n=0}^{\frac N4-1}x(4n+2)W_{\frac N4}^{nk}W_{N}^{2k} +\sum_{n=0}^{\frac N4-1}x(4n+3)W_{\frac N4}^{nk}W_{N}^{3k} \\ =&\sum_{n=0}^{\frac N4 -1}x_1(n)W_{\frac N4}^{nk}+\sum_{n=0}^{\frac N4 -1}x_2(n)W_{\frac N4}^{nk}W_{N}^{k}+\sum_{n=0}^{\frac N4 -1}x_3(n)W_{\frac N4}^{nk}W_{N}^{2k}+\sum_{n=0}^{\frac N4 -1}x_4(n)W_{\frac N4}^{nk}W_{N}^{3k} \\=&X_1(k)+W_{N}^{k}X_2(k)+W_{N}^{2k}X_3(k)+W_{N}^{3k}X_4(k)\end{flalign}</script><p>其中的$X_1(k)、X_2(k)$等分别为抽取为四份的四个序列的$\frac N4$点DFT，上面的公式只能计算$0$~$ \frac n4-1$的DFT，可以令$k=k+\frac N4$~$k+\frac{3N}{4}$，以及$W^{\frac N 4}=-j$的特性的得到完整的DFT结果序列：</p><script type="math/tex; mode=display">\begin{flalign}&X(k+N/4)\\  =& X_1(k) + W_N^{k+N/4} X_2(k) + W_N^{2(k+N/4)} X_3(k) + W_N^{3(k+N/4)} X_4(k) \\ =& X_1(k) - jW_N^k X_2(k) - W_N^{2k} X_3(k) + jW_N^{3k} X_4(k)\\ \\&X(k+2N/4)\\=& X_1(k) + W_N^{k+2N/4} X_2(k) + W_N^{2(k+2N/4)} X_3(k) + W_N^{3(k+2N/4)} X_4(k) \\=& X_1(k) - W_N^k X_2(k) + W_N^{2k} X_3(k) - W_N^{3k} X_4(k) \\ \\&X(k+3N/4)\\=& X_1(k) + W_N^{k+3N/4} X_2(k) + W_N^{2(k+3N/4)} X_3(k) + W_N^{3(k+3N/4)} X_4(k) \\=& X_1(k) + jW_N^k X_2(k) - W_N^{2k} X_3(k) - jW_N^{3k} X_4(k)\end{flalign}</script><p>$W^{\frac N 4}=-j$在复平面的图示，图中为radix=8的旋转因子[1]。</p><p><img src="/2025/02/28/FFT-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/image-20250325154357066.png" alt="image-20250325154357066"></p><blockquote id="fn_1"><sup>1</sup>. 图源自OpenFFT-SME: An Efficient Outer Product Pattern FFT Library on ARM SME CPUs<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><p>可以用矩阵形式表示四部分结果：</p><script type="math/tex; mode=display">\begin{bmatrix}X(k)\\X(k+\frac{N}{4})\\X(k+\frac{2N}{4})\\X(k+\frac{3N}{4})\end{bmatrix}=\begin{bmatrix}1 & 1 & 1  & 1 \\1 & W_N^{N/4} & W_N^{2N/4}  & W_N^{3N/4} \\1 & W_N^{2N/4} & W_N^{4N/4} & W_N^{6N/4} \\1 & W_N^{3N/4} & W_N^{6N/4} & W_N^{9N/4}\end{bmatrix}\begin{bmatrix}X_1(k) \\X_2(k)W_N^{k}\\X_3(k)W_N^{2k}\\X_4(k)W_N^{3k}\end{bmatrix}</script><p>对第二个矩阵进行周期性变换：</p><script type="math/tex; mode=display">\begin{bmatrix}X(k)\\X(k+\frac{N}{4})\\X(k+\frac{2N}{4})\\X(k+\frac{3N}{4})\end{bmatrix}=\begin{bmatrix}1 & 1 & 1  & 1 \\1 & W_4^{1} & W_4^{2}  & W_4^{3} \\1 & W_4^{2} & W_4^{4} & W_4^{6} \\1 & W_4^{3} & W_4^{6} & W_4^{9}\end{bmatrix}\begin{bmatrix}X_1(k) \\X_2(k)W_N^{k}\\X_3(k)W_N^{2k}\\X_4(k)W_N^{3k}\end{bmatrix}</script><p>对右边的向量展开到$\frac N4$列，并分解为逐元素乘：</p><script type="math/tex; mode=display">\begin{bmatrix}X_1(k) \\X_2(k)W_N^{k}\\X_3(k)W_N^{2k}\\X_4(k)W_N^{3k}\end{bmatrix}=\begin{bmatrix}X_1(0) & X_1(1) & X_1(2) & \cdots & X_1(\frac{N}{4}-1)\\X_2(0)W_N^{0} & X_2(1)W_N^{1} & X_2(2)W_N^{2} & \cdots & X_2(\frac{N}{4}-1)W_N^{\frac{N}{4}-1}\\X_3(0)W_N^{0} & X_3(1)W_N^{2}& X_3(2)W_N^{4} & \cdots & X_3(\frac{N}{4}-1)W_N^{2(\frac{N}{4}-1）}\\X_4(0)W_N^{0} & X_4(1)W_N^{3} & X_4(2)W_N^{6} & \cdots & X_4(\frac{N}{4}-1)W_N^{3(\frac{N}{4}-1)}\end{bmatrix}=</script><script type="math/tex; mode=display">\begin{bmatrix}X_1(0) & X_1(1) & X_1(2) & \cdots & X_1(\frac{N}{4}-1)\\X_2(0) & X_2(1) & X_2(2) & \cdots & X_2(\frac{N}{4}-1)\\X_3(0) & X_3(1) & X_3(2) & \cdots & X_3(\frac{N}{4}-1)\\X_4(0) & X_4(1) & X_4(2) & \cdots & X_4(\frac{N}{4}-1)\end{bmatrix}\odot\begin{bmatrix}1 & 1 & 1 & \cdots & 1\\W_N^{0} & W_N^{1} & W_N^{2} & \cdots & W_N^{\frac{N}{4}-1}\\W_N^{0} & W_N^{2}& W_N^{4} & \cdots & W_N^{2(\frac{N}{4}-1）}\\W_N^{0} & W_N^{3} & W_N^{6} & \cdots & W_N^{3(\frac{N}{4}-1)}\end{bmatrix}</script><p>因此基4FFT矩阵形式表达为：</p><script type="math/tex; mode=display">\begin{bmatrix}X(k)\\X(k+\frac{N}{4})\\X(k+\frac{2N}{4})\\X(k+\frac{3N}{4})\end{bmatrix}=\begin{bmatrix}1 & 1 & 1  & 1 \\1 & W_4^{1} & W_4^{2}  & W_4^{3} \\1 & W_4^{2} & W_4^{4} & W_4^{6} \\1 & W_4^{3} & W_4^{6} & W_4^{9}\end{bmatrix} \cdot</script><script type="math/tex; mode=display">\{\begin{bmatrix}X_1(0) & X_1(1) & X_1(2) & \cdots & X_1(\frac{N}{4}-1)\\X_2(0) & X_2(1) & X_2(2) & \cdots & X_2(\frac{N}{4}-1)\\X_3(0) & X_3(1) & X_3(2) & \cdots & X_3(\frac{N}{4}-1)\\X_4(0) & X_4(1) & X_4(2) & \cdots & X_4(\frac{N}{4}-1)\end{bmatrix}\odot\begin{bmatrix}1 & 1 & 1 & \cdots & 1\\W_N^{0} & W_N^{1} & W_N^{2} & \cdots & W_N^{\frac{N}{4}-1}\\W_N^{0} & W_N^{2}& W_N^{4} & \cdots & W_N^{2(\frac{N}{4}-1）}\\W_N^{0} & W_N^{3} & W_N^{6} & \cdots & W_N^{3(\frac{N}{4}-1)}\end{bmatrix}\}</script><p>而$X_{1、2、3、4}(k)$是$\frac N4$点DFT，可将矩阵形式表示记为：</p><script type="math/tex; mode=display">X_{out}=F_{N1}\cdot(T_{N_1N_2}\odot X_{in})</script><p>这里已经可以看出，Cooley Tukey算法将序列转换为了2维，行内进行DFT，再从列的维度上进行DFT，即其计算本质仍然是DFT，只是通过重用减少了计算量。由于上述计算的数据是不连续的，所以可以预先通过转置调整其为连续数据，自底向上进行计算和合并的过程，最后一个参考链接给出了转置调整顺序的过程以及一个简单易懂的例子。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>1.数字信号系统</p><p>2.<a href="https://zhuanlan.zhihu.com/p/129420167">https://zhuanlan.zhihu.com/p/129420167</a></p><p>3.<a href="https://www.woaitingting.site/index.php/archives/10/">https://www.woaitingting.site/index.php/archives/10/</a></p>]]></content>
      
      
      <categories>
          
          <category> 高性能计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速傅里叶变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DiffMorpher</title>
      <link href="/2024/11/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A/"/>
      <url>/2024/11/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="DiffMorpher-Unleashing-the-Capability-of-Diffusion-Models-for-Image-Morphing"><a href="#DiffMorpher-Unleashing-the-Capability-of-Diffusion-Models-for-Image-Morphing" class="headerlink" title="DiffMorpher: Unleashing the Capability of Diffusion Models for Image Morphing"></a><center>DiffMorpher: Unleashing the Capability of Diffusion Models for Image Morphing</center></h2><h3 id="1-研究背景"><a href="#1-研究背景" class="headerlink" title="1 研究背景"></a>1 研究背景</h3><h4 id="1-1-图像变形-Image-morphing"><a href="#1-1-图像变形-Image-morphing" class="headerlink" title="1.1 图像变形(Image morphing)"></a>1.1 图像变形(Image morphing)</h4><p>​        图像变形(Image morphing)是一种图像变换技术。是一个计算机视觉和图形学交叉的问题。给定相似物体的两张图像和一组对应关键点(可选)，生成一系列变形中间图像。这些图像插入两个输入图像之间，能让整个图像序列生成一个平滑过渡的视频。可用于深度学习中的数据增强，动画，照片编辑等领域。</p><h4 id="1-2-传统图像变形技术"><a href="#1-2-传统图像变形技术" class="headerlink" title="1.2 传统图像变形技术"></a>1.2 传统图像变形技术</h4><p>​        图像变形问题的经典解决方式是通过图像变形把两个图像的对应点对齐，然后进行颜色交融。但是这种方式有两个问题：</p><ul><li>只在颜色空间操作，无法解释图像纹理和语义的变化</li><li>生成的中间图像易出现伪影，效果不自然</li></ul><p>​        经典方法的问题在于无法创建超出给定输入的新内容，从而容易出现伪影。对于这个问题，最近产生了新的数据驱动的变形范式，利用特定对象类的大量图像来确定原图像到目标图像的平滑过渡路径。但是这需要大量单类的数据，也解决不了跨域等通用场景的应用。</p><h4 id="1-3-对抗模型-GAN-与扩散模型-Diffusion-model-在图像变形问题中的比较"><a href="#1-3-对抗模型-GAN-与扩散模型-Diffusion-model-在图像变形问题中的比较" class="headerlink" title="1.3 对抗模型(GAN)与扩散模型(Diffusion model)在图像变形问题中的比较"></a>1.3 对抗模型(GAN)与扩散模型(Diffusion model)在图像变形问题中的比较</h4><p>​        在前几年，已经有一些使用GAN来完成图像变形的研究。在GAN中，图像是由高维隐变量生成的，可以通过GAN反演把输入图像变为隐变量，再对隐变量进行插值，从而生成输入图像的中间过渡图像。但由于GAN反演的挑战以及GAN生成的图像通常局限于某一类别，泛用性差。</p><p>​        diffusion model在图像生成质量上强于GAN，也有一些使用diffusion model采用插值方式解决图像变形问题的研究，对DDIM反演[2]得到的纯噪声隐变量进行插值。由于diffusion model的潜在空间不够结构化[1]，插值常会导致随机和突然的内容闪烁，因此如何保证转换的平滑性是一个挑战。</p><blockquote><p>[1]：扩散模型从高维随机噪声开始，逐步学习去噪生成图像，映射更加复杂，每步结果都依赖噪声，模型权重，步数等因素，因此潜在空间相较于GAN不够结构化。</p><p>[2]：从一张真实图像恢复到其在扩散过程中的初始噪声的过程，基于DDIM（Denoising Diffusion Implicit Models）采样算法实现。</p></blockquote><p>​        本篇文章提出了LoRA插值和潜在噪声插值，自注意力插值等方法，提高diffusion model在解决图像变形问题时，生成中间图像的质量和平滑性。</p><h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2 方法"></a>2 方法</h3><h4 id="2-1-LoRA插值"><a href="#2-1-LoRA插值" class="headerlink" title="2.1 LoRA插值"></a>2.1 LoRA插值</h4><p>​        低秩适应是一种有效的模型调优技术，将模型参数的调整分解为对低秩矩阵的调整。假设有原始权重矩阵W，LoRA通过低秩矩阵A和B的乘积调整权重：</p><script type="math/tex; mode=display">W' = W + ΔW =W + A \cdot B</script><p>​        A和B是两个低秩矩阵，训练过程中，LoRA只需要更新A和B。这能提高训练效率。而本篇文章的作者发现<strong>LoRA能将高级图像语义封装到低秩参数空间</strong>，这样通过将LoRA拟合到单个图像，微调后的模型能在遍历噪声时生成语义一致的不同样本。        受此观察的启发，作者提出的方法首先在 SD UNet ϵθ 上为两个图像 I0 和 I1 训练两个 LoRA Δθ0、Δθ1。 形式上，训练 Δθi(i = 0, 1) 的学习目标是：</p><p><img src="/2024/11/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A/image-20241117165843678.png" alt="image-20241117165843678" style="zoom: 67%;"></p><ul><li>z0i 是原始图像 i 的VAE编码潜在嵌入。</li><li>ϵ 是实际的噪声(采样自高斯分布)</li><li>$\sqrt{\overline\alpha_t}z_0i+\sqrt{1-\overline\alpha_t}\epsilon$是step t的噪声潜在embedding</li><li>ϵ^θ+Δθ 是模型的预测噪声，基于当前的参数</li><li>ci是prompt的文本embedding</li><li>$ε_θ+Δθ_i$是Lora微调集成的UNET</li><li>t 是当前的时间步</li></ul><p>​        微调后$Δθ_0$和$Δθ_1$被固定并存储。 当生成中间图像 Iα 时，通过在低秩参数空间中应用线性插值来融合 I0 和 I1 中的高级语义：$ Δθ_α = (1 − α)Δθ_0 + αΔθ_1 $并使用 带有插值$ LoRA ϵ_θ+Δθ_α $的 UNet 作为去噪步骤中的噪声预测网络。 这样的插值$ Δθ_α $是有意义的，因为$ Δθ_0 $和$ Δθ_1 $是从相同的初始化中进行适度微调的，因此高度相关。</p><p>​        这一部分工作的重点在于通过LoRA将两个图像的一致语义保留，然后对LoRA的权重参数进行插值，实现语义的平滑过渡。</p><h4 id="2-2-潜在插值"><a href="#2-2-潜在插值" class="headerlink" title="2.2 潜在插值"></a>2.2 潜在插值</h4><p>​        通过噪声预测网络，生成 Iα 的下一步是找到相应的潜在噪声 zTα 和潜在文本条件 cα。 为此，本研究进一步引入潜在插值。通过DDIM反演得到两个图像对应的潜在噪声zT0、zT1，并通过球面线性插值（slerp）得到中间潜在噪声zTα：</p><p><img src="/2024/11/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A/image-20241117173005078.png" style="zoom:50%;"></p><p>​        为了缓解反演中不准确重建的问题，本研究在反转时利用了LoRA继承的UNet的权重。而潜在文本条件作者也采用了线性插值的方式：</p><p><img src="/2024/11/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A/image-20241117173337736.png" alt="image-20241117173337736" style="zoom: 67%;"></p><p>​        获得潜在噪声 zTα 和潜在条件 cα 后，通过 LoRA 集成的 UNet ϵθ+Δθα 对 zTα 进行去噪，获得具有自然空间过渡的语义有意义的中间图像。</p><p>​        这一部分工作是对输入图像对应的噪声和输入文本enbedding进行插值，提高中间图像的合理性。</p><h4 id="2-3-自注意力输入的插值与替换"><a href="#2-3-自注意力输入的插值与替换" class="headerlink" title="2.3 自注意力输入的插值与替换"></a>2.3 自注意力输入的插值与替换</h4><p>​        通过前两种方法已经提高了中间结果的语义合理性，但是纹理变化的不平滑仍然存在，作者将此归因为多步去噪过程中引入的非线性特性，并提出了一种新颖的自注意力插值和替换方法，该方法将线性变化的注意力特征引入到去噪过程中， 大大减少了生成视频的突然变化。</p><p>​        如图4所示，在去噪过程t时，将输入图像的噪声输入到LoRA的UNet中，得到自注意力模块的矩阵K和V，然后对两张图像的K和V矩阵插值，替换原有自注意力矩阵，从而让图像能够从输入图像中查询到相关结构和纹理，从而提高图像平滑性。</p><p><img src="/2024/11/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A/image-20241117190048319.png" alt="image-20241117190048319" style="zoom:50%;"></p><p>​        作者还发现自注意力插值替换会使图像纹理模糊，因此只在早期的λT步替换特征，后续步保持自注意力矩阵不变，并经实验确认λ取0.4-0.6是效果最好的。</p><p>​        这一部分的工作对自注意力矩阵替换，将原有的自注意力矩阵替换为输入图像插值后的自注意力矩阵，从而让中间图像生成过程能利用原图像的纹理，从而提高图像变换的平滑性，也通过控制进行替换的步数解决了替换自注意力的问题。</p><h4 id="2-4-自适应实例归一化"><a href="#2-4-自适应实例归一化" class="headerlink" title="2.4 自适应实例归一化"></a>2.4 自适应实例归一化</h4><p>​        在扩散模型的去噪过程中，为了确保生成图像与输入图像之间的颜色和亮度保持一致，作者引入了自适应实例归一化（AdaIN）对插值的潜在噪声进行调整。通过调整噪声的均值（µ）和标准差（σ）来改变图像的色调和亮度，从而使生成图像在颜色和亮度上更符合输入图像的特征。同样采用插值的方法，先计算输入图像的潜在噪声的各个通道的平均值和标准差，然后线性插值，据此调整中间图像的潜在噪声。</p><p><img src="/2024/11/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A/image-20241117195605371.png" alt="image-20241117195605371" style="zoom:50%;"></p><h4 id="2-5-采样重调度"><a href="#2-5-采样重调度" class="headerlink" title="2.5 采样重调度"></a>2.5 采样重调度</h4><p>​        通过以上的方法，可以实现在两个图像之间生成平滑的过渡图像。但是图像内容的过渡不均匀，即开始和结束时变化较慢，中间时刻图像变化过快。在选择插值比例α的选择上，如果α是等距的，即如果产生10个中间帧，混合比例[0,0.1,0.2,…,1]，不同比例的地方图像的变化率不同，变化率不均匀。</p><p>​        作者采用了一种类似平均颜色分布的直方图均衡化算法。调整了重采样的混合比例[0,α1,α2,α3,α4…1]，使相邻帧的变化了近乎相同。其推导见原文。</p><h3 id="3-实验结果"><a href="#3-实验结果" class="headerlink" title="3 实验结果"></a>3 实验结果</h3><p>​        由于图形变换问题缺乏具体的评价基准，作者提出了MorphBench，作为一个评估图像变形的数据集。收集了 90 对不同内容和风格的图片，并将它们分为两类：i）不同物体之间的变形（66 对）和 ii）相同物体的动画（24 对）。</p><p>​        作者和五种代表性的图形变形方法进行了比较，包括基于扭曲和混合的经典图形变形技术；基于GAN的插值方法DGP和styleGAN-XL；基于Diffusion model的深度差值方法DDIM和Diff.Interp。</p><p>​        定性评估实验结果，DiffMorpher 在图像保真度、语义一致性和转换平滑度方面都优于以前的所有方法，无论是用于在不同对象之间变形还是为同一对象设置动画，并且也没有出现残影等问题，并且色彩上也是平滑变化的。如图5所示：</p><img src="/2024/11/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A/image-20241117203859352.png" class title="image-20241117203859352"><p>​        为了定量评估，作者采用了Diff.Interp中采用的指标（这里作者没有详细阐释这些指标的计算方法和原理，可能在Diff.Interp中有介绍，此处只简单记录这些指标的作用）。</p><ul><li>Frechet inception distance(FID)：计算输入图像的分布和生成图像的分布之间的FID，从生成图像中随机采样两个图像10次，取平均FID分数作为中间图像的合理性和保真度指标。越低表示图形变换效果越好。</li><li>Perceptual path length(PPL)：计算 17 帧序列中相邻图像之间的感知损失之和，作为过渡视频的平滑度和一致性的指标。</li><li>Perceptual distance variance(PDV)：作者基于Perceptual path length (PPL)提出的新指标，计算连续图像之间的感知损失，然后计算序列中这些距离的方差，测试集中所有序列的平均序列方差被视为PDV，用于评估转换速率的均匀性。较低的PDV表示更均匀的速率。</li></ul><p>​        量化评估指标的结果如下表所示，本研究的效果优于DDIM等方法。但是在部分类型和指标上指标高于(对应效果劣于)WarpBlend即经典方法，作者说明了这是因为变形和混合操作的平滑和线性特性，所以经典方法从指标上看效果很好，但是很容易出现重影和伪影，从上面定性评估的warpBlend也能看出来，确实存在明显的重影和伪影。</p><p><img src="/2024/11/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A/image-20241117204721553.png" alt="image-20241117204721553" style="zoom: 67%;"></p><p>​        最后作者还进行了消融实验衡量各个具体方法的有效性，表2显示了4种不同方法的组合以及指标，提高语义一致性和平滑程度的关键是LoRA插值(降低FID和PPL)，采样重调度则使图像变化速率均匀，降低了PDV。</p><p><img src="/2024/11/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A/image-20241117205449238.png" alt="image-20241117205449238" style="zoom: 67%;"></p><h3 id="4-局限及问题"><a href="#4-局限及问题" class="headerlink" title="4 局限及问题"></a>4 局限及问题</h3><p>​        作者提出方法的局限性之一在于必须在图形变换前为每个输入图像训练LoRA，会花费额外的时间，也增加了图形变换求解本身的复杂性。此外，潜在差值部分对输入文本的嵌入表示插值，来提高中间图像的合理性，需要用户对输入的prompt文本进行对齐，这是作者在文章最后指出的。</p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CUDA笔记2</title>
      <link href="/2024/10/28/CUDA%20NOTE2/"/>
      <url>/2024/10/28/CUDA%20NOTE2/</url>
      
        <content type="html"><![CDATA[<h1 id="CUDA-笔记2"><a href="#CUDA-笔记2" class="headerlink" title="CUDA 笔记2"></a>CUDA 笔记2</h1><p><strong>Reference:</strong></p><p><a href="https://face2ai.com/program-blog/#GPU%E7%BC%96%E7%A8%8B%EF%BC%88CUDA%EF%BC%89">https://face2ai.com/program-blog/#GPU%E7%BC%96%E7%A8%8B%EF%BC%88CUDA%EF%BC%89</a></p><h2 id="4-共享内存"><a href="#4-共享内存" class="headerlink" title="4 共享内存"></a>4 共享内存</h2><h3 id="4-1-共享内存概述"><a href="#4-1-共享内存概述" class="headerlink" title="4.1 共享内存概述"></a>4.1 共享内存概述</h3><p>GPU的共享内存在片上，延迟低带宽高。常用语：</p><ul><li>块内线程通信的通道</li><li>用于全局内存数据的缓存</li><li>用于转换数据来优化全局内存访问模式</li></ul><p>回顾GPU的存储结构：</p><p><img src="/2024/10/28/CUDA%20NOTE2/5-1.png" alt="5-1" width="50%"></p><p>共享内存的生命周期是整个线程块执行的过程。每个线程对于共享内存的访问如果是独立进行的，则效率是比较高的，如果会产生竞态，就要解决冲突问题。如果线程束内32个线程访问同一地址，由一个线程访问完后进行广播。</p><p>一个SM上的所有的正在执行的线程块共同使用物理的共享内存，所以共享内存也成为了活跃线程块的限制，块使用的共享内存越小，线程块级别的并行度就越高。</p><h4 id="4-1-1-共享内存分配"><a href="#4-1-1-共享内存分配" class="headerlink" title="4.1.1 共享内存分配"></a>4.1.1 共享内存分配</h4><p>声明共享内存可以在核函数内，也可以在核函数外。也可以动态声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__shared__ <span class="type">float</span> a[size_x][size_y];</span><br></pre></td></tr></table></figure><p>size_x和size_y需要在编译期确定，如果需要动态声明，需要使用extern关键字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> __shared__ <span class="type">int</span> tile[];</span><br><span class="line">kernel&lt;&lt;&lt;grid,block,isize*<span class="title function_">sizeof</span><span class="params">(<span class="type">int</span>)</span>&gt;&gt;&gt;<span class="params">(...)</span>;</span><br></pre></td></tr></table></figure><p>动态声明只支持1维数组。</p><h4 id="4-1-2-共享内存存储与访问模式"><a href="#4-1-2-共享内存存储与访问模式" class="headerlink" title="4.1.2 共享内存存储与访问模式"></a>4.1.2 共享内存存储与访问模式</h4><p>共享内存是一维地址空间。其具有特殊的形式是共享内存分为32个内存模型，称为存储体，对应线程束的32个线程，如果线程访问共享内存时访问不同的存储体，就可以在无冲突的情况下一个事务完成访问。</p><p>线程束访问共享内存有三个模式：</p><ul><li>并行访问：多地址访问多存储体</li><li>串行访问：多地址访问同一存储体</li><li>广播访问：单一地址读取单一存储体</li></ul><p>并行访问可能会有冲突，如果有小部分冲突，可以将冲突的部分分隔执行。如果完全冲突，就变成了串行访问。而广播访问相较于并行访问的带宽利用率差，延迟接近。</p><p>理想并行访问：</p><img src="/2024/10/28/CUDA%20NOTE2/5-2.png" class title="5-2"><p>不规则但不冲突访问：</p><img src="/2024/10/28/CUDA%20NOTE2/5-3.png" class title="5-3"><p>可能产生冲突的访问：如果是同一地址就通过广播解决，否则产生冲突</p><img src="/2024/10/28/CUDA%20NOTE2/5-4.png" class title="5-4"><p>一个存储体的宽度与设备计算能力有关，3.x以上的为8字节。也就是说如果32个线程束访问32个地址上的小于8字节的数据，是可以并行进行的。</p><p>4字节的存储体：</p><p><img src="/2024/10/28/CUDA%20NOTE2/5-5.png" alt="5-5" style="zoom: 50%;"></p><p>8字节的存储体：</p><p><img src="/2024/10/28/CUDA%20NOTE2/5-6.png" alt="5-6" width="50%"></p><p>无冲突的两种情况：</p><p><img src="/2024/10/28/CUDA%20NOTE2/5-7.png" alt="5-7" style="zoom:50%;"></p><p><img src="/2024/10/28/CUDA%20NOTE2/5-8.png" alt="5-8" style="zoom: 50%;"></p><p>冲突的情况：两个线程访问了一个存储体的不同地址</p><p><img src="/2024/10/28/CUDA%20NOTE2/5-9.png" alt="5-9" style="zoom:50%;"></p><p>存储体冲突会严重影响共享内存访问效率。有时可以用填充来降低冲突：</p><p>假设只有4个存储体</p><p><img src="/2024/10/28/CUDA%20NOTE2/5-11.png" alt="5-11" style="zoom:50%;"></p><p>上面的存储方式，如果声明为<strong>shared</strong> int a[5][4];就会有冲突，但是如果加入一行：</p><p><img src="/2024/10/28/CUDA%20NOTE2/5-11-1.png" alt="5-11-1" style="zoom:50%;"></p><p>只有四个存储体，要访问的数据就会错开：</p><p><img src="/2024/10/28/CUDA%20NOTE2/5-12.png" alt="5-12" style="zoom:50%;"></p><p>以下语句可以查询存储体宽度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaDeviceGetSharedMemConfig</span><span class="params">(cudaSharedMemConfig * pConfig)</span>;</span><br><span class="line"><span class="comment">//返回值</span></span><br><span class="line">cudaSharedMemBankSizeFourByte</span><br><span class="line">cudaSharedMemBankSizeEightByte</span><br><span class="line"><span class="comment">//配置存储体带宽：</span></span><br><span class="line">cudaError_t <span class="title function_">cudaDeviceSetShareMemConfig</span><span class="params">(cudaSharedMemConfig config)</span>;</span><br></pre></td></tr></table></figure><p>在不同核函数之间修改配置需要进行一次同步。存储体大小不会影响共享内存的使用，但会对性能可能有较大的影响。</p><h4 id="4-1-3-配置共享内存"><a href="#4-1-3-配置共享内存" class="headerlink" title="4.1.3 配置共享内存"></a>4.1.3 配置共享内存</h4><p>共享内存的配置有两个函数，一个是针对设备的，另一个是针对核函数的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaDeviceSetCacheConfig</span><span class="params">(cudaFuncCache cacheConfig)</span>;</span><br><span class="line">cudaError_t <span class="title function_">cudaFuncSetCacheConfig</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* func,<span class="keyword">enum</span> cudaFuncCacheca cheConfig)</span>;</span><br></pre></td></tr></table></figure><p>config有几种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cudaFuncCachePreferNone: no <span class="title function_">preference</span><span class="params">(<span class="keyword">default</span>)</span></span><br><span class="line">cudaFuncCachePreferShared: prefer 48KB shared memory and 16 KB L1 cache</span><br><span class="line">cudaFuncCachePreferL1: prefer 48KB L1 cache and 16 KB shared memory</span><br><span class="line">cudaFuncCachePreferEqual: prefer 32KB L1 cache and 32 KB shared memory</span><br></pre></td></tr></table></figure><p>如果共享内存使用多，更多的共享内存更好。如果寄存器使用更多，L1Cache越多越好。两种存储的行为是不一样的。L1通过缓存行进行数据的访问和删除。而共享内存是完全编程控制的。</p><h4 id="4-1-3-同步"><a href="#4-1-3-同步" class="headerlink" title="4.1.3 同步"></a>4.1.3 同步</h4><p>CUDA采用宽松内存模型，即内存访问不是一定按照程序中的顺序执行的。因此必须进行同步。显示的同步是__sycthreads()调用。保证同步后所有的全局内存，共享内存都是所有线程可见的。</p><p>如果只是需要内存同步，可以用内存栅栏来同步。内存栅栏有三个维度：块，网格，系统。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __threadfence_block();</span><br><span class="line"><span class="type">void</span> __threadfence();<span class="comment">//网格</span></span><br><span class="line"><span class="type">void</span> __threadfence_system();</span><br></pre></td></tr></table></figure><p>这一节仅仅是一个概述，因此就到此结束了。</p><h3 id="4-2-共享内存布局"><a href="#4-2-共享内存布局" class="headerlink" title="4.2 共享内存布局"></a>4.2 共享内存布局</h3><p>本节重点要解决设计核函数时的两个问题：</p><ul><li>跨内存存储体映射数据元素</li><li>从线程索引到共享内存偏移的映射</li></ul><p>对于一个二维的共享内存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 32</span></span><br><span class="line">...</span><br><span class="line">__shared__ <span class="type">int</span> x[N][N];</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>习惯的访问方式可能是这样的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 32</span></span><br><span class="line">...</span><br><span class="line">__shared__ <span class="type">int</span> x[N][N];</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> a=x[threadIdx.y][threadIdx.x];</span><br></pre></td></tr></table></figure></p><p>这样的方式实际上也是最高效的，因为一个线程束中的线程是线程块中按行优先划分的，即<strong>线程束中的threadIdx.x是连续的</strong>。因此这样的访问方式，对应访问的也是共享内存的一行。并且每个线程访问一个存储体：(红色的是以上这种方式的访问模式)</p><p><img src="/2024/10/28/CUDA%20NOTE2/5-12-17302058018561.png" alt="5-12" style="zoom:67%;"></p><p>因此数据要<strong>优先行主序访问，和线程束的线程对应</strong>。</p><h4 id="4-2-1-Example1"><a href="#4-2-1-Example1" class="headerlink" title="4.2.1 Example1"></a>4.2.1 Example1</h4><p>用一个简单的程序读写共享内存，这个程序的核函数只做两个操作，将线程索引值写入二维共享内存，再按照行主序读取值存入全局内存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BLOCKDIM = <span class="number">32</span>*<span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">__global__ <span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> *out)</span>&#123;</span><br><span class="line">    __shared__ <span class="type">int</span> tile[<span class="number">32</span>][<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span> idx = threadIdx.y*blockDim.x + threadIdx.x;</span><br><span class="line">    tile[threadIdx.y][threadIdx.x] = idx;</span><br><span class="line">    __syncthreads();</span><br><span class="line">    out[idx] = tile[threadIdx.y][threadIdx.x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> *glob_h, *glob_d;</span><br><span class="line">    <span class="type">int</span> msize = <span class="keyword">sizeof</span>(<span class="type">int</span>)*BLOCKDIM*BLOCKDIM;</span><br><span class="line">    glob_h = (<span class="type">int</span> *)<span class="built_in">malloc</span>(msize);</span><br><span class="line">    cudaMalloc(&amp;glob_d, msize);</span><br><span class="line">    dim3 <span class="title function_">block</span><span class="params">(<span class="number">32</span>,<span class="number">32</span>)</span>;</span><br><span class="line">    dim3 <span class="title function_">grid</span><span class="params">((BLOCKDIM<span class="number">-1</span>)/block.x+<span class="number">1</span>, (BLOCKDIM<span class="number">-1</span>)/block.y+<span class="number">1</span>)</span>;</span><br><span class="line">    func&lt;&lt;&lt;grid,block&gt;&gt;&gt;(glob_d);</span><br><span class="line">    cudaMemcpy(glob_h, glob_d, msize,cudaMemcpyDeviceToHost);</span><br><span class="line">    cudaFree(glob_d);</span><br><span class="line">    <span class="built_in">free</span>(glob_h);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/10/28/CUDA%20NOTE2/image-20241029210647380.png" alt="image-20241029210647380" style="zoom: 67%;"></p><p>如果按列主序访问，则：</p><p><img src="/2024/10/28/CUDA%20NOTE2/image-20241029210818538.png" alt="image-20241029210818538" style="zoom:67%;"></p><p>所有的访问都会触发bank conflict。此时的核函数运行时间是行主序的6.3倍。</p><p>还可以尝试动态分配共享内存，和静态分配只是方法上不一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__global__ <span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> *out)</span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> __shared__ <span class="type">int</span> tile[];</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    func&lt;&lt;&lt;grid,block,<span class="number">32</span>*<span class="number">32</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>)&gt;&gt;&gt;(glob_d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文已经提到过了，可以通过填充使需要引用的数据交错来消除访问冲突，只需要将第二维度添加一个填充，就可以观察到bank conflicts完全消失。动态分配的共享内存填充时需要注意索引，因为数据是一维存储的。</p><p>在上面的例子，数据是正方形且和block大小一致，如果是矩形，并且读和写的时候主序不一致。就要考虑索引问题，需要先将索引转换成线性，再重新计算行和列的坐标。这里跳过了这部分内容，待有需要时再仔细考虑。</p><h3 id="4-3-减少全局内存访问"><a href="#4-3-减少全局内存访问" class="headerlink" title="4.3 减少全局内存访问"></a>4.3 减少全局内存访问</h3><p>在CUDA执行模型一章节已经介绍过避免分支分化和循环展开等方式的核函数优化方式。本节从减少全局内存访问的角度优化核函数：</p><ul><li>重新安排数据访问模式避免线程束分化</li><li>展开循环以保证有足够的操作使指令和内存带宽饱和</li></ul><p>这一节使用了之前的完全展开的规约计算为例。完全展开的规约计算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">__global__ <span class="type">void</span> <span class="title function_">reduceGmem</span><span class="params">(<span class="type">int</span> * g_idata,<span class="type">int</span> * g_odata,<span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//set thread ID</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tid = threadIdx.x;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> idx = blockDim.x*blockIdx.x+threadIdx.x;</span><br><span class="line"><span class="comment">//boundary check</span></span><br><span class="line"><span class="keyword">if</span> (tid &gt;= n) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//convert global data pointer to the</span></span><br><span class="line"><span class="type">int</span> *idata = g_idata + blockIdx.x*blockDim.x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in-place reduction in global memory</span></span><br><span class="line"><span class="keyword">if</span>(blockDim.x&gt;=<span class="number">1024</span> &amp;&amp; tid &lt;<span class="number">512</span>)</span><br><span class="line">idata[tid]+=idata[tid+<span class="number">512</span>];</span><br><span class="line">__syncthreads();</span><br><span class="line"><span class="keyword">if</span>(blockDim.x&gt;=<span class="number">512</span> &amp;&amp; tid &lt;<span class="number">256</span>)</span><br><span class="line">idata[tid]+=idata[tid+<span class="number">256</span>];</span><br><span class="line">__syncthreads();</span><br><span class="line"><span class="keyword">if</span>(blockDim.x&gt;=<span class="number">256</span> &amp;&amp; tid &lt;<span class="number">128</span>)</span><br><span class="line">idata[tid]+=idata[tid+<span class="number">128</span>];</span><br><span class="line">__syncthreads();</span><br><span class="line"><span class="keyword">if</span>(blockDim.x&gt;=<span class="number">128</span> &amp;&amp; tid &lt;<span class="number">64</span>)</span><br><span class="line">idata[tid]+=idata[tid+<span class="number">64</span>];</span><br><span class="line">__syncthreads();</span><br><span class="line"><span class="comment">//write result for this block to global mem</span></span><br><span class="line"><span class="keyword">if</span>(tid&lt;<span class="number">32</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> *vmem = idata;</span><br><span class="line">vmem[tid]+=vmem[tid+<span class="number">32</span>];</span><br><span class="line">vmem[tid]+=vmem[tid+<span class="number">16</span>];</span><br><span class="line">vmem[tid]+=vmem[tid+<span class="number">8</span>];</span><br><span class="line">vmem[tid]+=vmem[tid+<span class="number">4</span>];</span><br><span class="line">vmem[tid]+=vmem[tid+<span class="number">2</span>];</span><br><span class="line">vmem[tid]+=vmem[tid+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tid == <span class="number">0</span>)</span><br><span class="line">g_odata[blockIdx.x] = idata[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>idata是全局内存，并且通过同步和volatile保证内存写入的有序性，但是这也导致了每次写入都必须写回到全局内存，而不能使用缓存行。将idata的访问替换为对共享内存的访问：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">__global__ <span class="type">void</span> <span class="title function_">reduceSmem</span><span class="params">(<span class="type">int</span> * g_idata,<span class="type">int</span> * g_odata,<span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//set thread ID</span></span><br><span class="line">    __shared__ <span class="type">int</span> smem[DIM];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tid = threadIdx.x;</span><br><span class="line"><span class="comment">//unsigned int idx = blockDim.x*blockIdx.x+threadIdx.x;</span></span><br><span class="line"><span class="comment">//boundary check</span></span><br><span class="line"><span class="keyword">if</span> (tid &gt;= n) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//convert global data pointer to the</span></span><br><span class="line"><span class="type">int</span> *idata = g_idata + blockIdx.x*blockDim.x;</span><br><span class="line"></span><br><span class="line">    smem[tid]=idata[tid];</span><br><span class="line">__syncthreads();</span><br><span class="line"><span class="comment">//in-place reduction in global memory</span></span><br><span class="line"><span class="keyword">if</span>(blockDim.x&gt;=<span class="number">1024</span> &amp;&amp; tid &lt;<span class="number">512</span>)</span><br><span class="line">smem[tid]+=smem[tid+<span class="number">512</span>];</span><br><span class="line">__syncthreads();</span><br><span class="line"><span class="keyword">if</span>(blockDim.x&gt;=<span class="number">512</span> &amp;&amp; tid &lt;<span class="number">256</span>)</span><br><span class="line">smem[tid]+=smem[tid+<span class="number">256</span>];</span><br><span class="line">__syncthreads();</span><br><span class="line"><span class="keyword">if</span>(blockDim.x&gt;=<span class="number">256</span> &amp;&amp; tid &lt;<span class="number">128</span>)</span><br><span class="line">smem[tid]+=smem[tid+<span class="number">128</span>];</span><br><span class="line">__syncthreads();</span><br><span class="line"><span class="keyword">if</span>(blockDim.x&gt;=<span class="number">128</span> &amp;&amp; tid &lt;<span class="number">64</span>)</span><br><span class="line">smem[tid]+=smem[tid+<span class="number">64</span>];</span><br><span class="line">__syncthreads();</span><br><span class="line"><span class="comment">//write result for this block to global mem</span></span><br><span class="line"><span class="keyword">if</span>(tid&lt;<span class="number">32</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> *vsmem = smem;</span><br><span class="line">vsmem[tid]+=vsmem[tid+<span class="number">32</span>];</span><br><span class="line">vsmem[tid]+=vsmem[tid+<span class="number">16</span>];</span><br><span class="line">vsmem[tid]+=vsmem[tid+<span class="number">8</span>];</span><br><span class="line">vsmem[tid]+=vsmem[tid+<span class="number">4</span>];</span><br><span class="line">vsmem[tid]+=vsmem[tid+<span class="number">2</span>];</span><br><span class="line">vsmem[tid]+=vsmem[tid+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tid == <span class="number">0</span>)</span><br><span class="line">g_odata[blockIdx.x] = smem[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了将idata替换为共享内存，没有其他变化。执行后性能会有显著提升。由于时间有限，本节没有动手实验，直接搬了参考博客的代码。再进一步结合循环展开，充分利用带宽，性能还会有更大的提升。</p><h3 id="4-4-合并全局内存访问"><a href="#4-4-合并全局内存访问" class="headerlink" title="4.4 合并全局内存访问"></a>4.4 合并全局内存访问</h3><p>在之前的矩阵转置的例子，读取和写入总有一个是不连续的，存在非合并的访问。本节将学习如何使用共享内存合并访问。</p><p>为了避免交叉访问，可以用二维共享内存缓存矩阵数据，然后从共享内存中读取列存储到全局内存，因为共享内存按列读取的延迟更低，不过会遇到上述的冲突问题。这样读取是按照行进行的，写入也是按行进行的，原来的对全局内存的不连续读转换为了对共享内存的按列读取。</p><p><img src="/2024/10/28/CUDA%20NOTE2/re-5.png" alt="re-5" style="zoom:50%;"></p><p>由于矩阵块可能是非方形，所以需要对索引重处理，具体而言，最开始从全局内存读取时线程是在行上连续的，因此可以用threadIdx.x作为读取的列号，连续读取行；而从共享内存读取列时，由于blockDim.y和blockDim.x可以不相等，不能用threadIdx.x作为行号了，要重新计算一个行号和列号，所以先将原来的线程线性ID算出来，再根据块的维度重新分配读取的数据索引。</p><p><img src="/2024/10/28/CUDA%20NOTE2/image-20241031154324228.png" alt="image-20241031154324228" style="zoom:33%;"></p><p>对于原矩阵中的一个数据点，其ix为threadIdx.x+blockDim.x*blockIdx.x，iy=threadIdx.y+blockDim.y*blockIdx.y。转置之后，其行号列号为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bidx,irow,icol;</span><br><span class="line">bidx=threadIdx.y*blockDim.x+threadIdx.x;</span><br><span class="line">irow=bidx/blockDim.y;</span><br><span class="line">icol=bidx%blockDim.y;</span><br><span class="line"></span><br><span class="line">ix=blockIdx.y*blockDim.y+icol;</span><br><span class="line">iy=blockIdx.x*blockDim.x+irow;</span><br></pre></td></tr></table></figure><p>bidx是线程在块内的线性ID，所以借助共享内存转置的核函数为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">__global__ <span class="type">void</span> <span class="title function_">transformSmem</span><span class="params">(<span class="type">float</span> * in,<span class="type">float</span>* out,<span class="type">int</span> nx,<span class="type">int</span> ny)</span></span><br><span class="line">&#123;</span><br><span class="line">__shared__ <span class="type">float</span> tile[BDIMY][BDIMX];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ix,iy,transform_in_idx,transform_out_idx;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">ix=threadIdx.x+blockDim.x*blockIdx.x;</span><br><span class="line">    iy=threadIdx.y+blockDim.y*blockIdx.y;</span><br><span class="line">transform_in_idx=iy*nx+ix;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bidx,irow,icol;</span><br><span class="line">bidx=threadIdx.y*blockDim.x+threadIdx.x;</span><br><span class="line">irow=bidx/blockDim.y;</span><br><span class="line">icol=bidx%blockDim.y;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">ix=blockIdx.y*blockDim.y+icol;</span><br><span class="line">iy=blockIdx.x*blockDim.x+irow;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">transform_out_idx=iy*ny+ix;</span><br><span class="line"><span class="keyword">if</span>(ix&lt;nx&amp;&amp; iy&lt;ny)</span><br><span class="line">&#123;</span><br><span class="line">tile[threadIdx.y][threadIdx.x]=in[transform_in_idx];</span><br><span class="line">__syncthreads();</span><br><span class="line">out[transform_out_idx]=tile[icol][irow];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不过实际运行结果，核函数的执行时间(3.43ms)比连续读不连续写快(3.8ms)，比连续写不连续读还是更慢(2.65ms)，由于块设置为了32*32，产生了冲突问题。</p><img src="/2024/10/28/CUDA%20NOTE2/image-20241031155512899.png" class title="image-20241031155512899"><p>因此尝试做填充，只用了一个元素的填充就完全消除了冲突，核函数执行时间为2.14。</p><p>32*32不连续读，连续写入：</p><img src="/2024/10/28/CUDA%20NOTE2/image-20241031165611136.png" class title="image-20241031165611136"><p>32*32借助共享内存连续读连续写入</p><img src="/2024/10/28/CUDA%20NOTE2/image-20241031160054074.png" class title="image-20241031160054074"><p>由于之前尝试过，不连续读，连续写入在块比较小的时候，读取的缓存行内数据可以很快重用，所以可以减小块的大小以充分利用缓存，因此采用了8x32的块，保持写入的连续性，使整体块小一些，核函数执行时间只有1.56ms，现在对于使用共享内存的方法，也调整块的大小。在8x32得到了最佳性能1.57ms。其实在那一节已经通过nsys看过带宽已经达到理论峰值，无法提升，所以本章节使用共享内存并不会超过当时已经得出的带宽。但是8x32的共享内存版本存在bank conflicts，但没找到合适的填充完全消除。</p><h3 id="4-5-常量内存"><a href="#4-5-常量内存" class="headerlink" title="4.5 常量内存"></a>4.5 常量内存</h3><p>常量内存是核函数只读的，只有主机可以写常量内存。核函数通过将DRAM的常量内存缓存到片上的常量缓存来读取。对于常量内存，最佳的访问方式是线程束访问同一个位置，读取成本和线程束中线程读取常量内存的地址个数呈线性。</p><p>常量内存的声明前缀如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__constant</span><br></pre></td></tr></table></figure><p>初始化常量也就是将常量读取到片上通过以下函数完成：kind的默认参数是传输到设备。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaMemcpyToSymbol</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *symbol, <span class="type">const</span> <span class="type">void</span> * src,  <span class="type">size_t</span> count, <span class="type">size_t</span> offset, cudaMemcpyKind kind)</span></span><br></pre></td></tr></table></figure><p>本节以一维stencil计算为例，使用常量内存实现一维stencil。</p><img src="/2024/10/28/CUDA%20NOTE2/1-1.png" class title="1-1"><p>计算的值为函数的导数，使用差分近似。</p><script type="math/tex; mode=display">f'(x) = \sum_{i=1}^{4}c_i(f(x+i*h)-f(x-i*h))</script><p>计算时c_i是固定的，因此可以存储到常量内存，便于线程束读取。而每个输入数据都会被使用8次，因此使用共享内存缓存输入数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">__global__ <span class="type">void</span> <span class="title function_">stencilKernel</span><span class="params">(<span class="type">float</span> * in,<span class="type">float</span> * out,<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//开辟包含两端padding的共享内存</span></span><br><span class="line">    __shared__ <span class="type">float</span> smem[<span class="number">32</span>+<span class="number">2</span>*SIZE+<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//线程全局id</span></span><br><span class="line">    <span class="type">int</span> idx=threadIdx.x+blockDim.x*blockIdx.x;</span><br><span class="line">    <span class="comment">//线程在共享内存中的数据id 并将数据复制到共享内存</span></span><br><span class="line">    <span class="type">int</span> sidx=threadIdx.x+SIZE;</span><br><span class="line">    <span class="keyword">if</span>(idx&gt;=N) <span class="keyword">return</span>;</span><br><span class="line">    smem[sidx]=in[idx];</span><br><span class="line">    <span class="comment">//确认是否可以填充</span></span><br><span class="line">    <span class="keyword">if</span> (threadIdx.x&lt;SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(idx&gt;SIZE)    <span class="comment">//有左端填充</span></span><br><span class="line">            smem[sidx-SIZE]=in[idx-SIZE];</span><br><span class="line">        <span class="keyword">if</span>(idx&lt;N<span class="number">-32</span>)<span class="comment">//有右端填充</span></span><br><span class="line">            smem[sidx+<span class="number">32</span>]=in[idx+<span class="number">32</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    __syncthreads();</span><br><span class="line">    <span class="comment">//无法计算的位置</span></span><br><span class="line">    <span class="keyword">if</span> (idx&lt;SIZE||idx&gt;=N-SIZE)&#123;</span><br><span class="line">        out[idx] = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//stencil</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> unroll</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=SIZE;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp+=coef[i<span class="number">-1</span>]*(smem[sidx+i]-smem[sidx-i]);</span><br><span class="line">    &#125;</span><br><span class="line">    out[idx]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>11.78us。如果不使用共享内存，而是使用L1缓存来缓存数据为11.3us，这种情况下两种内存是差不多的。</p><p>除了常量内存，还可以使用只读缓存。使用只读缓存有两种方法，需要传入主机内存的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__global__ <span class="type">void</span> <span class="title function_">kernel</span><span class="params">(<span class="type">float</span>* output, <span class="type">float</span>* input)</span> &#123;</span><br><span class="line">...</span><br><span class="line">output[idx] += __ldg(&amp;input[idx]);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel</span><span class="params">(<span class="type">float</span>* output, <span class="type">const</span> <span class="type">float</span>* __restrict__ input)</span> &#123;</span><br><span class="line">...</span><br><span class="line">output[idx] += input[idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量缓存的优势是统一读取，而只读缓存适合分散读取。这两部分对于核函数都是只读的。需要视情况使用。使用方式比较简单，略过实现了。</p><h3 id="4-6-线程束shuffle指令"><a href="#4-6-线程束shuffle指令" class="headerlink" title="4.6 线程束shuffle指令"></a>4.6 线程束shuffle指令</h3><p>线程束shuffle指令是CUDA提供的特殊机制，允许线程束内两个线程互相访问对方的寄存器。由于寄存器在硬件上是临近的，直接交换数据能够提供比任何其他形式内存更高效的数据访问。</p><p>shuffle指令是基于线程束提出的。每个线程都可以通过threadIdx.x确认线程束的ID和线程束内索引。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> LaneID=threadIdx.x%<span class="number">32</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> warpID=threadIdx.x/<span class="number">32</span>;</span><br></pre></td></tr></table></figure><h4 id="4-6-1-线程束洗牌指令的不同形式"><a href="#4-6-1-线程束洗牌指令的不同形式" class="headerlink" title="4.6.1 线程束洗牌指令的不同形式"></a>4.6.1 线程束洗牌指令的不同形式</h4><p>线程束洗牌指令有两组，分别用于整型和浮点。</p><p>线程束内交换整型变量的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __shfl(<span class="type">int</span> var,<span class="type">int</span> srcLane,<span class="type">int</span> width=warpSize);</span><br></pre></td></tr></table></figure><p>var就是需要得到的变量名。而srclane和width则用于确认获取数据的线程位置。默认的width是线程束大小，当width为默认值，srclane就是束内线程。</p><img src="/2024/10/28/CUDA%20NOTE2/1-1-17307030748261.png" class title="1-1"><p>另一个函数调用时获取当前束内编号-delta编号线程的var值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __shfl_up(<span class="type">int</span> var,<span class="type">unsigned</span> <span class="type">int</span> delta,<span class="type">int</span> with=warpSize);</span><br></pre></td></tr></table></figure><img src="/2024/10/28/CUDA%20NOTE2/1-2.png" class title="1-2"><p>还有一个对称的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __shfl_down(<span class="type">int</span> var,<span class="type">unsigned</span> <span class="type">int</span> delta,<span class="type">int</span> with=warpSize);</span><br></pre></td></tr></table></figure><img src="/2024/10/28/CUDA%20NOTE2/1-3.png" class title="1-3"><p>最后一个是一个比较特别的指令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __shfl_xor(<span class="type">int</span> var,<span class="type">int</span> laneMask,<span class="type">int</span> with=warpSize);</span><br></pre></td></tr></table></figure><p>lanemask与当前线程索引得到的就是目标线程的编号。</p><img src="/2024/10/28/CUDA%20NOTE2/1-4.png" class title="1-4"><p>浮点数的函数版本是上述函数的重载，只需要将var传入浮点类型。</p><h4 id="4-6-2-使用shuffle指令进行数据交换"><a href="#4-6-2-使用shuffle指令进行数据交换" class="headerlink" title="4.6.2 使用shuffle指令进行数据交换"></a>4.6.2 使用shuffle指令进行数据交换</h4><p>对于前几个常规的shuffle指令，使用都比较简单，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__global__ <span class="type">void</span> <span class="title function_">test_shfl_broadcast</span><span class="params">(<span class="type">int</span> *in,<span class="type">int</span>*out,<span class="type">int</span> <span class="type">const</span> srcLans)</span>&#123;</span><br><span class="line">    <span class="type">int</span> value=in[threadIdx.x];</span><br><span class="line">    value=__shfl(value,srcLans);</span><br><span class="line">    out[threadIdx.x]=value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__shfl_down和__shfl_up的使用也是一样的。另外，这两个调用超出范围的部分会保持原值，而shfl调用是会对width取模的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__global__ <span class="type">void</span> <span class="title function_">test_shfl_wrap</span><span class="params">(<span class="type">int</span> *in,<span class="type">int</span>*out,<span class="type">int</span> <span class="type">const</span> offset)</span>&#123;</span><br><span class="line">    <span class="type">int</span> value=in[threadIdx.x];</span><br><span class="line">    value=__shfl(value,threadIdx.x+offset);</span><br><span class="line">    out[threadIdx.x]=value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2024/10/28/CUDA%20NOTE2/image-20241104162002630.png" class title="image-20241104162002630"><p>重点需要关注__shfl_xor，该操作足够灵活以组合出任何变换。先假设mask是1，这种情况下，最低位会翻转，因此就是完成FIGURE-5-23的蝶式变换。要实现指定的交换，需要仔细考虑mask的选取。因此接下来使用规约为例，使用__shfl_xor实现规约。</p><h4 id="4-6-3-使用线程束洗牌指令的并行规约"><a href="#4-6-3-使用线程束洗牌指令的并行规约" class="headerlink" title="4.6.3 使用线程束洗牌指令的并行规约"></a>4.6.3 使用线程束洗牌指令的并行规约</h4><p>在共享内存一节已经实现过用共享内存来传递线程规约的结果，本节使用shuffle指令来传递线程规约的结果，从而进一步提升效率，避免任何内存写入。</p><p>上面的例子只是简单交换了相邻的两个数据，shuffle的用法还有多种。最简单的来说，设mask是2的幂次方，那么交换的就是(lane + mask)%lane，因为mask位会翻转，其他位不变。对于规约，需要从16开始交换，即0和16线程交换值相加，依次类推，32个线程束内数据的规约如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__inline__ __device__ <span class="type">int</span> <span class="title function_">warpReduce</span><span class="params">(<span class="type">int</span> localSum)</span></span><br><span class="line">&#123;</span><br><span class="line">    localSum += __shfl_xor(localSum, <span class="number">16</span>);</span><br><span class="line">    localSum += __shfl_xor(localSum, <span class="number">8</span>);</span><br><span class="line">    localSum += __shfl_xor(localSum, <span class="number">4</span>);</span><br><span class="line">    localSum += __shfl_xor(localSum, <span class="number">2</span>);</span><br><span class="line">    localSum += __shfl_xor(localSum, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> localSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之前不同的是，每个线程都得到了规约的结果。线程束规约之后，再对线程束的结果进行规约就可以得到整个线程块的结果。(由于线程块的大小取了1024，下面的下标计算是比较简陋的)。以下是包含循环展开的使用shuffle指令的reduce，N=1 &lt;&lt; 24所以边界没有仔细处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">__global__ <span class="type">void</span> <span class="title function_">reductShuffle</span><span class="params">(<span class="type">int</span> *in, <span class="type">int</span> *out, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//set thread ID</span></span><br><span class="line">    __shared__ <span class="type">int</span> smem[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx = blockDim.x*blockIdx.x*blockPerthread+threadIdx.x;</span><br><span class="line">    <span class="keyword">if</span>(idx+(blockPerthread<span class="number">-1</span>) * blockDim.x &gt;= size) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> tmp0;</span><br><span class="line">    tmp0 = in[idx];</span><br><span class="line">    tmp0 += in[idx + blockDim.x];</span><br><span class="line">    tmp0 += in[idx + blockDim.x * <span class="number">2</span>];</span><br><span class="line">    tmp0 += in[idx + blockDim.x * <span class="number">3</span>];</span><br><span class="line">    tmp0 += in[idx + blockDim.x * <span class="number">4</span>];</span><br><span class="line">    tmp0 += in[idx + blockDim.x * <span class="number">5</span>];</span><br><span class="line">    tmp0 += in[idx + blockDim.x * <span class="number">6</span>];</span><br><span class="line">    tmp0 += in[idx + blockDim.x * <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mySum=tmp0;</span><br><span class="line"><span class="type">int</span> laneIdx=threadIdx.x%warpSize;</span><br><span class="line"><span class="type">int</span> warpIdx=threadIdx.x/warpSize;</span><br><span class="line"></span><br><span class="line">mySum=warpReduce(mySum);</span><br><span class="line"><span class="keyword">if</span>(laneIdx==<span class="number">0</span>)</span><br><span class="line">smem[warpIdx]=mySum;</span><br><span class="line">__syncthreads();</span><br><span class="line"></span><br><span class="line">mySum=(threadIdx.x&lt;<span class="number">1024</span>/warpSize)?smem[laneIdx]:<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(warpIdx==<span class="number">0</span>)</span><br><span class="line">mySum=warpReduce(mySum);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(threadIdx.x==<span class="number">0</span>)</span><br><span class="line">out[blockIdx.x]=mySum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的核函数时间如下：</p><div class="table-container"><table><thead><tr><th>Version</th><th>T</th></tr></thead><tbody><tr><td>基本规约</td><td>5.61ms</td></tr><tr><td>交错归约</td><td>2.77ms</td></tr><tr><td>交错归约+循环展开</td><td>510us</td></tr><tr><td>shuffle+循环展开</td><td>370us</td></tr></tbody></table></div><p>从性能指标上来看，最大的提升是memory throughput，从交错循环+循环展开的141.53Gbyte/s提升到了181.53，因为块内规约的过程中没有任何访存操作，只有规约前累积8个块的数据，而这部分读取是连续的，因此整体访存效率很高，比之前的转置的带宽以及stream测试的带宽还要更高。</p><h2 id="5-流和并发"><a href="#5-流和并发" class="headerlink" title="5 流和并发"></a>5 流和并发</h2><p>本章主要介绍流和事件的概念，理解网格级并发，核函数执行与CPU执行/数据传输的OVERLAP等内容。</p><h3 id="5-1-流和事件概述"><a href="#5-1-流和事件概述" class="headerlink" title="5.1 流和事件概述"></a>5.1 流和事件概述</h3><h4 id="5-1-1-流"><a href="#5-1-1-流" class="headerlink" title="5.1.1 流"></a>5.1.1 流</h4><p>使用CUDA求解问题的操作步骤包含主机端设备主存分配，数据传输，核函数启动，复制数据回主机。CUDA流能封装这些操作，并保持操作顺序。一个流中的操作是严格有序的，但不同流之间没有限制，多个流同时启动多个内核，就能实现网格级别并行，并且同时CPU还可以执行其他指令。</p><p>流在CUDA的API调用可以实现流水线和双缓冲。CUDA的API除了之前的同步接口，也有异步的，保证主机可以执行其他指令，执行多个流。不过流的并行还是受限于设备，只能提高设备的利用率，设备被占用时，其他流也只能等待。</p><p>之前的CUDA操作其实也是在流中运行的，只是隐式执行。流可以据此分为：</p><ul><li>隐式：空流</li><li>显式：非空流</li></ul><p>如果没有特别声明一个流，所有操作都是在默认空流中完成的。空流是无法管理的。所以控制流时必须使用非空流，基于流的异步内核支持以下类型的并发：</p><ul><li>主机和设备计算</li><li>主机计算和主机设备数据传输</li><li>主机设备传输和设备计算</li><li>多个设备计算</li></ul><p>异步执行自然有异步的函数，例如数据传输：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaMemcpyAsync</span><span class="params">(<span class="type">void</span>* dst, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> count,cudaMemcpyKind kind, cudaStream_t stream = <span class="number">0</span>)</span>;</span><br></pre></td></tr></table></figure><p>最后一个参数就是流，流的相关接口如下，destroy会等流执行完毕后才回收资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cudaStream_t a;</span><br><span class="line">cudaError_t <span class="title function_">cudaStreamCreate</span><span class="params">(cudaStream_t* pStream)</span>;</span><br><span class="line">cudaError_t <span class="title function_">cudaStreamDestroy</span><span class="params">(cudaStream_t stream)</span>;</span><br></pre></td></tr></table></figure><p><strong>执行异步数据传输时，主机内存必须是固定的。</strong>在全局内存一章已经说明了，主机内存可能随时移动，为了保证传输时内存是非分页的，需要使用固定内存分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaMallocHost</span><span class="params">(<span class="type">void</span> **ptr, <span class="type">size_t</span> size)</span>;</span><br><span class="line">cudaError_t <span class="title function_">cudaHostAlloc</span><span class="params">(<span class="type">void</span> **pHost, <span class="type">size_t</span> size, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><p>非空流执行内核时需要加入流：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel_name&lt;&lt;&lt;grid, block, sharedMemSize, stream&gt;&gt;&gt;(argument <span class="built_in">list</span>);</span><br></pre></td></tr></table></figure><p>在流的执行过程中，可以查询流的执行状态：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaStreamSynchronize</span><span class="params">(cudaStream_t stream)</span>;</span><br><span class="line">cudaError_t <span class="title function_">cudaStreamQuery</span><span class="params">(cudaStream_t stream)</span>;</span><br></pre></td></tr></table></figure></p><p>Sychronize会阻塞主机到流完成，而Query则会立刻返回，如果流执行结束会返回cudaSuccess，否则返回cudaErrorNotReady。</p><p>下面是常见的多流执行的模式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nStreams; i++) &#123;</span><br><span class="line">    <span class="type">int</span> offset = i * bytesPerStream;</span><br><span class="line">    cudaMemcpyAsync(&amp;d_a[offset], &amp;a[offset], bytePerStream, streams[i]);</span><br><span class="line">    kernel&lt;&lt;grid, block, <span class="number">0</span>, streams[i]&gt;&gt;(&amp;d_a[offset]);</span><br><span class="line">    cudaMemcpyAsync(&amp;a[offset], &amp;d_a[offset], bytesPerStream, streams[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nStreams; i++) &#123;</span><br><span class="line">    cudaStreamSynchronize(streams[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2024/10/28/CUDA%20NOTE2/6-1.png" class title="6-1"><h4 id="5-1-2-流调度"><a href="#5-1-2-流调度" class="headerlink" title="5.1.2 流调度"></a>5.1.2 流调度</h4><p>在Fermi架构上所有流都是在单一硬件上串行执行的。当要执行某个网格的时候CUDA会检测任务依赖关系，如果其依赖于其他结果，那么要等结果出来后才能继续执行。单一流水线可能会导致虚假依赖关系：</p><img src="/2024/10/28/CUDA%20NOTE2/6-2.png" class title="6-2"><p>这里只有红圈内部的操作是真正并行的，因为A执行时因为B依赖于A队列被阻塞，B执行时也是，只有到C时才发现可以并行执行P，然而事实上P和A B之间也没有依赖，可以在更早的时间并行进行。</p><p>解决上述虚假依赖的方式是建立多个工作队列。<strong>Hyper-Q</strong>技术就是用32个硬件队列同时执行多个流，最大化并发：</p><img src="/2024/10/28/CUDA%20NOTE2/6-3.png" class title="6-3"><h4 id="5-1-3-流的优先级"><a href="#5-1-3-流的优先级" class="headerlink" title="5.1.3 流的优先级"></a>5.1.3 流的优先级</h4><p>3.5以上的设备可以给流设定优先级，数值上更小的核函数先执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaStreamCreateWithPriority</span><span class="params">(cudaStream_t* pStream, <span class="type">unsigned</span> <span class="type">int</span> flags,<span class="type">int</span> priority)</span>;   <span class="comment">//创建有优先级的流</span></span><br><span class="line">cudaError_t <span class="title function_">cudaDeviceGetStreamPriorityRange</span><span class="params">(<span class="type">int</span> *leastPriority, <span class="type">int</span> *greatestPriority)</span>;<span class="comment">//查询优先级</span></span><br></pre></td></tr></table></figure><h4 id="5-1-4-事件"><a href="#5-1-4-事件" class="headerlink" title="5.1.4 事件"></a>5.1.4 事件</h4><p>事件用于同步流的执行，检查和记录流的进度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cudaEvent_t event;</span><br><span class="line">cudaError_t <span class="title function_">cudaEventCreate</span><span class="params">(cudaEvent_t* event)</span>;</span><br><span class="line">cudaError_t <span class="title function_">cudaEventDestroy</span><span class="params">(cudaEvent_t event)</span>;</span><br></pre></td></tr></table></figure><p>主要用途之一是记录事件之间的时间间隔。事件通过下面指令添加到CUDA流：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaEventRecord</span><span class="params">(cudaEvent_t event, cudaStream_t stream = <span class="number">0</span>)</span>;</span><br><span class="line">cudaError_t <span class="title function_">cudaEventElapsedTime</span><span class="params">(<span class="type">float</span>* ms, cudaEvent_t start, cudaEvent_t stop)</span>;</span><br></pre></td></tr></table></figure><p>可以等待或查询事件完成状态：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaEventSynchronize</span><span class="params">(cudaEvent_t event)</span>;</span><br><span class="line">cudaError_t <span class="title function_">cudaEventQuery</span><span class="params">(cudaEvent_t event)</span>;</span><br></pre></td></tr></table></figure></p><h4 id="5-1-5-流同步"><a href="#5-1-5-流同步" class="headerlink" title="5.1.5 流同步"></a>5.1.5 流同步</h4><p>既然流可以并行执行，也必然可以进行同步。以处理通信，避免竞争等。非空流对于所有CPU操作都是非阻塞的，之前已经提到了流的两种分类：</p><ul><li>异步流（非空流）</li><li>同步流（空流/默认流）</li></ul><p>显式声明的流都是异步流，异步流不会阻塞主机。但非空流并不都是非阻塞的。也可以分为阻塞流和非阻塞流。果一个非空流被声明为非阻塞的，那么不存在任何阻塞情况，如果声明为阻塞流，则会被空流阻塞。接下来详细说明这两种流。</p><p>阻塞流会被空流阻塞，例如下面的三个流：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kernel_1&lt;&lt;&lt;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, stream_1&gt;&gt;&gt;();</span><br><span class="line">kernel_2&lt;&lt;&lt;<span class="number">1</span>, <span class="number">1</span>&gt;&gt;&gt;();</span><br><span class="line">kernel_3&lt;&lt;&lt;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, stream_2&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure><p>空流会等待stream1，stream2会等待空流，但是对于主机来说三个核都是异步的。默认创建的流是阻塞的，非阻塞流用以下函数接口创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaStreamCreateWithFlags</span><span class="params">(cudaStream_t* pStream, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="comment">//两种flag</span></span><br><span class="line">cudaStreamDefault;<span class="comment">// 默认阻塞流</span></span><br><span class="line">cudaStreamNonBlocking: <span class="comment">//非阻塞流，对空流的阻塞行为失效。</span></span><br></pre></td></tr></table></figure><p>之前已经有cudaMemcpy和cudaDeviceSynchronize等进行同步。CUDA还可以通过事件实现跨流同步：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaEventSynchronize</span><span class="params">(cudaEvent_t event)</span>;</span><br><span class="line">cudaError_t <span class="title function_">cudaEventQuery</span><span class="params">(cudaEvent_t event)</span>;</span><br><span class="line">cudaError_t <span class="title function_">cudaStreamWaitEvent</span><span class="params">(cudaStream_t stream, cudaEvent_t event)</span>;</span><br></pre></td></tr></table></figure><p>这条命令的含义是，指定的流要等待指定的事件，事件完成后流才能继续，这个事件可以在这个流中，也可以不在，当在不同的流的时候，就实现了跨流同步。</p><img src="/2024/10/28/CUDA%20NOTE2/6-4.png" class title="6-4"><p>事件还可以进行一些配置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaEventCreateWithFlags</span><span class="params">(cudaEvent_t* event, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="comment">//possible flag:</span></span><br><span class="line">cudaEventDefault</span><br><span class="line">cudaEventBlockingSync</span><br><span class="line">cudaEventDisableTiming</span><br><span class="line">cudaEventInterprocess</span><br></pre></td></tr></table></figure><p>其中cudaEventBlockingSync指定使用cudaEventSynchronize同步会造成阻塞调用线程。cudaEventSynchronize默认使用cpu周期不断重复查询事件状态，而当指定了事件是cudaEventBlockingSync的时候，会将查询放在另一个线程中，而原始线程继续执行，直到事件满足条件，才会通知原始线程，这样可以减少CPU的浪费，但是由于通讯的时间，会造成一定的延迟。cudaEventDisableTiming表示事件不用于计时，可以减少系统不必要的开支也能提升cudaStreamWaitEvent和cudaEventQuery的效率。cudaEventInterprocess表明可能被用于进程之间的事件。</p><h3 id="5-2-并发内核执行"><a href="#5-2-并发内核执行" class="headerlink" title="5.2 并发内核执行"></a>5.2 并发内核执行</h3><p>本节介绍并发内核执行的一些基本问题：</p><ul><li>深度优先或广度优先调度</li><li>调整硬件工作队列</li><li>避免虚假依赖</li><li>检查默认流的阻塞</li><li>流之间添加依赖关系</li><li>检查资源使用对并发的影响</li></ul><h4 id="5-2-1-流的并发与工作队列"><a href="#5-2-1-流的并发与工作队列" class="headerlink" title="5.2.1 流的并发与工作队列"></a>5.2.1 流的并发与工作队列</h4><p>本节直接采用了reference博客的代码运行测试。首先是并发流的创建和运行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cudaStream_t *stream=(cudaStream_t*)<span class="built_in">malloc</span>(n_stream*<span class="keyword">sizeof</span>(cudaStream_t));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n_stream;i++)</span><br><span class="line">&#123;</span><br><span class="line">    cudaStreamCreate(&amp;stream[i]);</span><br><span class="line">&#125;</span><br><span class="line">dim3 <span class="title function_">block</span><span class="params">(<span class="number">1</span>)</span>;</span><br><span class="line">dim3 <span class="title function_">grid</span><span class="params">(<span class="number">1</span>)</span>;</span><br><span class="line">cudaEvent_t start,stop;</span><br><span class="line">cudaEventCreate(&amp;start);</span><br><span class="line">cudaEventCreate(&amp;stop);</span><br><span class="line">cudaEventRecord(start);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n_stream;i++)</span><br><span class="line">&#123;</span><br><span class="line">    kernel_1&lt;&lt;&lt;grid,block,<span class="number">0</span>,stream[i]&gt;&gt;&gt;();</span><br><span class="line">    kernel_2&lt;&lt;&lt;grid,block,<span class="number">0</span>,stream[i]&gt;&gt;&gt;();</span><br><span class="line">    kernel_3&lt;&lt;&lt;grid,block,<span class="number">0</span>,stream[i]&gt;&gt;&gt;();</span><br><span class="line">    kernel_4&lt;&lt;&lt;grid,block,<span class="number">0</span>,stream[i]&gt;&gt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">cudaEventRecord(stop);</span><br><span class="line">CHECK(cudaEventSynchronize(stop));</span><br><span class="line"><span class="type">float</span> elapsed_time;</span><br><span class="line">cudaEventElapsedTime(&amp;elapsed_time,start,stop);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;elapsed time:%f ms\n&quot;</span>,elapsed_time);</span><br></pre></td></tr></table></figure><p>每个流都按顺序执行4个kernel。最后的同步是必要的。原代码计算量有点不够，增加任意一些计算量就可以在nvvp看到了。此外上面创建流的操作，可以用openmp多线程并行完成。</p><img src="/2024/10/28/CUDA%20NOTE2/image-20241106103555095.png" class title="image-20241106103555095"><p>对于之前的虚假依赖问题，由于现在已经和很少有Fermi架构的GPU，不需要考虑这个问题了。对应的解决方式是用BFS的方式启动kernel，即所有流先启动第一个kernel，再继续启动第二个。</p><p>上面的nvvp结果，并发的流只有8个，这是因为Kepler支持的最大Hyper-Q 工作队列数为32，默认只开启8个，因为工作队列有资源消耗。修改工作队列配置的方式是修改环境变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#For Bash or Bourne Shell:</span><br><span class="line">export CUDA_DEVICE_MAX_CONNECTIONS=<span class="number">32</span></span><br><span class="line">#For C-Shell:</span><br><span class="line">setenv CUDA_DEVICE_MAX_CONNECTIONS <span class="number">32</span></span><br></pre></td></tr></table></figure><h4 id="5-2-2-并发资源的限制与流的阻塞和依赖"><a href="#5-2-2-并发资源的限制与流的阻塞和依赖" class="headerlink" title="5.2.2 并发资源的限制与流的阻塞和依赖"></a>5.2.2 并发资源的限制与流的阻塞和依赖</h4><p>并发的最大化是受硬件资源限制的，上面的例子的核函数资源很小，因此多个工作队列上的多个流完全可以并行，但是如果增加核函数使用的资源，流的并发性就会降低。例如将block和网格都增加到32。执行时间会显著变长，如果进一步增加，nvvp也可以看到流的并发性降低。</p><p>默认情况下，空流会被阻塞，非空流也会被空流阻塞，例如下图的核函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n_stream;i++)</span><br><span class="line">&#123;</span><br><span class="line">    kernel_1&lt;&lt;&lt;grid,block,<span class="number">0</span>,stream[i]&gt;&gt;&gt;();</span><br><span class="line">    kernel_2&lt;&lt;&lt;grid,block,<span class="number">0</span>,stream[i]&gt;&gt;&gt;();</span><br><span class="line">    kernel_3&lt;&lt;&lt;grid,block&gt;&gt;&gt;();</span><br><span class="line">    kernel_4&lt;&lt;&lt;grid,block,<span class="number">0</span>,stream[i]&gt;&gt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2024/10/28/CUDA%20NOTE2/image-20241106105300522.png" class title="image-20241106105300522"><p>上面的阻塞以及虚假依赖是需要避免的，但有时是需要创建流之间的依赖关系的，这时就要使用事件。事件不需要计时，所以创建时，可以声明为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cudaEvent_t * event=(cudaEvent_t *)<span class="built_in">malloc</span>(n_stream*<span class="keyword">sizeof</span>(cudaEvent_t));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n_stream;i++)</span><br><span class="line">&#123;</span><br><span class="line">    cudaEventCreateWithFlag(&amp;event[i],cudaEventDisableTiming);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过事件添加依赖：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n_stream;i++)</span><br><span class="line">&#123;</span><br><span class="line">    kernel_1&lt;&lt;&lt;grid,block,<span class="number">0</span>,stream[i]&gt;&gt;&gt;();</span><br><span class="line">    kernel_2&lt;&lt;&lt;grid,block,<span class="number">0</span>,stream[i]&gt;&gt;&gt;();</span><br><span class="line">    kernel_3&lt;&lt;&lt;grid,block,<span class="number">0</span>,stream[i]&gt;&gt;&gt;();</span><br><span class="line">    kernel_4&lt;&lt;&lt;grid,block,<span class="number">0</span>,stream[i]&gt;&gt;&gt;();</span><br><span class="line">    cudaEventRecord(event[i],stream[i]);</span><br><span class="line">    cudaStreamWaitEvent(stream[n_stream<span class="number">-1</span>],event[i],<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样最后一个流就会等待前面所有的流执行完毕后才可以完成。</p><h3 id="5-3-重叠内核执行和数据传输"><a href="#5-3-重叠内核执行和数据传输" class="headerlink" title="5.3 重叠内核执行和数据传输"></a>5.3 重叠内核执行和数据传输</h3><p>Fermi架构和Kepler架构都有两个数据传输队列，从设备到主机和从主机到设备是分离的，因此可以重叠完成。只要kernel的计算和特定数据传输无关，二者就可以在不同的流中重叠执行。</p><p>本节使用向量加法为例，N_REPEAT用于控制计算强度，便于nvvp查看性能数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__global__ <span class="type">void</span> <span class="title function_">sumArraysGPU</span><span class="params">(<span class="type">float</span>*a,<span class="type">float</span>*b,<span class="type">float</span>*res,<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> idx=blockIdx.x*blockDim.x+threadIdx.x;</span><br><span class="line">    <span class="keyword">if</span>(idx &lt; N)</span><br><span class="line">    <span class="comment">//for delay</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N_REPEAT;j++)</span><br><span class="line">            res[idx]=a[idx]+b[idx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个过程，数据的传输和计算是不能重叠的，但是向量的各个位是独立的，因此可以把向量分块，分为N-SEGMENT个流去执行，就能重叠计算和数据传输：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cudaStream_t stream[N_SEGMENT];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N_SEGMENT;i++)</span><br><span class="line">&#123;</span><br><span class="line">    CHECK(cudaStreamCreate(&amp;stream[i]));</span><br><span class="line">&#125;</span><br><span class="line">cudaEvent_t start,stop;</span><br><span class="line">cudaEventCreate(&amp;start);</span><br><span class="line">cudaEventCreate(&amp;stop);</span><br><span class="line">cudaEventRecord(start,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N_SEGMENT;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ioffset=i*iElem; CHECK(cudaMemcpyAsync(&amp;a_d[ioffset],&amp;a_h[ioffset],nByte/N_SEGMENT,cudaMemcpyHostToDevice,stream[i])); CHECK(cudaMemcpyAsync(&amp;b_d[ioffset],&amp;b_h[ioffset],nByte/N_SEGMENT,cudaMemcpyHostToDevice,stream[i]));</span><br><span class="line">    sumArraysGPU&lt;&lt;&lt;grid,block,<span class="number">0</span>,stream[i]&gt;&gt;&gt;(&amp;a_d[ioffset],&amp;b_d[ioffset],&amp;res_d[ioffset],iElem);</span><br><span class="line">    CHECK(cudaMemcpyAsync(&amp;res_from_gpu_h[ioffset],&amp;res_d[ioffset],nByte/N_SEGMENT,cudaMemcpyDeviceToHost,stream[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//timer</span></span><br><span class="line">CHECK(cudaEventRecord(stop, <span class="number">0</span>));</span><br><span class="line">CHECK(cudaEventSynchronize(stop));</span><br></pre></td></tr></table></figure><p>数据传输需要调用异步接口，还需要注意主机内存要用cudaHostAlloc声明为固定内存。可以观察到核函数和数据在主机和设备之间的传输重叠。这里因为计算强度不够，所以无法完全cover数据传输的时间。</p><img src="/2024/10/28/CUDA%20NOTE2/image-20241106155852973.png" class title="image-20241106155852973"><h3 id="5-4-GPU和CPU并行"><a href="#5-4-GPU和CPU并行" class="headerlink" title="5.4 GPU和CPU并行"></a>5.4 GPU和CPU并行</h3><p>在GPU执行流的同时CPU也可以完成一部分工作。可以通过事件来确认流是否执行结束：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cudaEvent_t start,stop;</span><br><span class="line">cudaEventCreate(&amp;start);</span><br><span class="line">cudaEventCreate(&amp;stop);</span><br><span class="line">cudaEventRecord(start,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N_SEGMENT;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ioffset=i*iElem;</span><br><span class="line">    CHECK(cudaMemcpyAsync(&amp;a_d[ioffset],&amp;a_h[ioffset],nByte/N_SEGMENT,cudaMemcpyHostToDevice,stream[i]));</span><br><span class="line">    CHECK(cudaMemcpyAsync(&amp;b_d[ioffset],&amp;b_h[ioffset],nByte/N_SEGMENT,cudaMemcpyHostToDevice,stream[i]));</span><br><span class="line">    sumArraysGPU&lt;&lt;&lt;grid,block,<span class="number">0</span>,stream[i]&gt;&gt;&gt;(&amp;a_d[ioffset],&amp;b_d[ioffset],&amp;res_d[ioffset],iElem);</span><br><span class="line">    CHECK(cudaMemcpyAsync(&amp;res_from_gpu_h[ioffset],&amp;res_d[ioffset],nByte/N_SEGMENT,cudaMemcpyDeviceToHost,stream[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//timer</span></span><br><span class="line">CHECK(cudaEventRecord(stop, <span class="number">0</span>));</span><br><span class="line"><span class="type">int</span> counter=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (cudaEventQuery(stop)==cudaErrorNotReady)</span><br><span class="line">&#123;</span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cpu counter:%d\n&quot;</span>,counter);</span><br></pre></td></tr></table></figure><h3 id="5-5-流回调"><a href="#5-5-流回调" class="headerlink" title="5.5 流回调"></a>5.5 流回调</h3><p>流回调可插入流中，在前面的任务完成后就会调用这个函数。回调函数不可以调用CUDA API，不可以执行同步。流函数有固定的参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> CUDART_CB <span class="title function_">my_callback</span><span class="params">(cudaStream_t stream, cudaError_t status, <span class="type">void</span> *data)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;callback from stream %d\n&quot;</span>, *((<span class="type">int</span> *)data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用以下接口插入流：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaStreamAddCallback</span><span class="params">(cudaStream_t stream,cudaStreamCallback_t callback, <span class="type">void</span> *userData, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><p>简单的回调插入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> CUDART_CB <span class="title function_">my_callback</span><span class="params">(cudaStream_t stream,cudaError_t status,<span class="type">void</span> * data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;call back from stream:%d\n&quot;</span>,*((<span class="type">int</span> *)data));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//asynchronous calculation</span></span><br><span class="line">    <span class="type">int</span> iElem=nElem/N_SEGMENT;</span><br><span class="line">    cudaStream_t stream[N_SEGMENT];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N_SEGMENT;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        CHECK(cudaStreamCreate(&amp;stream[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    cudaEvent_t start,stop;</span><br><span class="line">    cudaEventCreate(&amp;start);</span><br><span class="line">    cudaEventCreate(&amp;stop);</span><br><span class="line">    cudaEventRecord(start,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N_SEGMENT;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ioffset=i*iElem;</span><br><span class="line">        CHECK(cudaMemcpyAsync(&amp;a_d[ioffset],&amp;a_h[ioffset],nByte/N_SEGMENT,cudaMemcpyHostToDevice,stream[i]));</span><br><span class="line">        CHECK(cudaMemcpyAsync(&amp;b_d[ioffset],&amp;b_h[ioffset],nByte/N_SEGMENT,cudaMemcpyHostToDevice,stream[i]));</span><br><span class="line">        sumArraysGPU&lt;&lt;&lt;grid,block,<span class="number">0</span>,stream[i]&gt;&gt;&gt;(&amp;a_d[ioffset],&amp;b_d[ioffset],&amp;res_d[ioffset],iElem);</span><br><span class="line">        CHECK(cudaMemcpyAsync(&amp;res_from_gpu_h[ioffset],&amp;res_d[ioffset],nByte/N_SEGMENT,cudaMemcpyDeviceToHost,stream[i]));</span><br><span class="line">        CHECK(cudaStreamAddCallback(stream[i],my_callback,(<span class="type">void</span> *)(stream+i),<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//timer</span></span><br><span class="line">    CHECK(cudaEventRecord(stop, <span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> counter=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cudaEventQuery(stop)==cudaErrorNotReady)&#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HPCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CUDA笔记1</title>
      <link href="/2024/10/10/CUDA%20NOTE1/"/>
      <url>/2024/10/10/CUDA%20NOTE1/</url>
      
        <content type="html"><![CDATA[<h1 id="CUDA-笔记"><a href="#CUDA-笔记" class="headerlink" title="CUDA 笔记"></a>CUDA 笔记</h1><p>CUDA笔记。</p><p>Reference：</p><ul><li><a href="https://link.zhihu.com/?target=https%3A//face2ai.com/program-blog/%23GPU%E7%BC%96%E7%A8%8B%EF%BC%88CUDA%EF%BC%89">https://face2ai.com/program-blog/#GPU编程（CUDA）</a></li><li><a href="https://github.com/HeKun-NVIDIA/CUDA-Programming-Guide-in-Chinese">https://github.com/HeKun-NVIDIA/CUDA-Programming-Guide-in-Chinese</a></li><li>CUDA by example</li></ul><p>主要参考是<a href="https://www.cs.utexas.edu/~rossbach/cs380p/papers/cuda-programming.pdf">Professional CUDA C Programming</a>这本书和第一个链接博主的笔记。</p><h2 id="1-CUDA-编程模型"><a href="#1-CUDA-编程模型" class="headerlink" title="1 CUDA 编程模型"></a>1 CUDA 编程模型</h2><h3 id="1-1-CUDA并行编程模型概述"><a href="#1-1-CUDA并行编程模型概述" class="headerlink" title="1.1 CUDA并行编程模型概述"></a>1.1 CUDA并行编程模型概述</h3><h4 id="1-1-1-内存管理"><a href="#1-1-1-内存管理" class="headerlink" title="1.1.1 内存管理"></a>1.1.1 内存管理</h4><p>CUDA提供了API分配管理设备上的内存，这些API也可以分配管理主机上的内存。这些API和标准库的内存管理API是对应的。</p><p>API: cudaMalloc    cudaMemcpy    cudaMemSet    cudaFree</p><p>其中cudaMemcpy实现主机到设备的数据拷贝：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaMemcpy</span><span class="params">(<span class="type">void</span> * dst,<span class="type">const</span> <span class="type">void</span> * src,<span class="type">size_t</span> count,</span></span><br><span class="line"><span class="params">  cudaMemcpyKind kind)</span>;</span><br></pre></td></tr></table></figure><p>cudaMemcpyKind kind:</p><ul><li>cudaMemcpyHostToHost</li><li>cudaMemcpyHostToDevice</li><li>cudaMemcpyDeviceToHost</li><li>cudaMemcpyDeviceToDevice</li></ul><p>返回的结果有两种， cudaSuccess或cudaErrorMemoryAllocation，可以用以下接口得到详细信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">cudaGetErrorString</span><span class="params">(cudaError_t error)</span>;</span><br></pre></td></tr></table></figure><p>CUDA的内存层次可以大概用以下模型描述：</p><p><img src="/2024/10/10/CUDA%20NOTE1/image-20240918111230434.png" alt="image-20240918111230434" width="50%"></p><p>为了区分设备和主机内存，在分配时可以给变量添加后缀_d和_h。从而<strong>避免混用设备和主机的内存地址</strong>。</p><h4 id="1-1-2-线程管理"><a href="#1-1-2-线程管理" class="headerlink" title="1.1.2 线程管理"></a>1.1.2 线程管理</h4><p>组织GPU的线程是进行并行化时的一个主要问题。在GPU中，一个核函数包含一个grid，一个grid包含多个块，每个块中有多个线程。</p><p><img src="/2024/10/10/CUDA%20NOTE1/image-20240918112113544.png" alt="image-20240918112113544" width="33%"></p><p>一个线程块中的线程可以进行同步，并共享内存。线程的编号是由两个结构体确定的：</p><ul><li>blockIdx：块在网格中的索引。</li><li>threadIdx：线程在块内的索引。</li></ul><p>这两个结构体都包含三个无符号整数字段x，y，z。还有两个结构体保存上述x，y，z字段的范围：</p><ul><li>blockDim</li><li>gridDim</li></ul><p>这两个结构体同样包含x，y，z三个字段。为dim3类型。</p><p>一个网格通常被分为二维的块，每个块常被分为三维的线程。dim3是在主机定义的，不可修改。其各维度的限制后续介绍。</p><h4 id="1-1-3-核函数"><a href="#1-1-3-核函数" class="headerlink" title="1.1.3 核函数"></a>1.1.3 核函数</h4><p>核函数是在GPU上运行的代码，这部分代码是NVCC编译的。核函数都通过以下方式启动：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel_name&lt;&lt;&lt;grid,block&gt;&gt;&gt;(argument <span class="built_in">list</span>);</span><br></pre></td></tr></table></figure><p>可以使用dim3类型的grid和block配置内核函数运行，也可以直接使用常量/int变量初始化。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel_name&lt;&lt;&lt;<span class="number">4</span>,<span class="number">8</span>&gt;&gt;&gt;(argument <span class="built_in">list</span>);</span><br></pre></td></tr></table></figure><p>对应的线程布局为：</p><p><img src="/2024/10/10/CUDA%20NOTE1/image-20240918140101986.png" alt="image-20240918140101986" width="70%"></p><p>当主机启动核函数，控制流会回到主机代码。可以通过以下API进行同步：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaDeviceSynchronize</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>以上是显式进行同步。在启动核函数之后，cudaMemcpy等API也会进行隐式的同步。</p><p>核函数的声明限定符有三种，分别为：</p><div class="table-container"><table><thead><tr><th>限定符</th><th>执行</th><th>调用</th><th>备注</th></tr></thead><tbody><tr><td>__global__</td><td>设备</td><td>主机或计算能力3以上的设备</td><td>返回void</td></tr><tr><td>__device__</td><td>设备</td><td>设备</td><td></td></tr><tr><td>__host__</td><td>主机</td><td>主机</td><td>可省略</td></tr></tbody></table></div><p>核函数有以下限制：</p><ul><li>只能访问设备内存</li><li>必须返回void</li><li>不支持可变数量参数</li><li>不支持静态变量</li><li>显式异步</li></ul><h4 id="1-1-4-错误处理"><a href="#1-1-4-错误处理" class="headerlink" title="1.1.4 错误处理"></a>1.1.4 错误处理</h4><p>由于CUDA核函数是异步执行的，为了处理和方便发现错误，要检查调用的返回值，例如如下的宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK(call)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">  const cudaError_t <span class="keyword">error</span>=call;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(<span class="keyword">error</span>!=cudaSuccess)\</span></span><br><span class="line"><span class="meta">  &#123;\</span></span><br><span class="line"><span class="meta">      printf(<span class="string">&quot;ERROR: %s:%d,&quot;</span>,__FILE__,__LINE__);\</span></span><br><span class="line"><span class="meta">      printf(<span class="string">&quot;code:%d,reason:%s\n&quot;</span>,<span class="keyword">error</span>,cudaGetErrorString(<span class="keyword">error</span>));\</span></span><br><span class="line"><span class="meta">      exit(1);\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>在编写代码时，处理错误信息可以方便找到错误。在release版本中可以去掉错误检查。</p><h3 id="1-2-核函数计时"><a href="#1-2-核函数计时" class="headerlink" title="1.2 核函数计时"></a>1.2 核函数计时</h3><p>性能优化时常常对函数运行时间进行计时。然而，核函数的启动和返回本身是需要时间的，因此在启动前开始计时，同步后计时结束的时间和执行时间有偏差。</p><p><img src="/2024/10/10/CUDA%20NOTE1/image-20240918143153777.png" alt="image-20240918143153777" width="50%"></p><p>和c/c++程序使用perf进行性能分析一样，CUDA程序也可以使用一个名为nvprof的工具进行性能分析。</p><p>nvprof需要开启权限，在linux上sudo运行，在win上需要通过nvdia控制面板的开发者模式开启权限。win上还可能提示缺少.dll文件，可以在安装路径/extras下寻找.dll移动到bin下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvprof [nvprof_args] &lt;application&gt;[application_args]</span><br></pre></td></tr></table></figure><p>更详细的profile参数和指导见<a href="https://docs.nvidia.com/cuda/profiler-users-guide/index.html#。">https://docs.nvidia.com/cuda/profiler-users-guide/index.html#。</a></p><p><strong>nvprof已经不支持计算能力7.5以上的设备</strong>，只能做基本的计时，现在的设备基本都需要使用nsight system(nsys)进行详细性能分析，需要注意nsys分析需要应用路径合法。</p><h3 id="1-3-组织并行线程"><a href="#1-3-组织并行线程" class="headerlink" title="1.3 组织并行线程"></a>1.3 组织并行线程</h3><p>在2.2.2节已经初步介绍了线程的可组织方式。对于二维网格，下图可以直观的体现每个线程的编号：</p><p><img src="/2024/10/10/CUDA%20NOTE1/image-20240918145100584.png" alt="image-20240918145100584" width="50%"></p><p>这是用ix iy表示线程，如果用全局ID表示线程编号，为blockDim.x*blockDim.y*gridDim.x*blockIdx.y + blockDim.x*blockDim.y*blockIdx.x+threadIdx.y*blockDim.x+threadIdx.x。</p><p>当然，在设备上，数据都是线性存储的，例如一个二维矩阵：</p><p><img src="/2024/10/10/CUDA%20NOTE1/image-20240918145222734.png" alt="image-20240918145222734" width="60%"></p><p>线程和数据的映射关系可以自行设计，最简单的方式就是ix，iy的线程处理二维的(ix，iy)的数据。<strong>不同的线程的组织方式能得到不同的性能</strong>，在后续章节会介绍具体的原因。</p><h3 id="1-4-设备信息查询"><a href="#1-4-设备信息查询" class="headerlink" title="1.4 设备信息查询"></a>1.4 设备信息查询</h3><p>CUDA C提供了cudaGetDeviceCount获取设备数量，并可以使用cudaGetDeviceProperties( &amp;prop, i )获取设备的具体信息，从而选择合适的设备。可以为prop赋值，然后通过cudaChooseDevice( &amp;dev, &amp;prop )条件筛选合适的设备，cudaSetDevice( dev )决定使用的设备。CUDA by example提供了一份输出主要设备信息的示例代码，包含以下的信息：</p><p><img src="/2024/10/10/CUDA%20NOTE1/image-20240918150638009.png" alt="image-20240918150638009" width="50%"></p><h2 id="2-CUDA-执行模型"><a href="#2-CUDA-执行模型" class="headerlink" title="2 CUDA 执行模型"></a>2 CUDA 执行模型</h2><h3 id="2-1-架构概述"><a href="#2-1-架构概述" class="headerlink" title="2.1 架构概述"></a>2.1 架构概述</h3><p>GPU架构是基于流式多处理器(SM)搭建的。GPU中包含多个SM，SM的结构如下图：</p><p><img src="/2024/10/10/CUDA%20NOTE1/image-20240918160427915.png" alt="image-20240918160427915" width="50%"></p><p>这张图还省略了一些其他组件，例如寄存器文件和线程束调度器。CUDA使用SIMT并行。调度执行线程束，不同设备有不同线程束大小，通常为32。每个SM可以被分配到多个block，一个block可以有多个线程，但SM每次只执行一个线程束。线程块被分配到SM上时，会被分成多个线程束，线程束在SM上交替执行。</p><h3 id="2-2-线程束执行"><a href="#2-2-线程束执行" class="headerlink" title="2.2 线程束执行"></a>2.2 线程束执行</h3><h4 id="2-2-1-线程束分化"><a href="#2-2-1-线程束分化" class="headerlink" title="2.2.1 线程束分化"></a>2.2.1 线程束分化</h4><p>线程束执行时执行的是相同的指令，处理自己的数据。如果一个线程束的不同线程包含不同的控制条件，就会导致线程束的分化。例如一个if else条件选择块，每个线程都会执行所有的if和else部分，一部分线程执行if的部分，而其他线程只能等待，然后所有线程进入else代码块，上一步等待的线程再执行else的部分，其他线程等待。</p><p><img src="/2024/10/10/CUDA%20NOTE1/image-20240918162741874.png" alt="image-20240918162741874" width="80%"></p><p>如果线程束所有的线程都执行if或else时，就不会产生上述问题，因此可以控制一个线程束的线程进入同一个分支，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__global__ <span class="type">void</span> <span class="title function_">mathKernel2</span><span class="params">(<span class="type">float</span> *c)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tid = blockIdx.x* blockDim.x + threadIdx.x;</span><br><span class="line"><span class="type">float</span> a = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> b = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">if</span> ((tid/warpSize) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">a = <span class="number">100.0f</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">b = <span class="number">200.0f</span>;</span><br><span class="line">c[tid] = a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-线程束执行的资源分配"><a href="#2-2-2-线程束执行的资源分配" class="headerlink" title="2.2.2 线程束执行的资源分配"></a>2.2.2 线程束执行的资源分配</h4><p>线程束可以是已经执行的，也可以是已经分配到SM，但还未进行资源的分配。</p><p>每个SM上有多少个线程束可以处于执行状态，取决于寄存器等资源。kernel占用的资源越少，更多的线程就能同时执行。</p><p><img src="/2024/10/10/CUDA%20NOTE1/image-20240918171255332.png" alt="image-20240918171255332" width="50%"></p><h4 id="2-2-3-隐藏延迟"><a href="#2-2-3-隐藏延迟" class="headerlink" title="2.2.3 隐藏延迟"></a>2.2.3 隐藏延迟</h4><p>延迟有两种，计算延迟和访存延迟。必须有足够的线程束用于调度，才能最大效率使用计算资源和带宽。对于计算延迟，所需线程束是延迟 * 吞吐量。延迟是计算指令需要的时钟周期，吞吐量是单周期能进行的操作。</p><p><img src="/2024/10/10/CUDA%20NOTE1/image-20240918172727525.png" alt="image-20240918172727525" width="50%"></p><p>类似的，访存延迟的隐藏需要访存延迟*每个时钟周期可读取的数据量才能充分利用到GPU带宽。</p><p>线程束的下界为计算核心数<em>单条指令延迟、例如一个计算的延迟为32个时钟周期，则最少需要32\</em>20个线程使设备满载。</p><h3 id="2-3-并行性表现"><a href="#2-3-并行性表现" class="headerlink" title="2.3 并行性表现"></a>2.3 并行性表现</h3><p>本节通过修改核函数的配置，进行性能分析，进一步理解线程束执行的过程。本节使用的核函数为矩阵加法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>::chrono;</span><br><span class="line"></span><br><span class="line">__global__ <span class="type">void</span> <span class="title function_">matrixAdd</span><span class="params">(<span class="type">float</span> *ma, <span class="type">float</span> *mb, <span class="type">float</span> *mc, <span class="type">int</span> nx, <span class="type">int</span> ny)</span> &#123;</span><br><span class="line">  <span class="type">int</span> ix = threadIdx.x + blockDim.x * blockIdx.x;</span><br><span class="line">  <span class="type">int</span> iy = threadIdx.y + blockDim.y * blockIdx.y;</span><br><span class="line">  <span class="type">int</span> idx = ix + iy * ny;</span><br><span class="line">  <span class="keyword">if</span> (ix &lt; nx &amp;&amp; iy &lt; ny) &#123;</span><br><span class="line">    ma[idx] = mb[idx] + mc[idx];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> nx = <span class="number">1e4</span>, ny = <span class="number">1e4</span>;</span><br><span class="line">  <span class="type">int</span> nbyte = nx * ny * <span class="keyword">sizeof</span>(<span class="type">float</span>);</span><br><span class="line">  <span class="type">float</span> *a_h = (<span class="type">float</span> *)<span class="built_in">malloc</span>(nbyte);</span><br><span class="line">  <span class="type">float</span> *b_h = (<span class="type">float</span> *)<span class="built_in">malloc</span>(nbyte);</span><br><span class="line">  <span class="type">float</span> *c_h = (<span class="type">float</span> *)<span class="built_in">malloc</span>(nbyte);</span><br><span class="line">  <span class="type">float</span> *a_d, *b_d, *c_d;</span><br><span class="line">  cudaMalloc(&amp;a_d, nbyte);</span><br><span class="line">  cudaMalloc(&amp;b_d, nbyte);</span><br><span class="line">  cudaMalloc(&amp;c_d, nbyte);</span><br><span class="line">  cudaMemcpy(a_d, a_h, nbyte, cudaMemcpyHostToDevice);</span><br><span class="line">  cudaMemcpy(b_d, b_h, nbyte, cudaMemcpyHostToDevice);</span><br><span class="line">  <span class="type">int</span> dimx = argc &gt; <span class="number">2</span> ? atoi(argv[<span class="number">1</span>]) : <span class="number">32</span>;</span><br><span class="line">  <span class="type">int</span> dimy = argc &gt; <span class="number">2</span> ? atoi(argv[<span class="number">2</span>]) : <span class="number">32</span>;</span><br><span class="line">  dim3 <span class="title function_">block</span><span class="params">(dimx, dimy)</span>;</span><br><span class="line">  dim3 <span class="title function_">grid</span><span class="params">((nx - <span class="number">1</span>) / block.x + <span class="number">1</span>, (ny - <span class="number">1</span>) / block.y + <span class="number">1</span>)</span>;</span><br><span class="line">  <span class="keyword">auto</span> start = high_resolution_clock::now();</span><br><span class="line">  matrixAdd&lt;&lt;&lt;grid, block&gt;&gt;&gt;(a_d, b_d, c_d, nx, ny);</span><br><span class="line">  <span class="keyword">auto</span> end = high_resolution_clock::now();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;time:%lf\n&quot;</span>, duration_cast&lt;duration&lt;<span class="type">double</span>&gt;&gt;(end - start).count());</span><br><span class="line">  cudaDeviceSynchronize();</span><br><span class="line">  cudaMemcpy(c_h, c_d, nbyte, cudaMemcpyDeviceToHost);</span><br><span class="line">  cudaFree(a_d);</span><br><span class="line">  cudaFree(b_d);</span><br><span class="line">  cudaFree(c_d);</span><br><span class="line">  <span class="built_in">free</span>(a_h);</span><br><span class="line">  <span class="built_in">free</span>(b_h);</span><br><span class="line">  <span class="built_in">free</span>(c_h);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用nsys做profile，自己的gpu为gtx1650，metrics-set为tu11x，可以通过<code>--gpu-metrics-set=help</code>看支持的metrics-set。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nsys profile --gpu-metrics-set tu11x --gpu-metrics-devices 0 --stats=true ./main</span><br></pre></td></tr></table></figure><p>profile后较为细节的数据都在sqlite里面，可视化界面打开nsys-rep报告可以直观看到数据。但是nsys得到的是整体宏观的数据，不便观察更详细的核函数运行数据，因此用另一个工具nsight compute再做profile，记录不同线程块配置的一些数据：</p><div class="table-container"><table><thead><tr><th>block-size</th><th>Achieved Occupancy</th><th>time</th></tr></thead><tbody><tr><td>32x32</td><td>87.34</td><td>0.000054</td></tr><tr><td>16x32</td><td>82.68</td><td>0.000084</td></tr><tr><td>16x16</td><td>85.65</td><td>0.000077</td></tr><tr><td>32x16</td><td>82.68</td><td>0.000083</td></tr></tbody></table></div><p>可以看到规整的threadBlock有更好的效果，对于当前这个小计算任务，32x32的较大threadBlock的SM Occupancy是最高的，这也符合前面隐藏延迟的理论，因为这个计算并不复杂，占用的资源并不多，尽可能多的线程可以在SM上充分利用硬件资源完成计算。</p><p>除了achieved occupancy，nsight compute还能测量许多其他的指标，在调优时可能都需要关注。例如访存相关的数据：</p><p><img src="/2024/10/10/CUDA%20NOTE1/image-20241009163421168.png" alt="image-20241009163421168" width="67%"></p><p>说明这个程序的线程组织方式完全没有利用到L1 Cache，仍有很大的改进空间。</p><h3 id="2-4-避免分支分化"><a href="#2-4-避免分支分化" class="headerlink" title="2.4 避免分支分化"></a>2.4 避免分支分化</h3><p>本节从并行归约问题出发，学习GPU并行编程时避免分支分化的方法。</p><p>归约是常见的并行化的步骤，用于对分块的结果进行处理。首先考虑最简单的规约，对向量求元素和。并行时各个线程计算一组元素，得到的结果归约迭代求和。常见的元素划分方式有两种：相邻元素配对和交错配对。</p><p><img src="/2024/10/10/CUDA%20NOTE1/xianglin.png" alt="img" width="50%"></p><p><img src="/2024/10/10/CUDA%20NOTE1/jiaocuo.png" alt="img" width="50%"></p><p>以下是CPU的交错配对归约：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">recursiveReduce</span><span class="params">(<span class="type">int</span> *data, <span class="type">int</span> <span class="type">const</span> size)</span></span>&#123;</span><br><span class="line"><span class="comment">// terminate check</span></span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> data[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// renew the stride</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> stride = size / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (size % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stride; i++)</span><br><span class="line">data[i] += data[i + stride];</span><br><span class="line">data[<span class="number">0</span>] += data[size - <span class="number">1</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stride; i++)</span><br><span class="line">data[i] += data[i + stride];</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">recursiveReduce</span>(data, stride);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在GPU上，首先编写相邻元素配对的核函数，每个线程块计算一组数据，最后归约所有线程块的结果。这里假定了数据的总数是2的幂次方，如果不是需要考虑边界问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__global__ <span class="type">void</span> <span class="title function_">reductSum</span><span class="params">(<span class="type">int</span> *in, <span class="type">int</span> *out, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">  <span class="type">int</span> tid = threadIdx.x;</span><br><span class="line">  <span class="type">int</span> *a = in + blockIdx.x * blockDim.x;</span><br><span class="line">  <span class="keyword">if</span> (blockIdx.x * blockDim.x + tid &gt;= size)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> stride = <span class="number">1</span>; stride &lt; blockDim.x; stride *= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tid % (<span class="number">2</span> * stride) == <span class="number">0</span>) &#123;</span><br><span class="line">      a[tid] = a[tid] + a[tid + stride];</span><br><span class="line">    &#125;</span><br><span class="line">    __syncthreads();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (tid == <span class="number">0</span>)</span><br><span class="line">    out[blockIdx.x] = a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/10/10/CUDA%20NOTE1/3_22.png" alt="img" width="50%"></p><p>线程从一开始就只有1/2会进行计算，其他都在进行分支判断后等待，每一个线程束都只有一半的线程计算，却会使用整个SM。如果能将计算的线程控制在一起，不计算的线程控制在一起，不计算的线程的分支都不执行，SM就不会调度运行包含这些线程的线程束，节省了资源，从而提高了效率。</p><p><img src="/2024/10/10/CUDA%20NOTE1/3_23.png" alt="img" width="50%"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__global__ <span class="type">void</span> <span class="title function_">reductSumOpt</span><span class="params">(<span class="type">int</span> *in, <span class="type">int</span> *out, <span class="type">int</span> size)</span>&#123;</span><br><span class="line">  <span class="type">int</span> tid = threadIdx.x;</span><br><span class="line">  <span class="type">int</span> *a = in + blockIdx.x * blockDim.x;</span><br><span class="line">  <span class="keyword">if</span>(blockIdx.x * blockDim.x + tid &gt;= size) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> stride = <span class="number">1</span>; stride &lt; blockDim.x; stride *= <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">2</span> * stride * tid;</span><br><span class="line">    <span class="keyword">if</span>(idx &lt; blockDim.x)&#123;</span><br><span class="line">      a[idx] += a[idx + stride];</span><br><span class="line">    &#125;</span><br><span class="line">    __syncthreads();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (tid == <span class="number">0</span>)</span><br><span class="line">    out[blockIdx.x] = a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Correct. basic ver T=0.006428</span><br><span class="line">Correct. opt ver T=0.003778</span><br></pre></td></tr></table></figure><p>实现了1.7x的提升。这是非常显著的，和参考博客作者的性能提升也类似，说明实际的硬件执行情况是符合预期的。接下来对采集数据进行分析，nsight compute没有inst_per_warp这个指标了，但是指令相关的数据也还是可以观察到明显的不同：</p><img src="/2024/10/10/CUDA%20NOTE1/image-20241009201545033.png" class title="image-20241009201545033"><center>未优化的kernel</center><img src="/2024/10/10/CUDA%20NOTE1/image-20241009201645470.png" class title="image-20241009201645470"><center>优化后的kernel</center><p>调整线程分支处理后，执行的指令数下降了，未参与计算的线程束的分支指令没有调度执行。另外，访存的效率也提升了，MemoryThroughput从23.74提升到了44.56。</p><p>除了以上的方式，改用交错配对的方式也能将计算的线程控制在一起，如下图所示：</p><p><img src="/2024/10/10/CUDA%20NOTE1/3_24.png" alt="img" width="50%"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">reductSumInterleaved</span><span class="params">(<span class="type">int</span> *in, <span class="type">int</span> *out, <span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> tid = threadIdx.x;</span><br><span class="line">  <span class="type">int</span> *a = in + blockIdx.x * blockDim.x;</span><br><span class="line">  <span class="keyword">if</span>(blockIdx.x * blockDim.x + tid &gt;= size) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> stride = blockDim.x/<span class="number">2</span>; stride&gt;<span class="number">0</span>; stride/=<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tid &lt; stride)&#123;</span><br><span class="line">      a[tid] += a[tid + stride];</span><br><span class="line">    &#125;</span><br><span class="line">    __syncthreads();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(tid == <span class="number">0</span>)</span><br><span class="line">    out[blockIdx.x] = a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Correct. basic ver T=0.006622</span><br><span class="line">Correct. opt ver T=0.003767</span><br><span class="line">Correct. interleaved ver T=0.003731</span><br></pre></td></tr></table></figure><p>执行效率与上面的优化方式是一样的。从分支的角度考虑，和上面的优化一样，让靠后的线程束内的线程全部不进入分支，避免被调度执行从而提高了效率。同样的，从profile数据来看是否执行情况是符合预期的。</p><p>指令的执行情况如下，比上面的方式要略好一些，但是具体的原因还不太明确。</p><img src="/2024/10/10/CUDA%20NOTE1/image-20241009211736838.png" class title="image-20241009211736838"><p>从访存的角度来看，MemoryThroughput降低到了35，L1Cache和L2Cache的缓存命中率都下降了，这是符合预期的，因为起初的访存跨度是最大的，此后逐渐减小，而前两种方式的访存跨度是一开始较小，后面更大，后面跨度大时，数据已经载入到缓存了。因为截至这一节尚未学习内存模型，因此也可能和设想的这个原因不同。此外，虽然缓存命中率明显下降，但却没有影响性能，这是因为写回的数据变少了，上面两种方式写回L2cache的数据是这种的四倍，因为写入的数据是交错的，导致不需要写入的数据也进行了写入。这也充分说明了最佳的性能要通过访存和指令执行(运算)等多方面权衡得到。</p><h3 id="2-5-循环展开"><a href="#2-5-循环展开" class="headerlink" title="2.5 循环展开"></a>2.5 循环展开</h3><p>CPU执行代码中的循环展开很多时候编译器都可以完成，GPU执行的代码，，编译器是否能进行循环展开优化，考虑到编译器也在不断更新，还是需要实际测试一下。</p><p>上一节中的交错归约每个线程只处理了对应部分的数据，为了提高线程块的负载，对其进行循环展开，考虑用一个线程块处理多块数据。在一开始的时候就将相邻块的数据添加到线程对应位置上。</p><img src="/2024/10/10/CUDA%20NOTE1/1.png" class title="img"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__global__ <span class="type">void</span> <span class="title function_">reductSumInterleavedUnroll</span><span class="params">(<span class="type">int</span> *in, <span class="type">int</span> *out, <span class="type">int</span> size)</span>&#123;</span><br><span class="line">  <span class="type">int</span> tid = threadIdx.x;</span><br><span class="line">  <span class="type">int</span> *a = in + blockIdx.x * blockDim.x * <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> idx = blockIdx.x * blockDim.x * <span class="number">2</span> + tid;</span><br><span class="line">  <span class="keyword">if</span>(idx &gt;= size) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(idx + blockDim.x &lt; size) a[tid] += a[tid + blockDim.x];</span><br><span class="line">  __syncthreads();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> stride = blockDim.x/<span class="number">2</span>; stride&gt;<span class="number">0</span>; stride/=<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tid &lt; stride)&#123;</span><br><span class="line">      a[tid] += a[tid + stride];</span><br><span class="line">    &#125;</span><br><span class="line">    __syncthreads();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(tid == <span class="number">0</span>)</span><br><span class="line">    out[blockIdx.x] = a[<span class="number">0</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行时间如下，有显著的性能提升：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Correct. basic ver T=0.006359</span><br><span class="line">Correct. opt ver T=0.003661</span><br><span class="line">Correct. interleaved ver T=0.003305</span><br><span class="line">Correct. interleaved unrolling ver T=0.001069</span><br></pre></td></tr></table></figure><p>除了上面这种直接先将块的数据加到当前数据位置的方式，我还尝试了直接对两个块的数据进行交错归约，时间和上述方式基本一致。如果改变线程块的计算块数量，性能还会有进一步提升：</p><div class="table-container"><table><thead><tr><th>块数量</th><th>执行时间</th></tr></thead><tbody><tr><td>2</td><td>0.002182</td></tr><tr><td>4</td><td>0.001600</td></tr><tr><td>8</td><td>0.000957</td></tr></tbody></table></div><p>到了这里已经实现了相对于最基础的版本4.8x的加速比。用nsight compute观察一下各项指标的变化：</p><img src="/2024/10/10/CUDA%20NOTE1/image-20241010101831330.png" class title="image-20241010101831330"><img src="/2024/10/10/CUDA%20NOTE1/image-20241010102020002.png" class title="image-20241010102020002"><p>最直观的是指令数减少了，只有之前版本的16%，因为线程束减少了，每个线程都承担了原来8个线程的计算，但只增加了if分支内的8条语句，MemoryThroughput翻了一倍，因为每个线程都需要8个数据块的数据，这也导致了缓存命中率的下降，但并不影响性能的提升，最后，从L2cache写回DeviceMemory的数据也变成了原来的1/8，降低了写入开销。还有一些其他指标下降了，SM Throughput和SM Busy%等，这再次说明了好的性能是多个方面的均衡，要找到真正的性能瓶颈，对瓶颈优化可以牺牲其他方面的效率。</p><p>接下来考虑能不能将最后的64个数的计算进行展开。在交错归约的过程中，每计算一轮，有效线程数和数据都会减半。当线程数小于32时，就会出现最后一个线程束内有线程不进入(tid<stride)分支的情况，因此考虑将最后64个数的计算进行展开，更改的kernel部分如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> stride = blockDim.x/<span class="number">2</span>; stride&gt;<span class="number">32</span>; stride/=<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(tid &lt; stride)&#123;</span><br><span class="line">    a[tid] += a[tid + stride];</span><br><span class="line">  &#125;</span><br><span class="line">  __syncthreads();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tid&lt;<span class="number">32</span>)&#123;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">int</span> *vmem = a;</span><br><span class="line">  vmem[tid] += vmem[tid+<span class="number">32</span>];</span><br><span class="line">  vmem[tid] += vmem[tid+<span class="number">16</span>];</span><br><span class="line">  vmem[tid] += vmem[tid+<span class="number">8</span>];</span><br><span class="line">  vmem[tid] += vmem[tid+<span class="number">4</span>];</span><br><span class="line">  vmem[tid] += vmem[tid+<span class="number">2</span>];</span><br><span class="line">  vmem[tid] += vmem[tid+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></stride)分支的情况，因此考虑将最后64个数的计算进行展开，更改的kernel部分如下：></p><p>第一次计算是32个线程加上64个数据的后半部分，第二次计算时是前16个线程加上前32个数据的后16个，后16个线程也参与了计算，但计算的数据是无意义的，虽然这后16个线程会修改自己的数据，但是SM上线程的执行是同步的，当这16个线程要修改自己的值时，前16个线程已经读取了需要的后16个线程的上一轮数据，并计算完写入了，这也是要用volatile写入和读取数据的原因。</p><p>在实际的测试中，这个优化并没有效果，和上面的8次展开的计算时间是基本完全一致的，说明上述的问题对性能影响不大，但展开的思路仍然是值得学习的。</p><p>这里要指出，参考博客的作者通过本步优化得到了可见的性能提升，经过我自己的测试，发现性能的提升并不来源于这里，而很可能是来自于以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(idx + blockDim.x*(blockPerthread<span class="number">-1</span>) &lt; size)&#123;</span><br><span class="line">  <span class="type">int</span> tmp0;</span><br><span class="line">  tmp0 = a[tid + blockDim.x];</span><br><span class="line">  tmp0 += a[tid + blockDim.x * <span class="number">2</span>];</span><br><span class="line">  tmp0 += a[tid + blockDim.x * <span class="number">3</span>];</span><br><span class="line">  tmp0 += a[tid + blockDim.x * <span class="number">4</span>];</span><br><span class="line">  tmp0 += a[tid + blockDim.x * <span class="number">5</span>];</span><br><span class="line">  tmp0 += a[tid + blockDim.x * <span class="number">6</span>];</span><br><span class="line">  tmp0 += a[tid + blockDim.x * <span class="number">7</span>];</span><br><span class="line">  a[tid] += tmp0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果每个语句都是a[tid]的+=操作，时间刚好是作者测试的8次展开的0.0012左右的时间，修改为以上后，时间变为了0.0010xx甚至0.00095，优化了对a[tid]的写入。这里对cpu编程这样的代码编译器会不会自动优化没有印象，但至少GPU是不会的，因此可以得到可见的性能提升。</p><h3 id="2-6-动态并行"><a href="#2-6-动态并行" class="headerlink" title="2.6 动态并行"></a>2.6 动态并行</h3><p>CUDA支持在内核中启动内核，能让复杂内核更加有层次，这样就可以动态调整负载，并且通过内核中启动内核减少数据传输消耗及启动开销。在频繁启动内核的场景下，这是有必要的。有些类似openmp的task并行。</p><p>内核中启动的子线程网格和线程全部结束后，父线程和网格才可以结束。线程启动子网格是隐式同步的，即所有线程会同步启动子网格和子线程。</p><p><img src="/2024/10/10/CUDA%20NOTE1/3_26.png" alt="img" style="zoom:50%;"></p><p>核函数内部以相同的方式启动新的子网格，完成嵌套启动，书中给出了嵌套启动helloworld和嵌套规约的例子。</p><h2 id="3-全局内存"><a href="#3-全局内存" class="headerlink" title="3 全局内存"></a>3 全局内存</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>CUDA的内存模型比CPU要更丰富一些，GPU上的内存设备有：</p><ul><li>寄存器</li><li>共享内存</li><li>本地内存</li><li>常量内存</li><li>纹理内存</li><li>全局内存</li></ul><p>每种内存都有自己的作用域，生命周期和缓存行为。每个线程都有自己的私有的本地内存，而共享内存是线程块内所有线程可见的，所有线程都能读取常量内存和纹理内存，但这两部分是只读的。全局内存，常量内存和纹理内存都有相同的生命周期。</p><p><img src="/2024/10/10/CUDA%20NOTE1/1-5.png" alt="img" style="zoom: 33%;"></p><p><strong>寄存器</strong></p><p>寄存器是速度最快的内存。GPU的寄存器比CPU要更多。核函数内声明的变量都存储在寄存器中，定义的常数长度的数组也是在寄存器中分配地址的，而不像CPU在主存上。</p><p>寄存器是线程私有的。生命周期是核函数内部。Fermi架构中每个线程最多63个寄存器，Kepler结构最多255个寄存器。如果线程使用的寄存器越少，常驻线程块就越多。SM上并发的线程块越多。</p><p>如果变量太多导致寄存器溢出，数据就会存储在本地内存。可以在编译选项中加入-maxrregcount=32控制一个编译单元里所有核函数使用的寄存器最大数量。</p><p><strong>本地内存</strong></p><p>本地内存的存储的变量只可能是使用未知索引引用的本地数组，可能占用大量寄存器空间的数组或结构体，溢出的变量。现在的设备，本地内存都存储在每个SM的一级缓存或设备的二级缓存上。</p><p><strong>共享内存</strong></p><p>核函数中__share__修饰的内存称为共享内存。每个SM都有一定数量的由线程块分配的共享内存，共享内存是片上内存，延迟低，带宽高。其类似于一级缓存，但是可以被编程。共享内存和寄存器一样，需要避免使用过多导致活跃线程束数量减少。</p><p>共享内存在核函数内声明，生命周期和线程块一致。因为共享内存是块内线程可见的，所以就有竞争问题的存在，需要通过同步避免内存竞争。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __syncthreads();</span><br></pre></td></tr></table></figure><p>注意，__syncthreads();频繁使用会影响内核执行效率。</p><p>SM中的一级缓存，和共享内存共享一个64k的片上内存，他们通过静态划分，划分彼此的容量，运行时可以通过下面语句进行设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t cudaFuncSetCacheConfig(const void * func,enum cudaFuncCache);</span><br></pre></td></tr></table></figure><p>这个函数可以设置内核的共享内存和一级缓存之间的比例。cudaFuncCache参数可选如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cudaFuncCachePreferNone//无参考值，默认设置</span><br><span class="line">cudaFuncCachePreferShared//48k共享内存，16k一级缓存</span><br><span class="line">cudaFuncCachePreferL1// 48k一级缓存，16k共享内存</span><br><span class="line">cudaFuncCachePreferEqual// 32k一级缓存，32k共享内存</span><br></pre></td></tr></table></figure><p>Fermi架构支持前三种，后面的设备都支持。</p><p><strong>常量内存</strong></p><p>常量内存驻留在设备内存中，每个SM都有专用的常量内存缓存。内存常量通过__constant__在核函数外声明。对于所有设备，只可以声明64k的常量内存，常量内存静态声明，并对同一编译单元中的所有核函数可见。常量内存被主机端初始化后不能被核函数修改，初始化函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaMemcpyToSymbol</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* symbol,<span class="type">const</span> <span class="type">void</span> *src,<span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>当线程束中所有线程都从相同的地址取数据时，常量内存表现较好，比如执行某一个多项式计算，系数都存在常量内存里效率会非常高，但是如果不同的线程取不同地址的数据，常量内存就不那么好了，因为常量内存的读取机制是：<br>一次读取会广播给所有线程束内的线程。</p><p><strong>纹理内存</strong></p><p>纹理内存驻留在设备内存中，在每个SM的只读缓存中缓存，纹理内存是通过指定的缓存访问的全局内存，只读缓存包括硬件滤波的支持，它可以将浮点插入作为读取过程中的一部分来执行，纹理内存是对二维空间局部性的优化。<br>总的来说纹理内存设计目的应该是为了GPU本职工作显示设计的，但是对于某些特定的程序可能效果更好，比如需要滤波的程序，可以直接通过硬件完成。</p><p><strong>全局内存</strong></p><p>一般在主机端代码里定义，也可以在设备端定义，不过需要加修饰符，只要不销毁，是和应用程序同生命周期的。使用__device__在设备代码中静态声明全局内存变量。</p><p>因为全局内存的性质，当有多个核函数同时执行的时候，如果使用到了同一全局变量，应注意内存竞争。</p><p><strong>缓存</strong></p><p>与CPU缓存类似，GPU缓存不可编程，其行为出厂是时已经设定好了。GPU上有4种缓存：</p><ol><li>一级缓存</li><li>二级缓存</li><li>只读常量缓存</li><li>只读纹理缓存</li></ol><p>每个SM都有一个一级缓存，所有SM共用一个二级缓存。一级二级缓存的作用都是被用来存储本地内存和全局内存中的数据，也包括寄存器溢出的部分。Fermi，Kepler以及以后的设备，CUDA允许我们配置读操作的数据是使用一级缓存和二级缓存，还是只使用二级缓存。<br>与CPU不同的是，CPU读写过程都有可能被缓存，但是GPU写的过程不被缓存，只有加载会被缓存。<br>每个SM有一个只读常量缓存，只读纹理缓存，它们用于设备内存中提高来自于各自内存空间内的读取性能。</p><p><strong>静态全局变量</strong></p><p>除了cudaMalloc的动态分配全局内存，还可以在全局内存上静态分配变量，调用的是常量的memCpy接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">__device__ <span class="type">float</span> devData;</span><br><span class="line">__global__ <span class="type">void</span> <span class="title function_">checkGlobalVariable</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Device: The value of the global variable is %f\n&quot;</span>,devData);</span><br><span class="line">    devData+=<span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> value=<span class="number">3.14f</span>;</span><br><span class="line">    cudaMemcpyToSymbol(devData,&amp;value,<span class="keyword">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Host: copy %f to the global variable\n&quot;</span>,value);</span><br><span class="line">    checkGlobalVariable&lt;&lt;&lt;<span class="number">1</span>,<span class="number">1</span>&gt;&gt;&gt;();</span><br><span class="line">    cudaMemcpyFromSymbol(&amp;value,devData,<span class="keyword">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Host: the value changed by the kernel to %f \n&quot;</span>,value);</span><br><span class="line">    cudaDeviceReset();</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意与常量不同的是参数是变量标识符，而不是取址。并且这个内存也不能通过cudaMemcpy赋值。</p><h3 id="3-2-内存管理"><a href="#3-2-内存管理" class="headerlink" title="3.2 内存管理"></a>3.2 内存管理</h3><h4 id="3-2-1内存的分配，释放与数据传输"><a href="#3-2-1内存的分配，释放与数据传输" class="headerlink" title="3.2.1内存的分配，释放与数据传输"></a>3.2.1内存的分配，释放与数据传输</h4><p>在全局内存分配和释放方面，GPU和CPUS是类似的，使用cudaMalloc分配数据，并通过传输获取主机的数据。CPU到GPU的内存传输非常慢，因此要尽可能减少传输。</p><p><img src="/2024/10/10/CUDA%20NOTE1/4-3.png" alt="4-3" style="zoom: 33%;"></p><p>主机内存是分页管理的，一块内存可能在不连续的页上，可能发生物理换页，为了避免传输操作中出现换页，CUDA驱动会锁定页面，或分配固定的主机内存，再进行两次数据移动。</p><p><img src="/2024/10/10/CUDA%20NOTE1/4-4.png" alt="4-4" style="zoom: 33%;"></p><p>左侧就是两次数据移动。如果要使用右侧得到预先分配固定内存，需要使用以下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaMallocHost</span><span class="params">(<span class="type">void</span> ** devPtr,<span class="type">size_t</span> count)</span></span><br><span class="line">cudaError_t <span class="title function_">cudaFreeHost</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br></pre></td></tr></table></figure><p>这些内存的数据可以直接传输到设备，因此memcpy的时间比主机普通malloc内存进行传输的时间更短。但是这样的固定内存的释放和分配成本比可分页内存高，而且会影响实际的可用物理内存空间。</p><h4 id="3-2-2零拷贝内存"><a href="#3-2-2零拷贝内存" class="headerlink" title="3.2.2零拷贝内存"></a>3.2.2零拷贝内存</h4><p>一般情况，主机不能访问设备内存，设备不能直接访问主机内存，但零拷贝内存是个例外。GPU可以直接访问零拷贝内存，这部分内存在主机内存。</p><p>零拷贝内存是固定内存，不可分页，并且使用时要注意与主机的内存竞争。使用以下方式分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaHostAlloc</span><span class="params">(<span class="type">void</span> ** pHost,<span class="type">size_t</span> count,<span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br></pre></td></tr></table></figure><ul><li>cudaHostAllocDefalt</li><li>cudaHostAllocPortable</li><li>cudaHostAllocWriteCombined</li></ul><ul><li>cudaHostAllocMapped</li></ul><p>cudaHostAllocDefalt和cudaMallocHost函数一致，cudaHostAllocPortable函数返回能被所有CUDA上下文使用的固定内存，cudaHostAllocWriteCombined返回写结合内存，在某些设备上这种内存传输效率更高。cudaHostAllocMapped产生零拷贝内存。<br>零拷贝内存虽然不需要显式的传递到设备上，但是设备还不能通过pHost直接访问对应的内存地址，设备需要访问主机上的零拷贝内存，需要先获得另一个地址，这个地址帮助设备访问到主机对应的内存，方法是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cudaError_t <span class="title function_">cudaHostGetDevicePointer</span><span class="params">(<span class="type">void</span> ** pDevice,<span class="type">void</span> * pHost,<span class="type">unsigned</span> flags)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>FLAGS必须为0,。零拷贝内存比设备主存更慢，在CPU和GPU共用内存等特殊情况下才有较好的表现。</p><h4 id="3-2-3统一虚拟寻址"><a href="#3-2-3统一虚拟寻址" class="headerlink" title="3.2.3统一虚拟寻址"></a>3.2.3统一虚拟寻址</h4><p>在设备架构2.0后，NVIDA提出了UVA，设备内存和主机内存就都映射到相同的虚拟内存地址空间，使用上面的零拷贝内存，就不需要获取DEVICE POINTER了。</p><h4 id="3-2-4统一内存寻址"><a href="#3-2-4统一内存寻址" class="headerlink" title="3.2.4统一内存寻址"></a>3.2.4统一内存寻址</h4><p>设备在6.0版本后，NVIDIA又提出了统一内存寻址。统一内存中创建一个托管内存池，内存池中的空间可被主机和设备用相同指针访问。底层系统会自动进行设备和主机间的数据传输，是完全透明的。 在后续小节会介绍统一内存寻址。</p><h3 id="3-3-内存访问模式"><a href="#3-3-内存访问模式" class="headerlink" title="3.3 内存访问模式"></a>3.3 内存访问模式</h3><p>许多应用都是访存受限型，最大程度的利用全局内存的高带宽是非常重要的。前述的执行模型已经说明了cuda执行的基本单位是线程束，本节要研究的是线程束对全局内存的访问情况。</p><p>全局内存在硬件上大致是下图所示。</p><p><img src="/2024/10/10/CUDA%20NOTE1/1-1.png" alt="1-1" style="zoom:50%;"></p><p>SM独占L1，共享L2，还有常量缓存和只读缓存。</p><p>核函数从全局内存读取数据只有两种粒度：32字节 / 128字节。(有点类似缓存行)</p><p>如果启用一级缓存，加载数据的粒度为128字节，如果通过编译指令停用L1只用L2，粒度是32字节。</p><p>SM执行的基础是线程束，只要有一个线程访存，其他31个线程也要访存，因此最小粒度是32。</p><p>在优化内存访问的时候关注的是两个特性：</p><ul><li>对齐内存访问</li><li>合并内存访问</li></ul><p>以下图为例，如果访存刚好是128-255，一次访存就可以</p><img src="/2024/10/10/CUDA%20NOTE1/4-6.png" class title="4-6"><p>如果是127-255，就会需要两次(0-127和128-255)，用利用率来衡量的话，取得数据只有一半是用到的，利用率只有一半。更极端的场景下，利用率最低只有1/128。</p><p><strong>全局内存读取</strong></p><p>尝试从全局内存读取数据的过程为L1-&gt;L2-&gt;DRAM，编译选项<code>-Xptxa -dlcm=cg</code>会关闭L1，访存直接从L2开始，有些GPU的L1只用来存储溢出的寄存器，不用来缓存。</p><p>下面是一些访问缓存的对齐情况，非常直观所以不做说明。</p><img src="/2024/10/10/CUDA%20NOTE1/4-9.png" class title="4-9"><img src="/2024/10/10/CUDA%20NOTE1/4-10.png" class title="4-10"><img src="/2024/10/10/CUDA%20NOTE1/4-11.png" class title="4-11"><img src="/2024/10/10/CUDA%20NOTE1/4-12.png" class title="4-12"><img src="/2024/10/10/CUDA%20NOTE1/4-13.png" class title="4-13"><p>没有L1缓存的情况是类似的，只是粒度变成了32，好处是可能提高利用率，尤其是对上述的第五种分散访存的情况。</p><p><strong>只读缓存</strong></p><p>只读缓存最初是留给纹理内存的，但在3.5以上的设备，只读缓存也可以和L1一样缓存全局内存数据，粒度为32。有两种方法指导内存从只读缓存读取。</p><ul><li>使用函数_ldg</li><li>在间接引用的指针上使用修饰符</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__global__ <span class="type">void</span> <span class="title function_">copyKernel</span><span class="params">(<span class="type">float</span> * in,<span class="type">float</span>* out)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> idx=blockDim*blockIdx.x+threadIdx.x;</span><br><span class="line">    out[idx]=__ldg(&amp;in[idx]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>全局内存写入</strong></p><p>内存的写入和读取通常在缓存中有不同的策略。对于Fermi和Kepler GPU上L1不能用于写入，写入是从L2开始的，粒度同样为32.</p><p><strong>结构体数组与数组结构体</strong></p><p>AoS是数组，元素是结构体，SoA是结构体，成员是数组。显然对于GPU而言，每个线程访问的成员是一样的，如果使用AoS，数据是不连续的。使用SoA效果会更好。</p><img src="/2024/10/10/CUDA%20NOTE1/4-22.png" class title="4-22"><h3 id="3-4核函数可达到的带宽"><a href="#3-4核函数可达到的带宽" class="headerlink" title="3.4核函数可达到的带宽"></a>3.4核函数可达到的带宽</h3><p>在之前我们已经学习了两种方法改善内核性能：</p><ul><li>最大化线程束的数量隐藏内存延迟</li><li>对齐和合并访问</li></ul><p>如果内存访问模式本身是效率不高的，上述方式可能没有很好的效果，本节以矩阵转置为例来说明如何优化核函数的内存访问。</p><p>本节研究的二维矩阵的转置如下：</p><p><img src="/2024/10/10/CUDA%20NOTE1/4-4-1.png" alt="4-4-1" style="zoom:50%;"></p><p>由于在内存中数据都是一维的，所以读取时数据是连续的，写入时将是分散的：</p><p><img src="/2024/10/10/CUDA%20NOTE1/4-4-2.png" alt="4-4-2" width="50%/"></p><p>因此如果按行读取数据，就是连续读和不连续写，而如果按列读取数据，就是不连续读和连续写。</p><p><img src="/2024/10/10/CUDA%20NOTE1/4-4-3.png" alt="4-4-3" style="zoom:50%;"></p><p>实际上，对于有限范围大小的数据，即便是非连续的读，数据也在L1中可以待后续读取使用。因此读取的利用率并没有那么低。但是反过来就不一样了，因为写入是不会写回到L1缓存，直接写回L2缓存的，因此写回是连续的效果会更好。</p><p>测量不同读写方式下的矩阵转置之前，需要知道GPU的理论带宽，才能知道利用了带宽的多少。这里直接使用babelStream来测量，当然不测量也是可以的，因为nsight compute提供的报告会有带宽利用率。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:UoB-HPC/BabelStream.git</span><br><span class="line">cd BabelStream</span><br><span class="line">mkdir build </span><br><span class="line">cd build</span><br><span class="line">cmake -DMODEL=cuda -DCMAKE_CUDA_COMPILER=&quot;D:\LenovoSoftstore\Install\NVDIA GPU Computing ToolkitCUDAv11.4\bin\nvcc.exe&quot; -DCUDA_ARCH=sm_75 ..</span><br><span class="line">cmake --build .</span><br></pre></td></tr></table></figure><p><img src="/2024/10/10/CUDA%20NOTE1/image-20241019201010875.png" alt="image-20241019201010875" style="zoom:50%;"></p><p>接下来就可以试试按行读取，不连续写入和按列读取，连续写入这两种方式的带宽：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>::chrono;</span><br><span class="line"><span class="comment">//连续读 不连续写</span></span><br><span class="line">__global__ <span class="type">void</span> <span class="title function_">transpose1</span><span class="params">(<span class="type">double</span> *ma, <span class="type">double</span> *mb, <span class="type">int</span> nx, <span class="type">int</span> ny)</span>&#123;</span><br><span class="line">    <span class="type">int</span> ix = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    <span class="type">int</span> iy = blockIdx.y * blockDim.y + threadIdx.y;</span><br><span class="line">    <span class="keyword">if</span>(ix&lt;nx &amp;&amp; iy &lt;ny)&#123;</span><br><span class="line">        mb[iy + ix * ny ] = ma[ix + iy * nx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不连续读 连续写</span></span><br><span class="line">__global__ <span class="type">void</span> <span class="title function_">transpose2</span><span class="params">(<span class="type">double</span> *ma, <span class="type">double</span> *mb, <span class="type">int</span> nx, <span class="type">int</span> ny)</span>&#123;</span><br><span class="line">    <span class="type">int</span> ix = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    <span class="type">int</span> iy = blockIdx.y * blockDim.y + threadIdx.y;</span><br><span class="line">    <span class="keyword">if</span>(ix&lt;ny &amp;&amp; iy&lt;nx)&#123;</span><br><span class="line">        mb[ix + nx * iy] = ma[iy + ny * ix];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> nx = <span class="number">1</span>&lt;&lt;<span class="number">12</span>;</span><br><span class="line">    <span class="type">int</span> ny = <span class="number">1</span>&lt;&lt;<span class="number">12</span>;</span><br><span class="line">    <span class="type">double</span> *matrix_h = (<span class="type">double</span> *)<span class="built_in">std</span>::<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>)*nx*ny);</span><br><span class="line">    <span class="type">double</span> *matrix_da, *matrix_db;</span><br><span class="line">    cudaMalloc(&amp;matrix_da, <span class="keyword">sizeof</span>(<span class="type">double</span>)*nx*ny);</span><br><span class="line">    cudaMalloc(&amp;matrix_db, <span class="keyword">sizeof</span>(<span class="type">double</span>)*nx*ny);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> dimx = <span class="number">32</span>;</span><br><span class="line">    <span class="type">int</span> dimy = <span class="number">32</span>;</span><br><span class="line">    dim3 <span class="title function_">block</span><span class="params">(dimx, dimy)</span>;</span><br><span class="line">    dim3 <span class="title function_">grid</span><span class="params">((nx+dimx<span class="number">-1</span>)/dimx, (ny+dimy<span class="number">-1</span>)/dimy)</span>;</span><br><span class="line">    cudaMemcpy(matrix_da, matrix_h, <span class="keyword">sizeof</span>(<span class="type">double</span>)*nx*ny, cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> start = high_resolution_clock::now();</span><br><span class="line">    transpose1&lt;&lt;&lt;grid, block&gt;&gt;&gt;(matrix_da, matrix_db, nx, ny);</span><br><span class="line">    cudaDeviceSynchronize();</span><br><span class="line">    <span class="keyword">auto</span> end = high_resolution_clock::now();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;method 1:%lf\n&quot;</span>,duration_cast&lt;duration&lt;<span class="type">double</span>&gt;&gt;(end-start).count());</span><br><span class="line">    </span><br><span class="line">    start = high_resolution_clock::now();</span><br><span class="line">    transpose2&lt;&lt;&lt;grid, block&gt;&gt;&gt;(matrix_da, matrix_db, nx, ny);</span><br><span class="line">    cudaDeviceSynchronize();</span><br><span class="line">    end = high_resolution_clock::now();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;method 2:%lf\n&quot;</span>,duration_cast&lt;duration&lt;<span class="type">double</span>&gt;&gt;(end-start).count());</span><br><span class="line"></span><br><span class="line">    cudaMemcpy(matrix_h, matrix_db, <span class="keyword">sizeof</span>(<span class="type">double</span>)*nx*ny, cudaMemcpyDeviceToHost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>差距是相当明显的。上面代码连续运行了两个函数，为了排除缓存的影响，实际测试时每次只运行其中之一：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">method 1:0.004210</span><br><span class="line">method 2:0.003033</span><br></pre></td></tr></table></figure><p>连续读不连续写</p><img src="/2024/10/10/CUDA%20NOTE1/image-20241019210456237.png" class title="image-20241019210456237"><p>连续写不连续读，显然写回的数据量有明显下降。内存吞吐量也有显著提升，利用的带宽明显比上一种高。</p><img src="/2024/10/10/CUDA%20NOTE1/image-20241019210355943.png" class title="image-20241019210355943"><p>2.5节介绍了循环展开，对于转置这个例子也尝试进行展开，然而性能却没有什么变化，这里个人认为是因为这个核函数主要是访存受限，而循环展开在访存上并没有显著提升。我尝试运行了作者的代码，也没有性能提升，和原文记录的数据不符。</p><p>另外一个优化尝试是调整块的大小，发现调整块大小为8*32，在两种方式上都有显著提升，在第一种方法上性能甚至翻倍了。通过nsight comput可以看到是L2写回主存利用的带宽大大提升了，这里很可能是因为L2是共享的，并且写回的性能比读的性能更关键，减小块的大小，有利于写回时命中L2，从而实现更高的写入带宽。</p><p>8*32的连续读不连续写，核函数的时间为1.7msec。</p><img src="/2024/10/10/CUDA%20NOTE1/image-20241021102234103.png" class title="image-20241021102234103"><p>8*32的连续写不连续读，吞吐量甚至略超过了babel stream测量的带宽，时间为1.5msec。</p><img src="/2024/10/10/CUDA%20NOTE1/image-20241021102549344.png" class title="image-20241021102549344"><p>最后书上还提到了DRAM的读取如果太集中可能会排队，可以考虑让相邻的线程块映射到不相邻的数据块，避免这个问题。不过这个问题根据参考博客，是否真实存在存疑，并且上述修改块大小后，吞吐量已经略超过带宽峰值，应该不会有显著性能提升了，这里也不做测试了。</p>]]></content>
      
      
      <categories>
          
          <category> HPCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《并行计算与高性能计算》简记</title>
      <link href="/2024/09/23/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E4%B8%8E%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/"/>
      <url>/2024/09/23/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E4%B8%8E%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>并行计算与高性能计算》阅读简记。</p><h2 id="第一部分-并行计算介绍"><a href="#第一部分-并行计算介绍" class="headerlink" title="第一部分 并行计算介绍"></a>第一部分 并行计算介绍</h2><ul><li><p>并行计算的基本定律：</p><ul><li>Amdahl定律</li><li>强标度：总体问题规模确定，处理器数量增加，求解时间的变化。</li><li>弱标度：单个处理器处理的问题规模确定，处理器数量增加，求解时间的变化。</li></ul></li><li><p>并行方法(模型)：共享内存，消息传输，数据并行，流处理(GPU)。</p></li><li>算数强度：每个内存(4/8字节的数据)执行浮点运算次数。</li><li>理论性能峰值：虚拟核心数 × 频率 × 向量位 × FMA / (32或64)。</li><li>理论内存带宽：传输速率 × 通道数 × 访问字节数 × 插槽数。</li><li>实证测试：stream、cpufp。</li><li>Roofline模型</li></ul><p><img src="/2024/09/23/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E4%B8%8E%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/1620281-20220319105314544-314453643.png" alt="image" style="zoom: 50%;"></p><ul><li>面向内存带宽的数据结构设计：<ul><li>连续的二维数组分配。</li><li>结构数组、数组结构、混合结构，根据数据的使用情况确定合适的方式。</li></ul></li><li>除了尽量将连续访问的内存分配在一起，一次完成可预知大小的分配比碎片化的分配要效果更好</li></ul><h2 id="第二部分-CPU并行"><a href="#第二部分-CPU并行" class="headerlink" title="第二部分 CPU并行"></a>第二部分 CPU并行</h2><p>向量化的部分介绍了手动向量化和编译器自动向量化的方式，比较常规。</p><h3 id="OpenMP多线程并行"><a href="#OpenMP多线程并行" class="headerlink" title="OpenMP多线程并行"></a>OpenMP多线程并行</h3><p>OpenMP的部分除了介绍基本用法外，还介绍了一些重要的影响性能的细节：</p><ul><li>first touch：内存位置会分配到在第一次访问该地址的线程所在的位置，在此之前仅存在于虚拟地址空间的页表中，因此让每个线程first touch需要计算的数据有利于访存</li><li>高级OpenMP：当程序有多次OpenMP并行时，可以只启动并行段一次，将整体程序全部包含在其中，串行的部分通过线程号控制主线程处理，并且通过nowait最小化barrier和可能的同步操作</li></ul><p>书中给出了几个示例。这里也尝试一下前面提到的内存相关的优化效果。</p><p><strong>Example: SplitStencil</strong></p><div class="table-container"><table><thead><tr><th>opt</th><th>time</th></tr></thead><tbody><tr><td>baseline</td><td>27.459721</td></tr><tr><td>memopt</td><td>14.876064</td></tr><tr><td>omp4线程</td><td>10.687703</td></tr><tr><td>omp(一次并行启动4线程)</td><td>10.937465</td></tr></tbody></table></div><p>这里一次启动没有什么效果，暂不确定原因。但是memopt作用很明显。另外多线程效果也非常差。在另一台机器上多线程效果好一些，一次启动同样没有明显的效果，可能是启动开销并不大，memopt也没有效果，应该是原本的分配方式也刚好malloc到了统一的内存位置。关于性能上的差异和产生的问题，需要进一步profile才能确定原因。</p><p><strong>Example: PrefixScan</strong></p><p>排他前缀和的并行算法，首先将数据整体进行分块，每个线程首先计算自己块内的排他前缀和，此时每个线程的第一个位置为0，然后由主线程串行更新偏移，设定每个线程j的第一个位置为前j-1个线程的排他前缀和，这个值为j-1的起始位置+线程j-1的最后一个位置的排他前缀和+最后一个位置的值，特殊处理线程块内只有两个元素的情况，此时上一区间没有排他前缀和或者说为0，已经在处理上一个线程数据时修改了。最后再并行将每个块的第一个值也就是真正的前缀加到块内每一个数据上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrefixScan</span> <span class="params">(<span class="type">int</span> *input, <span class="type">int</span> *output, <span class="type">int</span> length)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Get the total number of threads and thread_id</span></span><br><span class="line">   <span class="type">int</span> nthreads = <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> thread_id   = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _OPENMP</span></span><br><span class="line">   nthreads = <span class="built_in">omp_get_num_threads</span>();</span><br><span class="line">   thread_id = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Compute the range for which this thread is responsible.</span></span><br><span class="line">   <span class="type">int</span> tbegin = length * ( thread_id     ) / nthreads;</span><br><span class="line">   <span class="type">int</span> tend   = length * ( thread_id + <span class="number">1</span> ) / nthreads;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Only perform this operation if there is a positive number of entries.</span></span><br><span class="line">   <span class="keyword">if</span> ( tbegin &lt; tend ) &#123;</span><br><span class="line">       <span class="comment">// Do an exclusive scan for each thread</span></span><br><span class="line">       output[tbegin] = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> ( <span class="type">int</span> i = tbegin + <span class="number">1</span> ; i &lt; tend ; i++ ) &#123;</span><br><span class="line">          output[i] = output[i<span class="number">-1</span>] + input[i<span class="number">-1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (nthreads == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Do adjustment to prefix scan for the beginning value for each thread</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _OPENMP</span></span><br><span class="line">   <span class="comment">// Wait until all threads get here. </span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp barrier</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">// On the master thread compute the beginning offset for each thread</span></span><br><span class="line">   <span class="keyword">if</span> (thread_id == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">1</span> ; i &lt; nthreads ; i ++ ) &#123;</span><br><span class="line">         <span class="type">int</span> ibegin = length * ( i - <span class="number">1</span> ) / nthreads;</span><br><span class="line">         <span class="type">int</span> iend   = length * ( i     ) / nthreads;</span><br><span class="line">         <span class="comment">//ibegin是前一个线程块之前的数据的前缀和，iend是当前块的第一个位置</span></span><br><span class="line">         <span class="keyword">if</span> ( ibegin &lt; iend ) </span><br><span class="line">            output[iend] = output[ibegin] + input[iend<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> ( ibegin &lt; iend - <span class="number">1</span> )</span><br><span class="line">            output[iend] += output[iend<span class="number">-1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp barrier</span></span><br><span class="line">   <span class="comment">// Start all threads again</span></span><br><span class="line">   <span class="comment">// Apply the offset to the range for this thread.</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp simd</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="type">int</span> i = tbegin + <span class="number">1</span> ; i &lt; tend ; i++ ) &#123;</span><br><span class="line">      output[i] += output[tbegin];</span><br><span class="line">   &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里把之前的前缀和放到了第一个位置，也可以换一种方式，对每个组最后一个元素求前缀和，这样每个组最后一个位置就是包含前面所有元素的前缀和，再更新整个组(除了最后一个位置)就可以了。</p><p>最后一节介绍了OpenMP的任务并行，使用#pragma omp task进行任务并行，然而仅给出了一个求和示例，没有更详细的介绍子句的用法，如果需要使用，还要阅读OpenMP的文档进一步学习。</p><h3 id="MPI并行"><a href="#MPI并行" class="headerlink" title="MPI并行"></a>MPI并行</h3><hr><h2 id="第三部分-GPU加速程序运行"><a href="#第三部分-GPU加速程序运行" class="headerlink" title="第三部分 GPU加速程序运行"></a>第三部分 GPU加速程序运行</h2><h3 id="1-GPU架构及概念"><a href="#1-GPU架构及概念" class="headerlink" title="1 GPU架构及概念"></a>1 GPU架构及概念</h3><p>介绍了很多概念性的基本知识，没有这本书的电子版，有一些图表不方便放上来。内容对于没接触过GPU计算的都很基础和必要，这里只记录一些概念。</p><ul><li>计算GPU的理论峰值：时钟频率(MHz)x计算单元数量(CU/SM)x处理单元数量(cores per CU)xflop/周期。对于NVIDIA最新的V100，CU有80个，单精度浮点core per CU为64，频率为1530MHz，其理论峰值为2(FMA) <em> 1530 </em> 80 * 64 / 10^6 = 15.6Tflop(单精度)。</li><li><p>理论带宽：内存时钟速率x内存总线(bit)x(1/8)x事务因子</p></li><li><p>测量GPU带宽：GPU stream benchmark，除了工具测量，带宽和roofline还可以在nsight compute看到。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:UoB-HPC/BabelStream.git</span><br><span class="line">cd BabelStream</span><br><span class="line">mkdir build </span><br><span class="line">cd build</span><br><span class="line">cmake -DMODEL=cuda -DCMAKE_CUDA_COMPILER=&quot;D:\LenovoSoftstore\Install\NVDIA GPU Computing ToolkitCUDAv11.4\bin\nvcc.exe&quot; -DCUDA_ARCH=sm_75 ..</span><br><span class="line">cmake --build .</span><br></pre></td></tr></table></figure><img src="/2024/09/23/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E4%B8%8E%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/image-20241012120208316.png" class title="image-20241012120208316"><ul><li>PCI总线是CPU与GPU之间的数据传输桥梁，版本目前称为PCI Express，已有六代。PCI总线的理论带宽为通道数x传输速率x开销因子x字节/8bit，新代的PCIe数据编码成本很小，因此开销因子接近100%。lspci可以获取PCI信息。或者桌面系统的NVDIA控制台也可以看到：</li></ul><p><img src="/2024/09/23/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E4%B8%8E%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/image-20241012150218456.png" alt="image-20241012150218456" width="50%"></p><ul><li>多GPU平台和MPI：多GPU平台通常需要使用MPI+GPU实现并行化，单个计算节点可以配置多个GPU，多个计算节点可以网络连接。当大量数据进行移动时，数据通过PCI总线发送可能称为性能的主要限制，在同一个计算节点，NVDIA GPUDirect或AMD DirectGMA可以在GPU之间传输数据，减少内存在GPU到处理器及系统内存之间的移动。NVDIA还退出了NVLink，取代GPU到GPU和GPU到CPU之间的连接，使用NVLink，数据传输速率可以达到300GB/s。</li><li>能耗的测量：使用制造商的热设计功率TDPx运行时间x处理器数量可以估计能耗上限。GPU的TDP比CPU一般更高，但是计算时间也更短。</li></ul><h3 id="2-GPU编程模型"><a href="#2-GPU编程模型" class="headerlink" title="2 GPU编程模型"></a>2 GPU编程模型</h3><p>CUDA部分单独阅读了一本书，内容都在另一份笔记里了。</p>]]></content>
      
      
      <categories>
          
          <category> HPCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Graph500</title>
      <link href="/2024/08/05/Graph500/"/>
      <url>/2024/08/05/Graph500/</url>
      
        <content type="html"><![CDATA[<h1 id="Graph500-Benchmarks"><a href="#Graph500-Benchmarks" class="headerlink" title="Graph500 Benchmarks"></a>Graph500 Benchmarks</h1><h2 id="1-Benchmark"><a href="#1-Benchmark" class="headerlink" title="1 Benchmark"></a>1 Benchmark</h2><h3 id="1-1-Overall"><a href="#1-1-Overall" class="headerlink" title="1.1 Overall"></a>1.1 Overall</h3><p>Graph 500是针对数据密集型计算问题设计的一个基准测试。该基准测试包括一个生成器，生成无向图给后两个内核使用，不允许修改使特定内核受益。后两个内核分别为广度优先搜索和单源最短路计算。三个内核都会计时。</p><p>基准测试执行步骤如下：</p><ul><li>生成边</li><li>构造图(kernel1，计时)</li><li>随机抽样64个度数为1的key，不包括自循环</li><li>对每个搜索键<ul><li>计算父数组(kernel2，计时)</li><li>验证父数组是否为正确的BFS搜索树</li></ul></li><li>对每个搜索键：<ul><li>计算父数组和距离数组(kernel3，计时)</li><li>验证父数组和距离向量是否为正确的单源最短路径搜索树</li></ul></li><li>计算输出性能信息</li></ul><p>性能信息是通过计时部分计算的。允许使用伪随机数抽样。后两个内核是分别单独进行的，而不是连续离开同一初始顶点。</p><h3 id="1-2-Generating-the-Edge-List"><a href="#1-2-Generating-the-Edge-List" class="headerlink" title="1.2 Generating the Edge List"></a>1.2 Generating the Edge List</h3><p>数据生成器会生成边的列表。每个边为元组(StartVertex，EndVertex，Weight)。如果只运行kernel2，可以不生成权重。生成的输入元组列表不得表现出任何可被计算内核利用的位置性。因此，顶点必须是随机的，并且必须将元组的随机排序呈现给kernel1。weight是单精度浮点[0,1]，顶点数为N。</p><p>Benchmark接受的唯一参数是SCALE，是顶点数的以二为底的对数，决定了N=2^SCALE。edgefactor为16，是边与顶点数的比率。M是边的数量，为edgefactor*N。</p><p>图的生成器是一种类似R-MAT的生成器。以邻接矩阵描述R-MAT，实现可以使用任何输出等效边元组列表的替代方法。R-MAT递归将图形邻接矩阵分为四个大小相等的分区A B C D，每次添加一条边，边选择概率为四个分区之一，概率为A = 0.57 B = 0.19 C = 0.19 D = 0.05。</p><p>图生成器在两个顶点之间创建少量的重复边以及自循环。在后续kernel中，可以忽略重复边、自循环和孤立的顶点，但必须将其包含在提供给第一个kernel的边缘列表中。该算法还生成具有高度局部性的数据元组。因此，作为最后一步，顶点数必须随机置换，然后shuffle边元组。</p><p>允许并行运行数据生成器。在这种情况下，必须确保顶点是全局命名的，并且生成的数据在本地内存中或跨处理器的全局位置不具有任何位置性。数据可以存储到RAM或磁盘，如果存储到磁盘，可以在启动kernel1前读取数据。生成和读取都是不计时的。</p><p>数据规模有五档：</p><h3 id="1-3-Kernel-1-–-Graph-Construction"><a href="#1-3-Kernel-1-–-Graph-Construction" class="headerlink" title="1.3 Kernel 1 – Graph Construction"></a>1.3 Kernel 1 – Graph Construction</h3><p>kernel 1可以将边列表转换为任何数据结构，但数据结构不能被后续kernel修改或在后续kernel之间修改。稀疏图有多种表示方式。生成图时仅有边列表和边列表大小，其他信息必须通过计算得出，例如顶点数。该过程计时。</p><h3 id="1-4-Sampling-64-Search-Keys"><a href="#1-4-Sampling-64-Search-Keys" class="headerlink" title="1.4 Sampling 64 Search Keys"></a>1.4 Sampling 64 Search Keys</h3><p>搜索键必须从图中的顶点中随机抽样。为避免琐碎的搜索，仅从连接到其他顶点的顶点中采样。他们的度数，不包括自循环，必须至少为一个。如果此类顶点少于 64 个，则运行少于 64 个搜索。此基准测试中的图形大小不应发生这种情况，但生成微不足道或几乎微不足道的图形的可能性不为零。使用的搜索键数包含在输出中，但此步骤是不计时的。</p><h3 id="1-5-Kernel-2-–-Breadth-First-Search"><a href="#1-5-Kernel-2-–-Breadth-First-Search" class="headerlink" title="1.5 Kernel 2 – Breadth First Search"></a>1.5 Kernel 2 – Breadth First Search</h3><p>BFS的输入和输出是指定的，并有一定的约束，但是具体的算法并不限制，只要能产生正确的搜索树。每次搜索必须是单独进行的。</p><p>对于每个搜索键，例程必须返回一个数组，其中包含有效的广度优先搜索父信息（每个顶点）。搜索键的父级是其自身(?)，树中未包含的任何顶点的父级是 -1。</p><h3 id="1-6-Kernel-3-–-Single-Source-Shortest-Paths"><a href="#1-6-Kernel-3-–-Single-Source-Shortest-Paths" class="headerlink" title="1.6 Kernel 3 – Single Source Shortest Paths"></a>1.6 Kernel 3 – Single Source Shortest Paths</h3><p>类似BFS，具体算法不做限制，只要能产生正确的距离向量。不能使用kernel2的结果，只能从一个初始顶点开始进行计算。</p><p>对于每个初始顶点，例程必须返回每个顶点与初始顶点之间的距离，以及有效的单源最短路径树中每个顶点的父顶点的距离。初始顶点的父项是其自身，而树中未包含的任何顶点的父项是 -1。</p><h3 id="1-7-Validation"><a href="#1-7-Validation" class="headerlink" title="1.7 Validation"></a>1.7 Validation</h3><p>验证时不要求与标准结果完全精确相同。也不要求使用最大SCALE进行验证。而是在适合被评估机器的最大数据集上执行这些算法并验证。</p><h3 id="1-8-输出及性能指标"><a href="#1-8-输出及性能指标" class="headerlink" title="1.8 输出及性能指标"></a>1.8 输出及性能指标</h3><p>为了衡量Graph 500性能，定义一个称为每秒遍历边数(TEPS)的指标。TEPS(n)=M/time(n)，M为无向边数。</p><p>输出包含SCALE edgefactor NBFS(搜索数)以及BFS和SSSP执行的时间，中位时间，TEPS的调和平均值等指标。</p><h2 id="2-Reference-code"><a href="#2-Reference-code" class="headerlink" title="2 Reference code"></a>2 Reference code</h2><p>Reference code的核心代码在src当中。为MPI并行。默认情况下processors per node应该为2的幂次方，如果不是，则需要定义-DPROCS_PER_NODE_NOT_POWER_OF_TWO。</p><h3 id="2-1-AML-active-message-lib"><a href="#2-1-AML-active-message-lib" class="headerlink" title="2.1 AML(active message lib)"></a>2.1 AML(active message lib)</h3><h4 id="2-1-1-overall"><a href="#2-1-1-overall" class="headerlink" title="2.1.1 overall"></a>2.1.1 overall</h4><p>AML是基于MPI的通信库，支持异步小消息传递，将多个小消息合并发送，减小通信开销。消息是异步传递的，传递后需要进行同步。使用时需要首先调用aml_init初始化，然后通过以下函数注册消息处理程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息处理程序应该为以下格式：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> fromPE, <span class="type">void</span>* data, <span class="type">int</span> dataSize)</span>; <span class="comment">//fromPE为发送方rank</span></span><br><span class="line"><span class="comment">//注册消息处理程序</span></span><br><span class="line">aml_register_handler(handler, handlerid);</span><br></pre></td></tr></table></figure><p>然后使用aml_send发送消息到其他节点，发送后调用aml_barrier确保消息处理完毕，最后调用aml_finalize结束使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aml_send(data, handlerid, dataSize, destPE)</span><br></pre></td></tr></table></figure><h4 id="2-1-2-implemention"><a href="#2-1-2-implemention" class="headerlink" title="2.1.2 implemention"></a>2.1.2 implemention</h4><p>AML首先在初始化中，对通信域进行了分隔：</p><ul><li>comm_intra：根据主机名将一个主机的进程划分在一个通信域内 </li><li>comm：在各个主机上有相同rank的进程划分在一个通信域内</li></ul><p>划分后进行亲和性绑定，将进程绑定在和local_rank对应的核上，通过pthread_setaffinity_np绑定。</p><p>接下来AML使用了MPI_Recv_init初始化几个异步接收操作。这是MPI-3引入的，不需要指定消息来源和标签，更加灵活。初始化的异步接收操作包括节点内的和跨节点的，还开辟了sendbuf，acks，nbuf。然后启动节点内部的异步接收，并初始化几个发送请求。这实际上是在实现<strong>One-sided communication</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点内部通信域也采取类似的初始化和启动</span></span><br><span class="line"><span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; num_groups; j++ ) &#123;</span><br><span class="line">sendsize[j] = <span class="number">0</span>; nbuf[j] = j;  acks[j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NRECV;i++)</span><br><span class="line">MPI_Start( rqrecv+i );</span><br><span class="line"><span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; NSEND; j++ ) &#123;</span><br><span class="line">MPI_Isend( <span class="literal">NULL</span>, <span class="number">0</span>, MPI_CHAR, MPI_PROC_NULL, <span class="number">0</span>, comm, rqsend+j );</span><br><span class="line">activebuf[j]=num_groups+j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>utils.c</strong></p><p>封装了一个set_global函数，初始化MPI环境，并封装了一个MPI数据类型packed_edge_mpi_type，该MPI数据类型是以下数据类型的封装：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">packed_edge</span> &#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> v0_low;</span><br><span class="line">  <span class="type">uint32_t</span> v1_low;</span><br><span class="line">  <span class="type">uint32_t</span> high; <span class="comment">/* v1 in high half, v0 in low half */</span></span><br><span class="line">&#125; packed_edge;</span><br></pre></td></tr></table></figure><p>封装了一个MPI_Alloc_mem。定义了一个取第一个大于等于x的2的幂次方的对数的函数。</p><p><strong>common.h</strong></p><p>定义了一组用于处理进程编号的宏。lgsize是节点进程数的对数。顶点是交错分布在节点上的，即若有4个顶点0 1 2 3，两个节点，则0 2在节点1，1 3在节点2。以及定义了边列表数据结构tuple_graph，边的数据可在文件中也可在内存中。还定义了一组宏，用于并行读入边列表的数据。</p>]]></content>
      
      
      <categories>
          
          <category> HPCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MPI4py</title>
      <link href="/2024/03/23/MPI4py/"/>
      <url>/2024/03/23/MPI4py/</url>
      
        <content type="html"><![CDATA[<p>mpi4py实现了MPI的很多接口，并可以方便的在多进程中传递python的数据结构，编写python多进程程序。</p><p><a href="https://mpi4py.readthedocs.io/en/stable/tutorial.html#running-python-scripts-with-mpi">https://mpi4py.readthedocs.io/en/stable/tutorial.html#running-python-scripts-with-mpi</a></p><span id="more"></span><p>在通信对象为python对象时，调用的方法是小写的，如Comm.send，Comm.recv，Comm.scatter等等。发送对象会作为参数传递给通信调用，接收对象则是值。</p><p>通信对象为缓冲区类数据时，调用的方法以大写字母开头，如Comm.Send、Comm.Recv、Comm.Bcast、Comm.Scatter、Comm.Gather。并且在传递时以元组形式传递类型，数量等，形式类似于[data, MPI.DOUBLE]，[data, count, MPI.DOUBLE]。而向量集合通信操作(Comm.Scatterv和Comm.Gatherv等)，参数需要指定为[data, count, displ, datatype]，count和dipl是整数值的序列。</p><p>mpi4py编写的程序通常使用<code>mpiexec -n 4 python script.py</code>这样的形式使用。</p><h3 id="1-通信"><a href="#1-通信" class="headerlink" title="1 通信"></a>1 通信</h3><p>一些一般对象通信的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI</span><br><span class="line"></span><br><span class="line">comm = MPI.COMM_WORLD</span><br><span class="line">rank = comm.Get_rank()</span><br><span class="line"><span class="comment"># Point to Point-----------------------------</span></span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    data = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">3.14</span>&#125;</span><br><span class="line">    comm.send(data, dest=<span class="number">1</span>, tag=<span class="number">11</span>)</span><br><span class="line"><span class="keyword">elif</span> rank == <span class="number">1</span>:</span><br><span class="line">    data = comm.recv(source=<span class="number">0</span>, tag=<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    data = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">3.14</span>&#125;</span><br><span class="line">    req = comm.isend(data, dest=<span class="number">1</span>, tag=<span class="number">11</span>)</span><br><span class="line">    req.wait()</span><br><span class="line"><span class="keyword">elif</span> rank == <span class="number">1</span>:</span><br><span class="line">    req = comm.irecv(source=<span class="number">0</span>, tag=<span class="number">11</span>)</span><br><span class="line">    data = req.wait()</span><br><span class="line"><span class="comment"># Collective---------------------------------- </span></span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    data = &#123;<span class="string">&#x27;key1&#x27;</span> : [<span class="number">7</span>, <span class="number">2.72</span>, <span class="number">2</span>+<span class="number">3j</span>],</span><br><span class="line">            <span class="string">&#x27;key2&#x27;</span> : ( <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;xyz&#x27;</span>)&#125;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    data = <span class="literal">None</span></span><br><span class="line">data = comm.bcast(data, root=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    data = [(i+<span class="number">1</span>)**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    data = <span class="literal">None</span></span><br><span class="line">data = comm.scatter(data, root=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>Numpy数组则是缓冲区数据类型，因此需要提前开辟空间，并使用大写字母开头的函数调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"></span><br><span class="line">comm = MPI.COMM_WORLD</span><br><span class="line">rank = comm.Get_rank()</span><br><span class="line">size = comm.Get_size()</span><br><span class="line"><span class="comment"># Point to Point---------------------------------------</span></span><br><span class="line"><span class="comment"># passing MPI datatypes explicitly</span></span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    data = numpy.arange(<span class="number">1000</span>, dtype=<span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">    comm.Send([data, MPI.INT], dest=<span class="number">1</span>, tag=<span class="number">77</span>)</span><br><span class="line"><span class="keyword">elif</span> rank == <span class="number">1</span>:</span><br><span class="line">    data = numpy.empty(<span class="number">1000</span>, dtype=<span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">    comm.Recv([data, MPI.INT], source=<span class="number">0</span>, tag=<span class="number">77</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># automatic MPI datatype discovery</span></span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    data = numpy.arange(<span class="number">100</span>, dtype=numpy.float64)</span><br><span class="line">    comm.Send(data, dest=<span class="number">1</span>, tag=<span class="number">13</span>)</span><br><span class="line"><span class="keyword">elif</span> rank == <span class="number">1</span>:</span><br><span class="line">    data = numpy.empty(<span class="number">100</span>, dtype=numpy.float64)</span><br><span class="line">    comm.Recv(data, source=<span class="number">0</span>, tag=<span class="number">13</span>)</span><br><span class="line"><span class="comment"># Collective-------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    data = np.arange(<span class="number">100</span>, dtype=<span class="string">&#x27;i&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    data = np.empty(<span class="number">100</span>, dtype=<span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">comm.Bcast(data, root=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">assert</span> data[i] == i</span><br><span class="line"></span><br><span class="line">sendbuf = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    sendbuf = np.empty([size, <span class="number">100</span>], dtype=<span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">    sendbuf.T[:,:] = <span class="built_in">range</span>(size)</span><br><span class="line">recvbuf = np.empty(<span class="number">100</span>, dtype=<span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">comm.Scatter(sendbuf, recvbuf, root=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">sendbuf = np.zeros(<span class="number">100</span>, dtype=<span class="string">&#x27;i&#x27;</span>) + rank</span><br><span class="line">recvbuf = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">    recvbuf = np.empty([size, <span class="number">100</span>], dtype=<span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">comm.Gather(sendbuf, recvbuf, root=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="2-I-O"><a href="#2-I-O" class="headerlink" title="2 I/O"></a>2 I/O</h3><p>这里和MPI有点区别，MPI的write_at_all是组文件I/O，进程读写相同的内容，而mpi4py中的write_at_all是和MPI的write_at一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpi4py <span class="keyword">import</span> MPI</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">amode = MPI.MODE_WRONLY|MPI.MODE_CREATE</span><br><span class="line">comm = MPI.COMM_WORLD</span><br><span class="line">fh = MPI.File.Open(comm, <span class="string">&quot;./datafile.contig&quot;</span>, amode)</span><br><span class="line"></span><br><span class="line">buffer = np.empty(<span class="number">10</span>, dtype=np.<span class="built_in">int</span>)</span><br><span class="line">buffer[:] = comm.Get_rank()</span><br><span class="line"></span><br><span class="line">offset = comm.Get_rank()*buffer.nbytes</span><br><span class="line">fh.Write_at_all(offset, buffer)</span><br><span class="line"></span><br><span class="line">fh.Close()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 高性能计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arm-Performance-Lib</title>
      <link href="/2024/03/13/Arm-Performance-Lib/"/>
      <url>/2024/03/13/Arm-Performance-Lib/</url>
      
        <content type="html"><![CDATA[<p>Arm Performance Libraries是ARM提供的ARM架构下的性能库，提供了Fortran和c的API，子程序包括BLAS，LAPACK。</p><p>doc：<a href="https://developer.arm.com/documentation/109408/0100/Compile-and-test-the-examples?lang=en">https://developer.arm.com/documentation/109408/0100/Compile-and-test-the-examples?lang=en</a></p><h2 id="一-安装与配置"><a href="#一-安装与配置" class="headerlink" title="一.安装与配置"></a>一.安装与配置</h2><p><strong>安装与配置</strong></p><p><a href="https://learn.arm.com/install-guides/armpl/">Arm Performance Libraries | Arm Learning Paths</a></p><p>安装ARMPL前需要有environment-modules包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install environment-modules</span><br><span class="line"><span class="built_in">source</span> /etc/profile.d/modules.sh</span><br></pre></td></tr></table></figure><p>如果报了bash: /usr/bin/tclsh: No such file or directory，说明缺少脚本语言tcl的包，<code>sudo apt install tcl</code>一下，再执行上述的<code>source /etc/profile.d/modules.sh</code>就可以了。</p><p>下载：<a href="https://developer.arm.com/Tools%20and%20Software/Arm%20Performance%20Libraries#Software-Download">https://developer.arm.com/Tools%20and%20Software/Arm%20Performance%20Libraries#Software-Download</a> (要注意gcc版本，要选和自己系统相符合或至少接近的)</p><p>Linux下安装ARMPL：(默认安装到/opt/arm下)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -xf arm-performance-libraries_23.10_Ubuntu-20.04_gcc-9.3.tar</span><br><span class="line"><span class="built_in">cd</span> arm-performance-libraries_23.10_Ubuntu-20.04/</span><br><span class="line">sudo ./arm-performance-libraries_23.10_Ubuntu-20.04.sh -a</span><br></pre></td></tr></table></figure><p>配置module files的路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> MODULEPATH=<span class="variable">$MODULEPATH</span>:/opt/arm/modulefiles</span><br></pre></td></tr></table></figure><p>之后<code>module avail</code>应该会出现类似：armpl/23.10.0_gcc-9.3。需要编译和使用armpl程序时：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module load armpl/23.10.0_gcc-9.3</span><br></pre></td></tr></table></figure><p>就可以使用armpl需要的环境了。</p><p><strong>测试</strong></p><p>在安装路径(默认为/opt/arm/armpl_23.10_gcc-9.3)下有一个examples文件夹，examples下有一些使用了armpl的程序和makefile，执行<code>make</code>会编译并运行这些程序，如果顺利完成，会提示Test passed OK，编写程序也可以从examples下的文件中寻找示例，命名是很规范的。</p><h2 id="二-编译与使用"><a href="#二-编译与使用" class="headerlink" title="二.编译与使用"></a>二.编译与使用</h2><p>在examples在的makefile可以看到程序编译的命令，下面以SpMV为例。</p><p>编译相关参数为(libspmv是另一个使用到的库)：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CXXOPTFLAGS = -mcpu=native -O3 -fopenmp -std=c++11 -I./libspmv/<span class="keyword">include</span> -L./libspmv/build -I$&#123;ARMPL_DIR&#125;/<span class="keyword">include</span> -L<span class="variable">$(ARMPL_DIR)</span>/lib -larmpl -lamath -lm -lspmv</span><br></pre></td></tr></table></figure><p>SpMV实现的代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">armpl_evaluation</span><span class="params">(SparseMatrixCOO *ordered_coo, <span class="type">char</span> *output_path)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">armpl_spmat_t</span> armpl_mat;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> alpha = <span class="number">1.0</span>, beta = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> creation_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> *x, *y;</span><br><span class="line">    SparseMatrixCSR *csr = (SparseMatrixCSR *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SparseMatrixCSR));</span><br><span class="line">    <span class="built_in">COO_to_CSR</span>(ordered_coo, csr);</span><br><span class="line">    y = (<span class="type">double</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">double</span>)*csr-&gt;nrows);</span><br><span class="line">    x = (<span class="type">double</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">double</span>)*csr-&gt;ncolumns);</span><br><span class="line">    <span class="built_in">generate_x</span>(x, csr-&gt;ncolumns);</span><br><span class="line">    </span><br><span class="line">    <span class="type">armpl_status_t</span> info = <span class="built_in">armpl_spmat_create_csr_d</span>(&amp;armpl_mat, csr-&gt;nrows, csr-&gt;ncolumns, csr-&gt;row_pointers, csr-&gt;col_indices, csr-&gt;values, creation_flags);</span><br><span class="line">    <span class="keyword">if</span> (info!=ARMPL_STATUS_SUCCESS) &#123; <span class="built_in">armpl_spmat_print_err</span>(armpl_mat); <span class="keyword">return</span> (<span class="type">int</span>)info;&#125;</span><br><span class="line">    <span class="comment">//不需要转置</span></span><br><span class="line">info = <span class="built_in">armpl_spmat_hint</span>(armpl_mat, ARMPL_SPARSE_HINT_SPMV_OPERATION, ARMPL_SPARSE_OPERATION_NOTRANS);</span><br><span class="line"><span class="keyword">if</span> (info!=ARMPL_STATUS_SUCCESS) &#123; <span class="built_in">armpl_spmat_print_err</span>(armpl_mat); <span class="keyword">return</span> (<span class="type">int</span>)info; &#125;</span><br><span class="line">    <span class="comment">//预计有多次调用</span></span><br><span class="line">info = <span class="built_in">armpl_spmat_hint</span>(armpl_mat, ARMPL_SPARSE_HINT_SPMV_INVOCATIONS, ARMPL_SPARSE_INVOCATIONS_MANY);</span><br><span class="line"><span class="keyword">if</span> (info!=ARMPL_STATUS_SUCCESS) &#123; <span class="built_in">armpl_spmat_print_err</span>(armpl_mat); <span class="keyword">return</span> (<span class="type">int</span>)info; &#125;</span><br><span class="line"></span><br><span class="line">info = <span class="built_in">armpl_spmv_optimize</span>(armpl_mat);</span><br><span class="line"><span class="keyword">if</span> (info!=ARMPL_STATUS_SUCCESS) &#123; <span class="built_in">armpl_spmat_print_err</span>(armpl_mat); <span class="keyword">return</span> (<span class="type">int</span>)info; &#125;</span><br><span class="line">    <span class="comment">//SpMV</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1</span>; i++) &#123;</span><br><span class="line">info = <span class="built_in">armpl_spmv_exec_d</span>(ARMPL_SPARSE_OPERATION_NOTRANS, alpha, armpl_mat, x, beta, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    info = <span class="built_in">armpl_spmat_destroy</span>(armpl_mat);</span><br><span class="line">    <span class="built_in">free</span>(x); </span><br><span class="line">    <span class="built_in">free</span>(y);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 高性能计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PETSc</title>
      <link href="/2024/03/12/PETSc/"/>
      <url>/2024/03/12/PETSc/</url>
      
        <content type="html"><![CDATA[<h2 id="一-安装-配置PETSc"><a href="#一-安装-配置PETSc" class="headerlink" title="一.安装/配置PETSc"></a>一.安装/配置PETSc</h2><p>PETSc需要MPI和BLAS库。还有gcc等基础包。mpich可以直接apt-get安装：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mpich</span><br></pre></td></tr></table></figure></p><p>如果不确定有没有安装BLAS/mpich，可以apt list —installed | grep blas找一下。</p><p>有了这两个之后<a href="https://petsc.org/release/install/download/#doc-download">下载</a>petsc，解压后执行<code>./configure</code>，接下来按照给出的提示完成安装就可以了。如果没有mpi或者blas，可以在后面加<code>--download-mpich --download-fblaslapack</code>。</p><p>PETSC有两个可设置的环境变量，分别是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PETSC_DIR=/path/to/petsc</span><br><span class="line">PETSC_ARCH=/</span><br></pre></td></tr></table></figure><p>PETSC这个环境变量的作用是指定特定的构建和配置，一般来说，在一般机器上会构建多个PETSC版本。默认情况下(按照上面的直接安装)是针对调试使用的，其路径为arch-linux-c-debug。还可以构建一个针对性能优化的版本(例如arch-linux-opt)。</p><p>以上已经编译了一个调试使用的版本，接下来构建一个arch-linux-opt配置的版本，和上面是类似的，运行以下命令，然后根据给出的提示完成安装配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure PETSC_ARCH=arch-linux-opt --with-debugging=no COPTFLAGS=<span class="string">&quot;-O3 -march=armv8-a&quot;</span> CXXOPTFLAGS=<span class="string">&quot;-O3 -march=armv8-a&quot;</span> FOPTFLAGS=<span class="string">&quot;-O3 --march=armv8-a&quot;</span></span><br></pre></td></tr></table></figure><h2 id="二-编译-运行PETSc程序"><a href="#二-编译-运行PETSc程序" class="headerlink" title="二.编译/运行PETSc程序"></a>二.编译/运行PETSc程序</h2><p>上述工作后，PETSc就编译好了。编写PETSC程序时引入头文件，就可以使用相应的API。编译PETSC程序前，都要保证环境变量中有PETSC_DIR和PETSC_ARCH，可以在编译前进行export，也可以直接写入~/.bashrc。然后使用以下命令编译程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpicxx -o main main.cpp -I<span class="variable">$&#123;PETSC_DIR&#125;</span>/include -I<span class="variable">$&#123;PETSC_DIR&#125;</span>/<span class="variable">$&#123;PETSC_ARCH&#125;</span>/include -L<span class="variable">$&#123;PETSC_DIR&#125;</span>/<span class="variable">$&#123;PETSC_ARCH&#125;</span>/lib -lpetsc</span><br></pre></td></tr></table></figure><p>运行的时候可能会发现报<code>error while loading shared libraries: libpetsc.so.3.20: cannot open shared object file: No such file or directory</code>，PETSC动态库没有链接上，遇到这种情况可以将其添加到动态库路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#找不到.so的位置可以find一下：</span></span><br><span class="line">find / -name libpetsc.so.3.20</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/root/petsc-3.20.5/arch-linux-opt/lib:LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure><p>然后就可以运行程序了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpirun -n 1 ./main</span><br></pre></td></tr></table></figure><h2 id="三-PETSc的API"><a href="#三-PETSc的API" class="headerlink" title="三.PETSc的API"></a>三.PETSc的API</h2><p>PETSc的API可以在<a href="https://petsc.org/release/manualpages/">petsc.org</a>找到，文档编写的非常详细。下面以用PETSc解决SpMV问题为例，为了方便没有使用PetscCall()处理可能的错误，而且是编写SpMV测试时使用的，因此值是从定义好的矩阵格式获取再SetValue插入的，PETSc还支持SetValues直接插入数组来填充矩阵值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">petsc_evaluation</span><span class="params">(SparseMatrixCOO *ordered_coo, <span class="type">char</span> *output_path)</span></span>&#123;    </span><br><span class="line">    </span><br><span class="line">    Mat A;</span><br><span class="line">    PetscMPIInt rank;</span><br><span class="line">    <span class="type">double</span> *vecx = (<span class="type">double</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">double</span>)*ordered_coo-&gt;ncolumns);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span> start, end;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span> elapsed;</span><br><span class="line"></span><br><span class="line">    PetscFunctionBeginUser;</span><br><span class="line">    <span class="built_in">PetscInitialize</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">MPI_Comm_rank</span>(PETSC_COMM_WORLD, &amp;rank);</span><br><span class="line">    <span class="built_in">MatCreate</span>(PETSC_COMM_WORLD, &amp;A);</span><br><span class="line">    <span class="built_in">MatSetType</span>(A, MATMPIAIJ);</span><br><span class="line">    <span class="built_in">MatSetSizes</span>(A, PETSC_DECIDE, PETSC_DECIDE, ordered_coo-&gt;nrows, ordered_coo-&gt;ncolumns);</span><br><span class="line">    <span class="built_in">MatSetFromOptions</span>(A);</span><br><span class="line">    <span class="built_in">MatSetUp</span>(A);</span><br><span class="line">    <span class="comment">// 填充矩阵的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ordered_coo-&gt;nnz;i++)&#123;</span><br><span class="line">        <span class="built_in">MatSetValue</span>(A, (PetscInt)ordered_coo-&gt;row_index[i], (PetscInt)ordered_coo-&gt;col_index[i], (PetscScalar)ordered_coo-&gt;values[i], INSERT_VALUES);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MatAssemblyBegin</span>(A, MAT_FINAL_ASSEMBLY);</span><br><span class="line">    <span class="built_in">MatAssemblyEnd</span>(A, MAT_FINAL_ASSEMBLY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建向量x</span></span><br><span class="line">    Vec x;</span><br><span class="line">    <span class="built_in">VecCreate</span>(PETSC_COMM_WORLD, &amp;x);</span><br><span class="line">    <span class="built_in">VecSetSizes</span>(x, PETSC_DECIDE, ordered_coo-&gt;ncolumns);</span><br><span class="line">    <span class="built_in">VecSetFromOptions</span>(x);</span><br><span class="line">    <span class="built_in">generate_x</span>(vecx, ordered_coo-&gt;ncolumns);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ordered_coo-&gt;ncolumns;i++) <span class="built_in">VecSetValue</span>(x, (PetscInt)i, (PetscScalar)vecx[i], INSERT_VALUES);</span><br><span class="line">    <span class="built_in">VecAssemblyBegin</span>(x);</span><br><span class="line">    <span class="built_in">VecAssemblyEnd</span>(x);</span><br><span class="line"></span><br><span class="line">    Vec y;</span><br><span class="line">    <span class="built_in">VecCreate</span>(PETSC_COMM_WORLD, &amp;y);</span><br><span class="line">    <span class="built_in">VecSetSizes</span>(y, PETSC_DECIDE, ordered_coo-&gt;ncolumns);</span><br><span class="line">    <span class="built_in">VecSetFromOptions</span>(y);</span><br><span class="line">    <span class="built_in">VecAssemblyBegin</span>(y);</span><br><span class="line">    <span class="built_in">VecAssemblyEnd</span>(y);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> iterations;</span><br><span class="line">    <span class="keyword">if</span>(ordered_coo-&gt;nnz&gt;<span class="number">150000</span>) iterations = <span class="number">5000</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ordered_coo-&gt;nnz&gt;<span class="number">300000</span>) iterations = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">else</span> iterations = <span class="number">50000</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">        iterations = <span class="number">1</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//SpMV kernel</span></span><br><span class="line">    <span class="built_in">clock_gettime</span>(CLOCK_MONOTONIC_RAW, &amp;start);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;iterations; i++) &#123;</span><br><span class="line">        <span class="built_in">MatMult</span>(A, x, y);</span><br><span class="line">        <span class="built_in">PetscBarrier</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">clock_gettime</span>(CLOCK_MONOTONIC_RAW, &amp;end);</span><br><span class="line">    elapsed = (end.tv_sec - start.tv_sec) * <span class="number">1000000</span> + (end.tv_nsec - start.tv_nsec) / <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">//gflops</span></span><br><span class="line">    <span class="built_in">clock_gettime</span>(CLOCK_MONOTONIC_RAW, &amp;start);</span><br><span class="line">    <span class="built_in">MatMult</span>(A, x, y);</span><br><span class="line">    <span class="built_in">PetscBarrier</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">clock_gettime</span>(CLOCK_MONOTONIC_RAW, &amp;end);</span><br><span class="line">    <span class="type">double</span> flops_count = ordered_coo-&gt;nnz*<span class="number">2</span>;</span><br><span class="line">    <span class="type">double</span> sec = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / <span class="number">1e9</span>;</span><br><span class="line">    <span class="type">double</span> GFLOPS =  flops_count / (sec*<span class="number">1e9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(rank==<span class="number">0</span>)&#123;</span><br><span class="line">        FILE *fp;</span><br><span class="line">        fp = <span class="built_in">fopen</span>(output_path, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件 %s\n&quot;</span>, output_path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">&quot;%s %llu %lf\n&quot;</span>, <span class="string">&quot;petsc&quot;</span>, elapsed, GFLOPS);</span><br><span class="line">        <span class="built_in">fclose</span>(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    <span class="comment">//MatView(A, PETSC_VIEWER_STDOUT_WORLD);</span></span><br><span class="line">    <span class="comment">//VecView(x, PETSC_VIEWER_STDOUT_WORLD);</span></span><br><span class="line">    <span class="comment">//VecView(y, PETSC_VIEWER_STDOUT_WORLD);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(vecx);</span><br><span class="line">    <span class="built_in">VecDestroy</span>(&amp;x);</span><br><span class="line">    <span class="built_in">VecDestroy</span>(&amp;y);</span><br><span class="line">    <span class="built_in">MatDestroy</span>(&amp;A);</span><br><span class="line">    <span class="built_in">PetscFinalize</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 高性能计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Merge-based Sparse Matrix-Vector Multiplication (SpMV) using the CSR Storage Format</title>
      <link href="/2024/02/21/Merge-based%20Sparse%20Matrix-Vector%20Multiplication/"/>
      <url>/2024/02/21/Merge-based%20Sparse%20Matrix-Vector%20Multiplication/</url>
      
        <content type="html"><![CDATA[<h1 id="Merge-based-Sparse-Matrix-Vector-Multiplication-SpMV-using-the-CSR-Storage-Format"><a href="#Merge-based-Sparse-Matrix-Vector-Multiplication-SpMV-using-the-CSR-Storage-Format" class="headerlink" title="Merge-based Sparse Matrix-Vector Multiplication (SpMV) using the CSR Storage Format"></a>Merge-based Sparse Matrix-Vector Multiplication (SpMV) using the CSR Storage Format</h1><p>这是一篇来自PPoPP的2016年的文章。本篇文章是考虑提高负载均衡程度从而提高并行化效率来提高SpMV性能。不需要改变格式，而是直接对CSR的SpMV过程进行更改，从而实现平衡的工作负载分配。</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>作者提出了一个非常均衡的基于合并的并行SpMV。算法是对CSR格式的稀疏矩阵进行运算。作者的算法对输入数据集进行公平的分区，确保单个线程不会因分配给任意长的行或大量0长度的行而负载不均衡。这种并行分解不需要预处理，也不需要辅助数据格式。作者在CPU和GPU都评估了该方法，传统的SpMV表现不一致，而作者的方法在性能上基本不受行长度的影响。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>并行 SpMV 性能的主要设计问题是 (1) 统一处理器利用率和 (2) 内存带宽的有效利用 [4]。实现这些目标需要并行分解和矩阵存储格式化的补充策略，并且仍然是一个活跃的研究领域。</p><p>通过创新的矩阵格式化来提高 SpMV 性能需要付出巨大的实际成本。应用程序主要依赖通用压缩稀疏行 (CSR) 格式进行内存中表示。因此，需要替代格式的 SpMV 实现最终会给应用程序带来 (1) 格式转换的处理时间和 (2) 重复的矩阵存储空间的负担（因为原始 CSR 矩阵可能是其他例程需要的并且不能被丢弃）。相比之下，作者的“基于合并”的 CsrMV 并行化方法无需格式转换或增强即可提供高性能。</p><p>尽管 CSR 格式可以通过各个线程之间的行分配来进行直接的 SpMV 并行化，以实现私有化的行缩减，但当代并行 CsrMV 实现会因不规则的行长度和/或宽纵横比而导致数据相关的性能下降。或者，可以采用“非零分割”策略，其中为并行处理器分配非零数据的正则化部分（即，值和column_indices数组）。当每个处理器消耗其非零部分时，它必须通过 row_offsets 数组跟踪其进度。不平衡仍然是可能的，因为某些处理器可能比其他处理器消耗任意更多的行偏移量。已经开发了许多启发式方法来改善这些问题。威廉姆斯等人。调查了多核 CPU 的各种优化技术 [5]，Filippone 等人。调查了 60 多个 GPU 特定的变体 [2]。</p><p>然而，这两种总体策略都没有被证明是万能的。 (1) 更宽的并行处理器越来越容易受到未充分利用的影响，(2) 无标度数据集，其中少数行比其他行长多个数量级，以及 (3) 数据集具有大量与有向图中的“叶”顶点相对应的零长度行。对于 CPU 和 GPU 微架构，这些 CsrMV 策略在类似大小的矩阵中通常会出现一个或多个数量级的性能缺陷。</p><p>为了完全消除工作负载不平衡，作者的方法采用细粒度的 MergePath 分解 [3] 来合并两个排序列表，从而允许其实现分配相等的SpMV份额。结果是均匀地利用并行处理元件来提供可预测的良好性能，而不管行不规则性和倾斜如何。</p><p>作者方法的中心思想是将并行 CsrMV 分解构建为两个列表的逻辑合并：</p><ul><li>行描述符（例如，CSR 行偏移）</li><li>自然数（例如，CSR 非零值的索引）。</li></ul><p>作者使用整个佛罗里达大学稀疏矩阵集合（目前有 4,201 个重要数据集）进行评估。该实验语料库涵盖了广泛的稀疏模式，从结构良好的矩阵（典型的离散几何流形）到幂律矩阵（典型的网络图）。对于共享内存 CPU 和 GPU 架构，作者展示了 MKL 和 cuSPARSE CsrMV 在类似大小的矩阵中通常表现出一个或多个数量级的性能差异。作者的方法的实验结果中，性能与不规则行长度基本上不相关，而与问题大小高度相关，通常匹配或超过 MKL 和 cuSPARSE 的性能，对于中型和大型数据集分别实现 1.6 倍和 1.1 倍的平均加速，对于高度不规则的数据集高达 198 倍。作者的方法在特殊格式（CSB [15]、HYB [7]）方面也表现良好，即使是那些利用昂贵的每处理器和永久矩阵自动调整的格式（pOSKI [16]、yaSpMV [17]）。</p><h2 id="2-Background"><a href="#2-Background" class="headerlink" title="2 Background"></a>2 Background</h2><h3 id="2-1-通用稀疏矩阵格式"><a href="#2-1-通用稀疏矩阵格式" class="headerlink" title="2.1 通用稀疏矩阵格式"></a>2.1 通用稀疏矩阵格式</h3><p>COO是最简单的稀疏矩阵表示格式，能提供工作负载平衡，但通常无法实现高水平性能，因为存储开销较高。CSR格式则是最常见的通用格式。</p><h3 id="2-2-专用稀疏矩阵格式"><a href="#2-2-专用稀疏矩阵格式" class="headerlink" title="2.2 专用稀疏矩阵格式"></a>2.2 专用稀疏矩阵格式</h3><p>有许多专用于SpMV的格式，通过0填充或重组织规范计算和内存访问。</p><p>重组策略尝试将类似大小的行映射到共同调度的线程组上。 Bell 和 Garland 研究了一种分组 (PKT) 格式，该格式对矩阵进行分区，然后以平衡线程间工作的方式布置每个部分的条目 [21]。阿沙里等人。建议按长度对行进行分箱，以便可以一起处理长度相似的行[9]。 Sliced ELL 格式 [22] 可以提供类似的好处，因为它也按长度对行进行装箱。尽管这些启发式方法改善了许多场景的平衡，但它们的粗糙度仍然会导致处理器利用率不足。</p><p>许多专用格式还旨在通过索引压缩来减少内存 I/O。分块是上述存储格式的常见扩展，其中仅使用单个索引来定位小而密集的矩阵条目块。 （基于合并的 CsrMV 与阻塞兼容，因为 CSR 结构以相同的方式使用来引用稀疏块而不是单个稀疏非零。）其他复杂的压缩方案尝试优化矩阵的位编码，但通常会付出代价大量的格式化开销[23]，[24]。 yaSpMV BCCOO 格式是块压缩 COO 的一种变体，它使用位标志来存储与列索引一致的行索引 [17]。</p><p>混合和多层次的格式也很常见。矩阵可以划分为单独的区域，每个区域可以以不同的格式存储。 pOSKI 自动调整框架探索了广泛的多级阻塞方案 [16]。压缩稀疏块 (CSB) 格式是一种嵌套的 COO-of-COO 表示形式，其中两个级别的元组都保存在 Morton Z 顺序中 [15]。 HYB 格式结合了 ELL 部分和 COO 部分 [7]。苏等人。演示了一个基于 Cocktail 格式的自动调整框架，该框架将探索任意杂交 [25]。对于扩展阅读，威廉姆斯等人。探索多核 CPU 的一系列技术 [5]、[26] 和 Filippone 等人。对 GPU 的 SpMV 方法进行了全面的调查 [6]。</p><h3 id="2-3-现有CSR-SpMV的并行化策略"><a href="#2-3-现有CSR-SpMV的并行化策略" class="headerlink" title="2.3 现有CSR SpMV的并行化策略"></a>2.3 现有CSR SpMV的并行化策略</h3><p>整体来说，并行化有两种策略：行分割；按非零元素数进行划分。</p><p><strong>行分割</strong></p><p>这种方法将行进行分割分配给处理器，部分和在最后通过聚合得到结果。小于分割尺寸的行长还是会带来负载不均衡。分割可以静态完成，也可以动态完成。动态分割需要运行时分配，可能会导致处理器争用，并在大规模并行系统上可扩展性有限。</p><p>向量化是行分割的常见变体。分配线程处理每一行。向量化是基于GPU的典型实现。当行长度与SIMD宽度不对齐时，SIMD通道可能严重未充分利用。Greathouse 和 Daga [8] 以及 Ashari 等人的最新工作[9]基于行长度自适应向量化，从而避免了向量化CSR内核在短行上表现不佳的问题。然而，这些方法需要额外的存储和预处理时间，以使用捕获线程分配的补充数据结构来扩充 CSR 矩阵。</p><p><strong>非零元素分割</strong></p><p>基于行的并行化的替代方法是分配相等份额的非零数据。处理器通过在行偏移数组中搜索来确定其数据项属于哪些行。当每个处理器消耗其非零部分时，它必须通过行偏移数组跟踪其进度。 Dalton 等人的 CsrMV 并行化。 [27]和Baxter [28]将这种搜索作为离线预处理步骤来执行，将处理器特定的路点存储在补充数据结构中。 （尽管它们的命名法不同，但这些实现并不是基于合并的，而是非零分割的示例。）</p><p>如图 2b 所示，不平衡仍然是可能的，因为在存在空行的情况下，某些处理器可能比其他处理器消耗任意更多的行偏移。尽管这种超稀疏[29]矩阵在数值代数中相当罕见（非奇异方阵必须nnz ≥ n），但它们在图计算中经常出现。</p><p><img src="/2024/02/21/Merge-based%20Sparse%20Matrix-Vector%20Multiplication/image-20240222100012946.png" alt="image-20240222100012946" style="zoom: 67%;"></p><h3 id="2-4-CsrMV-工作负载不平衡的说明"><a href="#2-4-CsrMV-工作负载不平衡的说明" class="headerlink" title="2.4 CsrMV 工作负载不平衡的说明"></a>2.4 CsrMV 工作负载不平衡的说明</h3><p>图 3a 和图 4a 说明了不规则稀疏结构的未充分利用，展示了整个佛罗里达稀疏矩阵集合中的 MKL 和 cuSPARSE CsrMV 经过的运行时间性能。理想情况下，我们会观察到与数据集大小 (nnz) 高度相关的平滑、连续的性能响应。然而，许多性能异常值是显而易见的（尽管是在对数刻度上绘制的），通常比类似大小的数据集慢一两个数量级。这在 GPU 上尤其明显，其中并行效率尤其受到工作负载不平衡的阻碍。</p><p><img src="/2024/02/21/Merge-based%20Sparse%20Matrix-Vector%20Multiplication/image-20240222100430619.png" alt="image-20240222100430619" style="zoom:80%;"></p><p><img src="/2024/02/21/Merge-based%20Sparse%20Matrix-Vector%20Multiplication/image-20240222100532232.png" alt="image-20240222100532232" style="zoom:80%;"></p><p>此外，图 5 和图 6 突出显示了基于行的 CsrMV 在计算具有多列和少量行的短而宽的矩阵时常见的性能悬崖。我们使用 MKL 和 cuSPARSE 来计算稠密矩阵（以稀疏 CSR 格式存储）的不同纵横比的 CsrMV，所有矩阵都包含相同数量的非零值。当行数低于可用硬件线程上下文的数量时，性能会严重下降。尽管 CSR 格式是通用的，但这些实现通过纵横比来区分短、宽稀疏矩阵的整个类型。</p><p><img src="/2024/02/21/Merge-based%20Sparse%20Matrix-Vector%20Multiplication/image-20240222100721082.png" alt="image-20240222100721082" style="zoom:50%;"></p><h2 id="3-Merge-based-CSRMV"><a href="#3-Merge-based-CSRMV" class="headerlink" title="3 Merge-based CSRMV"></a>3 Merge-based CSRMV</h2><p>CSRMV分解类似于用于有效合并两个排序列表A和B的细粒度合并路径方法，该方法的基本属性是为处理器提供等份额的|A|+|B|步骤。</p><p><strong>3.1 并行路径合并</strong></p><p>此处描述的并行路径合并可视为对有序的A+B进行合并的选择路径，每次从A或B选择一个元素。图7显示了二维网格，x轴表示A的元素，y轴表示B的元素。决策路径从左上角开始，到右下角结束。当按顺序跟踪时，合并路径在消耗来自 A 的元素时向右移动，而在消耗来自 B 的元素时向下移动。因此，路径坐标描述了跨两个输入序列的元素比较和消耗的完整时间表。此外，每个路径坐标可以通过其网格对角线线性索引，其中对角线从左上角到右下角枚举。按照惯例，在比较相同值的项目时，合并的语义总是优先选择 A 中的项目而不是 B 中的项目。这导致了唯一一条决策路径。</p><img src="/2024/02/21/Merge-based%20Sparse%20Matrix-Vector%20Multiplication/image-20240222103904916.png" class title="image-20240222103904916"><p>为了跨 p 个线程并行化，网格被对角地切成 p 个宽度相等的条带，每个线程的工作是通过其条带建立决策路径的路线。使用算法 3 中提出的二维搜索过程可以独立找到任何给定的路径坐标 (i,j)。更具体地说，可以通过以下方式找到计划在对角线 k 处进行比较的两个元素 Ai 和 Bj沿对角线进行约束二分搜索：找到第一个 (i,j)，其中 Ai 大于 Bj 之前消耗的所有项目，假设 i+j=k。每个线程只需要搜索其条带中的第一个对角线；其路径段的其余部分可以通过从该起始坐标开始的顺序比较来简单地建立。</p><p><img src="/2024/02/21/Merge-based%20Sparse%20Matrix-Vector%20Multiplication/image-20240222110416167.png" alt="image-20240222110416167" style="zoom: 80%;"></p><h3 id="3-2-应用于CSR-SpMV"><a href="#3-2-应用于CSR-SpMV" class="headerlink" title="3.2 应用于CSR SpMV"></a>3.2 应用于CSR SpMV</h3><p>如图8，将行偏移与值索引和列索引向量逻辑合并，可以通过合并路径分解来计算CSRMV。这一合并不是物理进行的，只用于实现CSR的公平分配。根据设计，决策路径的每个连续垂直部分都对应 CSR 稀疏矩阵中的一行非零。当线程沿着合并路径向下移动时，它们会累积矩阵-向量点积。向右移动时，线程会将这些累积值刷新到 y 中相应的行输出端，并重置累加器。无论矩阵结构如何，总是将等量的 CsrMV 工作分配给并行线程。</p><img src="/2024/02/21/Merge-based%20Sparse%20Matrix-Vector%20Multiplication/image-20240222104801727.png" class title="image-20240222104801727"><h3 id="3-3-CPU实现"><a href="#3-3-CPU实现" class="headerlink" title="3.3 CPU实现"></a>3.3 CPU实现</h3><p>为了说明这种方法的简便性，算法 2 中介绍了基于 CsrMV 的并行 OpenMP C++ 合并实现的全过程。第 3-6 行确定合并列表和合并路径长度（总长度和每线程长度）。进入并行部分后，第 16-21 行确定线程的起点和终点对角线，然后在合并网格内搜索相应的二维起点和终点坐标。在第 24-32 行中，每个线程沿着其在合并路径中的份额有效执行顺序 CsrMV 算法 1。第 35-36 行为与下一个线程共享的部分行累积任何非零。第 39-40 行保存线程的运行总数和行标识，以便后续修复。回到顺序阶段，第 44-46 行更新跨多个线程的行的 y 值。</p><p>为了强调工作负载平衡的重要性，作者的实现除了附加线程亲和性以防止内核间的迁移外，没有执行任何针对特定架构的优化，没有明确采用软件流水线、分支消除、SIMD、高级指针运算、预取等任何优化方法。</p><img src="/2024/02/21/Merge-based%20Sparse%20Matrix-Vector%20Multiplication/image-20240222105742197.png" class title="image-20240222105742197"><h2 id="4-Evaluation"><a href="#4-Evaluation" class="headerlink" title="4 Evaluation"></a>4 Evaluation</h2><p>作者将CSRMV实现与MKL和cuSPARSE做了比较。为了突出基于合并的 CsrMV 方法的绝对竞争力，作者还将其与几种专门为容忍行长变化而设计的非 CSR 格式进行了比较：CSB [15]、HYB [7]、pOSKI [16] 和 yaSpMV [17]。表 2 进一步详细介绍了这些实现的特性。将预处理开销定义为一次性检查、编码或调整活动，其运行时间与任何后续 SpMV 计算分开计算。将其归一化为预处理时间与单次 SpMV 运行时间的比率。作者没有将基于合并的二进制搜索和修正算作预处理，而是算作 SpMV 运行时间的一部分。不过 NUMA 页面迁移作为预处理开销进行报告。</p><p>评估硬件由一个双插槽 NUMA CPU 平台组成，其中包括两个英特尔至强 E5-2690v2 CPU 和一个英伟达™（NVIDIA®）Tesla K40 GPU。每个 CPU 由 10 个内核组成，具有双向超线程（共 40 个线程）和 25MB 三级缓存（共 50MB）。它们共同实现了 77.9 GB/s 的 Stream Triad [34] 分数。K40 由 15 个 SM 组成，可同时执行 960 个warps，每个 32 个线程（共 30k 个线程），提供 1.5MB 的二级缓存。</p><p>图 9a 显示了每种实现将 SpMV 吞吐量与行长不规则解耦的程度。相对于 MKL 和 cuSPARSE CsrMV，基于合并的性能与行长不规则性的关系要小得多，甚至比专门的 GPU 格式还要好。</p><img src="/2024/02/21/Merge-based%20Sparse%20Matrix-Vector%20Multiplication/image-20240222110939367.png" class title="image-20240222110939367"><p>此外，图 9b 显示了每种实现符合 SpMV 运行时间与矩阵大小之间线性关系这一一般预期的程度。这一通用指标包含了 SpMV 计算中可能影响性能可预测性的所有方面，如缓存层次结构、非零局部性等。</p><p>基于合并的 CsrMV 在类似大小的矩阵中并非完全没有性能差异。这些不规则现象主要是由于高速缓存对密集向量 x 中不同访问模式的响应不同造成的。</p><p>图 10 显示了 SpMV 的相对速度。与 MKL CsrMV 相比，基于 CPU 合并的方法在高度不规则矩阵上的速度提高了 15.8 倍。 NUMA 感知变体能够更好地将这一优势扩展到无法在芯片上捕获的大型数据集，平均速度比 MKL 快 26%。此外， CsrMV 能够近似 CSB 和 pOSKI 实现的一致性，同时在很大程度上提高了它们的性能。这对于小型问题来说尤其如此，因为片外内存访问的延迟无法掩盖这些专用格式所增加的复杂性。</p><img src="/2024/02/21/Merge-based%20Sparse%20Matrix-Vector%20Multiplication/image-20240222111254705.png" class title="image-20240222111254705"><p>还有一些分析部分，这里略过了。</p><h2 id="5-Conclusion"><a href="#5-Conclusion" class="headerlink" title="5 Conclusion"></a>5 Conclusion</h2><p>随着现代处理器不断扩展并行性，工作负载不平衡很快就会成为 CSR SpMV 等分段计算的高阶性能限制因素。更糟糕的是，与数据相关的性能下降往往会给需要可预测性能响应的应用带来巨大挑战。在这项工作中，作者调整了基于合并的并行分解，直接在 CSR 矩阵上计算平衡良好的 SpMV，而无需离线分析、格式转换或构建边带数据。这种分解方法尤其适用于跨多尺度处理器和具有固定大小本地存储器的系统的约束工作负载。这项研究表明，当代的 CsrMV 方法性能不稳定，而作者提出的方法的性能响应却不受行长不规则性的影响。</p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Performance Optimization of SpMV by Considering Scheduling on CPUs</title>
      <link href="/2024/02/21/Performance_Optimization_of_SpMV_Using_CRS_Format_by_Considering_OpenMP_Scheduling_on_CPUs_and_MIC/"/>
      <url>/2024/02/21/Performance_Optimization_of_SpMV_Using_CRS_Format_by_Considering_OpenMP_Scheduling_on_CPUs_and_MIC/</url>
      
        <content type="html"><![CDATA[<h1 id="Performance-optimization-of-SpMV-using-CRS-format-by-considering-OpenMP-scheduling-on-CPUs-and-MIC"><a href="#Performance-optimization-of-SpMV-using-CRS-format-by-considering-OpenMP-scheduling-on-CPUs-and-MIC" class="headerlink" title="Performance optimization of SpMV using CRS format by considering OpenMP scheduling on CPUs and MIC"></a>Performance optimization of SpMV using CRS format by considering OpenMP scheduling on CPUs and MIC</h1><p>该篇论文是2014年发表的，比较久远了。作者关注的是通过调度对SpMV优化，测试了使用不同OpenMP调度方式和chunk_size对性能的影响，发现对于一些矩阵性能影响会比较大，因此以AT的方式，先测量最佳调度方式，此后再使用最佳方式。autotune的方式是当时比较多的研究，现在采用模型预测最佳方式的研究比较多了。对于小矩阵，静态方式更快，对于大矩阵，动态方式可能更快，这是选择调度方式的一个依据。</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>这项研究中，作者评估了CSR格式下SpMV的性能与OpenMP调度设置之间的关系，并对结果进行分析，表明OpenMP调度对SpMV性能有很大影响。作者通过改进调度设置提升了SpMV的性能。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>在SpMV中通过OpenMP进行并行化是非常常见的。作者的研究通过调度设置来提高SpMV的性能，不提出新的调度算法，而是有效利用现有的调度方法，使用 Fujitsu 的 SPARC64 IXfx CPU、Intel 的 Xeon CPU 和 Intel 的 Xeon Phi MIC 测量许多稀疏矩阵的性能。作者使用了一系列 OpenMP 调度参数并评估它们的性能。</p><p>本文的其余部分安排如下。第2节介绍了一些相关研究。第 3 节包含目标矩阵的一般描述。第 4 节描述了计算环境和实现。第 5 节介绍评估的结果。第 6 节解释了新方法在 OpenATLib 中 SpMV 函数中的应用。最后，第 7 节给出了结论。</p><h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2 Related Work"></a>2 Related Work</h2><p>作者之前发表了在 CPU[9] 和 GPU[10] 上计算 SpMV 的研究。还开发并提供了用于 CPU 的自动调整数值库，称为 OpenATLib 和 Xabclib [11]。这些库提供了一些用于 SpMV 计算的 SpMV 函数和数值求解器。之前的研究还没有针对 OpenMP 中的调度设置来探讨 SpMV 在当前多核 CPU 和 MIC 上的性能。因此本篇中作者关注调度设置来优化SpMV性能。</p><h2 id="3-Target-Matrices"><a href="#3-Target-Matrices" class="headerlink" title="3 Target Matrices"></a>3 Target Matrices</h2><p>为了分析稀疏矩阵与性能之间的一般关系，作者使用佛罗里达大学稀疏矩阵集合 [14] 中的 132 个稀疏矩阵作为目标矩阵。所有这些目标矩阵都是正定的。图 1 显示了目标矩阵中非零元素的数量和行数。最小非零元素数为 46，最小行数为 14（LFAT5 矩阵）。最大非零元素数为 77,651,847，最大行数为 943,695（audikw 1 矩阵）。</p><h2 id="4-Computational-Environment-and-Implementation"><a href="#4-Computational-Environment-and-Implementation" class="headerlink" title="4 Computational Environment and Implementation"></a>4 Computational Environment and Implementation</h2><p>在以下部分中，描述使用两个 CPU 和一个 MIC 作为评估环境（表 I）。第一个 CPU 是 Fujitsu SPARC64 IXfx CPU，安装在 Fujitsu FX10 超级计算机系统。第二个 CPU 是 Intel Xeon E5 CPU，MIC 是 Intel Xeon Phi。将这些环境分别称为 SPARC64、Xeon 和 MIC。</p><p>为了评估 OpenMP 调度设置与其性能之间的关系，使用各种 OpenMP 调度设置实现了 CSR 格式的基本 SpMV 内核。作者使用 Fortran (Fortran90) 和双精度浮点值作为数据类型。 OpenMP 的循环并行化由 Fortran 中的 omp do 和 C 语言中的 omp for 应用，但 OpenMP 规范[15]定义了一些额外的调度变体（子句），如下所示。</p><ul><li>Static scheduling<br>omp do/for schedule (static, chunk size)</li><li>Dynamic scheduling<br>omp do/for schedule (dynamic, chunk size)</li><li>Guided scheduling<br>omp do/for schedule (guided, chunk size)</li><li>Runtime scheduling<br>omp do/for schedule (runtime)</li></ul><p>应该注意的是，运行时调度使用环境变量在运行时从其他类型的调度中进行选择。此外，规范要求 no Schedule 子句的使用取决于实现，将其称为默认调度。在动态调度和引导调度中使用 no chunk size 子句与 chunk size = 1 相同。</p><p>作者实现并评估了默认调度和前三种调度方法，chunk_size取1-250，共754个测试(1+251+251+251)。</p><p>作者使用以下编译器、编译器选项和执行环境。对于 SPARC64，使用 Fujitsu Fortran 编译器 (frtpx 1.2.1) 并应用编译器选项：-Kfast、openmp、,间接预取、simd=2，使用 Fujitsu 用户指南中的示例。 OpenMP 线程数始终设置为 16。对于 Xeon，使用 ifort (IFORT) 14.0.2 并应用编译器选项：-xHOST -mcmodel=large -O2 -prec-div -openmp -align array32byte -shared-intel。 OpenMP 线程数始终设置为 20。对于 MIC，使用与 Xeon 相同的编译器并应用编译器选项： mcmodel=large -O2 -prec-div -openmp -align array64byte -mmic -shared-intel 。 OpenMP 线程数始终设置为 240。</p><h2 id="5-Performance-Evaluation"><a href="#5-Performance-Evaluation" class="headerlink" title="5 Performance Evaluation"></a>5 Performance Evaluation</h2><h3 id="5-1-Overaall-Performance"><a href="#5-1-Overaall-Performance" class="headerlink" title="5.1 Overaall Performance"></a>5.1 Overaall Performance</h3><p>本小节描述总体性能评估。每次计算都会执行到满足执行次数超过1000次且总时间为1.0s的条件。然后选择平均计算结果。</p><p>图 2 显示了每种硬件类型的评估结果。图 2 (a) 说明了使用默认调度的 SpMV 的性能 (GFLOPS)。图 2 中的其他图显示了静态调度、动态调度和引导调度与默认调度相比的相对性能。对于不同的块大小，这三种调度类型是最快的。 x 轴根据非零元素的数量进行排序，方式与图 1 类似。</p><p><img src="/2024/02/21/Performance_Optimization_of_SpMV_Using_CRS_Format_by_Considering_OpenMP_Scheduling_on_CPUs_and_MIC/image-20240221153918014.png" alt="image-20240221153918014" style="zoom: 67%;"></p><p>图2a显示性能与NNZ有关，NNZ超出缓存大小时，性能显著下降。</p><p>图 2 (b)、(c) 和 (d) 显示了所有三种硬件类型共有的一些性能趋势。</p><p>在小矩阵的情况下，默认调度和静态调度提供几乎相同的性能水平，并且它们都比动态调度和引导调度表现得更好。这是因为小矩阵的执行时间很短，动态调度需要一些处理线程的开销。这些结果表明，默认调度可以为小矩阵提供良好的性能，并且不可能通过优化这些矩阵中的调度来获得更好的性能。</p><p>大型矩阵的情况下，静态调度、动态调度和引导调度都优于某些矩阵的默认调度。对应的矩阵数量并不多，但对于某些矩阵，默认调度与其他方法的性能差异大于20%。因此可以认为这个结果表明优化的调度设置对性能有显着影响。作者还列出了这些矩阵，以及不同调度方式在三种硬件架构上相对于默认调度的最大加速比，此处就不列举了。这些矩阵被作者称为有利矩阵。</p><h3 id="5-2-Performance-Analysis"><a href="#5-2-Performance-Analysis" class="headerlink" title="5.2 Performance Analysis"></a>5.2 Performance Analysis</h3><p>上一小节报告的结果表明，优化调度对所有三种环境中 SpMV 的性能都有相当大的影响。然而，性能基于许多不同的块大小值。因此，本小节重点关注优势矩阵，并考虑性能和块大小之间的关系。</p><p>图 3 显示了有利矩阵的性能与块大小之间的关系。 x 轴按块大小排序。 y 轴显示采用默认调度的每个硬件的相对性能，其中值 1.0 是前面小节中采用默认调度的性能。所有图表均显示相对于默认调度的最大、最小和平均性能。最大性能表示与使用每个硬件系统的有利矩阵的默认调度相比的最高性能。类似地，最低性能表示与使用每个硬件系统的有利矩阵的默认调度相比的最低性能。平均性能是与使用每个硬件系统的有利矩阵的默认调度相比的平均性能。</p><img src="/2024/02/21/Performance_Optimization_of_SpMV_Using_CRS_Format_by_Considering_OpenMP_Scheduling_on_CPUs_and_MIC/image-20240221154812294.png" class title="image-20240221154812294"><p>对于 SPARC64，除非块大小非常小，否则最大性能和平均性能不会受到块大小的太大影响。相比之下，最低性能受块大小的影响。 SPARC64 上的最高平均性能是通过静态调度和块大小 = 92 获得的，其中性能比为 1.21。</p><p>对于 Xeon，性能趋势与 SPARC64 非常相似。然而，静态调度的相对性能低于其他调度类型。其最大性能通过动态调度获得，块大小=204，其中性能比为1.70。</p><p>在 MIC 的情况下，性能趋势也与其他非常相似，除了小块大小通过静态调度获得良好的性能。 MIC 的最高平均性能是通过动态调度和块大小 = 57 获得的，其中性能比为 1.23。</p><p>有些参数代表了稀疏矩阵的特征，例如行数、非零元素总数、每行平均非零元素数。作者预计有利矩阵与每行非零元素数量的分布之间存在很强的关联。因此，动态调度和引导调度可以解决负载均衡问题，并获得比静态调度更高的性能。然而，获得的结果表明静态调度的性能与其他调度类型相同，并且我们没有检测到调度设置与非零元素数量分布之间的强关系。这可能是因为行数足够大；这样就在一定程度上解决了负载均衡问题。此外，与静态调度相比，动态调度和引导调度在处理线程时会产生更大的开销，因此动态调度和引导调度的性能可能会下降。动态调度和引导调度可能比静态调度表现更好，因为 Xeon 的线程管理成本非常低。然而，动态调度和引导调度受到计算时序的影响，因此很难完整地分析执行时序。作者将在未来的研究中进行这种分析。</p><h2 id="6-Optimized-Scheduling-in-OpenATLib"><a href="#6-Optimized-Scheduling-in-OpenATLib" class="headerlink" title="6 Optimized Scheduling in OpenATLib"></a>6 Optimized Scheduling in OpenATLib</h2><h3 id="6-1-Approach-and-Implemention"><a href="#6-1-Approach-and-Implemention" class="headerlink" title="6.1 Approach and Implemention"></a>6.1 Approach and Implemention</h3><p>正如上一节所述，OpenMP 的调度会影响 SpMV 的性能。因此，我们的目标是通过优化调度来提高 SpMV 在各种应用中的性能。然而，优化 OpenMP 调度以获得良好性能的条件尚未完全阐明。因此，作者目标是使用自动调整（AT）技术来优化调度。</p><p>之前，作者研究了 AT 技术并开发了名为 OpenATLib 和 Xabclib[11] 的数值库。 OpenATLib 提供各种自动调整数值函数，Xabclib 包含一些使用 OpenATLib 的自动调整数值求解器。 OpenATLib 中有一个自动调整的双精度 SpMV 函数，称为“OpenATI DURMV”。该 SpMV 函数包含 SpMV 的多个实现以及用于选择最快实现的 AT 机制。图 4 显示了 OpenATI DURMV 的流程。</p><p><img src="/2024/02/21/Performance_Optimization_of_SpMV_Using_CRS_Format_by_Considering_OpenMP_Scheduling_on_CPUs_and_MIC/image-20240221155320736.png" alt="image-20240221155320736" style="zoom:67%;"></p><p>第一次计算时，会测试哪种计算方法是最优的，此后就沿用这种方法，尽管这会带来额外的开销，但是鉴于SpMV通常对相同矩阵进行非常多次，代价会被摊销。</p><p>OpenATLib 提供的现有 SpMV 实现如下：</p><ul><li>行分解法：行分解方法将目标矩阵划分为所需的线程数，以平衡每个线程处理的行数。此实现与上一节中的默认调度相同，其中块大小 = (非零元素数)/(线程数)。</li><li>标准化法：标准化 NZ 方法将目标矩阵划分为标准化每个线程处理的非零元素数量所需的线程数。该算法可以提供比行分解方法更好的性能，特别是当行中非零元素的数量存在较大差异时。</li><li>BSS方法：当行中的非零元素之间存在较大差异且难以对其进行平均时，BSS 方法非常有用。该方法基于原始SS方法，适用于向量处理器。 BSS 方法已被修改，以便在多核处理器上获得良好的性能。此方法可以将行拆分为子段并将这些段分配给多个线程。</li></ul><p>每种实现都有其优点和缺点。对于具有不平衡矩阵的 SpMV，行分解方法的性能较低。归一化 NZ 方法可能比行分解方法获得更好的性能，但性能很大程度上取决于行中元素数量之间的平衡。 BSS 方法适用于不平衡矩阵，但不适用于平衡矩阵，因为该方法需要额外的计算。因此，在执行之前很难确定哪种方法可以获得最佳性能，因此 AT 机制会很有用。</p><h3 id="6-2-评估"><a href="#6-2-评估" class="headerlink" title="6.2 评估"></a>6.2 评估</h3><p>为了评估优化调度的有效性，作者使用修改后的 OpenATI DURMV 测量数值求解器的性能，使用 Xabclib GMRES 函数。该函数求解线性方程问题Ax=b，其中A是大规模非对称稀疏矩阵，x是解向量，b是右侧向量。该算法的概述如图 5 所示。</p><p>作者使用三个有利矩阵和三个其他矩阵进行测试。评价结果如表2和图6所示。</p><p>对于有利矩阵，无论迭代次数如何，仅选择新的 SpMV 实现。改进的水平取决于目标矩阵，但是使用所有三个有利的矩阵都可以获得性能改进，除了在某些迭代次数非常少的情况下。对于其他矩阵，选择原始 SpMV 实现。尽管这些测量不包括搜索所需的时间（AT 开销），但在某些情况下会出现性能下降。这是因为运行 SpMV 所需的时间是可变的。可变性的影响通过多次迭代进行平均。然而，通过少量的迭代，效果就很明显。根据上一节中给出的结果，所有有利的矩阵都有望将性能提高 20% 以上，但并没有获得如此高的改进。作者认为这是由于缓存的可变性或行为造成的，其中 SpMV 以外的计算会更改缓存的状态。</p><p><img src="/2024/02/21/Performance_Optimization_of_SpMV_Using_CRS_Format_by_Considering_OpenMP_Scheduling_on_CPUs_and_MIC/image-20240221160316669.png" alt="image-20240221160316669" style="zoom: 67%;"></p><p>图 6 (b) 显示，通过大量迭代，所有三个有利矩阵都获得了性能改进。 AT 开销和性能改进相互抵消，因此在使用少量迭代时，cranskseg 1 矩阵会出现性能下降。然而，其他三个矩阵并没有提供我们预期的性能改进。为了减少AT开销，需要优化OpenATLib和Xabclib的AT机制。</p><p>总的来说，作者成功地确认了为每个目标矩阵选择了最佳的 SpMV 实现，并且在某些情况下减少了 SpMV 和 GMRES 的总执行时间。仅使用 SpMV（使用 Dubcova1 矩阵和 400 次迭代）的最佳性能改进为 26.7%，而使用相同 Dubcova1 矩阵和 400 次迭代的总体 GMRES 的最佳性能改进为 11.4%。这些结果证明了优化的调度方法的实用性及其在 OpenATLib 中的应用。</p><h2 id="7-Conclusion"><a href="#7-Conclusion" class="headerlink" title="7 Conclusion"></a>7 Conclusion</h2><p>在本研究中，作者使用 CRS 格式在两个 CPU（SPARC64 IXfx 和 Xeon）和一个 MIC（Xeon Phi）上评估了 SpMV 的性能。我们评估了许多目标矩阵，并将性能与各种类型的 OpenMP 调度设置进行了比较。与默认调度相比，使用有利矩阵获得的最高平均性能改进为：在 SPARC64（块大小 = 92 的静态调度）上提高 1.57 倍，在 Xeon（块大小 = 204 的动态调度）上提高 2.44 倍，在 MIC 上提高 2.11 倍（块大小 = 57 的动态调度）。因此，OpenMP调度对SpMV的性能有相当大的影响。</p><p>然而，并非所有矩阵都获得了这些性能改进，并且很难确定是否可以获得比默认调度更好的性能。因此作者测试了自动调整技术的使用。作者修改了 OpenATLib 的 SpMV 函数，并使用具有特定调度设置的 SpMV 作为附加 SpMV 内核。评估了 GMRES 求解器的性能，并确认在某些情况下可以获得比默认实现更好的性能。仅使用 SpMV 就成功获得了高达 26.7% 的性能提升，而使用整个 GMRES 流程则成功获得了高达 11.4% 的性能提升。</p><p>在未来的研究中，作者将分析非零元素的布局与最佳OpenMP调度方法之间的关系。正如第 5 节所述，这是一个具有挑战性的问题，并且影响很大。自动选择调度设置的快速变化也是一个重要问题。然而，也使用除CRS格式之外的矩阵格式。因此作者还将优化 SpMV 与这些其他格式的性能进行比较，并在未来的研究中对这些其他格式应用相同的方法。</p>]]></content>
      
      
      <categories>
          
          <category> 论文(略读) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Optimizing SpMV on Emerging Many-Core Architectures</title>
      <link href="/2024/02/20/Optimizing_SpMV_on_many_core_platform/"/>
      <url>/2024/02/20/Optimizing_SpMV_on_many_core_platform/</url>
      
        <content type="html"><![CDATA[<h1 id="Optimizing-SpMV-on-Emerging-Many-Core-Architectures"><a href="#Optimizing-SpMV-on-Emerging-Many-Core-Architectures" class="headerlink" title="Optimizing SpMV on Emerging Many-Core Architectures"></a>Optimizing SpMV on Emerging Many-Core Architectures</h1><p>本文实现了一个针对众核平台实现的自适应格式选择的模型，能够针对不同矩阵选择合适的压缩矩阵格式进行计算。两个众核平台分别为Intel KNL和FTP。选取的格式为CSR，CSR5，ELL，SELL，HYB。数据集采用suitsparce的900+个矩阵。</p><p>在实现SpMV时，只在KNL上做了向量化，而FTP没有进行向量化，因为ARM NEON没有gather/scatter指令，对不同位置数据的加载慢。经测试，在FTP上，SELL在最多矩阵中有最佳性能，而CSR，CSR5，HYB在一部分矩阵中有最佳性能，ELL则最差。</p><p>作者实现的模型为决策树，采用了一些基本特征来预测最合适的压缩格式，并进行计算。</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>本文全面研究了稀疏矩阵表示对两种众核架构(Intel KNL Xeon Phi和FT-2000Plus)上的计算性能。实验涉及956个稀疏矩阵和五种主流SpMV表示上执行的9500多次不同的分析运行。结果表明，最佳稀疏矩阵表示取决于底层架构和程序输入，作者使用机器学习来开发预测模型，首先使用一组训练示例进行离线训练，学习到的模型用于预测给定架构的最佳矩阵表示。模型在KNL和FTP上分别提供了平均95%和91%的最佳可用性能。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>已有的研究表明稀疏矩阵格式对性能有很大影响，最佳格式和架构及矩阵的大小和模式有关。虽然已经有大量在多核架构上优化SpMV的研究，但是没有明确不同的稀疏矩阵格式如何影响新型多核架构上的SpMV性能。</p><p>KNL和FTP集成了多个处理器内核，可提供潜在的高性能。而本研究中稀疏矩阵格式选取五种：CSR、CSR5、ELL、SELL和HYB。</p><p>作者的研究表明选取合适的格式对性能很重要，并建立了一个机器学习模型来选择合适的格式。模型的输入是矩阵的一些特征，输出是最合适的格式。作者的实验结果表明模型在格式的选择上是非常有效的。</p><h2 id="2-Background"><a href="#2-Background" class="headerlink" title="2 Background"></a>2 Background</h2><p>以下是稀疏矩阵存储的一些常见格式</p><p><strong>COO</strong></p><p>最基本的格式。</p><p><strong>CSR</strong></p><p>最常用的通用稀疏矩阵格式。对COO进行了进一步的压缩。</p><p><strong>CSR5</strong></p><p>为了对任何结构的稀疏矩阵实现负载均衡，CSR5首先将所有非零元素平均分为相同大小的2D块。当执行并行计算时，计算核心分配到多个2D块，并且核心的每个SIMD通道处理块的一列。</p><p>CSR5是CSR的扩展，有两个参数：ω和σ，分别为块的宽度和高度。在CSR的数据结构基础上，还引入了两个数据结构tile_ptr和tile_des。</p><p><strong>ELL</strong></p><p>ELLPACK是针对向量体系结构的，通过填充0将数据存储在M*K的数组中。K是行的最大非零元素数。ELLPACK会浪费一些空间，为了减少浪费，可以将其与其他格式进行结合。</p><p><strong>SELL &amp; SELL-C-σ</strong></p><p>SELL是将ELLPACK划分，相邻的C行一组。每组ELL格式。而SELL-C-σ进一步将组长度进行排序来节省空间。相邻的σ行是有序的，σ是C的倍数。</p><p><strong>HYB</strong></p><p>HYB是ELL和COO的结合，存储矩阵主要部分的元素为ELL格式，其余为COO格式。通常，HYB以ELL格式存储每行的典型非零数(K)，以COO格式存储特别长的行。K可以直接从输入矩阵计算出来。</p><h3 id="3-Experiment-Setup"><a href="#3-Experiment-Setup" class="headerlink" title="3 Experiment Setup"></a>3 Experiment Setup</h3><p><strong>FTP</strong></p><p>图二是FTP的高层次结构图示。该结构有64个ARMv8核，提供双精度最大512GFLOPS的性能，最大功耗100W，核的最大频率为2.4GHz，并分组为8 panel * 8 core。每个核有32KB L1，4核共享的2MB L2。panel通过DCU连接，核缓存都通过2D网格连接。外部 I/O 由 DDR4 内存控制器 (MC) 管理。</p><p><img src="/2024/02/20/Optimizing_SpMV_on_many_core_platform/image-20240220152836397.png" alt="image-20240220152836397" style="zoom: 67%;"></p><p><strong>KNL</strong></p><p>KNL的shaun高精度峰值性能为3Tflops/s。一个KNL通道最多有72核，每核可以以1.3GHz运行4个线程，每个核有32KB的L1数据和32KB的L1指令缓存，两个向量单元。</p><p>KNL的核被组织为32tile，每个tile两核，两核共享1MB的L2数据缓存，由cache/home agent (CHA)管理。tiles通过2D网格连接保证L2缓存的一致性。此外，KNL 芯片具有“近”和“远”存储组件。近存储器组件是多通道 DRAM (MCDRAM)，它们通过 MCDRAM 控制器 (EDC) 连接到区块。 “远”内存组件是 DDR4 RAM，通过 DDR 内存控制器 (DDR MC) 连接到芯片。虽然“近”内存比“远”内存小，但它提供的带宽是传统 DDR 的 5 倍。根据芯片的配置方式，某些部分或整个近存储器可以与远存储器共享全局存储器空间，或者用作缓存。在这种情况下，MCDRAM用于缓存模式，数据集可以保存在高速存储器中。</p><p><img src="/2024/02/20/Optimizing_SpMV_on_many_core_platform/image-20240220154723402.png" alt="image-20240220154723402" style="zoom:67%;"></p><p><strong>系统软件</strong></p><p>平台均为Linux系统，FTP的kernel为4.4.0，KNL的为3.10.0。编译选项为-O3，分别使用gcc和intel icc编译器。使用OpenMP实现多线程，FTP上64线程，KNL上272线程。</p><p><strong>数据集</strong></p><p>使用来自suitesparce的956个矩阵。NNZ范围为100K到20M。包含规则和不规则的矩阵，各种领域应用的矩阵。</p><p><strong>SPMV实现</strong></p><p>算法 1 使用 CSR5 格式作为示例说明了基于库的 SpMV 实现。库将 Matrix Market 格式的原始数据放入 COO 格式的内存中。然后基于 COO 的数据转换为目标存储格式（CSR、CSR5、ELL、SELL 或 HYB）。在计算SpMV时，使用OpenMP线程模型进行并行化。此过程与格式相关，即基本任务可以是行、块行或数据图块。</p><p><img src="/2024/02/20/Optimizing_SpMV_on_many_core_platform/image-20240220155217638.png" alt="image-20240220155217638" style="zoom:67%;"></p><p>计算结果向量y的单个元素被分割到不同任务中，需要收集部分结果。这种有效的数据收集可以通过使用内在函数手动向量化 SpMV 代码来实现。NEON没有gather和scatter功能，因此在FTP上不使用NEON intrinsics，因为实验表明使用intrinsics会导致性能的下降。测量性能时，运行FRQ次实验并计算平均结果。</p><h3 id="4-Memory-Allocation-and-Code-Vectorization"><a href="#4-Memory-Allocation-and-Code-Vectorization" class="headerlink" title="4 Memory Allocation and Code Vectorization"></a>4 Memory Allocation and Code Vectorization</h3><p>SpMV 性能取决于众核架构上的许多因素。其中包括内存分配和代码优化策略，以及稀疏矩阵表示。这项工作的重点是确定导致最快运行时间的最佳稀疏矩阵表示。为了隔离问题，需要确保在最佳的内存分配和代码优化策略上进行不同表示的性能比较。为此，作者研究了非均匀内存访问 (NUMA) 和代码矢量化如何影响 FTP 和 KNL 上的 SpMV 性能。然后作者对最佳的 NUMA 内存分配和矢量化策略进行了实验。</p><p><strong>NUMA 绑定</strong></p><p>FTP架构一组8核心连接到本地内存模块，可以间接访问远程内存模块，但速度较慢，实验使用numactl从正在运行的处理器的本地内存分配所需要的数据缓冲区。</p><p>图4是采用numactl的结果，性能明显比不使用numactl更好。</p><p><img src="/2024/02/20/Optimizing_SpMV_on_many_core_platform/image-20240220160212687.png" alt="image-20240220160212687" style="zoom:50%;"></p><p><strong>KNL上进行的向量化</strong></p><p>本研究的两个架构都支持SIMD。图5显示了KNL上SpMV的性能优化效果。作者没有对FTP上的SpMV进行向量化，因为NEON不支持gather指令，从不同位置载入数据的速度不够快。因此作者只向量化了KNL上的SpMV。</p><p><img src="/2024/02/20/Optimizing_SpMV_on_many_core_platform/image-20240220161040747.png" alt="image-20240220161040747" style="zoom:67%;"></p><p><strong>FTP与KNL的比较</strong></p><p>图6展示了KNL和FTP的性能比较。KNL在各种格式上都更快。性能差异来自于架构内存层次结构的差异。 KNL 与 FTP 的不同之处在于，它在 L2 缓存和 DDR4 内存之间有一个高速内存，又称 MCDRAM。 MCDRAM 可提供比传统 DDR 内存高 5 倍的内存带宽。数据集被载入MCDRAM高速内存，应用就可以以更高内存带宽访问数据，有更好的性能。此外，KNL对gather/scatter指令的支持也对性能的提升很关键。</p><p><img src="/2024/02/20/Optimizing_SpMV_on_many_core_platform/image-20240220161423421.png" alt="image-20240220161423421" style="zoom:50%;"></p><p>从图 6 中，还可以观察到 FTP 在某些矩阵上的性能优于 KNL，特别是当输入矩阵的大小较小时。性能差异是由于 KNL 和 FTP 在二级缓存中的容量和一致性协议方面有所不同。</p><p><strong>最佳矩阵格式</strong></p><p>图7展现了FTP和KNL上的SpMV性能。在 FTP 平台上，SELL 是大约 50% 稀疏矩阵的最佳格式，ELL 在大多数情况下表现最差。在KNL平台上，CSR在大多数情况下表现最佳，其次是CSR5和SELL。在 KNL 上，ELL 和 HYB 对于总共 64 个稀疏矩阵给出了最佳性能（表 II）。</p><p><img src="/2024/02/20/Optimizing_SpMV_on_many_core_platform/image-20240220162114855.png" alt="image-20240220162114855" style="zoom:50%;"></p><p>表 III 显示了在测试用例中使用固定格式时相对于最佳格式的平均减速情况。减速与给定格式最佳的频率呈负相关。例如，CSR 在 KNL 上提供了最佳的整体性能，因此它的整体减速程度最低。此外，SELL 和 HYB 在 FTP 上的平均速度相似，因为它们通常提供相似的性能（参见图 7(a)）。</p><p><img src="/2024/02/20/Optimizing_SpMV_on_many_core_platform/image-20240220162259989.png" alt="image-20240220162259989" style="zoom:50%;"></p><p>鉴于最佳稀疏矩阵存储格式因架构和输入而异，找到最佳格式是一项艰巨的任务。为了得到自适应方案，需要实现为给定的输入和架构自动选择正确的格式，在下一节将介绍如何实现这部分内容。</p><h2 id="5-Adaptive-Representation-Selection"><a href="#5-Adaptive-Representation-Selection" class="headerlink" title="5 Adaptive Representation Selection"></a>5 Adaptive Representation Selection</h2><h3 id="5-1-总体方法"><a href="#5-1-总体方法" class="headerlink" title="5.1 总体方法"></a>5.1 总体方法</h3><p>作者采用的方法的overview如下：</p><p><img src="/2024/02/20/Optimizing_SpMV_on_many_core_platform/image-20240220165642676.png" alt="image-20240220165642676" style="zoom:50%;"></p><p>预测模型是基于scikit-learn机器学习包实现的。</p><p>对于给定的稀疏矩阵，收集一组信息或特征，以捕获矩阵的特征。可以在编译时或运行时收集该组特征值。表 IV 列出了作者考虑的所有功能的完整列表。收集特征值后，基于机器学习的预测器（离线训练）接收特征值并预测目标架构应使用哪种矩阵表示。然后，将矩阵转换为预测格式并生成该格式的计算代码。</p><p><img src="/2024/02/20/Optimizing_SpMV_on_many_core_platform/image-20240220165824111.png" alt="image-20240220165824111" style="zoom:50%;"></p><h3 id="5-2-预测模型"><a href="#5-2-预测模型" class="headerlink" title="5.2 预测模型"></a>5.2 预测模型</h3><p>作者采用决策树作为预测最佳矩阵格式的模型。作者还尝试了其他的模型，包括回归、朴素贝叶斯和 K 最近邻。决策树的效果是最好的，并且与其他黑盒模型相比更便于分析和解释。</p><p>构建和使用此类模型遵循监督机器学习的 3 个步骤流程：(i) 生成训练数据 (ii) 训练预测模型 (iii) 使用预测器，如下所述。</p><p><strong>训练预测器</strong></p><p>训练预测模型的方法如图 9 所示。使用相同的方法为每个目标架构训练模型。为了训练预测器，首先需要为每个训练矩阵示例找到最佳的稀疏矩阵表示，并提取特征。然后使用这组数据和分类标签来训练预测模型。</p><p>使用五重交叉验证进行训练。这种标准机器学习技术的工作原理是选择 20% 的样本进行测试，并使用 80% 的样本进行训练。为了生成模型的训练数据，使用了 SuiteSparse 矩阵集合中的 756 个稀疏矩阵。使用每个稀疏矩阵表示多次执行 SpMV，直到在 95% 置信区间设置下置信区间上限和下限的差距小于 5%。然后在 KNL 和 FTP 上记录每个训练样本的最佳性能矩阵表示。最后从每个矩阵中提取所选特征集的值。</p><p>最佳矩阵表示标签及其相应的特征集被传递给监督学习算法。学习算法试图找到特征值和最佳表示标签之间的相关性。学习算法的输出是基于决策树的模型的一个版本。因为在本文中针对两个平台，所以构建了两个预测模型，每个平台一个模型。由于训练是离线执行的，并且对于给定的架构只需要执行一次，这是一次性成本。</p><p>模型的总训练时间由两部分组成：收集训练数据，然后构建模型。收集训练数据消耗了总训练时间的大部分，在本文中，两个平台花费了大约 3 天的时间。相比之下，实际构建模型所花费的时间可以忽略不计，不到 10 毫秒。</p><p><strong>特征</strong></p><p>构建成功的预测器的关键方面之一是开发正确的特征来表征输入。预测模型完全基于目标矩阵的静态特征，不需要动态分析。因此，它可以应用于任何硬件平台。这些特征是使用 Python 脚本提取的。由于作者的目标是开发一种可移植的、独立于架构的方法，因此作者不使用任何特定于硬件的功能。</p><p>在这项工作中，作者总共考虑了七个候选原始特征（表 IV）。一些特征是根据直觉根据可能影响 SpMV 性能的因素选择的，例如nnz frac和variation，其他特征是根据以前的工作选择的[33]。总而言之，候选特征应该能够代表 SpMV 内核的内在部分。</p><p>将特征传递给机器学习模型之前的最后一步是将特征向量的每个标量值缩放到公共范围（0 到 1 之间），以防止任何单个特征的范围成为影响其重要性的因素。缩放特征不会影响其值的分布或方差。为了在部署期间缩放新图像的特征，记录训练数据集中每个特征的最小值和最大值，并使用它们来缩放相应的特征。</p><p><strong>运行时部署</strong></p><p>预测模型的部署被设计得简单且易于使用。为此，作者的方法以 API 的形式实现。该 API 封装了所有内部工作，例如特征提取和矩阵格式转换。作者还提供了源到源转换工具，将给定 SpMV 内核的计算转换为每个目标表示。使用预测标签，运行时可以选择使用哪个 SpMV 内核。</p><h3 id="5-3-预测模型评估"><a href="#5-3-预测模型评估" class="headerlink" title="5.3 预测模型评估"></a>5.3 预测模型评估</h3><p>作者使用交叉验证来评估方法。将 965 个矩阵随机分为两部分：756 个用于训练的矩阵和 200 个用于测试的矩阵。学习一个具有训练矩阵和五种表示形式的模型。通过应用学习模型对 200 个测试矩阵进行预测来评估它。多次重复此过程，以确保每个矩阵至少测试一次。</p><p>图 10 显示，预测器在 FTP 和 KNL 上平均分别实现了最佳可用 SpMV 性能（通过详尽搜索发现）的 91% 和 95%。它优于仅使用单一格式的策略。正如在表三中分析的那样，SELL 和 HYB 可以在 FTP 上获得比其他三种格式更好的性能。但他们仍然被预测器超越。然而，在 KNL 上，预测器的性能是通过使用 CSR 表示来跟踪的。此外，使用 ELL 表示在 FTP 和 KNL 上的性能都很差。这表明预测器在选择正确的稀疏矩阵表示方面非常有效。</p><p><img src="/2024/02/20/Optimizing_SpMV_on_many_core_platform/image-20240220171702344.png" alt="image-20240220171702344" style="zoom: 67%;"></p><p><img src="/2024/02/20/Optimizing_SpMV_on_many_core_platform/image-20240220171731561.png" alt="image-20240220171731561" style="zoom:67%;"></p><h3 id="5-4-其他模型"><a href="#5-4-其他模型" class="headerlink" title="5.4 其他模型"></a>5.4 其他模型</h3><p>图 11 显示了使用不同技术构建预测模型时相对于最佳可用性能的结果性能。除了基于决策树的模型 (DTC) 之外，作者还考虑高斯朴素贝叶斯 (GNB)、多层感知 (MLP)、软投票/多数规则分类 (VC)、k 最近邻 (KNC, k=1) ）、逻辑回归（LR）、随机森林分类（RFC）。由于高质量的特征，所有分类器在选择稀疏矩阵表示时都非常准确。作者选择 DTC 是因为它的准确性与替代技术相当，并且可以轻松可视化和解释。</p><p><img src="/2024/02/20/Optimizing_SpMV_on_many_core_platform/image-20240220172003098.png" alt="image-20240220172003098" style="zoom:50%;"></p><h2 id="6-Related-Work"><a href="#6-Related-Work" class="headerlink" title="6 Related Work"></a>6 Related Work</h2><p>在过去的几十年里，SpMV 在各种平台上得到了广泛的研究 [24]、[30]、[46]。大量工作致力于在多核和众核处理器上实现高效且可扩展的 SpMV。作者的工作是第一次对KNL和FTP进行全面的研究。在 SIMD 处理器上，一些研究人员设计了新的压缩格式以实现高效的 SpMV [1]、[13]、[17]、[46]、[47]。刘等人。提出了一种存储格式CSR5 [21]，它是一种基于图块的格式。 CSR5在各种平台上提供高通量SpMV，并在规则矩阵和不规则矩阵都表现出良好的性能。</p><p>而且从CSR到CSR5的格式转换可以低至几次SpMV操作的成本。关于 KNC，Liu 等人。已经确定并解决了几个瓶颈[22]。他们利用 KNC 的显着架构特征，使用专门的数据结构和仔细的负载平衡来获得令人满意的性能。唐伟腾等人。提出了一种称为矢量化混合COO+CSR（VHCC）的SpMV格式[35]，它采用2D锯齿状分区、平铺和矢量化前缀和计算来改善硬件资源。对于一系列无标度矩阵，他们的 SpMV 实现比英特尔 MKL 平均加速 3 倍。</p><p>近年来，ELLPACK 是宽SIMD 处理器上最成功的格式。 Bell 和 Garland 提出了第一个基于 ELLPACK 的格式 HYB，将 ELLPACK 与 COO 格式相结合 [1]。 HYB 可以提高 SpMV 性能，特别是对于“宽”矩阵。 Monakov 等人提出了切片 ELLPACK 格式，其中矩阵的切片分别以 ELLPACK 格式打包[25]。 BELLPACK 是一种源自 ELLPACK 的格式，它按每行非零数对矩阵的行进行排序 [5]。蒙里茨·克罗伊策等人。设计了基于 Sliced ELLPACK 的 Sliced ELLPACK SELL-C-sigma 变体作为 SIMD 友好的数据格式，其中切片被排序 [19]。</p><p>还有一些针对 SIMT GPU 专用 SpMV 的优化研究 [1]、[23]、[35]、[39]。唐伟腾等人。引入了一系列用于在 GPU 上表示稀疏矩阵的位表示优化压缩方案，包括 BRO-ELL、BRO-COO、BRO-HYB，这些方案对索引数据进行压缩，并通过减少内存流量来帮助加速 GPU 上的 SpMV [ 34]。 Jee W. Choi 等人。提出了经典的分块压缩稀疏行（BCSR）和分块ELLPACK（BELLPACK）存储格式[5]，它可以匹配或超过最先进的实现。他们还开发了一个性能模型，可以指导矩阵相关参数调整，这需要对 GPU 架构进行离线测量和运行时估计建模。杨等人。提出了一种新颖的非参数和自可调方法[49]来计算该内核的数据表示，特别是针对表示幂律图的稀疏矩阵。他们考虑了呈现幂律图的矩阵中非零分布的偏斜。</p><p>稀疏矩阵存储格式选择之所以需要，是因为已经针对不同的应用场景和计算机体系结构提出了各种格式[52]。在[33]中，Sedaghat 等人。研究 GPU 架构、稀疏矩阵表示和稀疏数据集之间的相互关系。此外，他们构建了一个基于决策树的模型，以在给定 GPU 平台上自动选择给定稀疏矩阵的最佳表示。决策树技术也在[20]中使用，其中Li等人。开发稀疏矩阵向量乘法自动调整系统，以弥合特定优化和通用用途之间的差距。该框架为用户提供了CSR格式的统一编程接口，并在运行时自动确定任何输入稀疏矩阵的最佳格式和实现。在[52]中，赵等人。建议使用深度学习方法选择合适的格式，与传统的机器学习技术相比，使用深度学习可以避免为学习目的而提出正确的矩阵特征的困难。结果表明，基于 CNN 的技术可以将格式选择错误减少三分之二。</p><h2 id="7-Conclusion"><a href="#7-Conclusion" class="headerlink" title="7 Conclusion"></a>7 Conclusion</h2><p>本文使用五种主流矩阵表示形式对两种新兴多核架构上的 SpMV 性能进行了全面研究。研究 NUMA 绑定、矢量化和 SpMV 存储表示如何影响运行时性能。实验结果表明，性能最佳的稀疏矩阵表示取决于底层架构和输入数据集的稀疏模式。为了便于选择最佳表示，使用机器学习自动学习模型来预测给定架构和输入的正确矩阵表示。模型首先进行离线训练，学习到的模型可用于任何看不见的输入矩阵。实验结果表明，模型在选择矩阵表示方面非常有效，在评估平台上提供了超过 90% 的最佳可用性能。</p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPC-Game-1th</title>
      <link href="/2024/01/23/HPC-Game%201th/"/>
      <url>/2024/01/23/HPC-Game%201th/</url>
      
        <content type="html"><![CDATA[<p>主页：<a href="https://hpcgame.pku.edu.cn/">https://hpcgame.pku.edu.cn/</a></p><p>赛事组的题解：<a href="https://github.com/lcpu-club/hpcgame_1st_problems">https://github.com/lcpu-club/hpcgame_1st_problems</a></p><h2 id="1-流量"><a href="#1-流量" class="headerlink" title="1.流量"></a>1.流量</h2><p>PCAP是一种数据包记录。本题要从PCAP数据包中破解出一个密码。</p><p>破解PCAP文件的程序为/usr/bin/quantum-cracker，只能破解全部为SSH；流量的PCAP文件作为参数。</p><p>在/lustre/shared_data/potato_kingdom_univ_trad_cluster/pcaps中，有16个pcap文件，是数据包的记录，并且进行了分块。</p><p>集群的节点上有一个wireshark-cli的软件包，提供了一些命令，包括tshark和mergecap，前者可以从PCAP文件中过滤信息，后者可以合并多个PCAP文件。</p><p>本题要求使用4个计算节点，每个节点4个tshark进程同时从16个PCAP文件中提取SSH流量，要求使用Slurm调度器运行这一步骤，将这一计算的Slurm JobID和获得的密码提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#srun job</span></span><br><span class="line">srun -pC064M0256G -N4 --ntasks-per-node=4 bash -c <span class="string">&#x27;tshark -r /lustre/shared_data/potato_kingdom_univ_trad_cluster/pcaps/$SLURM_PROCID.pcap -Y ssh -w $SLURM_PROCID.ssh.pcap&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#jobID</span></span><br><span class="line">sacct -u $(<span class="built_in">whoami</span>) --format JobID | <span class="built_in">tail</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#merge&amp;decode</span></span><br><span class="line">mergecap -w merged.pcap *.ssh.pcap</span><br><span class="line">/usr/bin/quantum-cracker merged.pcap</span><br></pre></td></tr></table></figure><h2 id="2-高性能数据校验"><a href="#2-高性能数据校验" class="headerlink" title="2.高性能数据校验"></a>2.高性能数据校验</h2><p>题目提到的高性能校验算法如下：算法的流程如下（对算法的具体解释见 baseline 代码）：</p><ul><li><p>对数据进行分块，每一块的大小为 M=1MB，记划分的块数为 n。如果文件剩余内容不足一块的大小，则补二进制0至一个块大小。</p></li><li><p>对于第 i 个块，在其末尾连接上第 i-1 个块的 SHA512 校验码的二进制值，将所得到的 M + 64 大小的数据进行 SHA512 校验，得到第 i 个块的校验码。（i 从 0 开始，第 -1 个块的校验码为空文件的校验码）</p></li><li><p>最后一个块的校验码，即为文件的校验码</p></li></ul><p>调用SHA512()计算和给出的代码中的计算是等价的。</p><p>baseline版本如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">checksum</span><span class="params">(<span class="type">uint8_t</span> *data, <span class="type">size_t</span> len, <span class="type">uint8_t</span> *obuf)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> num_block = (len + BLOCK_SIZE - <span class="number">1</span>) / BLOCK_SIZE;</span><br><span class="line">  <span class="type">uint8_t</span> prev_md[SHA512_DIGEST_LENGTH];</span><br><span class="line"></span><br><span class="line">  EVP_MD_CTX *ctx = <span class="built_in">EVP_MD_CTX_new</span>();</span><br><span class="line">  EVP_MD *sha512 = <span class="built_in">EVP_MD_fetch</span>(<span class="literal">nullptr</span>, <span class="string">&quot;SHA512&quot;</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//SHA512(data, len, md);</span></span><br><span class="line">  <span class="built_in">SHA512</span>(<span class="literal">nullptr</span>, <span class="number">0</span>, prev_md);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_block; i++) &#123;</span><br><span class="line">    <span class="type">uint8_t</span> buffer[BLOCK_SIZE]&#123;&#125;;</span><br><span class="line">    <span class="built_in">EVP_DigestInit_ex</span>(ctx, sha512, <span class="literal">nullptr</span>);</span><br><span class="line">    std::<span class="built_in">memcpy</span>(buffer, data + i * BLOCK_SIZE,</span><br><span class="line">                std::<span class="built_in">min</span>(BLOCK_SIZE, len - i * BLOCK_SIZE));</span><br><span class="line">    <span class="built_in">EVP_DigestUpdate</span>(ctx, buffer, BLOCK_SIZE);</span><br><span class="line">    <span class="built_in">EVP_DigestUpdate</span>(ctx, prev_md, SHA512_DIGEST_LENGTH);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">EVP_DigestFinal_ex</span>(ctx, prev_md, &amp;len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">memcpy</span>(obuf, prev_md, SHA512_DIGEST_LENGTH);</span><br><span class="line">  <span class="built_in">EVP_MD_CTX_free</span>(ctx);</span><br><span class="line">  <span class="built_in">EVP_MD_free</span>(sha512);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为可以先计算块本身的数据，最后再加上上一个块的校验码，所以可以首先并行计算每个块本身的数据(第一块除外，可以直接完整计算)，计算完毕后，接收上一个节点的计算结果，更新自己的每个块的校验码，再将最后一个块的校验码传给下一个节点。使用MPI的IO接口读入数据，因为最后一个测试点是16G文件，每个节点要读4G文件，超过了单词读入的size参数(32位整型)，所以要分两次读入。但是这个版本只能拿到74分，正解是边读边接收上一块计算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> fs = std::filesystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> BLOCK_SIZE = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_checksum</span><span class="params">(std::ostream &amp;os, <span class="type">uint8_t</span> *md, <span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">MPI_Init</span>(&amp;argc, &amp;argv);</span><br><span class="line">    <span class="type">int</span> rank, nprocs;</span><br><span class="line">    <span class="built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;rank);</span><br><span class="line">    <span class="built_in">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;nprocs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> t1 = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">//check arg</span></span><br><span class="line">    <span class="keyword">if</span>(rank==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;input_file&gt; &lt;output_file&gt;&quot;</span>&lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">MPI_Abort</span>(MPI_COMM_WORLD, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//read file----------------------------------------------------------------</span></span><br><span class="line">    fs::path input_path = argv[<span class="number">1</span>];</span><br><span class="line">    fs::path output_path = argv[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">auto</span> file_size = fs::<span class="built_in">file_size</span>(input_path);</span><br><span class="line">    std::cout &lt;&lt; input_path &lt;&lt; <span class="string">&quot; size: &quot;</span> &lt;&lt; file_size &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">uint8_t</span> *file_buffer = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num_block = (file_size + BLOCK_SIZE - <span class="number">1</span>) / BLOCK_SIZE;</span><br><span class="line">    <span class="type">int</span> block_per_proc = num_block/nprocs;</span><br><span class="line">    <span class="type">int</span> nblocks;</span><br><span class="line">    <span class="keyword">if</span>(rank!=nprocs<span class="number">-1</span>)  nblocks = block_per_proc;</span><br><span class="line">    <span class="keyword">else</span> nblocks = num_block - (nprocs<span class="number">-1</span>)*block_per_proc;</span><br><span class="line"></span><br><span class="line">    MPI_File file;</span><br><span class="line">    <span class="built_in">MPI_File_open</span>(MPI_COMM_WORLD, argv[<span class="number">1</span>], MPI_MODE_RDONLY, MPI_INFO_NULL, &amp;file);</span><br><span class="line"></span><br><span class="line">    MPI_Offset global_offset = rank * block_per_proc * BLOCK_SIZE;</span><br><span class="line">    <span class="type">size_t</span> my_data_size;</span><br><span class="line">    <span class="keyword">if</span>(rank!=nprocs<span class="number">-1</span>) my_data_size = nblocks*BLOCK_SIZE;</span><br><span class="line">    <span class="keyword">else</span> my_data_size = file_size - block_per_proc*BLOCK_SIZE*(nprocs<span class="number">-1</span>);</span><br><span class="line">    file_buffer = <span class="keyword">new</span> <span class="type">uint8_t</span>[my_data_size];</span><br><span class="line">    <span class="type">size_t</span> exceed_size = <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    exceed_size *= <span class="number">1024</span>*<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span>(file_size&lt;exceed_size) <span class="built_in">MPI_File_read_at</span>(file, global_offset, file_buffer, my_data_size, MPI_BYTE, MPI_STATUS_IGNORE);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">MPI_File_read_at</span>(file, global_offset, file_buffer, my_data_size/<span class="number">2</span>, MPI_BYTE, MPI_STATUS_IGNORE);</span><br><span class="line">        <span class="built_in">MPI_File_read_at</span>(file, global_offset + my_data_size/<span class="number">2</span>, file_buffer + my_data_size/<span class="number">2</span>, my_data_size-my_data_size/<span class="number">2</span>, MPI_BYTE, MPI_STATUS_IGNORE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//caculation----------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (rank == <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//caculate checksum---------------------------------------------</span></span><br><span class="line">        <span class="type">uint8_t</span> obuf[SHA512_DIGEST_LENGTH];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//calculate my block</span></span><br><span class="line">        EVP_MD_CTX *ctx = <span class="built_in">EVP_MD_CTX_new</span>(); </span><br><span class="line">        EVP_MD *sha512 = <span class="built_in">EVP_MD_fetch</span>(<span class="literal">nullptr</span>, <span class="string">&quot;SHA512&quot;</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="type">uint8_t</span> prev_md[SHA512_DIGEST_LENGTH];</span><br><span class="line">        <span class="built_in">SHA512</span>(<span class="literal">nullptr</span>, <span class="number">0</span>, prev_md);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nblocks;i++)&#123;</span><br><span class="line">            <span class="built_in">EVP_DigestInit_ex</span>(ctx, sha512, <span class="literal">nullptr</span>);</span><br><span class="line">            <span class="built_in">EVP_DigestUpdate</span>(ctx, file_buffer + i * BLOCK_SIZE, BLOCK_SIZE);</span><br><span class="line">            <span class="built_in">EVP_DigestUpdate</span>(ctx, prev_md, SHA512_DIGEST_LENGTH);</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">EVP_DigestFinal_ex</span>(ctx, prev_md, &amp;len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//send my last </span></span><br><span class="line">        <span class="built_in">MPI_Send</span>(prev_md, SHA512_DIGEST_LENGTH, MPI_UINT8_T, <span class="number">1</span>, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">        <span class="built_in">EVP_MD_CTX_free</span>(ctx);</span><br><span class="line">        <span class="built_in">EVP_MD_free</span>(sha512);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//caculate my block</span></span><br><span class="line">        EVP_MD_CTX *ctx[nblocks]; </span><br><span class="line">        EVP_MD *sha512 = <span class="built_in">EVP_MD_fetch</span>(<span class="literal">nullptr</span>, <span class="string">&quot;SHA512&quot;</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span>(rank!=nprocs<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nblocks;i++)&#123;</span><br><span class="line">                ctx[i] = <span class="built_in">EVP_MD_CTX_new</span>();</span><br><span class="line">                <span class="built_in">EVP_DigestInit_ex</span>(ctx[i], sha512, <span class="literal">nullptr</span>);</span><br><span class="line">                <span class="built_in">EVP_DigestUpdate</span>(ctx[i], file_buffer + i * BLOCK_SIZE, BLOCK_SIZE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nblocks<span class="number">-1</span>;i++)&#123;</span><br><span class="line">                ctx[i] = <span class="built_in">EVP_MD_CTX_new</span>();</span><br><span class="line">                <span class="built_in">EVP_DigestInit_ex</span>(ctx[i], sha512, <span class="literal">nullptr</span>);</span><br><span class="line">                <span class="built_in">EVP_DigestUpdate</span>(ctx[i], file_buffer + i * BLOCK_SIZE, BLOCK_SIZE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">size_t</span> x = nblocks<span class="number">-1</span>; </span><br><span class="line">            ctx[x] = <span class="built_in">EVP_MD_CTX_new</span>();</span><br><span class="line">            <span class="type">uint8_t</span> buffer[BLOCK_SIZE]&#123;&#125;;</span><br><span class="line">            <span class="built_in">EVP_DigestInit_ex</span>(ctx[x], sha512, <span class="literal">nullptr</span>);</span><br><span class="line">            std::<span class="built_in">memcpy</span>(buffer, file_buffer + x * BLOCK_SIZE, my_data_size - x * BLOCK_SIZE);</span><br><span class="line">            <span class="built_in">EVP_DigestUpdate</span>(ctx[x], buffer, BLOCK_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//prev</span></span><br><span class="line">        <span class="type">uint8_t</span> prev_md[SHA512_DIGEST_LENGTH];</span><br><span class="line">        <span class="built_in">MPI_Recv</span>(prev_md, SHA512_DIGEST_LENGTH, MPI_UINT8_T, rank<span class="number">-1</span>, <span class="number">0</span>, MPI_COMM_WORLD, MPI_STATUS_IGNORE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nblocks; i++) &#123;</span><br><span class="line">            <span class="built_in">EVP_DigestUpdate</span>(ctx[i], prev_md, SHA512_DIGEST_LENGTH);</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">EVP_DigestFinal_ex</span>(ctx[i], prev_md, &amp;len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//send my last</span></span><br><span class="line">        <span class="keyword">if</span>(rank != nprocs<span class="number">-1</span>) <span class="built_in">MPI_Send</span>(prev_md, SHA512_DIGEST_LENGTH, MPI_UINT8_T, (rank+<span class="number">1</span>)%nprocs, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// write checksum to output file</span></span><br><span class="line">            std::ofstream <span class="built_in">output_file</span>(output_path);</span><br><span class="line">            <span class="built_in">print_checksum</span>(output_file, prev_md, SHA512_DIGEST_LENGTH);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nblocks;i++)&#123;</span><br><span class="line">            <span class="built_in">EVP_MD_CTX_free</span>(ctx[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">EVP_MD_free</span>(sha512);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> t2 = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="type">int</span> d1 = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(t2 - t1).<span class="built_in">count</span>();</span><br><span class="line">    <span class="keyword">if</span>(rank==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%dms\n&quot;</span>, d1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_File_close</span>(&amp;file);</span><br><span class="line">    <span class="keyword">delete</span>[] file_buffer;</span><br><span class="line">    <span class="built_in">MPI_Finalize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/sha.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIGEST_NAME <span class="string">&quot;SHA512&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fs = std::filesystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> BLOCK_SIZE = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_checksum</span><span class="params">(std::ostream &amp;os, <span class="type">uint8_t</span> *md, <span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_num_block</span><span class="params">(<span class="type">int</span> rank, <span class="type">int</span> nprocs, <span class="type">int</span> num_block_total)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num_block_total / nprocs + ((rank &lt; num_block_total % nprocs) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_Init</span>(&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rank, nprocs;</span><br><span class="line">    <span class="built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;rank);</span><br><span class="line">    <span class="built_in">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;nprocs);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num_block_total, num_block, fd;</span><br><span class="line">    <span class="type">size_t</span> file_size;</span><br><span class="line"></span><br><span class="line">    EVP_MD_CTX *ctx = <span class="built_in">EVP_MD_CTX_new</span>();</span><br><span class="line">    EVP_MD *sha512 = <span class="built_in">EVP_MD_fetch</span>(<span class="literal">nullptr</span>, DIGEST_NAME, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    fs::path input_path, output_path;</span><br><span class="line">    <span class="type">uint8_t</span> *file_buffer = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rank == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;input_file&gt; &lt;output_file&gt;&quot;</span></span><br><span class="line">                      &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">MPI_Abort</span>(MPI_COMM_WORLD, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    input_path = argv[<span class="number">1</span>];</span><br><span class="line">    output_path = argv[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (rank == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        file_size = fs::<span class="built_in">file_size</span>(input_path);</span><br><span class="line">        std::cout &lt;&lt; input_path &lt;&lt; <span class="string">&quot; size: &quot;</span> &lt;&lt; file_size &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_Bcast</span>(&amp;file_size, <span class="number">1</span>, MPI_INT64_T, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">    num_block_total = (file_size + BLOCK_SIZE - <span class="number">1</span>) / BLOCK_SIZE;</span><br><span class="line">    num_block = <span class="built_in">get_num_block</span>(rank, nprocs, num_block_total);</span><br><span class="line"></span><br><span class="line">    MPI_Datatype filetype, contig;</span><br><span class="line">    MPI_Offset disp;</span><br><span class="line">    <span class="built_in">MPI_Type_contiguous</span>(BLOCK_SIZE, MPI_BYTE, &amp;contig);</span><br><span class="line">    <span class="built_in">MPI_Type_create_resized</span>(contig, <span class="number">0</span>, nprocs * BLOCK_SIZE, &amp;filetype);</span><br><span class="line">    <span class="built_in">MPI_Type_commit</span>(&amp;filetype);</span><br><span class="line"></span><br><span class="line">    MPI_Offset offset = rank * BLOCK_SIZE;</span><br><span class="line">    MPI_File fh;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_File_open</span>(MPI_COMM_WORLD, input_path.<span class="built_in">c_str</span>(), MPI_MODE_RDONLY,</span><br><span class="line">                  MPI_INFO_NULL, &amp;fh);</span><br><span class="line">    <span class="built_in">MPI_File_set_view</span>(fh, offset, MPI_BYTE, filetype, <span class="string">&quot;native&quot;</span>, MPI_INFO_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> prevdigest[SHA512_DIGEST_LENGTH];</span><br><span class="line">    <span class="type">uint8_t</span> outdigest[SHA512_DIGEST_LENGTH];</span><br><span class="line">    MPI_Request request[<span class="number">2</span>] = &#123;MPI_REQUEST_NULL, MPI_REQUEST_NULL&#125;;</span><br><span class="line">    <span class="type">int</span> nblk_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> curr_block[BLOCK_SIZE];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_block; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">MPI_File_read</span>(fh, curr_block, BLOCK_SIZE, MPI_BYTE, MPI_STATUS_IGNORE);</span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rank == <span class="number">0</span> &amp;&amp; i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">SHA512</span>(<span class="literal">nullptr</span>, <span class="number">0</span>, prevdigest);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// receive the checksum of prev data block</span></span><br><span class="line">            <span class="built_in">MPI_Irecv</span>(prevdigest, SHA512_DIGEST_LENGTH, MPI_BYTE,</span><br><span class="line">                      (rank == <span class="number">0</span> ? nprocs - <span class="number">1</span> : rank - <span class="number">1</span>), <span class="number">1</span>, MPI_COMM_WORLD,</span><br><span class="line">                      &amp;request[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">EVP_DigestInit_ex</span>(ctx, sha512, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">EVP_DigestUpdate</span>(ctx, curr_block, BLOCK_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">MPI_Waitall</span>(<span class="number">2</span>, request, MPI_STATUSES_IGNORE);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">EVP_DigestUpdate</span>(ctx, prevdigest, SHA512_DIGEST_LENGTH);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">EVP_DigestFinal_ex</span>(ctx, outdigest, &amp;len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i * nprocs + rank == num_block_total - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// send the result to rank 0</span></span><br><span class="line">            <span class="built_in">MPI_Send</span>(outdigest, SHA512_DIGEST_LENGTH, MPI_BYTE, <span class="number">0</span>, <span class="number">2</span>, MPI_COMM_WORLD);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// send to checksum to the next data block</span></span><br><span class="line">            <span class="built_in">MPI_Isend</span>(outdigest, SHA512_DIGEST_LENGTH, MPI_BYTE, (rank + <span class="number">1</span>) % nprocs,</span><br><span class="line">                      <span class="number">1</span>, MPI_COMM_WORLD, &amp;request[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_File_close</span>(&amp;fh);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rank == <span class="number">0</span> &amp;&amp; num_block == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// deal with the situation that file_size is 0</span></span><br><span class="line">        <span class="built_in">SHA512</span>(<span class="literal">nullptr</span>, <span class="number">0</span>, outdigest);</span><br><span class="line">        <span class="built_in">MPI_Send</span>(outdigest, SHA512_DIGEST_LENGTH, MPI_BYTE, <span class="number">0</span>, <span class="number">2</span>, MPI_COMM_WORLD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rank == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// receive result</span></span><br><span class="line">        <span class="type">uint8_t</span> resultdigest[SHA512_DIGEST_LENGTH];</span><br><span class="line">        <span class="built_in">MPI_Recv</span>(resultdigest, SHA512_DIGEST_LENGTH, MPI_BYTE, MPI_ANY_SOURCE, <span class="number">2</span>,</span><br><span class="line">                 MPI_COMM_WORLD, MPI_STATUS_IGNORE);</span><br><span class="line"></span><br><span class="line">        <span class="function">std::ofstream <span class="title">output_file</span><span class="params">(output_path)</span></span>;</span><br><span class="line">        <span class="built_in">print_checksum</span>(output_file, resultdigest, SHA512_DIGEST_LENGTH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EVP_MD_free</span>(sha512);</span><br><span class="line">    <span class="built_in">EVP_MD_CTX_free</span>(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_Finalize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_checksum</span><span class="params">(std::ostream &amp;os, <span class="type">uint8_t</span> *md, <span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        os &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; std::hex</span><br><span class="line">           &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(md[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-齐心协力-RAY"><a href="#3-齐心协力-RAY" class="headerlink" title="3.齐心协力(RAY)"></a>3.齐心协力(RAY)</h2><p>ray是python实现的消息传递API，本题对于每个数据，需要4个步骤完成，因此可以构建四个worker组成的流水线，进行数据处理。</p><p>与上一题相同，本题也只拿了75分，两个题API不同，但过程是相似的，因此可能是有同样的可以优化的地方。</p><p>RAY的文档：<a href="https://docs.ray.io/en/latest/ray-core/walkthrough.html">https://docs.ray.io/en/latest/ray-core/walkthrough.html</a></p><p>最后还是看题解才知道做这个题对RAY的理解很多地方还是有问题。当时看文档没有仔细看。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> ray</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> ThreadPool</span><br><span class="line"><span class="keyword">from</span> ray.util.placement_group <span class="keyword">import</span> (</span><br><span class="line">    placement_group,</span><br><span class="line">    placement_group_table,</span><br><span class="line">    remove_placement_group,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> ray.util.scheduling_strategies <span class="keyword">import</span> PlacementGroupSchedulingStrategy</span><br><span class="line"></span><br><span class="line"><span class="comment">#Actor---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="meta">@ray.remote(<span class="params">num_cpus=<span class="number">4</span></span>)  </span><span class="comment"># 指定每个worker需要4个CPU</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">workerA</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,rank</span>):</span><br><span class="line">        self.pool = ThreadPool(<span class="number">4</span>)</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        self.rank = rank</span><br><span class="line">        self.weight = (np.load(<span class="string">f&quot;weights/weight_<span class="subst">&#123;rank&#125;</span>.npy&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_next</span>(<span class="params">self,<span class="built_in">next</span></span>):</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_data</span>(<span class="params">self, i</span>):</span><br><span class="line">        mtx = np.load(<span class="string">f&quot;inputs/input_<span class="subst">&#123;i&#125;</span>.npy&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> mtx</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write_data</span>(<span class="params">self, data_struct</span>):</span><br><span class="line">        i = data_struct[<span class="number">0</span>]</span><br><span class="line">        mtx = data_struct[<span class="number">1</span>]</span><br><span class="line">        np.save(<span class="string">f&quot;outputs/output_<span class="subst">&#123;i&#125;</span>.npy&quot;</span>, mtx)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_data</span>(<span class="params">self, mtx</span>):</span><br><span class="line">        mtx = np.dot(mtx, self.weight)</span><br><span class="line">        mtx = np.maximum(<span class="number">0</span>, mtx)</span><br><span class="line">        <span class="keyword">return</span> mtx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># mtx是包含四个矩阵的列表</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">self, i, mtx = <span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> self.rank==<span class="number">0</span>:</span><br><span class="line">            mtx = self.pool.<span class="built_in">map</span>(self.read_data, <span class="built_in">range</span>(i,i+<span class="number">4</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#每个worker都要处理</span></span><br><span class="line">        mtx = self.pool.<span class="built_in">map</span>(self.process_data, mtx)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#处理结果</span></span><br><span class="line">        <span class="keyword">if</span> self.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            data_pack = []</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                data_pack.append([i+k, mtx[k]])</span><br><span class="line">            ret = self.pool.<span class="built_in">map</span>(self.write_data, data_pack)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.<span class="built_in">next</span>.process.remote(i, mtx)</span><br><span class="line"></span><br><span class="line"><span class="comment">#--------------------------------------------------------------------------------------------------</span></span><br><span class="line">ray.init(address=<span class="string">f&quot;<span class="subst">&#123;os.environ[<span class="string">&#x27;RAY_CLUSTER_ADDR&#x27;</span>]&#125;</span>&quot;</span>,log_to_driver=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 每个bundle4个CPU，4个bundle</span></span><br><span class="line">pg = ray.util.placement_group([&#123;<span class="string">&quot;CPU&quot;</span>: <span class="number">4</span>&#125;] * <span class="number">4</span>, strategy=<span class="string">&quot;PACK&quot;</span>)</span><br><span class="line">ray.get(pg.ready())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建worker</span></span><br><span class="line">firstw = workerA.options(placement_group=pg, placement_group_bundle_index=<span class="number">0</span>).remote(<span class="number">0</span>)</span><br><span class="line">secw = workerA.options(placement_group=pg, placement_group_bundle_index=<span class="number">1</span>).remote(<span class="number">1</span>)</span><br><span class="line">thirdw = workerA.options(placement_group=pg, placement_group_bundle_index=<span class="number">2</span>).remote(<span class="number">2</span>)</span><br><span class="line">lastw = workerA.options(placement_group=pg, placement_group_bundle_index=<span class="number">3</span>).remote(<span class="number">3</span>)</span><br><span class="line">ray.get(firstw.set_next.remote(secw))</span><br><span class="line">ray.get(secw.set_next.remote(thirdw))</span><br><span class="line">ray.get(thirdw.set_next.remote(lastw))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&quot;outputs&quot;</span>):</span><br><span class="line">    os.mkdir(<span class="string">&quot;outputs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动流水线</span></span><br><span class="line">refs = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">100</span>,<span class="number">4</span>):</span><br><span class="line">    refs.append(firstw.process.remote(i))</span><br><span class="line"></span><br><span class="line"><span class="comment"># get result</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">25</span>):</span><br><span class="line">    ref = ray.get(refs[i])  <span class="comment"># workB remote ref</span></span><br><span class="line">    ref = ray.get(ref)      <span class="comment"># workC remote ref</span></span><br><span class="line">    ref = ray.get(ref)      <span class="comment"># workD remoteref</span></span><br><span class="line">    ret = ray.get(ref)</span><br></pre></td></tr></table></figure><p>题解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ray</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">num_batches = <span class="number">100</span></span><br><span class="line">num_workers = <span class="number">4</span></span><br><span class="line">input_prefix = <span class="string">&quot;inputs&quot;</span></span><br><span class="line">output_prefix = <span class="string">&quot;outputs&quot;</span></span><br><span class="line">weight_prefix = <span class="string">&quot;weights&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ray.remote(<span class="params">num_cpus=<span class="number">4</span></span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, weight_path: <span class="built_in">str</span>, rank: <span class="built_in">int</span></span>):</span><br><span class="line">        self.weight = np.load(weight_path)</span><br><span class="line">        self.rank = rank</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">self, x: np.ndarray</span>):</span><br><span class="line">        <span class="keyword">return</span> np.maximum(x @ self.weight, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    </span><br><span class="line">    start_time = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(output_prefix):</span><br><span class="line">        os.makedirs(output_prefix)</span><br><span class="line">    </span><br><span class="line">    feature = np.load(<span class="string">f&quot;<span class="subst">&#123;input_prefix&#125;</span>/input_0.npy&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    workers = []</span><br><span class="line">    features = []</span><br><span class="line">    </span><br><span class="line">    ray.init()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> worker_idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_workers):</span><br><span class="line">        workers.append(Worker.remote(<span class="string">f&quot;<span class="subst">&#123;weight_prefix&#125;</span>/weight_<span class="subst">&#123;worker_idx&#125;</span>.npy&quot;</span>, worker_idx))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> input_idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_batches):</span><br><span class="line">        <span class="keyword">for</span> worker <span class="keyword">in</span> workers:</span><br><span class="line">            feature = worker.calculate.remote(feature)</span><br><span class="line">        features.append(feature)</span><br><span class="line">        <span class="keyword">if</span> input_idx != num_batches - <span class="number">1</span>:</span><br><span class="line">            feature = np.load(<span class="string">f&quot;<span class="subst">&#123;input_prefix&#125;</span>/input_<span class="subst">&#123;input_idx + <span class="number">1</span>&#125;</span>.npy&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i, result <span class="keyword">in</span> <span class="built_in">enumerate</span>(features):</span><br><span class="line">        output = ray.get(result)</span><br><span class="line">        np.save(<span class="string">f&quot;outputs/output_<span class="subst">&#123;i&#125;</span>.npy&quot;</span>, output)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Time taken: <span class="subst">&#123;time.time() - start_time&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="4-3D生命游戏"><a href="#4-3D生命游戏" class="headerlink" title="4.3D生命游戏"></a>4.3D生命游戏</h2><p><a href="https://face2ai.com/program-blog/#GPU编程（CUDA）">人工智能编程 | 谭升的博客 (face2ai.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/34587739">CUDA编程入门极简教程 - 知乎 (zhihu.com)</a></p><p>本题只拿了10分，直接等题解。</p><h2 id="5-矩阵乘法"><a href="#5-矩阵乘法" class="headerlink" title="5.矩阵乘法"></a>5.矩阵乘法</h2><p>最经典的高性能计算实例，这次终于看懂goto算法了，但是在实现的过程中实际上是写了一个简化的版本，但是pack和缓存都考虑到了，所以分数还可以，150/200。</p><p>尽管用以下一张图就可以表示这个算法，真的完全理解和实现还是更复杂一些。</p><img src="/2024/01/23/HPC-Game%201th/image-20240205192551868.png" class title="image-20240205192551868"><h3 id="GOTO算法"><a href="#GOTO算法" class="headerlink" title="GOTO算法"></a>GOTO算法</h3><p>计算记为C = A x B。</p><p>单独画了和上方不一样的图，是因为要提醒自己，每个块划分完之后是存在偏移的，数据定位是要考虑偏移的。一直到第二层循环，数据都打包好了以后，就可以将原问题转为子矩阵和子矩阵的计算了。</p><p>对于大型矩阵乘法计算，由于数据规模大，局部性会变得非常差。为了提高局部性，要对矩阵进行分块，对矩阵分块有多种分块计算方式。如果矩阵比较小，可以直接将矩阵C横向和纵向都进行划分，分为小块进行计算，也就是6重循环的计算方法，但是如果矩阵规模大，这种方式就会因为没有很好的利用到局部性而性能快速下降。所以对于大规模的矩阵，要一步一步划分，考虑每个划分后的子矩阵的计算方式，来最大化局部性。在goto算法中，主要利用到的是以下这两种划分方式，一个是按列，一个是分层。</p><p><img src="/2024/01/23/HPC-Game%201th/image-20240205210352046.png" alt="image-20240205210352046" style="zoom:50%;"></p><p>首先通过按列划分，减少矩阵计算的规模，每次计算Cj，Cj包含nc列，Cj的起始列号假设为js，此后访问Cj和Bj的数据都要注意加上js这个偏移量。此时<strong>C(i，j)为C[ldc*i + j + js]</strong>，矩阵按行存储。</p><p><img src="/2024/01/23/HPC-Game%201th/image-20240205210415849.png" alt="image-20240205210415849" style="zoom:50%;"></p><p>而对于Cj的计算，按照分层的方式进行划分：</p><p><img src="/2024/01/23/HPC-Game%201th/image-20240205210839211.png" alt="image-20240205210839211" style="zoom:50%;"></p><p>此时的Bpj已经经过两次划分，可以对其进行打包，至于打包的格式，取决于最核心kernel对其的计算方式，这里可以先不看。打包的目的是为了加快计算和提升局部性，接下来还要对Cj进行划分，这次按照行进行划分，子矩阵的计算就变成了Aip和Bpj的计算，Bpj会在计算Cij时反复使用，因此可以考虑将其大小与L3Cache适配。这里打包时，假设起始行号为as，将as行起的kc行打包到单独的一块内存。</p><p><img src="/2024/01/23/HPC-Game%201th/image-20240205211152664.png" alt="image-20240205211152664" style="zoom:50%;"></p><p>到了这里，计算已经划分为Cij += Aip × Bpj，可以将其作为一个macro kernel封装了。而A也已经划分为一个块，可以将其打包，以便于计算和放入缓存，此时L3已经存入Bpj，Aip作为更小的块，将其适配L2缓存。而对于每一个Cij，在内部再进行划分，此时Aip和Bpj都是打包后的了，可以不考虑原矩阵中的位置而访问数据，只有C的数据访问还需要在原矩阵中定位。Cij内部的划分和上述过程是一样的，先按列划分，再按行划分，最后计算子矩阵块，这时就可以直接搬出这个图了：</p><img src="/2024/01/23/HPC-Game%201th/image-20240205192551868.png" class title="image-20240205192551868"><p>按照最终的计算顺序，对A和B进行相应的打包来加快计算。在我的实现中，最内层的kernel不是分层划分计算的，而是按照常规的矩阵乘法应用AVX计算的。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>这里假定大小是可以对齐，多加上长度的控制，就可以对通用大小进行计算了。此外，macro_kernel也不是严格按照上述算法分解的，但是原理是一致的，划分大小也是按照packB在L3缓存，packA在K2缓存，最小计算在L1和向量寄存器中完成而设定的。</p><p>gemm的整体实现如下，为了多线程并行计算，准备线程数个packA的打包缓冲区，在第三层循环这里进行多线程并行计算，注意macro_kernel传入的packA地址是当前线程对应的packA地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">uint64_t</span> gemm_nc = <span class="number">4096</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">uint64_t</span> gemm_kc = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">uint64_t</span> gemm_mc = <span class="number">64</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">uint64_t</span> gemm_mr = <span class="number">8</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">uint64_t</span> gemm_nr = <span class="number">32</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ncore = <span class="built_in">omp_get_num_procs</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul_opt</span><span class="params">(<span class="type">double</span>* a, <span class="type">double</span>* b, <span class="type">double</span>* c, <span class="type">uint64_t</span> n1, <span class="type">uint64_t</span> n2, <span class="type">uint64_t</span> n3)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> *packA = (<span class="type">double</span>*)<span class="built_in">aligned_alloc</span>(<span class="number">64</span>, <span class="built_in">sizeof</span>(<span class="type">double</span>)*(gemm_mc+<span class="number">1</span>)*gemm_kc*ncore);</span><br><span class="line">    <span class="type">double</span> *packB = (<span class="type">double</span>*)<span class="built_in">aligned_alloc</span>(<span class="number">64</span>, <span class="built_in">sizeof</span>(<span class="type">double</span>)*(gemm_nc+<span class="number">1</span>)*gemm_kc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, n1, n2, n3);</span><br><span class="line">    <span class="comment">//js是Cj块的起始列号, Bj的起始列号</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint64_t</span> js = <span class="number">0</span>; js &lt; n3; js += gemm_nc)&#123;</span><br><span class="line">        <span class="comment">//as是Ap块的起始列号, 也是Bpj的起始行号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">uint64_t</span> as = <span class="number">0</span>; as &lt; n2; as += gemm_kc)&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            *   计算Ap*Bpj</span></span><br><span class="line"><span class="comment">            *   这里Cj和Ap在原矩阵中都是列块，此时访问数据的方式已变为：</span></span><br><span class="line"><span class="comment">            *   Cj(i,j) = C[i*ldc + offset_c + j]</span></span><br><span class="line"><span class="comment">            *   而B是pack过后的数据</span></span><br><span class="line"><span class="comment">            */</span>  </span><br><span class="line">            <span class="comment">//is是Cij的起始行索引</span></span><br><span class="line">            <span class="built_in">packBpj</span>(&amp;b[as*n3], n3, js, packB);   </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> omp parallel for num_threads(ncore)      </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">uint64_t</span> is = <span class="number">0</span>; is &lt; n1; is += gemm_mc)&#123;</span><br><span class="line">                <span class="comment">//计算Aip*Bpj</span></span><br><span class="line">                <span class="comment">//按列划分，并把Aip打包到packA</span></span><br><span class="line">                <span class="type">int</span> tid = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">                <span class="built_in">packAip</span>(&amp;a[is*n2], n2, as, packA, tid);</span><br><span class="line">                <span class="built_in">macro_kernel</span>(&amp;c[is*n3], n3, js, packA+(<span class="type">uint64_t</span>)tid*gemm_mc*gemm_kc, packB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(packA);</span><br><span class="line">    <span class="built_in">free</span>(packB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>packB：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将Bpj按照nr列一组，组内行优先放入packB</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">packBpj</span><span class="params">(<span class="type">double</span> *ob, <span class="type">size_t</span> ldb, <span class="type">size_t</span> offset_b, <span class="type">double</span> *nb)</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for num_threads(ncore)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint64_t</span> j = <span class="number">0</span>; j &lt; gemm_nc ; j += gemm_nr)&#123;<span class="comment">//nc/nr列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; gemm_kc; i++)&#123;<span class="comment">//kc行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">uint64_t</span> k = <span class="number">0</span>; k &lt; gemm_nr; k++)&#123;</span><br><span class="line">                <span class="comment">//将ob的第i行j列起第k个放入nb</span></span><br><span class="line">                nb[j*gemm_kc + i*gemm_nr + k] = ob[i*ldb + offset_b + j + k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>packA：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">packAip</span><span class="params">(<span class="type">double</span> *oa, <span class="type">size_t</span> lda, <span class="type">size_t</span> offset_a, <span class="type">double</span> *na, <span class="type">int</span> tid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; gemm_mc; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">uint64_t</span> j = <span class="number">0</span>; j &lt; gemm_kc; j++)&#123;</span><br><span class="line">            na[(<span class="type">uint64_t</span>)tid*gemm_mc*gemm_kc + i*gemm_kc + j] = oa[i*lda + offset_a + j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>macro_kernel:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">macro_kernel</span><span class="params">(<span class="type">double</span> *c, <span class="type">size_t</span> ldc, <span class="type">size_t</span> offset_c, <span class="type">double</span> *a, <span class="type">double</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将C分为mr*nr的小块计算</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; gemm_mc; i+=gemm_mr)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">uint64_t</span> j = <span class="number">0</span>; j &lt; gemm_nc; j += gemm_nr)&#123;</span><br><span class="line">            <span class="comment">//C00 = A(0,P)*B(P,0) C01 = A(0,P)*B(P,1) ...</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">uint64_t</span> ii=<span class="number">0</span>; ii &lt; gemm_mr; ii++)&#123;</span><br><span class="line">                __m512d vec1 = _mm512_load_pd(&amp;c[(i+ii)*ldc+offset_c+j]);</span><br><span class="line">                __m512d vec2 = _mm512_load_pd(&amp;c[(i+ii)*ldc+offset_c+j+<span class="number">8</span>]);</span><br><span class="line">                __m512d vec3 = _mm512_load_pd(&amp;c[(i+ii)*ldc+offset_c+j+<span class="number">16</span>]);</span><br><span class="line">                __m512d vec4 = _mm512_load_pd(&amp;c[(i+ii)*ldc+offset_c+j+<span class="number">24</span>]);</span><br><span class="line">                <span class="comment">//i是Cij的行号, j为列号</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">uint64_t</span> p = <span class="number">0</span>; p &lt; gemm_kc; p++)&#123;</span><br><span class="line">                    __m512d vec_a = _mm512_set1_pd(a[(i+ii)*gemm_kc+p]);</span><br><span class="line">                    __m512d vec_b1 = _mm512_load_pd(&amp;b[gemm_kc*j+p*gemm_nr]);</span><br><span class="line">                    __m512d vec_b2 = _mm512_load_pd(&amp;b[gemm_kc*j+p*gemm_nr+<span class="number">8</span>]);</span><br><span class="line">                    __m512d vec_b3 = _mm512_load_pd(&amp;b[gemm_kc*j+p*gemm_nr+<span class="number">16</span>]);</span><br><span class="line">                    __m512d vec_b4 = _mm512_load_pd(&amp;b[gemm_kc*j+p*gemm_nr+<span class="number">24</span>]);</span><br><span class="line">                    vec1 = _mm512_fmadd_pd(vec_a, vec_b1, vec1);</span><br><span class="line">                    vec2 = _mm512_fmadd_pd(vec_a, vec_b2, vec2);</span><br><span class="line">                    vec3 = _mm512_fmadd_pd(vec_a, vec_b3, vec3);</span><br><span class="line">                    vec4 = _mm512_fmadd_pd(vec_a, vec_b4, vec4);</span><br><span class="line">                &#125;</span><br><span class="line">                _mm512_store_pd(&amp;c[(i+ii)*ldc+offset_c+j], vec1); </span><br><span class="line">                _mm512_store_pd(&amp;c[(i+ii)*ldc+offset_c+j+<span class="number">8</span>], vec2);</span><br><span class="line">                _mm512_store_pd(&amp;c[(i+ii)*ldc+offset_c+j+<span class="number">16</span>], vec3);</span><br><span class="line">                _mm512_store_pd(&amp;c[(i+ii)*ldc+offset_c+j+<span class="number">24</span>], vec4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-LOGISTIC方程"><a href="#6-LOGISTIC方程" class="headerlink" title="6.LOGISTIC方程"></a>6.LOGISTIC方程</h2><p>AVX512+OPENMP。一开始就直接尽量填充了流水线，如果没有这么做，可能拿不满分数。见代码。</p><h2 id="7-H66"><a href="#7-H66" class="headerlink" title="7.H66"></a>7.H66</h2><p>用Vtune可以找到热点代码是spmv，原始计算是使用COO格式完成的，可以转为CSR，然后使用AVX和OPENMP计算，只拿到了部分分数，因为时间问题，没有尝试其他压缩格式。等题解。</p><p>以下是CSR的SPMV计算过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//out=m*v;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mmv</span><span class="params">(std::vector&lt;<span class="type">double</span>&gt;&amp; out, <span class="type">const</span> sparse_csr&amp; m, <span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for num_threads(ncore)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : out) &#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*COO SPMV</span></span><br><span class="line"><span class="comment">    for (size_t i = 0; i &lt; m.data.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">        out[m.row[i]] += m.data[i] * v[m.col[i]];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//CSR SPMV</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for num_threads(ncore) schedule(dynamic)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m.nrow;i++)&#123;</span><br><span class="line">        __m512d yi1 = _mm512_set1_pd(<span class="number">0.0</span>);</span><br><span class="line">        <span class="type">int</span> start = m.row_ptrs[i], end = m.row_ptrs[i+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j = start; j + <span class="number">8</span> &lt; end; j += <span class="number">8</span>)&#123;</span><br><span class="line">            __m512d m_vec1 = _mm512_loadu_pd(&amp;m.data[j]);</span><br><span class="line">            __m512d v_vec1 = _mm512_set_pd(v[m.col_idx[j+<span class="number">7</span>]], v[m.col_idx[j+<span class="number">6</span>]], v[m.col_idx[j+<span class="number">5</span>]], v[m.col_idx[j+<span class="number">4</span>]], v[m.col_idx[j+<span class="number">3</span>]], v[m.col_idx[j+<span class="number">2</span>]], v[m.col_idx[j+<span class="number">1</span>]], v[m.col_idx[j]]);</span><br><span class="line">            yi1 = _mm512_fmadd_pd(m_vec1,v_vec1,yi1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> sum = _mm512_reduce_add_pd(yi1);</span><br><span class="line">        <span class="keyword">for</span>(; j &lt; end; j++)&#123;</span><br><span class="line">            sum += m.data[j]*v[m.col_idx[j]];</span><br><span class="line">        &#125;</span><br><span class="line">        out[i] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-光之游戏"><a href="#8-光之游戏" class="headerlink" title="8.光之游戏"></a>8.光之游戏</h2><p>未完成，等题解。</p><h2 id="9-洪水困兽"><a href="#9-洪水困兽" class="headerlink" title="9.洪水困兽"></a>9.洪水困兽</h2><p>OPENMP题，对其中一部分数据要原子更新，并行化就可以拿到满分。</p>]]></content>
      
      
      <categories>
          
          <category> HPCLAB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MPI</title>
      <link href="/2024/01/20/MPI/"/>
      <url>/2024/01/20/MPI/</url>
      
        <content type="html"><![CDATA[<p> MPI内容主要来自<a href="https://mpitutorial.com/tutorials/。由于MPI">https://mpitutorial.com/tutorials/。由于MPI</a> tutorial的内容比较基础，缺少了常用的非阻塞通信，并行文件读写，因此补充了《高性能计算-MPI并行编程技术》(都志辉编著)中的一些内容。</p><span id="more"></span><h2 id="1-MPI介绍"><a href="#1-MPI介绍" class="headerlink" title="1 MPI介绍"></a>1 MPI介绍</h2><p>MPI在设计上有一些经典概念。</p><p>通讯器定义了一组能够互发消息的进程，每个进程有一个序号，称为秩(rank)，并通过指定rank通信。</p><p>一个进程可以通过指定另一个进程的rank和一个消息tag来发送消息，接收者可以指定tag进行接收(或不管tag，接收任何消息)，这样的发送接收过程为点对点通信。很多情况下，需要广播通信，MPI提供了专门的接口处理这类集体性通信。</p><p>MPI的HelloWorld程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 MPI 环境</span></span><br><span class="line">    <span class="built_in">MPI_Init</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过调用以下方法来得到所有可以工作的进程数量</span></span><br><span class="line">    <span class="type">int</span> world_size;</span><br><span class="line">    <span class="built_in">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;world_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到当前进程的秩</span></span><br><span class="line">    <span class="type">int</span> world_rank;</span><br><span class="line">    <span class="built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;world_rank);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到当前进程的名字</span></span><br><span class="line">    <span class="type">char</span> processor_name[MPI_MAX_PROCESSOR_NAME];</span><br><span class="line">    <span class="type">int</span> name_len;</span><br><span class="line">    <span class="built_in">MPI_Get_processor_name</span>(processor_name, &amp;name_len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印一条带有当前进程名字，秩以及</span></span><br><span class="line">    <span class="comment">// 整个 communicator 的大小的 hello world 消息。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world from processor %s, rank %d out of %d processors\n&quot;</span>,</span><br><span class="line">           processor_name, world_rank, world_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 MPI 的一些资源</span></span><br><span class="line">    <span class="built_in">MPI_Finalize</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MPI_init时会创建MPI的相关变量，通讯器会根据所有可用进程被创建出来(通过mpi参数指定进程数)。一般来说MPI_Init的参数是没有用的，只是保留待用。</p><p>编译使用了MPI的程序需要使用mpicc，mpicc只是对gcc做了一层封装。编译好的程序通过<code>mpirun</code>运行，mpirun提供了-n参数指定进程数，-f可以指定hostfile文件，如果要在多个节点的集群跑MPI程序，hostfile中需要包含所有节点的名称，还可以指定节点的进程数。</p><h2 id="2阻塞通信"><a href="#2阻塞通信" class="headerlink" title="2阻塞通信"></a>2阻塞通信</h2><h3 id="2-1-Send-amp-Recv"><a href="#2-1-Send-amp-Recv" class="headerlink" title="2.1 Send&amp;Recv"></a>2.1 Send&amp;Recv</h3><p>如果A进程要发送消息给B进程，A进程会把需要发送给N的数据打包好，放入一个缓存，如果B进程确认想要收到A的数据，数据就传输成功了，并且消息可以使用tag进行区分。</p><p>MPI发送和接收方法的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MPI_Send</span>(</span><br><span class="line">    <span class="type">void</span>* data,</span><br><span class="line">    <span class="type">int</span> count,</span><br><span class="line">    MPI_Datatype datatype,</span><br><span class="line">    <span class="type">int</span> destination,</span><br><span class="line">    <span class="type">int</span> tag,</span><br><span class="line">    MPI_Comm communicator);</span><br><span class="line"><span class="built_in">MPI_Recv</span>(</span><br><span class="line">    <span class="type">void</span>* data,</span><br><span class="line">    <span class="type">int</span> count,</span><br><span class="line">    MPI_Datatype datatype,</span><br><span class="line">    <span class="type">int</span> source,</span><br><span class="line">    <span class="type">int</span> tag,</span><br><span class="line">    MPI_Comm communicator,</span><br><span class="line">    MPI_Status* status);</span><br></pre></td></tr></table></figure></p><p>MPI_Send会发送count数量个元素，MPI_Recv最多接收count个元素，而MPI_Recv的最后一个参数提供接收的信息状态。MPI的数据结构与基础数据结构是对应的：</p><div class="table-container"><table><thead><tr><th>MPI datatype</th><th>C</th></tr></thead><tbody><tr><td>MPI_SHORT</td><td>short int</td></tr><tr><td>MPI_INT</td><td>int</td></tr><tr><td>MPI_LONG</td><td>long int</td></tr><tr><td>MPI_LONG_LONG</td><td>long long int</td></tr><tr><td>MPI_UNSIGNED_CHAR</td><td>unsigned char</td></tr><tr><td>MPI_UNSIGNED_SHORT</td><td>unsigned short int</td></tr><tr><td>MPI_UNSIGNED</td><td>unsigned int</td></tr><tr><td>MPI_UNSIGNED_LONG</td><td>unsigned long int</td></tr><tr><td>MPI_UNSIGNED_LONG_LONG</td><td>unsigned long long int</td></tr><tr><td>MPI_FLOAT</td><td>float</td></tr><tr><td>MPI_DOUBLE</td><td>double</td></tr><tr><td>MPI_LONG_DOUBLE</td><td>long double</td></tr><tr><td>MPI_BYTE</td><td>char</td></tr></tbody></table></div><p>以下是一个最简单的例子，MPI_Comm_rank获取当前进程的rank，而MPI_Comm_size获取当前通讯器空间的大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到当前进程的 rank 以及整个 communicator 的大小</span></span><br><span class="line"><span class="type">int</span> world_rank;</span><br><span class="line"><span class="built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;world_rank);</span><br><span class="line"><span class="type">int</span> world_size;</span><br><span class="line"><span class="built_in">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;world_size);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"><span class="keyword">if</span> (world_rank == <span class="number">0</span>) &#123;</span><br><span class="line">    number = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">MPI_Send</span>(&amp;number, <span class="number">1</span>, MPI_INT, <span class="number">1</span>, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (world_rank == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">MPI_Recv</span>(&amp;number, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, <span class="number">0</span>, MPI_COMM_WORLD,</span><br><span class="line">             MPI_STATUS_IGNORE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Process 1 received number %d from process 0\n&quot;</span>,</span><br><span class="line">           number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-动态消息"><a href="#2-2-动态消息" class="headerlink" title="2.2 动态消息"></a>2.2 动态消息</h3><p>上述介绍了MPI发送事先知道消息长度的消息，MPI本身可以通过额外的函数调用支持动态消息。</p><p>MPI_Recv将MPI_Status结构体的地址作为参数(可以使用MPI_STATUS_IGNORE忽略)。操作完成后，该结构体会填充有关接收操作的其他信息。三个主要的信息包括：</p><ul><li>发送端的rank，通过stat.MPI_SOURCE访问。</li><li>消息的标签：MPI_TAG。</li><li>消息的长度：在结构体中没有预定义的函数，需要使用MPI_Get_count找出消息的长度。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MPI_Get_count</span>(</span><br><span class="line">    MPI_Status* status,</span><br><span class="line">    MPI_Datatype datatype,</span><br><span class="line">    <span class="type">int</span>* count)</span><br></pre></td></tr></table></figure><p>MPI_Recv会提供一个很大的缓冲区来为可能的传输大小处理，而MPI_probe可以在实际接收消息前先查询消息大小：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MPI_Probe</span>(</span><br><span class="line">    <span class="type">int</span> source,</span><br><span class="line">    <span class="type">int</span> tag,</span><br><span class="line">    MPI_Comm comm,</span><br><span class="line">    MPI_Status* status)</span><br></pre></td></tr></table></figure><p>MPI_probe除了不接受消息以外，和MPI_Recv是一样的。也同样会阻塞具有匹配消息和发送rank的消息，消息可用时，会填充status结构体。然后可以使用MPI_Recv接收实际的消息。以下是动态接收消息的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> number_amount;</span><br><span class="line"><span class="keyword">if</span> (world_rank == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAX_NUMBERS = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> numbers[MAX_NUMBERS];</span><br><span class="line">    <span class="comment">// Pick a random amount of integers to send to process one</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    number_amount = (<span class="built_in">rand</span>() / (<span class="type">float</span>)RAND_MAX) * MAX_NUMBERS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send the random amount of integers to process one</span></span><br><span class="line">    <span class="built_in">MPI_Send</span>(numbers, number_amount, MPI_INT, <span class="number">1</span>, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0 sent %d numbers to 1\n&quot;</span>, number_amount);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (world_rank == <span class="number">1</span>) &#123;</span><br><span class="line">    MPI_Status status;</span><br><span class="line">    <span class="comment">// Probe for an incoming message from process zero</span></span><br><span class="line">    <span class="built_in">MPI_Probe</span>(<span class="number">0</span>, <span class="number">0</span>, MPI_COMM_WORLD, &amp;status);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When probe returns, the status object has the size and other</span></span><br><span class="line">    <span class="comment">// attributes of the incoming message. Get the message size</span></span><br><span class="line">    <span class="built_in">MPI_Get_count</span>(&amp;status, MPI_INT, &amp;number_amount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a buffer to hold the incoming numbers</span></span><br><span class="line">    <span class="type">int</span>* number_buf = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * number_amount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now receive the message with the allocated buffer</span></span><br><span class="line">    <span class="built_in">MPI_Recv</span>(number_buf, number_amount, MPI_INT, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">             MPI_COMM_WORLD, MPI_STATUS_IGNORE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1 dynamically received %d numbers from 0.\n&quot;</span>,</span><br><span class="line">           number_amount);</span><br><span class="line">    <span class="built_in">free</span>(number_buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MPI_Probe是许多动态MPI应用程序的基础，例如控制端和子程序在交换变量大小的消息时会大量使用MPI_Probe。</p><h3 id="2-3-其他通信模式"><a href="#2-3-其他通信模式" class="headerlink" title="2.3 其他通信模式"></a>2.3 其他通信模式</h3><p>上述的MPI_Send是标准通讯模式，MPI实际提供了四种通讯模式：</p><p><img src="/2024/01/20/MPI/image-20240321200414798.png" alt="image-20240321200414798" style="zoom:50%;"></p><p>其他通讯模式是没有相应的接收函数的。这些模式与标准通讯模式的区别在于是否对发送数据缓冲，发送数据缓冲什么时候可以重用。详情见书。</p><h2 id="3-集合通信"><a href="#3-集合通信" class="headerlink" title="3 集合通信"></a>3 集合通信</h2><p>collective通信隐含着所有的进程都必须到达一个同步点后才能继续执行。</p><p>MPI的barrier函数如下，用于实现进程之间的同步。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MPI_Barrier(MPI_Comm communicator)</span><br></pre></td></tr></table></figure><p>组通信又可以根据通信方向分为一对多，多对一，多对多。广播是常见的一对多通信，而收集是最常见的多对一通信。</p><h3 id="3-1-MPI-BCAST"><a href="#3-1-MPI-BCAST" class="headerlink" title="3.1 MPI_BCAST"></a>3.1 MPI_BCAST</h3><p>MPI_BCAST用于将消息广播到其他的进程，广播和接收消息的进程的count等参数需要保持一致，并且<strong>广播和接收都是使用这一个函数来进行的</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MPI_Bcast</span>(</span><br><span class="line">    <span class="type">void</span>* buffer,</span><br><span class="line">    <span class="type">int</span> count,</span><br><span class="line">    MPI_Datatype datatype,</span><br><span class="line">    <span class="type">int</span> root, </span><br><span class="line">    MPI_Comm comm)</span><br></pre></td></tr></table></figure><h3 id="3-2-Gather-amp-Scatter"><a href="#3-2-Gather-amp-Scatter" class="headerlink" title="3.2 Gather &amp; Scatter"></a>3.2 Gather &amp; Scatter</h3><p>MPI_Gather用于一个进程从其他进程收集数据。只有接收进程需要一个有效的接收缓存，所有其他调用进程只需要传NULL，recvcount是接收到的每个进程发来的数据数量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Gather</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>* sendbuf, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> sendcount, </span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_Datatype sendtype,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>* recvbuf, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> recvcount, </span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_Datatype recvtype,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> root, </span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_Comm comm)</span></span></span><br></pre></td></tr></table></figure><p>MPI_SCATTER则用于一个进程向其他进程发送数据，与BCAST的区别是发送的是数据的各个部分给不同的进程。</p><p><img src="/2024/01/20/MPI/image-20240311211508108.png" alt="image-20240311211508108" style="zoom:50%;"></p><p>其原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MPI_Scatter</span>(</span><br><span class="line">    <span class="type">void</span>* send_data,</span><br><span class="line">    <span class="type">int</span> send_count,</span><br><span class="line">    MPI_Datatype send_datatype,</span><br><span class="line">    <span class="type">void</span>* recv_data,</span><br><span class="line">    <span class="type">int</span> recv_count,</span><br><span class="line">    MPI_Datatype recv_datatype,</span><br><span class="line">    <span class="type">int</span> root,</span><br><span class="line">    MPI_Comm communicator)</span><br></pre></td></tr></table></figure><p>send_data是所有数据的数组，而<strong>每个进程将接收到原数组连续的send_count个数据</strong>。</p><p>在使用Scatter和Gather时，发送进程需要开辟完整的数据空间，每个进程开辟一块独立的数据空间。以下是使用Gather和Scatter计算平均数的一段示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (world_rank == <span class="number">0</span>) &#123;</span><br><span class="line">  rand_nums = <span class="built_in">create_rand_nums</span>(elements_per_proc * world_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a buffer that will hold a subset of the random numbers</span></span><br><span class="line"><span class="type">float</span> *sub_rand_nums = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">float</span>) * elements_per_proc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scatter the random numbers to all processes</span></span><br><span class="line"><span class="built_in">MPI_Scatter</span>(rand_nums, elements_per_proc, MPI_FLOAT, sub_rand_nums,</span><br><span class="line">            elements_per_proc, MPI_FLOAT, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute the average of your subset</span></span><br><span class="line"><span class="type">float</span> sub_avg = <span class="built_in">compute_avg</span>(sub_rand_nums, elements_per_proc);</span><br><span class="line"><span class="comment">// Gather all partial averages down to the root process</span></span><br><span class="line"><span class="type">float</span> *sub_avgs = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (world_rank == <span class="number">0</span>) &#123;</span><br><span class="line">  sub_avgs = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">float</span>) * world_size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">MPI_Gather</span>(&amp;sub_avg, <span class="number">1</span>, MPI_FLOAT, sub_avgs, <span class="number">1</span>, MPI_FLOAT, <span class="number">0</span>,</span><br><span class="line">           MPI_COMM_WORLD);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute the total average of all numbers.</span></span><br><span class="line"><span class="keyword">if</span> (world_rank == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="type">float</span> avg = <span class="built_in">compute_avg</span>(sub_avgs, world_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ALL Gather类似与Gather，作用是将数据收集到每个进程上，如下图示：</p><p><img src="/2024/01/20/MPI/image-20240312121859621.png" alt="image-20240312121859621" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MPI_Allgather</span>(</span><br><span class="line">    <span class="type">void</span>* send_data,</span><br><span class="line">    <span class="type">int</span> send_count,</span><br><span class="line">    MPI_Datatype send_datatype,</span><br><span class="line">    <span class="type">void</span>* recv_data,</span><br><span class="line">    <span class="type">int</span> recv_count,</span><br><span class="line">    MPI_Datatype recv_datatype,</span><br><span class="line">    MPI_Comm communicator)</span><br></pre></td></tr></table></figure><h3 id="3-2-MPI-Reduce"><a href="#3-2-MPI-Reduce" class="headerlink" title="3.2 MPI_Reduce"></a>3.2 MPI_Reduce</h3><p>MPI_Reduce在每个进程上获取一个输入元素数组，将输出元素数组返回给root进程，输出元素包含reduce的结果。原型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MPI_Reduce</span>(</span><br><span class="line">    <span class="type">void</span>* send_data,</span><br><span class="line">    <span class="type">void</span>* recv_data,</span><br><span class="line">    <span class="type">int</span> count,</span><br><span class="line">    MPI_Datatype datatype,</span><br><span class="line">    MPI_Op op,</span><br><span class="line">    <span class="type">int</span> root,</span><br><span class="line">    MPI_Comm communicator)</span><br></pre></td></tr></table></figure></p><p>send_data是每个进程处理的数据，recv_data则存放规约结果，大小为sizeof(datatype)*count，op对应的规约操作有：</p><ul><li>MPI_MAX/MIN/SUM</li><li>MPI_PROD(所有元素相乘)</li><li>MPI_LAND/LOR/BAND/BOR(所有元素与/或/按位与/按位或)</li><li>MPI_MAXLOC/MINLOC(返回最小值/最大值所在进程的rank)</li></ul><p>当多个元素reduce时，需要注意是对应的元素进行reduce，而不是所有元素reduce。如下图：</p><p><img src="/2024/01/20/MPI/image-20240312122633209.png" alt="image-20240312122633209" style="zoom:50%;"></p><p>以下是使用reduce计算平均值的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">rand_nums = <span class="built_in">create_rand_nums</span>(num_elements_per_proc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sum the numbers locally</span></span><br><span class="line"><span class="type">float</span> local_sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_elements_per_proc; i++) &#123;</span><br><span class="line">  local_sum += rand_nums[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reduce all of the local sums into the global sum in order to</span></span><br><span class="line"><span class="comment">// calculate the mean</span></span><br><span class="line"><span class="type">float</span> global_sum;</span><br><span class="line"><span class="built_in">MPI_Allreduce</span>(&amp;local_sum, &amp;global_sum, <span class="number">1</span>, MPI_FLOAT, MPI_SUM,</span><br><span class="line">              MPI_COMM_WORLD);</span><br><span class="line"><span class="type">float</span> mean = global_sum / (num_elements_per_proc * world_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute the local sum of the squared differences from the mean</span></span><br><span class="line"><span class="type">float</span> local_sq_diff = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_elements_per_proc; i++) &#123;</span><br><span class="line">  local_sq_diff += (rand_nums[i] - mean) * (rand_nums[i] - mean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reduce the global sum of the squared differences to the root</span></span><br><span class="line"><span class="comment">// process and print off the answer</span></span><br><span class="line"><span class="type">float</span> global_sq_diff;</span><br><span class="line"><span class="built_in">MPI_Reduce</span>(&amp;local_sq_diff, &amp;global_sq_diff, <span class="number">1</span>, MPI_FLOAT, MPI_SUM, <span class="number">0</span>,</span><br><span class="line">           MPI_COMM_WORLD);</span><br></pre></td></tr></table></figure><p>类似ALLgather，reduce也有一个对应的ALLreduce函数，能将数据规约到每一个进程上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MPI_Allreduce</span>(</span><br><span class="line">    <span class="type">void</span>* send_data,</span><br><span class="line">    <span class="type">void</span>* recv_data,</span><br><span class="line">    <span class="type">int</span> count,</span><br><span class="line">    MPI_Datatype datatype,</span><br><span class="line">    MPI_Op op,</span><br><span class="line">    MPI_Comm communicator);</span><br></pre></td></tr></table></figure><h2 id="4-组和通讯器"><a href="#4-组和通讯器" class="headerlink" title="4 组和通讯器"></a>4 组和通讯器</h2><p>对于简单的程序，使用MPI_COMM_WORLD作为通讯器就够了，因为进程通常只与另外一个进程对话，或是和其他所有进程对话。当程序规模变大，需要只与进程组的子集对话，就需要使用新的通讯器。</p><h3 id="4-1-通讯器"><a href="#4-1-通讯器" class="headerlink" title="4.1 通讯器"></a>4.1 通讯器</h3><p>当需要创建新的通讯器时，以下是一个最常见的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MPI_Comm_split</span>(</span><br><span class="line">MPI_Comm comm,</span><br><span class="line">    <span class="type">int</span> color,</span><br><span class="line">    <span class="type">int</span> key,</span><br><span class="line">    MPI_Comm* newcomm)</span><br></pre></td></tr></table></figure><p>comm为原始的通讯器，调用该函数会在不影响原始通讯器的情况下创建新的通讯器newcomm。color参数确定进程属于哪个通讯器，color值相同的进程会分配给同一通讯器，若color为MPI_UNDEFINED，则该进程不在新通讯器当中。key则确定进程在新通讯器中的rank，按照key从小到大分配rank。</p><p>以下示例将通讯器拆分为一组通讯器：</p><p><img src="/2024/01/20/MPI/image-20240321194237707.png" alt="image-20240321194237707" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> world_rank, world_size;</span><br><span class="line"><span class="built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;world_rank);</span><br><span class="line"><span class="built_in">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;world_size);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> color = world_rank / <span class="number">4</span>; <span class="comment">// 根据行确定颜色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据颜色拆分通讯器，然后调用</span></span><br><span class="line"><span class="comment">// 利用原始秩</span></span><br><span class="line">MPI_Comm row_comm;</span><br><span class="line"><span class="built_in">MPI_Comm_split</span>(MPI_COMM_WORLD, color, world_rank, &amp;row_comm);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> row_rank, row_size;</span><br><span class="line"><span class="built_in">MPI_Comm_rank</span>(row_comm, &amp;row_rank);</span><br><span class="line"><span class="built_in">MPI_Comm_size</span>(row_comm, &amp;row_size);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;WORLD RANK/SIZE: %d/%d \t ROW RANK/SIZE: %d/%d\n&quot;</span>,</span><br><span class="line">world_rank, world_size, row_rank, row_size);</span><br><span class="line"></span><br><span class="line"><span class="built_in">MPI_Comm_free</span>(&amp;row_comm);</span><br></pre></td></tr></table></figure><p>以上代码将原通讯器按行拆分，并使用原始秩作为key，这样进程在新通讯器中和在原来通讯器中的顺序是一致的。最后，使用MPI_Comm_free释放通讯器，这是有必要的，因为MPI可以创建的对象数量是有限的。</p><p>除了MPI_Comm_split，还有其他用于创建通讯器的函数。MPI_Comm_dup的作用是创建通讯器的副本，常常用于使用库执行特殊函数的应用，用来保证用户代码和库代码不互相干扰，因此每个程序都首先创建一个MPI_COMM_WORLD的副本，避免其他使用MPI_COMM_WORLD的库的问题。</p><h3 id="4-2-组"><a href="#4-2-组" class="headerlink" title="4.2 组"></a>4.2 组</h3><p>组MPI_Group是MPI中的另外一种对象。通讯器是通讯的上下文及该通讯器包含的一组进程，而组是通讯器中所有进程的集合。</p><p>组可以进行集合理论中的各种操作，例如交，并等。</p><p><img src="/2024/01/20/MPI/image-20240321195138855.png" alt="image-20240321195138855" style="zoom:50%;"></p><p>在MPI中，提供API获取通讯器的进程组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MPI_Comm_group</span>(</span><br><span class="line">CMPI_Comm comm,</span><br><span class="line">MPI_Group* group)</span><br></pre></td></tr></table></figure><p>组可以获取rank和size，但不能通讯，因为没有上下文，但由于组不用于通信，可以在本地进行各种操作，例如交、并：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MPI_Group_union</span>(</span><br><span class="line">MPI_Group group1,</span><br><span class="line">MPI_Group group2,</span><br><span class="line">MPI_Group* newgroup)</span><br><span class="line"><span class="built_in">MPI_Group_intersection</span>(</span><br><span class="line">MPI_Group group1,</span><br><span class="line">MPI_Group group2,</span><br><span class="line">MPI_Group* newgroup)</span><br></pre></td></tr></table></figure><p>MPI还支持组的减，排除特定rank等操作。组可以用于创建通讯器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MPI_Comm_create_group</span>(</span><br><span class="line">MPI_Comm comm,</span><br><span class="line">MPI_Group group,</span><br><span class="line"><span class="type">int</span> tag,</span><br><span class="line">MPI_Comm* newcomm)</span><br></pre></td></tr></table></figure><h2 id="5-非阻塞通信"><a href="#5-非阻塞通信" class="headerlink" title="5 非阻塞通信"></a>5 非阻塞通信</h2><p>非阻塞通信主要用于实现计算与通信的重叠。</p><p>阻塞通信中，阻塞发送后该缓冲区可以被更新，而接收操作后数据已经完整，可以正确使用。且对于接收进程，接收消息是按照顺序接收的，无论消息到达的顺序先后。</p><p>由于通信经常需要一段时间，通信没有结束时，只能等待，非阻塞通信可以实现计算和通信的重叠，提高执行效率。非阻塞通信不必等待通信操作完成就可以返回，将通信交给特定硬件完成，和异步I/O的思想是一致的。在非阻塞通信中，发送缓冲区必须等待发送完成后释放，而接收消息必须等到消息到达后才可以引用。</p><p>非阻塞通信和通信模式结合，有四种形式，而MPI还引入了在循环中使用的重复非阻塞通信，因此通信模式有：</p><p><img src="/2024/01/20/MPI/image-20240321203029337.png" alt="image-20240321203029337" style="zoom:50%;"></p><p>此外，MPI还提供了多种非阻塞通信的完成方法和完成检测方法。</p><h3 id="5-1-ISEND-amp-IRECV"><a href="#5-1-ISEND-amp-IRECV" class="headerlink" title="5.1 ISEND&amp;IRECV"></a>5.1 ISEND&amp;IRECV</h3><p>MPI_ISEND启动一个非阻塞发送，调用后立即返回，比SEND多了一个参数request，request是一个非阻塞通信对象，通过对其的查询可以知道非阻塞发送是否完成。而IRECV则是启动一个非阻塞接收，与ISEND类似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MPI_Isend</span>(</span><br><span class="line">    <span class="type">void</span>* buf, </span><br><span class="line">    <span class="type">int</span> count, </span><br><span class="line">    MPI_Datatype datatype, </span><br><span class="line">    <span class="type">int</span> dest, </span><br><span class="line">    <span class="type">int</span> tag,</span><br><span class="line">MPI_Comm comm, </span><br><span class="line">    MPI_Request *request)</span><br><span class="line"><span class="built_in">MPI_Irecv</span>(</span><br><span class="line">    <span class="type">void</span>* buf, </span><br><span class="line">    <span class="type">int</span> count, </span><br><span class="line">    MPI_Datatype datatype, </span><br><span class="line">    <span class="type">int</span> source, </span><br><span class="line">    <span class="type">int</span> tag,</span><br><span class="line">MPI_Comm comm, </span><br><span class="line">    MPI_Request *request)</span><br></pre></td></tr></table></figure><h3 id="5-2-WAIT-amp-TEST"><a href="#5-2-WAIT-amp-TEST" class="headerlink" title="5.2 WAIT&amp;TEST"></a>5.2 WAIT&amp;TEST</h3><p>MPI提供了两个调用MPI_WAIT和MPI_TEST来检查发送和接收是否完成。</p><p>MPI_WAIT以非阻塞通信对象为参数，等到通信完成后才返回，同时释放该对象，这样就不用手动释放非阻塞通信对象。而MPI_TEST只检查非阻塞通信是否完成，设置完成标志，不释放相应的非阻塞通信对象。如果不使用wait释放request，就要手动释放request，如果对应通信没有完成，request不会被释放，而是会等到通信结束，因此使用request_free释放request不影响通信的完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MPI_Wait</span>(MPI_Request *request, MPI_Status *status);</span><br><span class="line"><span class="built_in">MPI_Test</span>(MPI_Request*request, <span class="type">int</span> *flag, MPI_Status *status);</span><br><span class="line"><span class="built_in">MPI_Request_free</span>(MPI_Request * request);</span><br></pre></td></tr></table></figure><p>MPI还提供了一次完成多个已经启动的非阻塞通信调用的接口，MPI_WAITANY，MPI_WAIT_ALL，MPI_WAIT_SOME，这里不一一介绍了。</p><h2 id="6-并行I-O"><a href="#6-并行I-O" class="headerlink" title="6 并行I/O"></a>6 并行I/O</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p>MPI根据读写定位方法的不同，提供了三种并行I/O：</p><ul><li>指定显式的偏移：没有文件指针的概念，每次读写指定读写位置。</li><li>各进程拥有独立文件指针：不需要指定读写位置，读写完成后自动移动到下一个数据位置，每个进程有一个视口，视口数据是文件连续或不连续的一部分。</li><li>共享文件指针：每个进程对文件的操作都从当前共享文件指针开始，且指针移动对所有进程可见。</li></ul><p>根据同步机制的不同，对文件的操作可以是阻塞的或非阻塞的。而非阻塞又分为单步和两步，单步中MPI只提供文件读写的开始操作，通过类似MPI_WAIT的方式完成；而两步则提供读写的开始和完成操作两步。只有对组读写才可以使用两步。</p><p>在MPI2中，对于非阻塞的组读写，只有两步法，这样将读写明显分开，可以提供给MPI更多的优化机会。</p><p>在文件的组调用时，调用使用的进程组就是打开文件时指定的通信域进程组。</p><p><img src="/2024/01/20/MPI/image-20240323155555228.png" alt="image-20240323155555228" style="zoom:50%;"></p><h3 id="6-2-并行文件基本操作"><a href="#6-2-并行文件基本操作" class="headerlink" title="6.2 并行文件基本操作"></a>6.2 并行文件基本操作</h3><p>并行的文件打开，关闭，删除等接口如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_File_open</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_Comm comm, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">char</span> * filename, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> amode, </span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_Info info,</span></span></span><br><span class="line"><span class="params"><span class="function"> MPI_File * fh)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_File_close</span><span class="params">(MPI_File * fh)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_File_delete</span><span class="params">(<span class="type">char</span> * filename, MPI_Info info)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_File_set_size</span><span class="params">(MPI_File fh, MPI_Offset size)</span></span>;<span class="comment">//字节为单位</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_File_preallocate</span><span class="params">(MPI_File fh, MPI_Offset size)</span></span>;<span class="comment">//保证文件分配到size字节空间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_File_get_size</span><span class="params">(MPI_File fh, MPI_Offset * size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_File_get_group</span><span class="params">(MPI_File fh, MPI_Group * group)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_File_get_amode</span><span class="params">(MPI_File fh, <span class="type">int</span> * amode)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_File_set_info</span><span class="params">(MPI_File fh, MPI_Info info)</span></span>;<span class="comment">//传递优化和提示信息</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_File_set_info</span><span class="params">(MPI_File fh, MPI_Info info)</span></span>;</span><br></pre></td></tr></table></figure><p>文件的打开方式有以下九种之一：</p><p><img src="/2024/01/20/MPI/image-20240323160041965.png" alt="image-20240323160041965" style="zoom:50%;"></p><h3 id="6-3-显式偏移的并行文件读写"><a href="#6-3-显式偏移的并行文件读写" class="headerlink" title="6.3 显式偏移的并行文件读写"></a>6.3 显式偏移的并行文件读写</h3><p>在文件读写时需要注意大小，所有文件读写的数量参数count都是int型，当读取G级别的数据时，就要考虑是否超出了int表示范围(&lt;2G)。</p><p><strong>阻塞方式</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_File_read_at</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_File fh, </span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_Offset offset, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> * buf, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> count,</span></span></span><br><span class="line"><span class="params"><span class="function"> MPI_Datatype datatype, </span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_Statye * status)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_File_write_at</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_File fh, </span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_Offset offset, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> * buf, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> count,</span></span></span><br><span class="line"><span class="params"><span class="function"> MPI_Datatype datatype, </span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_Status * status)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_File_read_at_all</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_File fh, </span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_Offset offset, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *buf, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> count,</span></span></span><br><span class="line"><span class="params"><span class="function">MPI_Datatype datatype, </span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_Status * status)</span></span>;</span><br></pre></td></tr></table></figure><p>read_at_all是一个组调用，要求所有进程调用时都使用相同的偏移量和读取参数，所有进程读取相同位置的数据。</p><p><strong>非阻塞方式</strong></p><p>类似于非阻塞通信，非阻塞并行读写为IREAD/IWRITE，并有一个request参数，用于检查非阻塞读写是否完成。检查是否完成同样是MPI_WAIT和MPI_TEST函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_File_iread_at</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_File fh, </span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_Offset offset, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> * buf, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> count,</span></span></span><br><span class="line"><span class="params"><span class="function"> MPI_Datatype datatype, </span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_Request * request)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_File_iwrite_at</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_File fh, </span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_Offset offset, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> * buf, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> count,</span></span></span><br><span class="line"><span class="params"><span class="function"> MPI_Datatype datatype, </span></span></span><br><span class="line"><span class="params"><span class="function">    MPI_Request * request)</span></span>;</span><br></pre></td></tr></table></figure><p>此外，还有应用于组的两步非阻塞调用形式，明确将读写分为两步完成，详情见书。</p><h3 id="6-4-多视口并行文件读写"><a href="#6-4-多视口并行文件读写" class="headerlink" title="6.4 多视口并行文件读写"></a>6.4 多视口并行文件读写</h3><p>多视口并行文件读写中，每个进程都有自己的文件指针，可以看到一个视口内的文件数据。</p><p><img src="/2024/01/20/MPI/image-20240323162950790.png" alt="image-20240323162950790" style="zoom:50%;"></p><p>其他内容待后续需要使用时补充。</p><h3 id="6-5-共享文件读写"><a href="#6-5-共享文件读写" class="headerlink" title="6.5 共享文件读写"></a>6.5 共享文件读写</h3><p>待后续需要使用时补充。</p>]]></content>
      
      
      <categories>
          
          <category> 高性能计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpV8_Pursuing_Optimal_Vectorization_and_Regular_Computation_Pattern_in_SpMV</title>
      <link href="/2024/01/17/SpV8_Pursuing_Optimal_Vectorization_and_Regular_Computation_Pattern_in_SpMV/"/>
      <url>/2024/01/17/SpV8_Pursuing_Optimal_Vectorization_and_Regular_Computation_Pattern_in_SpMV/</url>
      
        <content type="html"><![CDATA[<h1 id="SpV8-Pursuing-Optimal-Vectorization-and-Regular-Computation-Pattern-in-SpMV"><a href="#SpV8-Pursuing-Optimal-Vectorization-and-Regular-Computation-Pattern-in-SpMV" class="headerlink" title="SpV8_Pursuing_Optimal_Vectorization_and_Regular_Computation_Pattern_in_SpMV"></a>SpV8_Pursuing_Optimal_Vectorization_and_Regular_Computation_Pattern_in_SpMV</h1><p>在之前的论文阅读中，发现间隔一段时间后，即使看笔记也想不起来第一次读的完整感觉了，所以之后还是把重要的内容记在最前面。</p><p>本文作者提出了一个SpV8算法，从并行化计算的角度来优化SpMV，而矩阵格式则仍然采用CSR。这样做的原因是其他矩阵格式实现高向量利用率的同时，引入了大量的分支预测和控制代价，因此作者尝试在基本的结构上提高向量利用率，避免复杂的计算过程，从而实现高效的优化。</p><p>SpMV有两种SIMD并行策略，行内并行，跨行并行(列内的元素用一个向量寄存器计算)，作者的优化就是基于这两种策略的。行内并行对于比较长的行有效，而跨行并行对行长度相似的情况比较有效，这样的话无论行的长短，都能提高向量化率。作者的优化就是将行按长度排序，然后将长度相同的放在一起跨行并行，长度不同的行内并行，从而在避免SpMV过程复杂化的同时提高向量化率。并且为了减少排序的开销，将矩阵进行分区，对分区规模进行不同的设定。而在分区时，每8行一个单元放入分区，从而避免伪共享。</p><p>整体而言，提高SpMV的最常见的两个切入点就是提高向量化率和提高访存速度，本篇的重点是通过行内并行和跨行并行混合来提高向量化率，但不引入过多的额外执行开销，避免复杂的执行过程和规约，在访存方面没有涉及。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>作者首先阐述了SpMV算法的一些基本内容，并提到SpMV通常是对同一矩阵迭代进行的，因此可以对矩阵结构进行优化，因为预处理成本可以在接下来的迭代中摊销[3]。</p><p>许多研究是从格式和复杂的且不规则的计算模式来优化。本文作者认为不规则的计算会带来沉重的开销，在作者之前的研究[4]中，发现MKL由于不规则的计算流程，40%的周期会浪费在错误的分支预测上，具体来说，不规则的SpMV会遇到以下问题：</p><ul><li>预测：复杂的执行流程会导致更多分支和错误预测乘法。</li><li>规约：最终结果的计算和顺序取决于矩阵的结构，可能需要进行规约。这会带来加法树和原子加法，损害整体性能。</li><li>掩码：向量操作需要掩码。不规则的计算需要设置精细的掩码来完成计算，这会带来额外的控制开销，并减少向量化的使用。</li></ul><p>为了研究这些问题，作者分析了最先进的一些SpMV方法：CVR，CSR5，ESB。CVR和CSR5可以通过连接和扭曲行与SIMD宽度对齐来实现高度向量化。作为代价，这两种方法都需要在每次向量乘法之后检查行结束条件，以便可以正确处理最终值。每行的nnz不规则，因此这会导致大量分支预测错误。同时CSR5还需要一个灵活的加法树，进行求和操作。加法树是通过掩码向量运算实现的，这会导致掩码操作和额外向量计算开销。ESB则使用改进的ELLPACK，对行进行排序，按列进行向量计算，需要用掩码来选择列和元素，会导致额外的控制逻辑，同时，行长度的高方差也是一个问题，因为最长的行可能阻碍向量化。这让ESB对矩阵结构敏感，ESB采用列分段减轻这种影响，但是这又增加了规约的成本，需要在最后计算和总结多个列分段的部分和。</p><p>作者在XEON CPU评估上述方法，使用suitsparse中的soc-sign-epinions矩阵，这是一个社交网络矩阵，行非常稀疏，行方差很高。图2a展现了该矩阵的nnz分布。baseline是MKL的SpMV，MKL_opt是MKL的优化方法。所有的性能结果列在图2b。而图2c展现了向量使用率，图2d则展现了分支预测开销。作者将执行过程分为四类指令类型：</p><ul><li>SIMD Arith</li><li>SIMD Other(load/store，permute/shuffle等)</li><li>Scalar Arith</li><li>Scalar Other</li></ul><p>图2e展现了这些指令的数量。</p><p><img src="/2024/01/17/SpV8_Pursuing_Optimal_Vectorization_and_Regular_Computation_Pattern_in_SpMV/image-20240122154427333.png" alt="image-20240122154427333" style="zoom:50%;"></p><p><img src="/2024/01/17/SpV8_Pursuing_Optimal_Vectorization_and_Regular_Computation_Pattern_in_SpMV/image-20240122154538196.png" alt="image-20240122154538196" style="zoom:50%;"></p><p>可以看到MKL的向量利用很低，而且有很高的预测开销。MKL_opt使用了更多向量指令，但是还是使用率很低。ESB提高了向量使用率，但是由于行长度的不同而带来了更多掩码操作以及多余的SIMD指令。CVR和CSR5都有很高的向量利用率，但是相应的复杂的分支带来了很大的开销。所有的结果都证实了不规则计算模式的乘法是很重的，向量使用和不规则计算模式之间的权衡是最先进的SpMV工作中的挑战。</p><p>作者提出的SpV8通过常规计算模式实现高向量化效率，在不使用复杂控制流或掩码的情况下执行最有利的计算方法。因此SpV8有显著性能优势。此外，其预处理开销也很低，表明其在许多场景有很高的适用性。</p><h2 id="2-SpV8-Kernel-Design"><a href="#2-SpV8-Kernel-Design" class="headerlink" title="2 SpV8 Kernel Design"></a>2 SpV8 Kernel Design</h2><h3 id="A-Vectorization-Strategy"><a href="#A-Vectorization-Strategy" class="headerlink" title="A. Vectorization Strategy"></a>A. Vectorization Strategy</h3><p>作者首先在 SIMD 机器上研究 SpMV 中的两种基本矢量化策略：行内并行和跨行并行，如图 3 所示。没有采用其他更复杂的策略，因为它们不可避免地会带来额外的开销，如上面各节所述。</p><p><img src="/2024/01/17/SpV8_Pursuing_Optimal_Vectorization_and_Regular_Computation_Pattern_in_SpMV/image-20240122160719776.png" alt="image-20240122160719776" style="zoom:50%;"></p><p>行内并行是最简单的 SIMD 实现，也是 MKL CSR SpMV 的默认算法。它收集同一行的值并在 SIMD 向量中计算它们。很明显，行内并行对于允许更高向量化使用的长行更有效。然而，对于大多数非零值位于短行中的无标度矩阵，此策略可能会遇到并行度极低的问题。</p><p>另一种基本策略是跨行并行，它使用 SIMD 通道同时处理多个panel，如图 3(b) 所示。同一panel中的行一起处理，直到计算出最长的行。向量位掩码用于在行不均匀的情况下过滤掉不需要的数据负载和计算。在相邻行具有相似长度的矩阵中，跨行并行比行内并行具有优势，因为它不需要长行来实现高向量使用。因此，一种有效的优化方法是将相同长度的行放在一起，这样更有利于跨行并行。然而，如果行的长度分布很宽，这种优化通常效果不佳。</p><p>图 4 比较了两种随机生成稀疏结构的行内并行和跨行并行：等长行和随机长度行。跨行并行在等长行上实现了高性能，但在随机长度行上受到严重破坏，因为它的许多操作都被屏蔽了。从这个实验中观察到的一个有趣的现象是，行内并行的性能随着行长度的增加而迅速提高，因为较长的行可以更好地矢量化。例如，对于长度超过 40 的行，矢量化率将不低于 85%。如图 4(a) 所示，当行数为 40 或更长时，行内并行性能良好，与跨行并行相比效率更高，而跨行并行在偶数行上应该是最佳的。这表明，在长行上，行内并行是一种有效的方法，可以提供接近最佳的性能。</p><p><img src="/2024/01/17/SpV8_Pursuing_Optimal_Vectorization_and_Regular_Computation_Pattern_in_SpMV/image-20240122161432464.png" alt="image-20240122161432464" style="zoom:50%;"></p><h3 id="B-Basic-Kernel"><a href="#B-Basic-Kernel" class="headerlink" title="B. Basic Kernel"></a>B. Basic Kernel</h3><p>SpV8尽可能的实现接近100%的向量化，并最小化算法的复杂性，不使用部分向量操作和掩码简化计算模式。多余的nnz通过标量计算处理。并通过规则的产生结果来避免不规则的规约，从而最大限度减少条件分支的数量，图5描述了SpV8预处理步骤：</p><ul><li>按行nnz的长度进行排序</li><li>从每个长度组的最后一行开始，将末尾的行合并到Fragment，保留向量长度行来作为Panel</li><li>将所有panel转为列主序格式方便计算</li></ul><p><img src="/2024/01/17/SpV8_Pursuing_Optimal_Vectorization_and_Regular_Computation_Pattern_in_SpMV/image-20240122161856038.png" alt="image-20240122161856038" style="zoom: 67%;"></p><p>SpV8将矩阵分为Panel和一个fragment，这两部分有不同的特征。对于panel，器长度与SIMD宽度对齐，可以通过跨行并行实现最佳向量化。而fragment则更适合行内并行，而非向量化的值通过标量计算完成、这样能让SpV8的计算模式高度规则化。最终的结果也是规则产生的，不需要掩码和不规则的规约及复杂的条件分支。</p><h3 id="C-Partitioning"><a href="#C-Partitioning" class="headerlink" title="C. Partitioning"></a>C. Partitioning</h3><p>SpMV的许多矩阵都是来自工业或科学场景。例如，许多社交网络矩阵都是对热链接的社交检测的结果。</p><p>社区检测：一种发现网络中紧密连接的节点群体的方法。这些群体通常代表了具有共同兴趣或行为的用户群体。通过社区检测，可以将热链接(频繁或强烈的互动)转移到对角线矩阵，这样在矩阵中，对角线附近的元素表示同一社区内的连接，反之表示不同社区之间的连接。</p><p>在材料科学问题中，nnz很可能是连续的。这种固有结构在 SpMV 中是有益的，因为它们有利于输入向量 x 上的数据重用。同时，由于输出向量y是顺序写入的，因此对y的访问也可以被忽略。</p><p>SpV8对行进行排序会改变对向量x和y的访存顺序。这可能导致局部性下降。为了避免全局排序带来对x和y访问的大量缓存缺失，矩阵被划分为多个分区，分区内进行排序。过于精细的分区会减少向量使用，产生较少的panel和更多fragment，因此分区大小的选择是访存和向量化效率之间的trade-off。</p><p>作者在两种矩阵实验了不同的分区(500-2k行)，一个是soc-sign-epinions，是一个无标度矩阵，行长度高度不规则，nnz随机分布；另一个是tx-20210，行长度限制在一个小范围，nnz分布有结构性。结果如图6。作者首先测试了panels和fragment中的nnz比例，小的分区会导致fragment很大，不过许多fragment都足够长来实现高度向量化。</p><p>因此，即使分区规模较小，SpV8 也能实现不错的矢量化率（&gt; 90%）。另一方面，分区规模对两个矩阵的内存访问有不同的影响。 tx-2010 对规模更敏感，因为其原始位置更好，因此破坏成本更高。另一方面，分区规模的增长只会导致 soc-sign-epinions 的访存延迟轻微增加。上述观察得出的结论：不同的矩阵类型应该使用不同的权衡分区尺度，以避免大量的内存访问损失，同时仍然保持较高的向量使用率。在本文中，根据经验，无标度矩阵的分区规模设置为 10K 行左右，HPC 矩阵的分区规模设置为 2K 行左右。</p><p><img src="/2024/01/17/SpV8_Pursuing_Optimal_Vectorization_and_Regular_Computation_Pattern_in_SpMV/image-20240122165603227.png" alt="image-20240122165603227" style="zoom:50%;"></p><h2 id="3-MULTI-CORE-IMPLEMENTATION"><a href="#3-MULTI-CORE-IMPLEMENTATION" class="headerlink" title="3 MULTI-CORE IMPLEMENTATION"></a>3 MULTI-CORE IMPLEMENTATION</h2><p>SpV8可以通过将分区给不同线程实现多核并行，为了保持平衡的工作负载，使用nnz而不是行数来创建分区，因为行的长度通常具有很高的方差。同时要求分区数量超过线程数量。虽然每个分区都是由单个线程独立计算的，但使用调度程序动态地将分区分配给空闲线程，直到处理完所有分区。这样的分区调度策略有效保证了多个线程的工作负载平衡。具体来说，每个分区的非零值阈值 Np 可以计算为：</p><p><img src="/2024/01/17/SpV8_Pursuing_Optimal_Vectorization_and_Regular_Computation_Pattern_in_SpMV/image-20240122165945357.png" alt="image-20240122165945357" style="zoom:50%;"></p><p>Nall是nnz，Rall是行数，T是线程数，Rk是上述提到的分区规模，通过上式保证至少4T的分区被创建。</p><p>为了避免同步或原子操作，不分割行。同时，为了避免伪共享，以Lcache/Ldata的粒度分配行，Lcache是L1缓存行大小(64byte)，Ldata是每个向量y元素的大小，以便两个线程永远不会写入同一缓存行(跨行访问，8行的元素放在一起是64byte)。在作者的实现中，使用双浮点，分配粒度为8行。所以在创建分区时，每次从矩阵中收集8行，当nnz超出Np时，当前分区就创建完成了，再创建下一个分区。</p><h2 id="4-Evaluation"><a href="#4-Evaluation" class="headerlink" title="4 Evaluation"></a>4 Evaluation</h2><h3 id="A-Experiment-Setting"><a href="#A-Experiment-Setting" class="headerlink" title="A. Experiment Setting"></a>A. Experiment Setting</h3><p>实验平台为Xeon Gold 6146。CPU频率限制在2.5GHz。baseline是MKL 2020.2 CSR。作者评估了ESB，CSV和CSR5的实现。所有的实现都采用AVX512。所有的方法都在单线程和8线程分别测试。benchmark是71个稀疏矩阵，36个是无标量矩阵，35个是HPC矩阵。矩阵规模从40K-2.3Billion nnz不等，行数在10K到200M之间。</p><h3 id="B-Vectorization-and-Regularity"><a href="#B-Vectorization-and-Regularity" class="headerlink" title="B. Vectorization and Regularity"></a>B. Vectorization and Regularity</h3><p>作者评估了一些无标度和 HPC 矩阵上测试方法的向量化效率。作者还通过两个指标来评估不规则计算模式的惩罚：分支推测错误（通过浪费的 µ-op 流水线的比率来衡量）和每 NNZ 指令数（通过将总指令数除以总量来计算）非零值。结果如图 7 所示。</p><p><img src="/2024/01/17/SpV8_Pursuing_Optimal_Vectorization_and_Regular_Computation_Pattern_in_SpMV/image-20240122171920431.png" alt="image-20240122171920431" style="zoom:50%;"></p><p>如图所示，SpV8、CVR 和 CSR5 在两种类型上均实现了较高的向量使用率。 MKL opt 更适合无标度矩阵，因为它使用行内并行，可以更好地处理不均匀的行。另一方面，ESB 使用跨行并行，这在行长度不太不规则的 HPC 矩阵上效率更高。</p><p>同时，不规则性问题对 MKL opt、CVR 和 CSR5 影响很大，因为它们往往会遇到更多的分支预测错误并需要更多的指令。有趣的是，无标度矩阵对分支预测更加友好，因为它们通常具有更可预测的很长的行。它们对 CVR 和 CSR5 也更友好，因为无标度矩阵中的长行降低了控制流和结果计算的复杂性。同时，SpV8在所有实验中表现出最小的惩罚，具有接近零的分支预测误差和最低的指令量，表明SpV8具有最小的计算复杂度。</p><h3 id="C-Overall-Performance"><a href="#C-Overall-Performance" class="headerlink" title="C. Overall Performance"></a>C. Overall Performance</h3><p>图 8 分别使用单线程和8线程描述了所有测试方法在无标度和 HPC 矩阵上的性能。通过tmkl/topt计算每种方法相对于 MKL 基线的加速比，其中topt和tmkl分别是优化方法和基线的运行时间。图 8 列出了所有方法的平均加速比。如图所示，在所有条件下，SpV8 都以巨大的裕度实现了最佳性能。对于所有 71 个矩阵（使用单个线程）的平均加速比，SpV8 比baseline高出 2.0 倍，比第二佳（ESB 和 CSR5）高出 1.3 倍。使用8线程时，SpV8 比基线高 2.8 倍，比第二佳 (CSR5) 高 1.4 倍。需要注意的是，对于无标度矩阵的计算，多线程kernel的实现很有挑战性，因为不规则性增加了工作负载平衡的难度，结果证明了SpV8在大规模无标度矩阵上具有良好可扩展性。</p><img src="/2024/01/17/SpV8_Pursuing_Optimal_Vectorization_and_Regular_Computation_Pattern_in_SpMV/image-20240122172256076.png" class title="image-20240122172256076"><h3 id="D-Pre-processing-Overhead"><a href="#D-Pre-processing-Overhead" class="headerlink" title="D. Pre-processing Overhead"></a>D. Pre-processing Overhead</h3><p>与MKL baseline相比，SpV8的预处理时间为8x，而CVR是最小的，为6x。考虑到真实应用的潜在迭代数量，SpV8的预处理代价是可接受的。</p><h2 id="5-Conclusion"><a href="#5-Conclusion" class="headerlink" title="5 Conclusion"></a>5 Conclusion</h2><p>在本文中，作者提出了 SpV8，这是一种新的 SpMV 内核，旨在在具有常规计算模式的同时实现最大向量使用。作者研究了多种计算模式在不同矩阵结构上的性能，并设计了 SpV8 以在不同的行上选择最合适的解决方案。在 Intel Xeon CPU 上的实验结果表明，SpV8 在各种矩阵类型上都优于其他最先进的方法，具有最低的复杂性和非常好的性能及很小的预处理开销。代码在<a href="https://github.com/monkey2000/spv8-public。">https://github.com/monkey2000/spv8-public。</a></p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm and hardware co optimized solution for large SpMV problems</title>
      <link href="/2024/01/15/Algorithm_and_hardware_co-optimized_solution_for_large_SpMV_problems/"/>
      <url>/2024/01/15/Algorithm_and_hardware_co-optimized_solution_for_large_SpMV_problems/</url>
      
        <content type="html"><![CDATA[<h1 id="Algorithm-and-hardware-co-optimized-solution-for-large-SpMV-problems"><a href="#Algorithm-and-hardware-co-optimized-solution-for-large-SpMV-problems" class="headerlink" title="Algorithm and hardware co optimized solution for large SpMV problems"></a>Algorithm and hardware co optimized solution for large SpMV problems</h1><p>本篇论文用了特定硬件来结合优化，所以泛用性不高。但是提醒了我按行访问数据和按列访问数据，对于不同稀疏模式的矩阵来说是不一样的，另外就是尽量让x停留在缓存当中。</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>SpMV 在商用 (COTS) 架构上的性能和效率很差，特别是当数据大小超过片上内存或末级缓存 (LLC) 时。这项工作提出了一种针对大型SpMV问题的算法协同优化硬件加速器。首先探讨各种 SpMV 算法的数据传输特性的基本差异。作者提出了一种算法，该算法需要最少的数据传输量，同时确保所有访问的主内存流。然而，所提出的算法需要高效的多路合并，而这在 COTS 架构中很难实现。因此，作者提出了一种硬件加速器模型，其中包括用于多路合并操作的专用集成电路（ASIC）。所提出的加速器采用了最先进的 3D 堆叠高带宽内存 (HBM)，以展示所提出的算法与最新技术相结合的能力。使用标准基准的仿真结果显示，与具有商业库的 COTS 架构相比，能源效率和性能提高了 100 倍以上。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>SpMV的重要性这里不在赘述。COTS 架构（CPU、GPU 等）的SpMV性能不佳的原因有两个。首先是内存墙问题，也就是说，相对于可用的计算能力，主存带宽已经很稀缺。第二，可能也是更重要的原因是，COTS 架构建立在传统的内存层次结构之上，该层次结构期望数据具有空间和时间局部性。然而，由于稀疏性，大型 SpMV 问题几乎缺乏空间和时间局部性。这使得 COTS 平台中的传统内存层次结构本质上不适合 SpMV。当我们为 SpMV 实现选择 COTS 平台时，我们会遇到架构问题。</p><p>尽管如此，研究人员研究了架构限制，并尝试通过多种技术将 SpMV 适合 COTS 架构。以CPU为例，研究人员尝试通过采用复杂的存储格式，或使用密集的预处理方法（例如寄存器分块、矩阵）来减轻矩阵结构稀疏性的影响。重新排序。对于 GPU，研究人员探索了许多复杂的方法，例如细粒度并行分解、基于模型的自动调整以及矩阵表示转换和平铺以增加时间局部性。然而，通过这些方法获得的性能和效率仍然远未达到密集矩阵运算所实现的水平。</p><p><strong>Contributions</strong></p><p>在这项工作中，作者提出了一种针对大型 SpMV 问题的解决方案，该解决方案在性能和效率方面比传统架构提高了 100 倍。该解决方案的关键步骤如下。</p><p>为了解决架构问题，我们从相反的方向考虑SpMV。即首先选择最适合大型 SpMV 数据传输特性的算法，然后构建所需的实现平台。作者提出了一种称为“TwoStep”的算法，该算法可确保所有数据访问的 DRAM 流式传输（即充分利用内存带宽），并消除 COTS 架构上 SpMV 实现通常所需的过多数据传输。然而，为了使该算法实现高性能和高效率，我们需要对大量长排序列表进行多路合并操作。由于使用 CPU 或 GPU 很难有效地实现这一点，因此我们提出了专用集成电路（ASIC）作为所提出的两步算法的计算平台。</p><p>为了解决内存墙问题，作者考虑最先进的 3D 堆叠主内存，即高带宽内存(HBM)和中介层技术。 HBM 提供的极限带宽显着缓解了内存墙问题。因此，我们提出了一种 SpMV 加速器模型，该模型通过中介层将TwoStep算法的 ASIC 集成到 HBM。</p><h2 id="2-PROPOSED-ALGORITHM"><a href="#2-PROPOSED-ALGORITHM" class="headerlink" title="2 PROPOSED ALGORITHM"></a>2 PROPOSED ALGORITHM</h2><p>TwoStep算法将向量分为多段，将矩阵按列划分，存储格式为CSR。x的宽度对应于片上存储的大小，为了便于并行性化，进一步将矩阵条水平划分为块。</p><p><strong>Step1</strong></p><p>一个向量段从主存传输到片上存储，相应的矩阵条带也从主存读取。然后进行矩阵向量乘。每个处理元件(PE)负责为其分配的矩阵条带部分处理，所有PE共享向量段。该过程完成后，得到第k个矩阵条带的对应向量vk，PE将vk存入主存。该中间向量是稀疏的，因此位置索引与值一起存储。当我们在条带内按行方向遍历矩阵元素时，vk 的元素按照矩阵元素的行指针的升序顺序生成。因此，每个稀疏中间向量根据其元素索引（键）进行排序，这对于该算法的第二步至关重要。第一步，我们对所有矩阵条带继续此过程，最终得到 DRAM 中的 n 个稀疏中间向量。</p><p><strong>Step2</strong></p><p>在第二步中，所有中间向量 (vks) 从主存储器流回 PE，其中本质上对这些排序列表 (vks) 进行多路合并操作以构造结果向量 y。每个PE仅合并中间向量的一部分，如图1所示。</p><p><img src="/2024/01/15/Algorithm_and_hardware_co-optimized_solution_for_large_SpMV_problems/image-20240116090000181.png" alt="image-20240116090000181" style="zoom:50%;"></p><p>两步算法的主要贡献在于它保证了完整的 DRAM 流式访问，同时消除了由于矩阵划分而导致的过多向量数据传输。源向量的每个元素仅从 DRAM 到片上存储进行一次传输，这对于传统架构上的大型 SpMV 实现来说通常是不正确的。作者将在第四节详细讨论这一点。</p><p>作者提出的两步算法理论上可以在 CPU 或 GPU 上实现。不幸的是，对于大型 SpMV 问题，两步法需要合并数千个排序列表，其中每个列表有数百万个元素，这是一项具有挑战性的任务。这种大型多路合并是受计算限制的，并且由于糟糕的扩展行为，很难使用 COTS 架构有效地完成。然而，通过定制硬件设计，可以实现大量长列表的高效且可扩展的多路合并。因此，作为一种解决方案，在这项工作中，作者开发了一个协同优化的 ASIC 硬件加速器，作为我们提出的两步算法的实现平台。</p><p>TwoStep的伪代码如下：</p><p><img src="/2024/01/15/Algorithm_and_hardware_co-optimized_solution_for_large_SpMV_problems/image-20240116085226127.png" alt="image-20240116085226127" style="zoom:50%;"></p><h2 id="3-PROPOSED-HARDWARE-ACCELERATOR"><a href="#3-PROPOSED-HARDWARE-ACCELERATOR" class="headerlink" title="3 PROPOSED HARDWARE ACCELERATOR"></a>3 PROPOSED HARDWARE ACCELERATOR</h2><p>作为两步算法的实现平台，作者在这项工作中开发了一个硬件加速器，如图 2 所示。对于主存储器，使用多个 HBM [15]。这种最先进的 3D 堆栈存储器可以提供极高的带宽（多个堆栈时约为 TB/s）。整个系统位于插入器底座上，在主存储器和计算核心之间提供宽广的高速通道。 HBM 与中介层一起显着缓解了 SpMV 等内存限制问题的内存墙问题。然而，应该注意的是，HBM 并不是两步算法必须有用的。</p><p><img src="/2024/01/15/Algorithm_and_hardware_co-optimized_solution_for_large_SpMV_problems/image-20240116090307784.png" alt="image-20240116090307784" style="zoom: 67%;"></p><p>对于片上存储（算法所需的快速随机存取存储），我们使用嵌入式 DRAM (eDRAM) 暂存器。与静态随机存取存储器 (SRAM) 相比，它具有更高的密度和更低的泄漏。此外，eDRAM 使用更多的存储体和较小的页面大小，允许以适度的面积损失进行低功耗操作 [16]，并且可以提供高随机访问带宽 [17]。</p><p>PE 由两种不同类型的内核组成。第一种是乘法累加 (MA) 核心，负责算法的步骤 1。它包括多组串联的流水线浮点乘法器和加法器，如图3所示。步骤1中与矩阵条带相关的计算可以由多个PE的MA核来处理。 MA 核心总数取决于片上 eDRAM 的随机存取带宽和 DRAM 的流带宽。由于 eDRAM 具有许多小型存储体，并且访问 xk 时发生存储体冲突的可能性（由于 Ak 的稀疏性）较低，因此可以在 MA 内核之间共享片上存储，而不会在流水线中引入许多停顿。</p><p><img src="/2024/01/15/Algorithm_and_hardware_co-optimized_solution_for_large_SpMV_problems/image-20240116090604479.png" alt="image-20240116090604479" style="zoom:50%;"></p><p>另一种类型的核心，即多路合并（MM）核心，处理第二步。基数排序网络和基于二叉树的流水线合并排序网络的组合构成了MM核心。 MM 内核的完整硬件详细信息超出了本文的范围。 MM 内核还利用 eDRAM 暂存器的一小部分来存储每个列表 (vk) 的 DRAM 页大小级别数据块。这样做是为了在每次发出列表数据的加载请求时完全摊销 DRAM 页面打开成本。定制 MM ASIC 可以提供足够高的吞吐量以使 HBM 的流带宽达到饱和。此外，多个PE的多个MM核可以并行工作并独立地合并中间向量的不同部分。</p><h2 id="4-EVALUATION-OF-LARGE-SPMV-ALGORITHMS"><a href="#4-EVALUATION-OF-LARGE-SPMV-ALGORITHMS" class="headerlink" title="4 EVALUATION OF LARGE SPMV ALGORITHMS"></a>4 EVALUATION OF LARGE SPMV ALGORITHMS</h2><p>SpMV 具有较高的内存访问与计算比率，因此数据传输特性是 SpMV 算法最重要的方面之一。在本节中，为了评估提出的算法，作者探讨了不同 SpMV 算法系列的数据传输特性的基本差异，同时忽略了计算要求。作者假设磁盘访问（DAM）模型建立在两级存储(主存和片上存储)之上，提出了单核场景中快速和慢速内存级别之间的数据传输的高级数学模型，但是分析也适用于多核共享内存场景。</p><p>由于高效的 SpMV 内核应该受内存限制 [1]，因此通常衡量 SpMV 算法成功与否的标准是可以实现的峰值带宽的分数。在本研究中，我们主要考虑实现完整主存（DRAM）流式访问（即利用峰值带宽）的算法。因此，我们衡量成功的标准是执行时间，它与内存层次结构级别之间传输的数据量成反比。</p><p>通常会对大型稀疏矩阵进行分区，以避免随机访问 DRAM 并实现并行化。图 4 显示了这样一个 N ×N 矩阵，该矩阵被划分为 m × n 块。使用方阵来简化计算而不失一般性。矩阵 A 总共最多有 hN 个非零值，其中 h 是每行非零值的平均数量。我们还将 Sm 定义为矩阵元素（包括元数据）的平均大小，将 Sv 定义为向量元素和结果向量元素的大小。</p><p><img src="/2024/01/15/Algorithm_and_hardware_co-optimized_solution_for_large_SpMV_problems/image-20240116091106704.png" alt="image-20240116091106704" style="zoom:50%;"></p><p>与矩阵块数据存储格式和计算方法无关，基本上有两种遍历矩阵块的方法。如图 4 所示，一种方法是按行主方向遍历块，另一种方法是按列主方向遍历块。将遵循行主块遍历的算法系列命名为 Algor，将遵循列主块遍历的其他算法命名为 Algoc。提出的 TwoStep 算法属于 Algoc 。</p><p>对于 Algor，如[19]中所使用的，源向量 (x) 的矩阵块和相关段可以从 DRAM 流式传输到芯片，并在块的乘法累加操作后被丢弃。因此，整个源向量必须从 DRAM 流式传输以遍历矩阵块的一行，并且由于尺寸较大而无法存储在芯片上以供重复使用。并且所得到的向量部分需要存储在片上以供随机访问。</p><p>因此，所得向量段 (N/m) 由片上存储大小决定。表 I 显示了 Algor 的片上存储器和 DRAM 之间的数据传输量。例如，为了计算矩阵的每个块行，需要将 hN*Sm/m 数量的矩阵数据从 DRAM 流式传输到片上存储。对于矩阵 A 的整个计算，hNSm 量的矩阵数据从 DRAM 流式传输到芯片中。从表 I 中，可以表示 Algor (Dr) 的总数据传输量，如公式 1 所示。</p><p><img src="/2024/01/15/Algorithm_and_hardware_co-optimized_solution_for_large_SpMV_problems/image-20240116092416428.png" alt="image-20240116092416428" style="zoom:50%;"></p><p>对于 Algoc，与 Algor 类似，矩阵块可以从 DRAM 流式传输到芯片。然而，在这种情况下，当我们沿列主方向遍历 m 个矩阵块时，需要随机访问向量 x 的段。因此，片上存储被向量段占用。与 Algor 的另一个重要区别是矩阵块的每一列都会产生一个中间结果向量。在最坏的情况下（当没有减少时），中间向量将具有与该列中所有矩阵块中的非零总数 (NNZ) 相同的元素数量。当我们移动到矩阵块的下一列时，需要更新中间结果向量。由于每次更新中间结果向量变得更加密集，因此将其存储在芯片上是不可行的。现在，我们可以通过几种方式进行更新。一种方法是将中间向量保留在 DRAM 中，并通过随机访问 DRAM 来更新其元素，但这会导致带宽使用效率低下，并使 SpMV 延迟受到限制。另一种方法是每次遍历新的矩阵块列时将整个中间结果流式传输到芯片。然而，即使保证 DRAM 流，大量冗余数据会被传输。在此方法中，必须在芯片和 DRAM 之间传输冗余数据。仅从数据传输的角度来看，更好的方法是在生成 n 个中间向量（A 的每个列块一个）时将其流式传输到 DRAM。之后，必须将所有中间向量从 DRAM 流式传输到芯片，并对它们应用归约操作以获得最终的结果向量 y。表 II 列出了 Algoc 中操作的数据传输。此外，我们可以推断出 Algoc (Dc) 的总数据传输量，如公式 2 所示。</p><p><img src="/2024/01/15/Algorithm_and_hardware_co-optimized_solution_for_large_SpMV_problems/image-20240116092735966.png" alt="image-20240116092735966" style="zoom:50%;"></p><p>从公式 1 和公式 2 中可以看出前两项（hNSm 和 NSv）是相同的。方程中的第三项使这些算法彼此不同。对于 Algor 来说，mNSv 的出现是因为从 DRAM 读取整个向量 m 次。另一方面，(2h+1)NSv 表示从芯片到 DRAM 往返的 Algoc 的中间结果。通过进一步研究，我们可以看到 Algor 和 Algoc 的关键因素分别是 m 和 (2h +1)。如果 m&lt; (2h +1)，则 Algor 更可取，因为它的数据传输量比 Algoc 少。否则，当m&gt;(2h+1)时，Algoc是优选的。</p><p>接下来，从系统配置、矩阵维度 (N) 和稀疏度 (h) 导出 m。对于任何具有 CDRAM 的 DRAM 容量的系统，给定 h，它能够处理的最大矩阵维度 N 可以通过公式 3 计算得出。假设矩阵、源向量和结果向量完全占用主存储器。</p><p><img src="/2024/01/15/Algorithm_and_hardware_co-optimized_solution_for_large_SpMV_problems/image-20240116092949910.png" alt="image-20240116092949910" style="zoom:50%;"></p><p>现在，Algor 需要将结果向量的第 1/m 部分存储在片上存储器中。因此，可以将片内存储器Cchip的容量表示为：</p><p><img src="/2024/01/15/Algorithm_and_hardware_co-optimized_solution_for_large_SpMV_problems/image-20240116093033358.png" alt="image-20240116093033358" style="zoom:50%;"></p><p>联立(3)(4)：</p><p><img src="/2024/01/15/Algorithm_and_hardware_co-optimized_solution_for_large_SpMV_problems/image-20240116093113475.png" alt="image-20240116093113475" style="zoom:50%;"></p><p>从上面的方程可以看出，m 与慢速（DRAM）和快速（片上）内存大小的比率成正比。典型系统的该比率通常远大于 SpMV 问题的矩阵稀疏度。例如，对于大型稀疏矩阵，h 可以是 1 → 10 的顺序（例如 Twitter 列表、KONECT 库中的 YouTube 等社交网络图 [20]）。另一方面，对于能够处理大型 SpMV 问题的系统，m 约为数千。</p><p>对于许多实际系统，探讨了 h = 3 时 m 的值、最大矩阵维度 N 和两种算法的执行时间（假设数据以峰值带宽传输）。表三总结了作者的发现。对于 DRAM 尺寸相对较小的系统，m 约为数百。对于具有大 DRAM 容量的系统，m 约为数千，远大于 (2h +1) = 7。因此，Algor 需要比 Algoc 更多的数据传输，特别是对于大型 SpMV 问题。例如，具有 1.5 TB DRAM 的 Haswell 服务器可以在 23B×23B 矩阵上运行，平均每行 NNZ 为 3。如果使用 Algor，则需要将 23B 元素的源向量从 DRAM 传输到芯片 m = 4200 次（600x大于 2h+1)，而对于 Algoc，源向量仅传输一次。由于中间结果的开销，对于 Algoc 来说比传输源向量 m 次要少得多，因此使用 Algoc 将执行时间缩短了 417 倍。此外，m 与矩阵维度 N 成正比，这使得 Algor 的可扩展性不如 Algoc。因此分析表明，基于列主矩阵块遍历的 SpMV 算法（例如作者提出的两步算法）更适合大型 SpMV 问题。</p><p>另一种简单的Algon算法是按照行顺序访问矩阵，对于每个元素，取出向量中对应的xj，不将整个向量流式传输到片上存储，这种算法收到延迟限制，因为需要在DRAM中随机访问，每个向量的缓存行级数数据都会传输到数据，但由于矩阵稀疏性，几乎没有重用，因此会有大量的冗余数据传输，如图5所示，灰色部分即为冗余传输：</p><p><img src="/2024/01/15/Algorithm_and_hardware_co-optimized_solution_for_large_SpMV_problems/image-20240116094109379.png" alt="image-20240116094109379" style="zoom:50%;"></p><p>图 5 中的一个有趣的观察结果是，Algoc 的有效负载始终大于延迟限制朴素方法 (Algon)。这是因为中间向量 (vks) 必须为 Algoc 进行一次完整的往返 DRAM 的操作。尽管如此，对于迭代算法，例如PageRank [19]，通过重叠所提出算法中的两个步骤，可以消除由于 vks 往返而导致的有效负载的增加。由于篇幅有限，在本文中跳过该讨论。</p><h2 id="5-EXPERIMENTAL-RESULTS"><a href="#5-EXPERIMENTAL-RESULTS" class="headerlink" title="5 EXPERIMENTAL RESULTS"></a>5 EXPERIMENTAL RESULTS</h2><p>关于硬件配置的部分跳过了。</p><p>对于测试矩阵，矩阵尺寸从 1M 到 70M 不等，每行 1 到 5 NNZ。还使用一些随机生成的稀疏矩阵来引入矩阵模式方面的最坏情况场景。作为基准测试，在双路 Xeon E5-2620 (22nm) CPU 和 Xeon Phi 5110P (22nm) 协处理器上使用 Intel Math Kernel Library (MKL) 实现了 SpMV。两种架构均具有 30MB 末级缓存 (LLC)。 CPU 峰值带宽为 102GB/s，协处理器峰值带宽为 352GB/s。此外，Nvidia CUDA Sparse (cuSPARSE) 库用于在 GTX-980 GPU 上实现 SpMV，峰值带宽为 224GB/s。能源效率和性能是针对基准进行测量的，并针对所提出的加速器进行模拟的。结果如图 6 和图 7 所示。CPU (Xeon E5) 的指标最差，而协处理器 (Xeon Phi 5110P) 的平均指标表现一般。在大多数情况下，GPU（GTX-980）在COTS架构中具有最好的效率和性能。尽管如此，所提出的加速器始终能够实现比 GPU 高两个数量级的性能和效率。这意义重大。</p><p>作者希望模拟结果能够与实际实现相匹配，因为模拟器负载假设和功率估计是悲观的。尽管如此，正确调整主存储器和 ASIC 之间的接口非常重要，以确保针对每个读写请求传输 DRAM 页大小的块数据。这对于最大限度地利用 DRAM 带宽和完全摊销 DRAM 页面打开成本至关重要。</p>]]></content>
      
      
      <categories>
          
          <category> 论文(略读) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HPC-Game</title>
      <link href="/2024/01/06/HPC-Game/"/>
      <url>/2024/01/06/HPC-Game/</url>
      
        <content type="html"><![CDATA[<p>HPC Game 0th. 作为HPC的小练习来完成，因为0th是一年前了，所以记录自己的解题应该没有问题。因为提供的超算平台现在不可以用了，相关文档现在也无法访问了，所以是直接做的题目。注册还可以看到题目。</p><p>主页：<a href="https://hpcgame.pku.edu.cn/">https://hpcgame.pku.edu.cn/</a></p><p>2024.1.16更新：</p><p>才只做了一点，现在主页进去已经是HPC Game 1th了，开始时间是下周，这次可以跟着参加尝试一下了，本篇也不用更新了。</p><h2 id="一-高性能计算简介"><a href="#一-高性能计算简介" class="headerlink" title="一.高性能计算简介"></a>一.高性能计算简介</h2><h3 id="1-实验室的新机器"><a href="#1-实验室的新机器" class="headerlink" title="1.实验室的新机器"></a>1.实验室的新机器</h3><p>本题的要求是编写一个脚本在集群上运行程序。</p><p>Slurm是一个开源的集群资源管理和作业调度系统，可以在Linux集群上运行各种并行程序，如MPI等。一些相关的信息可查看<a href="https://docs.hpc.sjtu.edu.cn/job/slurm.html">上交超算平台手册-Slurm作业调度系统</a>或<a href="http://faculty.bicmr.pku.edu.cn/~wenzw/pages/quickstart.html">快速入门</a>。</p><p>根据要求编写一个脚本启动程序，因为题目中说明不会使用sbatch，所以使用srun运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">srun -p compute -N1 -n1 -c1 ./program <span class="variable">$1</span> &gt; output.dat</span><br><span class="line">seff $(<span class="built_in">cat</span> job_id.dat) &gt; seff.dat</span><br></pre></td></tr></table></figure><p>如果用sbatch启动：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#SBATCH -J program           </span></span><br><span class="line"><span class="comment">#SBATCH -p compute</span></span><br><span class="line"><span class="comment">#SBATCH -N 1                 </span></span><br><span class="line"><span class="comment">#SBATCH --cpus-per-task=1    </span></span><br><span class="line"><span class="comment">#SBATCH -t x:00       #任务最大运行时间</span></span><br><span class="line"><span class="comment">#SBATCH -o output.dat #将输出结果保存</span></span><br><span class="line"></span><br><span class="line">./program <span class="variable">$1</span></span><br><span class="line">seff $(<span class="built_in">cat</span> job_id.dat) &gt; seff.dat</span><br></pre></td></tr></table></figure></p><h3 id="2-基础知识问答"><a href="#2-基础知识问答" class="headerlink" title="2.基础知识问答"></a>2.基础知识问答</h3><ul><li>TOP500中能效最高的超算：能效最高的应该是Henri，性能最高的是Frontier。</li><li>戈登贝尔奖是并行计算领域的最高奖项，设立于1987年。中国人第一次获得戈登贝尔奖是2016年，第一作者是杨超，现工作于计算所。</li><li>天河二号采用的是Xeon E5和Xeon Phi处理器，太湖之光采用申威众核处理器。TOP500曾排名最高的是太湖之光。</li><li>一般来说，服务器使用的 CPU 相比于同代同等级的游戏 CPU，核心更多，多核性能更强。单核频率更低，单核性能更弱。</li></ul><p>5-7题：</p><p>假设单位内存是1，内存写为直写，全相联，块大小为1，替换策略为LRU，对于如下的矩阵乘法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> m in [<span class="number">1</span>, N]:</span><br><span class="line">    <span class="keyword">for</span> n in [<span class="number">1</span>,N]:</span><br><span class="line">        <span class="keyword">for</span> k in [<span class="number">1</span>, N]:</span><br><span class="line">            C[m,n] = C[m,n] + A[m, k] * B[k, n]</span><br></pre></td></tr></table></figure><p>5.对ABC均进行了N^3次读，对C进行了N^3次写。</p><p>6.如果有一个一级cache处理器，cache大小为3*N^2，运算开始时ABC在内存，结束后强制将cache写回内存(直写)。则会对内存进行3N^2次读运算，N^3+3N^2次写运算。</p><p>7.如果6中的cache大小为2N+1，则会对内存进行3N^3次读，N^3+2N+1次写。</p><h3 id="3-简单题"><a href="#3-简单题" class="headerlink" title="3.简单题"></a>3.简单题</h3><p>本题的要求是使用P个核心，把N个 32 位有符号整数数组中所有元素 + 1，并且求原来（未加一）的数字之和(MOD 100001651)并输出。</p><p>这里复习一下mmap和文件操作，fstream的文件如果要mmap需要int fd = fs.rdbuf()-&gt;fd()转为整型，转完就可以把文件流关掉了，然后就可以mmap了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd1 = <span class="built_in">open</span>(<span class="string">&quot;input1.bin&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="type">int</span> fd2 = <span class="built_in">open</span>(<span class="string">&quot;output.bin&quot;</span>, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd1 == <span class="number">-1</span> || fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Open file error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line">    <span class="type">int</span> r = <span class="built_in">fstat</span>(fd1, &amp;st);</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Get file size error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">close</span>(fd1);</span><br><span class="line">        <span class="built_in">close</span>(fd2);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> size = st.st_size;</span><br><span class="line">    <span class="built_in">ftruncate</span>(fd2, size<span class="number">-4</span>);</span><br><span class="line">    <span class="type">void</span> *p1 = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, size, PROT_READ, MAP_PRIVATE, fd1, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p1 == MAP_FAILED ) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Map file error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">close</span>(fd1);</span><br><span class="line">        <span class="built_in">close</span>(fd2);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> *p2 = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, size<span class="number">-4</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd2, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p2 == MAP_FAILED ) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Map file error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">close</span>(fd1);</span><br><span class="line">        <span class="built_in">close</span>(fd2);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *input = (<span class="type">int</span> *)p1;</span><br><span class="line">    <span class="type">int</span> *output = (<span class="type">int</span>*)p2;</span><br><span class="line">    <span class="type">int</span> p = *input;</span><br><span class="line">    <span class="type">int</span> n = *(input + <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p = &quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;, n = &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp prallel for reduction(+: sum) num_threads(p)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> num = *(input+<span class="number">2</span>+i);</span><br><span class="line">        sum = (sum+num)%<span class="number">100001651</span>;</span><br><span class="line">        *(output+<span class="number">1</span>+i) = num;</span><br><span class="line">    &#125;</span><br><span class="line">    *output = sum%<span class="number">100001651</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sum = &quot;</span>&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">msync</span>(p2, size<span class="number">-4</span>, MS_SYNC);</span><br><span class="line">    <span class="built_in">munmap</span>(p1, size);</span><br><span class="line">    <span class="built_in">munmap</span>(p2, size<span class="number">-4</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd1);</span><br><span class="line">    <span class="built_in">close</span>(fd2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-并行与大规模"><a href="#二-并行与大规模" class="headerlink" title="二.并行与大规模"></a>二.并行与大规模</h2><h3 id="1-求积分"><a href="#1-求积分" class="headerlink" title="1.求积分"></a>1.求积分</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rhs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g_ncore = <span class="built_in">omp_get_num_procs</span>(); </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dtn</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> min_iteration)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> max_threads = n/min_iteration;</span><br><span class="line">    <span class="keyword">return</span> max_threads&gt;g_ncore?g_ncore:<span class="built_in">max</span>(max_threads,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;usage: main &lt;N&gt;&quot;</span> &lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> N = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="function">ofstream <span class="title">fs</span><span class="params">(<span class="string">&quot;output.dat&quot;</span>)</span></span>;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for reduction(+:sum) num_threads(dtn(N, 1e3))</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="type">double</span> x = (i<span class="number">-0.5</span>)/N;</span><br><span class="line">        <span class="type">double</span> res;</span><br><span class="line">        <span class="built_in">rhs</span>(x,res);</span><br><span class="line">        sum += res;</span><br><span class="line">    &#125;</span><br><span class="line">    fs &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">12</span>) &lt;&lt; sum &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    fs.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-乘一乘"><a href="#2-乘一乘" class="headerlink" title="2.乘一乘"></a>2.乘一乘</h3><p>写的时候遇到C++小问题，rhs提供的函数参数是unsigned int的引用，如果传int进去，会被转换为unsigned，变成临时值，会变成右值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> uint;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g_ncore = <span class="built_in">omp_get_num_procs</span>();</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dtn</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> min_iteration)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> max_threads = n/min_iteration;</span><br><span class="line">    <span class="keyword">return</span> max_threads&gt;g_ncore?g_ncore:<span class="built_in">max</span>(max_threads,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">matrix_mul_parallel</span><span class="params">(<span class="type">double</span> **result, <span class="type">int</span> N1, <span class="type">int</span> N2, <span class="type">int</span> N3)</span></span>&#123;</span><br><span class="line">    <span class="type">clock_t</span> start, end;</span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for num_threads(dtn(N1,10))</span></span><br><span class="line">    <span class="keyword">for</span>(uint i=<span class="number">0</span>;i&lt;(uint)N1;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(uint k=<span class="number">0</span>;k&lt;(uint)N2;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(uint j=<span class="number">0</span>;j&lt;(uint)N3;j++)&#123;</span><br><span class="line">                <span class="type">double</span> va, vb;</span><br><span class="line">                <span class="built_in">matA</span>(i,k,va);</span><br><span class="line">                <span class="built_in">matB</span>(k,j,vb);</span><br><span class="line">                result[i][j] += va*vb;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    end = <span class="built_in">clock</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;matrix_mul_parallel time = &quot;</span> &lt;&lt; <span class="built_in">double</span>(end - start) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次还尝试了一下collapse和只对第一层循环并行的比较，时间结果如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./omp_cmul 100 1000 1000</span><br><span class="line">matrix_mul time = 7.333s</span><br><span class="line">matrix_mul_parallel time = 0.91s</span><br><span class="line">matrix_mul_collapse time = 7.479s</span><br><span class="line">PS C:\Users\Desktop\tmp\hpcgame\q2b&gt; ./omp_cmul 1000 1000 1000</span><br><span class="line">matrix_mul time = 73.78s</span><br><span class="line">matrix_mul_parallel time = 8.02s</span><br><span class="line">matrix_mul_collapse time = 9.282s</span><br></pre></td></tr></table></figure></p><p>矩阵乘是有访问的空间局部性的，并且每一层循环内的负载是均衡的，因此将循环第一层并行化更快，collapse的效果和矩阵的形状有很大关系，但尝试的一些形状都比将第一层循环并行化更慢。</p><h3 id="3-解方程"><a href="#3-解方程" class="headerlink" title="3.解方程"></a>3.解方程</h3><p>其实f()的值在每轮迭代都是一样的，可以先处理出来，不用每次算，但是反正也没办法交到平台测性能，这里就不优化了。遇到的一个小tip是<strong>reduction操作会算上原来的值，因此要注意进入并行循环之前的值</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">possion</span><span class="params">(<span class="type">double</span> mat[MAXN][MAXN], <span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=N;j++) mat[i][j] = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> eps;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        eps = <span class="number">1e-16</span>;</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp parallel for reduction(max:eps) num_threads(dtn(N*N, 20))</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;N;j++)&#123;</span><br><span class="line">                <span class="type">double</span> xi, yi, va, tmp;</span><br><span class="line">                xi = i/(<span class="type">double</span>)N;</span><br><span class="line">                yi = j/(<span class="type">double</span>)N;</span><br><span class="line">                <span class="built_in">rhs</span>(xi, yi, va); </span><br><span class="line">                tmp = mat[i][j];</span><br><span class="line">                mat[i][j] = (mat[i<span class="number">-1</span>][j]+mat[i+<span class="number">1</span>][j]+mat[i][j<span class="number">-1</span>]+mat[i][j+<span class="number">1</span>]+va/(<span class="type">double</span>)N/(<span class="type">double</span>)N)/<span class="number">4.0</span>;</span><br><span class="line">                eps = (eps&lt;<span class="number">1e-15</span>)?<span class="built_in">abs</span>(mat[i][j]-tmp):<span class="built_in">max</span>(<span class="built_in">abs</span>(mat[i][j]-tmp),eps);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(eps&gt;<span class="number">1e-15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HPCLAB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Performance analysis and optimization for SpMV based on ARM</title>
      <link href="/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/"/>
      <url>/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/</url>
      
        <content type="html"><![CDATA[<h1 id="Performance-analysis-and-optimization-for-SpMV-based-on-aligned-storage-formats-on-an-ARM-processor"><a href="#Performance-analysis-and-optimization-for-SpMV-based-on-aligned-storage-formats-on-an-ARM-processor" class="headerlink" title="Performance analysis and optimization for SpMV based on aligned storage formats on an ARM processor"></a>Performance analysis and optimization for SpMV based on aligned storage formats on an ARM processor</h1><p>这篇论文对毕设方向帮助很大。确定了重点在于优化而不是方法选择，因为ARM的SIMD向量只有128bit，很多格式没有必要，并且这里提出的对齐格式也给出了明确的优化效果分界点。这篇文章还在理论分析那一部分没有完全理解，估计以后还会看很多次。</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>稀疏矩阵向量乘法(SpMV)一直是科学计算和大数据处理的研究热点，但稀疏矩阵中非零元素的稀疏性和不连续性导致了SpMV的内存瓶颈。在本文中，作者提出了对齐的CSR(ACSR)和对齐的ELL(AELL)格式以及并行SpMV算法，以在ARM处理器上利用 NEON SIMD寄存器。作者分析了 SIMD 指令延迟、缓存访问和缓存未命中对不同格式的 SpMV 的影响。在实验中，基于ACSR的SpMV算法分别比基于CSR的SpMV和PETSc中的SpMV实现了1.18倍和1.56倍的加速，而AELL比ELL实现了1.21倍的加速。ACSR中指令延迟和缓存访问的理论结果与实验结果的偏差分别为 10.26% 和 10.51%，AELL 中的理论结果与实验结果的偏差分别为 5.68% 和 2.91%。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><h3 id="1-1-motivation"><a href="#1-1-motivation" class="headerlink" title="1.1 motivation"></a>1.1 motivation</h3><p>SpMV是数值计算的核心程序，在求解过程中可能会执行很多次。但是硬件的复杂性和矩阵的特性可能会导致内存瓶颈，使优化SpMV的性能具有挑战性。</p><p>已有的研究已经提出了多种稀疏矩阵存储格式，有些格式适合计算平台的计算。大多数对于SpMV的研究都是针对x86或其他加速器的。针对ARM处理器的工作很少。</p><p>ARMv8-A是ARM提出的高性能计算架构，因为其性能好，能耗低等特点，在移动设备中广泛应用。ARMv8支持64位指令和双精度浮点，并通过NEON指令集支持SIMD运算。并且2020的超算排名，集成48核A64FX的Fugaku取得了第一，这是首个ARM架构处理器实现的top超算。</p><h3 id="1-2-contribution"><a href="#1-2-contribution" class="headerlink" title="1.2 contribution"></a>1.2 contribution</h3><p>这篇主要的工作为：</p><ul><li>提出了对齐格式ACSR和AELL，适合NEON的双精度浮点运算。</li><li>提出了基于对齐格式的SpMV算法。</li><li>在鲲鹏920处理器上评估了两种格式的性能。</li></ul><p>作者使用20个矩阵进行评估，结果NEON加速的SpMV在CSR中的平均性能提升达到 19.91%，在ELL中达到 19.15%。对于NEON的使用，与ELL相比，AELL在双精度计算时间、缓存访问和缓存未命中方面的平均性能提升分别为20.54%、34.10%和28.85%，而ACSR的平均性能提升为18.17%，与CSR相比分别为18.59%和18.00%。此外，基于ACSR的SpMV的平均加速度比PETSc中的SpMV高56.46%。</p><h2 id="2-Related-work"><a href="#2-Related-work" class="headerlink" title="2 Related work"></a>2 Related work</h2><h3 id="2-1-Compressed-storage-formats-for-sparse-matrices"><a href="#2-1-Compressed-storage-formats-for-sparse-matrices" class="headerlink" title="2.1. Compressed storage formats for sparse matrices"></a>2.1. Compressed storage formats for sparse matrices</h3><p>为了存储和加快稀疏矩阵运算，有许多不同的压缩格式，最基本有COO和CSR，还有针对对角矩阵的DIA格式，还有针对nnz元素比较均匀的ELLPACK格式。针对处理器设计存储格式可以最大限度提高性能，例如针对GPU和x86CPU的HYB、SELL-C-σ格式，CSR5、BCE等等。</p><p>实际应用中的稀疏矩阵规模越来越大，因此矩阵划分越越重要了。有一些研究比较了不同分块格式的性能，BCSR用于稀疏矩阵密集子块的计算，随后BCSR被优化为未对齐块压缩稀疏行(UBCSR)格式，还有许多类似的研究。</p><h3 id="2-2-ARMv8-A"><a href="#2-2-ARMv8-A" class="headerlink" title="2.2 ARMv8-A"></a>2.2 ARMv8-A</h3><p>ARM结构的处理器广泛用于移动设备，但现在也有许多公司购买了该架构，研发了用于服务器的处理器。</p><h2 id="3-Sparse-matrix-compression-and-NEON-technology"><a href="#3-Sparse-matrix-compression-and-NEON-technology" class="headerlink" title="3 Sparse matrix compression and NEON technology"></a>3 Sparse matrix compression and NEON technology</h2><h3 id="3-1-General-storage-formats-for-sparse-matrices"><a href="#3-1-General-storage-formats-for-sparse-matrices" class="headerlink" title="3.1 General storage formats for sparse matrices"></a>3.1 General storage formats for sparse matrices</h3><p>本节主要介绍CSR和ELLPACK格式。因为对这两种格式已经有了解了所以不详细阐述了。</p><p><strong>CSR</strong></p><p>CSR对矩阵的特征不敏感。使用三个数组来存储矩阵，一个存储值，一个存储col-idx，一个存储每一行第一个元素的下标。</p><p><strong>ELLPACK</strong></p><p>ELLPACK中，矩阵被压缩为两个小矩阵，存储元素和col_idx，假设每行最多有K个NNZ，两个矩阵的大小为NxK，空余部分用0填充。</p><h3 id="3-2-NEON-techknowlogy"><a href="#3-2-NEON-techknowlogy" class="headerlink" title="3.2 NEON techknowlogy"></a>3.2 NEON techknowlogy</h3><p>ARMv8提供32个128bit的NEON寄存器。在向量乘时，向量x需要一个元素一个元素的存入SIMD寄存器。但是如果采用ACSR和AELL，SIMD寄存器可一次性用矩阵和向量值填充。</p><h2 id="4-Aligned-compressed-storage-formats"><a href="#4-Aligned-compressed-storage-formats" class="headerlink" title="4 Aligned compressed storage formats"></a>4 Aligned compressed storage formats</h2><p>ARM的SIMD一般都是加载连续的数据到向量寄存器，而SpMV中由于x的访问是不连续的，只能一个一个load到向量中。为了提高效率，作者设计了ASR和AELL来使用ARM的SIMD结构。</p><p>稀疏矩阵压缩后，如果两个相邻非零元素的列索引也相邻，则在计算SpMV时，与这两个非零元素相乘的向量中对应的两个元素相邻。如果两个非零元素的列索引不相邻，则向量中对应的两个元素也不相邻。如果两个不相邻元素之间的距离超过了缓存行的宽度，则不可能一次将两个元素加载到向量寄存器中。如果两者的列索引之间的偏差小于8，则认为它们位于同一缓存行并在当前非零元素之前插入零。如果不是，则在当前非零之后插入零，这保证了填充操作不会在访问允许的情况下导致冗余的跨缓存行。</p><h3 id="4-1-ACSR"><a href="#4-1-ACSR" class="headerlink" title="4.1 ACSR"></a>4.1 ACSR</h3><p>ACSR中有三个数组，v_value存储了值及填充0，v_columns存储了每个向量的首个列index，v_rowptr存储了每行的第一个v_columns的index。</p><p><img src="/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/image-20240105210816245.png" alt="image-20240105210816245" style="zoom: 50%;"></p><p>假设有M行NNZ，则非对齐CSR的存储空间为SCSR = NNZ x (4+8) + (M+1) x 4 = 12NNZ + 4(M+1)，而ACSR的0填充率为FR，则SACSR = NNZ x (1+FR) x (8+4/2) + 4(M+1) = 10NNZ(1+FR) + 4(M+1)，联立两式，当FR &gt; 0.2时ACSR的存储需要比CSR更大的空间。</p><h3 id="4-2-AELL"><a href="#4-2-AELL" class="headerlink" title="4.2 AELL"></a>4.2 AELL</h3><p>类似ELLPACK，只是做了0填充。</p><p><img src="/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/image-20240105210829624.png" alt="image-20240105210829624" style="zoom:50%;"></p><p>同样假设M行NNZ，则ELLPACK的存储空间为M x K x (4+8) = 12MK，如果AELLPACK的向量有Vk个，则存储空间为Vk x M x (2x8+4) = 20MVk，联立两式，当Vk&gt;0.6K时AELL的存储空间会比ELLPACK更大。</p><h2 id="5-Parallel-algorithms-of-SpMV"><a href="#5-Parallel-algorithms-of-SpMV" class="headerlink" title="5. Parallel algorithms of SpMV"></a>5. Parallel algorithms of SpMV</h2><p>CSR的SpMV核心用NEON实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//The result vector is y </span></span><br><span class="line"><span class="type">float64x2_t</span> matrix;</span><br><span class="line"><span class="type">float64x2_t</span> <span class="built_in">vector</span>;</span><br><span class="line"><span class="type">float64x2_t</span> temp_y;</span><br><span class="line">temp_y = vdupq_n_f64(<span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">0</span> to rows<span class="number">-1</span> <span class="keyword">do</span>:</span><br><span class="line"><span class="keyword">for</span> j=rowptr[i];j&lt;rowptr[i+<span class="number">1</span>];j+=<span class="number">2</span> <span class="keyword">do</span>:</span><br><span class="line">matrix = vld1q_f64(values+j);</span><br><span class="line"><span class="built_in">vector</span> = vld1q_lane_f64(x+columns[j]);</span><br><span class="line"><span class="built_in">vector</span> = vld1q_lane_f64(x+columns[j+<span class="number">1</span>]);</span><br><span class="line">temp_y = vmlaq_f64(temp_y, matrix, <span class="built_in">vector</span>);</span><br><span class="line">end <span class="keyword">for</span></span><br><span class="line">    y[i] += vget_lane_f64(temp_y, <span class="number">0</span>) + vget_lane_f64(temp_y, <span class="number">1</span>);</span><br><span class="line">end <span class="keyword">for</span></span><br></pre></td></tr></table></figure></p><p>ELLPACK的SpMV用NEON实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//The result vector is y </span></span><br><span class="line"><span class="type">float64x2_t</span> matrix;</span><br><span class="line"><span class="type">float64x2_t</span> <span class="built_in">vector</span>;</span><br><span class="line"><span class="type">float64x2_t</span> temp_y;</span><br><span class="line">temp_y = vdupq_n_f64(<span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">0</span> to rows<span class="number">-1</span> <span class="keyword">do</span>:</span><br><span class="line"><span class="keyword">for</span> j=ixK;j&lt;(i+<span class="number">1</span>)xK;j+=<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">matrix = vld1q_f64(ELL_values+j);</span><br><span class="line"><span class="built_in">vector</span> = vld1q_lane_f64(x+ELL_columns[j]);</span><br><span class="line"><span class="built_in">vector</span> = vld1q_lane_f64(x+ELL_columns[j+<span class="number">1</span>]);</span><br><span class="line">temp_y = vmlaq_f64(temp_y, matrix, <span class="built_in">vector</span>);</span><br><span class="line">end <span class="keyword">for</span></span><br><span class="line">y[i] += vget_lane_f64(temp_y, <span class="number">0</span>) + vget_lane_f64(temp_y, <span class="number">1</span>);</span><br><span class="line">end <span class="keyword">for</span></span><br></pre></td></tr></table></figure><p>而ACSR和AELL的实现如下，需要注意x需要在末尾添加一个0元素，防止访问越界：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ACSR</span></span><br><span class="line"><span class="type">float64x2_t</span> matrix;</span><br><span class="line"><span class="type">float64x2_t</span> <span class="built_in">vector</span>;</span><br><span class="line"><span class="type">float64x2_t</span> temp_y;</span><br><span class="line">temp_y = vdupq_n_f64(<span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">0</span> to rows<span class="number">-1</span> <span class="keyword">do</span>:</span><br><span class="line"><span class="keyword">for</span> j = rowptr[i] to j&lt;rowptr[i+<span class="number">1</span>]<span class="number">-1</span> <span class="keyword">do</span>:</span><br><span class="line">matrix = vld1q_f64(v_values+j x <span class="number">2</span>);</span><br><span class="line"><span class="built_in">vector</span> = vld1q_f64(x+v_columns[j]);</span><br><span class="line">temp_y = vmlaq_f64(temp_y, matrix, <span class="built_in">vector</span>);</span><br><span class="line">end <span class="keyword">for</span></span><br><span class="line">    y[i] += vget_lane_f64(temp_y, <span class="number">0</span>) + vget_lane_f64(temp_y, <span class="number">1</span>);</span><br><span class="line">end <span class="keyword">for</span></span><br><span class="line"><span class="comment">//AELL</span></span><br><span class="line"><span class="type">float64x2_t</span> matrix;</span><br><span class="line"><span class="type">float64x2_t</span> <span class="built_in">vector</span>;</span><br><span class="line"><span class="type">float64x2_t</span> temp_y;</span><br><span class="line">temp_y = vdupq_n_f64(<span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">0</span> to rows<span class="number">-1</span> <span class="keyword">do</span>:</span><br><span class="line"><span class="keyword">for</span> j=ixK to j&lt;(i+<span class="number">1</span>)xK <span class="keyword">do</span></span><br><span class="line">matrix = vld1q_f64(AELL_values+jx2);</span><br><span class="line"><span class="built_in">vector</span> = vld1q_f64(x+AELL_columns[j]);</span><br><span class="line">temp_y = vmlaq_f64(temp_y, matrix, <span class="built_in">vector</span>);</span><br><span class="line">end <span class="keyword">for</span></span><br><span class="line">y[i] += vget_lane_f64(temp_y, <span class="number">0</span>) + vget_lane_f64(temp_y, <span class="number">1</span>);</span><br><span class="line">end <span class="keyword">for</span>    </span><br></pre></td></tr></table></figure><h2 id="6-Performace-analysis"><a href="#6-Performace-analysis" class="headerlink" title="6.Performace analysis"></a>6.Performace analysis</h2><p>ACSR和AELL通过加快向量加载到向量寄存器来提高效率，但是也增加了对0填充的额外计算量。因此SpMV在不同填充率下性能会有波动。本节作者分析了不同压缩格式的SpMV中NEON SIMD指令的执行延迟、缓存访问的影响以及缓存未命中情况。</p><h3 id="6-1-SpMV-performance-analysis-for-ARMv8-architecture"><a href="#6-1-SpMV-performance-analysis-for-ARMv8-architecture" class="headerlink" title="6.1. SpMV performance analysis for ARMv8 architecture"></a>6.1. SpMV performance analysis for ARMv8 architecture</h3><p>下表是性能分析的一些变量：</p><p><img src="/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/image-20240106210412380.png" alt="image-20240106210412380" style="zoom:50%;"></p><p>对于SpMV计算，指令数量由稀疏矩阵中非零元素的数量决定，访问的数据量与稀疏矩阵的存储格式和右向量的访问方式有关。不同的格式下有不同的零填充，也会有不同的数据访问。因此并行程序的实际运行性能不仅与程序本身的计算规模有关，还与处理器的指令执行周期、指令的并行执行、缓存数据的利用效率、内存数据的读写次数、带宽利用率、处理器所有计算核心的利用率等有关。为了减少指令的执行周期，可以选择执行周期短的指令。另外，可以将指令分布到不同的计算核心上并行执行。这也可以提高流水线和SIMD指令的数据量。 SpMV串行操作在ARMv8处理器上的性能可以描述为</p><center>T = f(L, A)</center><p>L和A是执行时间和数据访问时间。T和这两个值是正相关。而L由指令总数和处理器的指令延迟确定。对于ARMv8处理器。L为：</p><center>L=Lin(向量寄存器)+Lis(通用寄存器)+Cin(向量计算)+Cis(通用计算)</center><p>对于SpMV，乘法共有NNZ个，加法有NNZ-M个，运算指令数是由稀疏矩阵确定的。可以通过选择执行延迟短的指令并同时使用更多指令单元来减少计算时间。表3显示了ARMv8处理器上不同计算指令的时钟周期。指令流水线和SIMD技术可以提高多条指令的并发操作，从而导致指令执行吞吐量的提高。例如，如果向量运算单元的长度为M字节，浮点数为4字节，则一次向量运算可以计算M/4个浮点数，只需要NNZ/(M/4)次向量计算。如果数据访问受限于缓存访问和未命中访存，A为：</p><center>A=ACnum x ACt + Miss_num x AMt</center><p>访问缓存和内存延迟是固定的。为了提升数据访问性能，应该减少缓存访问次数和缓存未命中率。</p><p><img src="/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/image-20240106213231496.png" alt="image-20240106213231496" style="zoom:50%;"></p><h3 id="6-2-The-execution-latency-of-instructions"><a href="#6-2-The-execution-latency-of-instructions" class="headerlink" title="6.2. The execution latency of instructions"></a>6.2. The execution latency of instructions</h3><p>根据ARM官方文档中描述的执行延迟，可以通过分析依赖于所描述的组中的指令的操作来获得最小延迟。作者分析了基于ACSR和AELL格式以及CSR和ELL格式的SpMV之间SIMD指令延迟的差异。</p><p>主要指令的延迟在表3中。NNZ的列索引是通过LDR指令load的，而向量加载使用LD1指令完成的，而向量乘使用的是FMLA指令。此外，FMLA在表3中的括号内的3表示计算完成后3个周期就可以应用计算结果。</p><p>对于双精度SpMV，列索引需要先加载到通用寄存器，然后访存。因此必须执行LDR指令NNZ次。在CSR格式下，LD1指令需要NNZ/2次，因为128bit寄存器可以一次存入两个元素。但是对x的访问不行，因为对x的访问可能不连续。因此loadx需要NNZ次。而FLMA则需要NNZ/4次，所以可以计算L为：</p><p><img src="/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/image-20240106215736816.png" alt="image-20240106215736816" style="zoom:50%;"></p><p>而在ACSR中，对列索引和x的访问都可以通过向量一次访问两个数据，因此LACSR=19/2NNZ(1+FR)。</p><p><img src="/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/image-20240106220253636.png" alt="image-20240106220253636" style="zoom:50%;"></p><p>因为ARMv8的流水线有两个ASIMD单元，所以计算延迟是NNZ/4。</p><p>同样的，作者推导出了ELL和AELL的延迟：</p><p><img src="/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/image-20240106220200750.png" alt="image-20240106220200750" style="zoom:50%;"></p><p><img src="/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/image-20240106220449084.png" alt="image-20240106220449084" style="zoom:50%;"></p><p>由此，我们可以获得不同格式的SpMV的ASIMD指令的延迟。利用上述公式分析基于不同存储格式的SpMV运算的性能，可以得到以下命题：</p><p><strong>FR&lt;9/19时，ACSR的计算周期小于CSR的周期。</strong></p><p>推导过程如下：</p><p><img src="/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/image-20240106221334268.png" alt="image-20240106221334268" style="zoom:50%;"></p><p><img src="/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/image-20240106221349034.png" alt="image-20240106221349034" style="zoom:50%;"></p><p>FR是0元素填充率。</p><p><strong>Vk&lt;14/19K时，AELL的计算周期小于ELLPACK的计算周期。</strong></p><p>推导过程如下：</p><p><img src="/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/image-20240106221449509.png" alt="image-20240106221449509" style="zoom:50%;"></p><p>Vk是包含0填充的行的宽度(单位为向量)。</p><h3 id="6-3-Cache-access-times"><a href="#6-3-Cache-access-times" class="headerlink" title="6.3 Cache access times"></a>6.3 Cache access times</h3><p>对于CSR和ACSR，SpMV都要访问行偏移2M次找到每行的NNZ元素。计算时NNZ以向量形式访问NNZ/2和NNZ’/2次。对col_idx的访问为NNZ和NNZ’/2次。而对于向量x的访问在CSR中NNZ次，ACSR中NNZ’/2次。而结果存入向量y需要M次。因此CSR和ACSR的缓存访问时间为：</p><p><img src="/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/image-20240107223004884.png" alt="image-20240107223004884" style="zoom:50%;"></p><p>对于ELL，访问矩阵元素是按向量访问的，但是列偏移和向量x以及向量y都要顺序访问，因此ELL的缓存访问时间为：</p><p><img src="/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/image-20240107223241272.png" alt="image-20240107223241272" style="zoom:50%;"></p><p>对于AELL，矩阵元素，列索引，x都可以按向量访问，因此缓存时间访问为：</p><p><img src="/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/image-20240107223338109.png" alt="image-20240107223338109" style="zoom:50%;"></p><p>类似6.2，可以计算出ACSR和AELL缓存时间比CSR和ELL的增加比例：</p><p><img src="/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/image-20240107223458153.png" alt="image-20240107223458153" style="zoom:50%;"></p><p>可以得出两个结论：</p><p><strong>FR&lt;2/3时，ACSR的缓存访问比CSR少</strong></p><p><strong>Vk&lt;5/6K时，AELL的缓存访问比ELL少</strong></p><h3 id="6-4-Cache-miss-times"><a href="#6-4-Cache-miss-times" class="headerlink" title="6.4 Cache miss times"></a>6.4 Cache miss times</h3><p>使用NEON加速的SpMV一次可以完成两个向量操作。基于CSR和ELL格式的SpMV中的非零元素需要访问缓存十次，并且包含向量形式的非零元素两次，列索引四次，向量x四次。ACSR和AELL格式需要访问缓存六次，其中values和x仅以向量形式访问两次，并且列索引只需要两个向量的起始列索引。</p><p>在每次计算中，在最坏的情况下，CSR和ELL中加载的四个x值可能分布在四个缓存行中，而ACSR和AELL中只有两个缓存行。实验是在鲲鹏920上进行的，L1缓存中有4条64B大小的缓存行。因此，在计算过程中，CSR和ELL格式可能会出现缓存行冲突，在最坏的情况下可能会被替换访问缓存6次，而ACSR和AELL格式只有4次。因此可以推断，与基于CSR和ELL的SpMV相比，ACSR和AELL格式可以降低缓存冲突的概率并导致缓存未命中的减少。</p><h2 id="7-Experimentals"><a href="#7-Experimentals" class="headerlink" title="7. Experimentals"></a>7. Experimentals</h2><h3 id="7-1-Platform"><a href="#7-1-Platform" class="headerlink" title="7.1 Platform"></a>7.1 Platform</h3><p>实验平台为华为的鲲鹏920。鲲鹏920支持基于ARMv8.2架构的多条并行指令，配备两个浮点单元(FPU)。如表4所示，鲲鹏920双精度浮点计算峰值性能达到665.6 Gflops。而且鲲鹏920支持8通道内存，但实验中只使用了4通道。</p><p><img src="/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/image-20240107225256935.png" alt="image-20240107225256935" style="zoom: 50%;"></p><p>作者在鲲鹏920上考察了非均匀内存访问（NUMA）架构对性能的影响。如果不考虑NUMA，可能会因为操作系统进程切换而导致跨节点访问内存，从而造成更大的延迟。而且，在这种情况下，实验结果是不准确的。因此，为了在实验中获得稳定可靠的结果，作者通过NUMA工具<code>numactl</code>将线程和数据进行绑定，这样可以保证线程访问同一部分的内存。使用perf测试cycles，缓存缺失等指标。</p><p>所有的算法都使用openMP实现多线程，编译选项为-O2。</p><p>由于ACSR格式中每行的非零元素并不统一，并且操作系统在使用openMP自动并行时可能会调度线程来保证负载平衡，这种影响在性能评估中不容易预测。实验中，所有实验均选择性能最佳时的线程数。并且对于每个稀疏矩阵的对比实验，最终执行的线程数是相同的，这显着降低了多线程对性能评估的影响。</p><h3 id="7-2-Experiment-data"><a href="#7-2-Experiment-data" class="headerlink" title="7.2. Experiment data"></a>7.2. Experiment data</h3><p>作者使用了20个SuitSparse矩阵来进行测试。</p><h2 id="8-Experimental-results"><a href="#8-Experimental-results" class="headerlink" title="8. Experimental results"></a>8. Experimental results</h2><p>结果分为3部分。</p><ul><li>SpMV通过NEON加速的效果</li><li>实验数据的分析</li><li>不同格式下性能的比较</li></ul><h3 id="8-1-NEON-acceleration-for-CSR-and-ELL"><a href="#8-1-NEON-acceleration-for-CSR-and-ELL" class="headerlink" title="8.1 NEON acceleration for CSR and ELL"></a>8.1 NEON acceleration for CSR and ELL</h3><p>表6显示了NEON加速的效果。分别为CSR和ELL实现了19.91%和19.15%的提升。对于有些矩阵，加速效果不明显，因为对x的访问仍然是不连续的。</p><p><img src="/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/image-20240107225832748.png" alt="image-20240107225832748" style="zoom:50%;"></p><p>由于NEON操作指令本身的等待时间，数据量的增加可能会导致内存访问指令延迟过高，从而降低SpMV的性能。例如，ELL 中的“bbmat”和“FEM_3D_ Thermal”以及 CSR 和 ELL 中的“TSOPF_RS_b2383”。此外，基于CSR和带有NEON的ELL的SpMV可能会导致更多的缓存未命中，因为它需要额外的两次缓存访问。在进一步的实验中，基于CSR和ELL的SpMV均由NEON加速。</p><h3 id="8-2-Analysis-of-experimental-data"><a href="#8-2-Analysis-of-experimental-data" class="headerlink" title="8.2 Analysis of experimental data"></a>8.2 Analysis of experimental data</h3><p>表6显示了ACSR和AELL的填充比率：</p><img src="/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/image-20240107230159544.png" class title="image-20240107230159544"><p>根据第6节提到的结论和表5中的比率，表7显示了真实的指令延迟改善：</p><p><img src="/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/image-20240107230318893.png" alt="image-20240107230318893" style="zoom:50%;"></p><p>实验结果与理论分析一致。由图可见，ACSR较CSR平均可减少周期7.30%，AELL值较ELL减少21.08%。</p><p>测量结果和理论推导稍有偏差，这是因为分析时只考虑了主要的指令，实际执行时还有其他指令。==因此，实际结果表明如果ACSR的FR超过47%，就会有负提升。==并且因为OS调度线程，会带来ACSR的额外负载。</p><p>例如，“TSOPF_RS_b2383”中非零元素的分布过于分散，这可能会增加ACSR和AELL的内存访问次数。在一些CSR格式矩阵的并行SpMV计算中，主要性能取决于具有最大非零元素的长行。虽然理论上串行计算的指令时钟周期比CSR格式有所增加，但是并行计算中可能会出现与理论相反的情况，因为ACSR格式的长行的零元素填充率可能为零。例如“car4”、“Chebyshev2”、“hangGlider_3”和“EPA”。它们的非零行的平均长度与它们的长行相差数百或数千倍，而长行的零填充率几乎为零。因此，这些稀疏矩阵的实验结果与图7中的理论分析不一致。</p><p>访存的数据如图9,10,11：</p><p><img src="/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/image-20240107230917104.png" alt="image-20240107230917104" style="zoom:50%;"></p><p><img src="/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/image-20240107230933649.png" alt="image-20240107230933649" style="zoom:50%;"></p><p><img src="/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/image-20240107231000513.png" alt="image-20240107231000513" style="zoom:50%;"></p><p>图9和图10展示了ACSR和AELL格式减少的缓存访问事件数，分别比CSR和ELL减少了18.59%和34.10%，理论值与实际值偏差为5.68%和2.91%。</p><p>虽然缓存访问对ACSR和AELL格式的影响与理论分析一致，但ACSR中少数矩阵的实验结果仍然存在较大偏差。通过分析这些矩阵中非零元素的分布，并与AELL进行比较，偏差较大的原因可能是计算过程中负载不平衡，例如“bbmat”和“TSOPF_RS_b2383”。</p><p>此外，作者发现ACSR和AELL格式可以减少单次计算中的缓存命中冲突。如图11所示，ACSR和AELL可以分别减少SpMV的缓存未命中次数28.85%和18.00%。</p><p>ACSR和AELL格式可以降低每次计算过程中发生缓存冲突的概率，因为添加的零元素和之前的非零元素通常保留在同一缓存行上。然而，由于缓存冲突，存在跨缓存行的向量。因此，当稀疏矩阵的非零元素分布相对集中时，AELL格式的零填充可能会导致额外的缓存未命中。例如，“Chevron1”是一个对角稀疏矩阵，所有非零元素都聚集在对角线上。因此，整个缓存行中的非零元素较少，因此额外的零填充会导致更多的缓存未命中。</p><h3 id="Performance-of-ACSR-and-AELL"><a href="#Performance-of-ACSR-and-AELL" class="headerlink" title="Performance of ACSR and AELL"></a>Performance of ACSR and AELL</h3><p>在这部分实验中，作者比较了使用由NEON加速的CSR和ELL的ACSR和AELL格式的SpMV的计算时间。我们发现ACSR格式在大多数情况下是最好的。图12记录了基于ACSR的SpMV与CSR格式的SpMV和PETSc相比的性能改进，并在鲲鹏920处理器上对AELL和ELL进行了比较。同时，图13显示了在FT2000+处理器上的实验结果，以验证对齐的存储格式的性能改进。</p><p><img src="/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/image-20240107231526934.png" alt="image-20240107231526934" style="zoom:50%;"></p><p><img src="/2024/01/05/Performance%20analysis%20and%20optimization%20for%20SpMV%20based%20on%20aligned/image-20240107231611536.png" alt="image-20240107231611536" style="zoom:50%;"></p><p>最终的实验结果与第6节的分析一致。在这个实验中，ACSR和AELL格式的SpMV比CSR和ELL格式能够获得更好的性能。与CSR和PETSc相比，ACSR可以实现平均性能提升18.17%和56.46%，AELL在鲲鹏920处理器上比ELL实现平均性能提升20.54%，而在FT2000+处理器上平均性能提升分别为24.83%、61.14%和22.55%。</p><p>而稀疏矩阵“car4”是具有局部连续性的对角矩阵，其在ACSR中的填充率达到了56.32%。基于ACSR的SpMV计算表明，与使用CSR的SpMV相比，在指令延迟、缓存访问和缓存未命中方面几乎没有任何改善。</p><h2 id="9-Conclusions"><a href="#9-Conclusions" class="headerlink" title="9. Conclusions"></a>9. Conclusions</h2><p>在本文中，作者提出了两种对齐的存储格式：ACSR和AELL，它们专注于128位SIMD运算，以在ARM处理器上以双精度并行优化SpMV。作者分析了ACSR和AELL格式在指令延迟、缓存访问和缓存未命中方面的改进。并选择了PETSc进行比较，ACSR取得了56.46%的性能提升。在未来，作者可能会对更多指令类型进行考虑，考虑从缓存性能等角度进行进一步优化。</p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NEON编程</title>
      <link href="/2024/01/02/Neon/"/>
      <url>/2024/01/02/Neon/</url>
      
        <content type="html"><![CDATA[<p>原书为Arm的NEON Programmer’s Guide和NEON Programmer Guide for Armv8-A。</p><p>根据我的实际体验，这份文档的帮助不大，只是对A64有个基本认识，实际上手NEON编程，可以在<a href="https://arm-software.github.io/acle/neon_intrinsics/advsimd.html#list-of-intrinsics">手册</a>直接找相应指令，而关于A64和架构，可以阅读<a href="https://www.zhihu.com/column/c_1455195069590962177。">https://www.zhihu.com/column/c_1455195069590962177。</a></p><span id="more"></span><h2 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction" class="headerlink" title="Chapter 1 Introduction"></a>Chapter 1 Introduction</h2><h3 id="1-1-Data-processing-technologies"><a href="#1-1-Data-processing-technologies" class="headerlink" title="1.1 Data processing technologies"></a>1.1 Data processing technologies</h3><p>数据处理的常见方法有SISD，SIMD(vector mode)，SIMD(packed data mode)。</p><p><strong>vector mode</strong></p><p>假设vector size为4，SIMD(vector)可使用单指令完成4个数据的操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VADD.F32 S24, S8, S16</span><br><span class="line">// four operations occur</span><br><span class="line">// S24 = S8 +S16</span><br><span class="line">// S25 = S9 +S17</span><br><span class="line">// S26 = S10 +S18</span><br><span class="line">// S27 = S11 +S20</span><br></pre></td></tr></table></figure><p>在ARM中，这称为<strong>Vector Floating Point(VFP)</strong>，在ARMv5引入，源和目标寄存器既可以是单个寄存器也可以是多个寄存器。在ARMv7，NEON代替了VFP实现多寄存器上的操作。</p><p><strong>packed data mode</strong></p><p>这种模式下，一个指令可以指定一个大寄存器中的多个数据部分进行相同的处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VADD.I16 Q10, Q8, Q9</span><br><span class="line">// One operation adds two 64-bit registers,</span><br><span class="line">// but each of the four 16-bit lanes in the register is added separately.</span><br><span class="line">// There are no carries between the lanes</span><br></pre></td></tr></table></figure><p>在ARM中，这称为SIMD或NEON。</p><h3 id="1-2-Comparison-between-ARM-NEON-technology-and-other-implementations"><a href="#1-2-Comparison-between-ARM-NEON-technology-and-other-implementations" class="headerlink" title="1.2 Comparison between ARM NEON technology and other implementations"></a>1.2 Comparison between ARM NEON technology and other implementations</h3><p>与ARMv6中相比，ARM NEON的计算单元支持128-bit的向量操作，在ARMv6中只有32-bit的向量操作。并且在NEON中，这些寄存器是单独的，并且其向量操作是专门优化过的，而ARMv6中只是使用和其他指令相同的寄存器和流水线。</p><p>与X86的MMX/SSE的比较以及与DSP的比较这里略去了。</p><h3 id="1-3-Architecture-support-for-NEON-technology"><a href="#1-3-Architecture-support-for-NEON-technology" class="headerlink" title="1.3 Architecture support for NEON technology"></a>1.3 Architecture support for NEON technology</h3><ul><li>不能保证ARMv7-A或ARMv7-R处理器包含NEON或VFP技术。</li><li>ARMv7核心的可能组合包括没有NEON或VFP单元，仅有NEON单元，仅有VFP单元或同时具有NEON和VFP单元。</li><li>具有NEON单元但没有VFP单元的处理器无法在硬件中执行浮点运算。</li><li>由于NEON SIMD操作更有效地执行矢量计算，从ARMv7引入开始，VFP矢量模式操作被弃用。</li><li>VFP单元有时被称为浮点单元（FPU）。</li><li>具有NEON或VFP单元的处理器可能不支持某些扩展，如半精度和融合乘加。</li></ul><ul><li>半精度指令仅在包含半精度扩展的NEON和VFP系统上可用。</li><li>Fused Multiply-Add (FMA)指令是对VFP和NEON的可选扩展。仅在实现了Fused Multiply-Add扩展的NEON或VFP系统上才可用。VFPv4和Advanced SIMDv2支持Fused Multiply-Add指令。</li></ul><h3 id="1-4-Fundamentals-of-NEON-technology"><a href="#1-4-Fundamentals-of-NEON-technology" class="headerlink" title="1.4 Fundamentals of NEON technology"></a>1.4 Fundamentals of NEON technology</h3><p>NEON单元的组成部分包括：</p><ul><li>NEON寄存器文件</li><li>NEON整数执行流水线</li><li>NEON单精度浮点执行流水线</li><li>NEON加载/存储和置换流水线。</li></ul><p>NEON指令和浮点指令使用相同的寄存器文件，称为NEON和浮点寄存器文件。这与ARM核心寄存器文件不同。NEON和浮点寄存器文件是一组可被访问为32位、64位或128位寄存器的寄存器的集合。哪个寄存器可用于指令取决于它是NEON指令还是VFP指令。本文将NEON和浮点寄存器称为NEON寄存器。某些VFP和NEON指令在通用寄存器和NEON寄存器之间移动数据，或使用ARM通用寄存器来寻址内存。</p><p><img src="/2024/01/02/Neon/image-20240102210351577.png" alt="image-20240102210351577" style="zoom: 33%;"></p><p><img src="/2024/01/02/Neon/image-20240102210425127.png" alt="image-20240102210425127" style="zoom:33%;"></p><p>Arm v8 AArch64有32个128位寄存器，也能当作32位Sn寄存器或是64位Dn寄存器使用。</p><p>一些NEON指令会使用标量，标量可以通过下标表示。例如VMOV.8 D0[3], R3。NEON标量可以是8bit，16bit，32bit或64bit，除了乘法指令，其他指令都可以访问寄存器中的任意位标量，乘法只能访问：</p><ul><li>16bit标量：D0-D7的[0-3]</li><li>32bit标量：D0-D15的[0-1]</li></ul><p>NEON中的数据类型：</p><p><img src="/2024/01/02/Neon/image-20240102211912523.png" alt="image-20240102211912523" style="zoom: 50%;"></p><h2 id="Chapter-2-Compiling-NEON-Instructions"><a href="#Chapter-2-Compiling-NEON-Instructions" class="headerlink" title="Chapter 2 Compiling NEON Instructions"></a>Chapter 2 Compiling NEON Instructions</h2><p>要使用GCC进行自动向量化，需要添加以下选项：</p><ul><li>-ftree-vectorize</li><li>-mfpu=neon</li><li>-mcpu 指定核或架构</li></ul><p>以-O3编译相当于添加了-ftree-vectorize。</p><p>通常，如果不采用自动向量化，一般使用INTRINSIC代码嵌入C中来使用NEON。需要在头文件中包含<code>arm_neon.h</code>，并指定处理器类型，例如<code>-mcpu=cortex-a72</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arm_neon.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_float_arrays</span><span class="params">(<span class="type">float</span> *a, <span class="type">float</span> *b, <span class="type">float</span> *c, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// assume n is a multiple of 4</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="comment">// load 4 floats from a and b into NEON registers</span></span><br><span class="line">    <span class="type">float32x4_t</span> va = <span class="built_in">vld1q_f32</span>(a + i);</span><br><span class="line">    <span class="type">float32x4_t</span> vb = <span class="built_in">vld1q_f32</span>(b + i);</span><br><span class="line">    <span class="comment">// add the vectors</span></span><br><span class="line">    <span class="type">float32x4_t</span> vc = <span class="built_in">vaddq_f32</span>(va, vb);</span><br><span class="line">    <span class="comment">// store the result into c</span></span><br><span class="line">    <span class="built_in">vst1q_f32</span>(c + i, vc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C pointer aliasing</strong></p><p>标准C中，指针可能指向相同或重叠的数据，这给优化带来了困难。C99和C++引入了restrict关键字，用于声明指针的唯一性，从而提高编译器的优化能力。ARM编译器和GCC都支持restrict关键字，但有不同的语法和选项。</p><p><strong>Natural types</strong></p><p>算法使用特定数据类型有其原因，但转换为处理器自然类型可以提高运算速度和精度。</p><p><strong>Array grouping</strong></p><p>对于寄存器数量较少的处理器设计（如x86），通常会将多个数组合并为一个。这样可以让同一个指针的不同偏移量访问数据的不同部分。但是这种方式可能会让编译器误认为偏移量导致了数据集的重叠。除非可以保证不会对数组进行写入操作，否则请避免这样做。将复合数组拆分为单独的数组，可以简化指针的使用并消除这种风险。</p><p><strong>Inside knowledge</strong></p><p>NEON代码需要知道数组大小，否则编译器会生成多余的代码。数组大小可以在编译时指定，也可以根据工程师的知识进行优化。</p><h2 id="Chapter-3-coding-for-NEON"><a href="#Chapter-3-coding-for-NEON" class="headerlink" title="Chapter 3 coding for NEON"></a>Chapter 3 coding for NEON</h2><h3 id="3-1-Overview"><a href="#3-1-Overview" class="headerlink" title="3.1 Overview"></a>3.1 Overview</h3><p>这份guide包含以下内容：</p><ul><li>Memory operations, and how to use the flexible load and store instructions. </li><li>Using the permutation instructions to deal with load and store leftovers. </li><li>Using NEON to perform an example data processing task, matrix multiplication. </li><li>Shifting operations, using the example of converting image data formats.</li></ul><h3 id="3-2-Load-and-store-example-RGB-conversion"><a href="#3-2-Load-and-store-example-RGB-conversion" class="headerlink" title="3.2 Load and store - example RGB conversion"></a>3.2 Load and store - example RGB conversion</h3><p>本节以RGB到BGR的转换为例。在一个24bit的RGB图中，像素在内存中以R G B R G B的模式存储。假设现在要完成一个简单的图像处理，交换R和B channel。将RGB数据项按顺序从内存放入寄存器会使交换红色和蓝色通道难以操作。</p><p>以下指令将RGB data每次一字节存入NEON寄存器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD1 &#123; V0.16B, V1.16B, V2.16B &#125;, [x0]</span><br></pre></td></tr></table></figure><p><img src="/2024/01/02/Neon/image-20240104151616427.png" alt="image-20240104151616427" style="zoom: 50%;"></p><p>这种情况下，交换不同的Lane会比较复杂。NEON提供了结构load和store指令来应对这种情况，可以将连续的数据分别存储到不同的寄存器。在这个例子中，可以使用LD3指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD3 &#123; V0.16B, V1.16B, V2.16B &#125;, [x0]</span><br></pre></td></tr></table></figure><p><img src="/2024/01/02/Neon/image-20240104151905763.png" alt="image-20240104151905763" style="zoom:50%;"></p><p>这样只需要使用MOV指令对整个Vector交换，然后使用ST3 store指令写回，完整的操作如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LD3 &#123; V0.16B, V1.16B, V2.16B &#125;, [x0], #48 // 3-way interleaved load from</span><br><span class="line"> // address in X0, post-incremented</span><br><span class="line"> // by 48</span><br><span class="line">MOV V3.16B, V0.16B // Swap V0 -&gt; V3</span><br><span class="line">MOV V0.16B, V2.16B // Swap V2 -&gt; V0</span><br><span class="line">MOV V2.16B, V3.16B // Swap V3 -&gt; V2</span><br><span class="line"> // (net effect is to swap V0 and V2)</span><br><span class="line">ST3 &#123; V0.16B, V1.16B, V2.16B &#125;, [x1], #48 // 3-way interleaved store to address</span><br><span class="line"> // in X1, post-incremented by 48</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每一步的操作如下：</p><ul><li>Loads from memory 16 red bytes into V0, 16 green bytes into V1, and 16 blue bytes into V2. </li><li>Increments the source pointer in X0 by 48 bytes ready for the next iteration. The increment of 48 bytes is the total number of bytes that we read into all three registers, so 3 x 16 bytes in total. </li><li>Swaps the vector of red values in V0 with the vector of blue values in V2, using V3 as an intermediary. </li><li>Stores the data in V0, V1, and V2 to memory, starting at the address that is specified by the destination pointer in X1, and increments the pointer.</li></ul><h3 id="3-3-Load-and-store-data-structures"><a href="#3-3-Load-and-store-data-structures" class="headerlink" title="3.3 Load and store - data structures"></a>3.3 Load and store - data structures</h3><p>在上一个例子中提到的指令进行的操作如下图：</p><p><img src="/2024/01/02/Neon/image-20240104152831778.png" alt="image-20240104152831778" style="zoom:50%;"></p><p>指令的语法如下：</p><p><img src="/2024/01/02/Neon/image-20240104152856011.png" alt="image-20240104152856011" style="zoom:50%;"></p><p>其中的Registers根据interleave pattern最多可以有四个，后面的16B表示每个数据是1B(byte)，每个向量是128bit，存储16B。数据类型有8(B)，16(H)，32(S)，64(D)bits。</p><p>以下是两个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LD2 &#123;V0.8H, V1.8H&#125;, [X0]</span><br><span class="line">LD2 &#123;V0.4S, V1.4S&#125;, [X0]</span><br></pre></td></tr></table></figure><p><img src="/2024/01/02/Neon/image-20240104153412464.png" alt="image-20240104153412464" style="zoom: 33%;"></p><p><img src="/2024/01/02/Neon/image-20240104153437456.png" alt="image-20240104153437456" style="zoom:33%;"></p><p>structure load还允许加载一个元素到vector的所有lane中，如下指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD3R &#123; V0.16B, V1.16B, V2.16B &#125; , [x0]</span><br></pre></td></tr></table></figure><p><img src="/2024/01/02/Neon/image-20240104153841418.png" alt="image-20240104153841418" style="zoom: 50%;"></p><p>也可以只load到一个lane当中，这在从存储中获取分散的数据到vector中很有用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD3 &#123; V0.B, V1.B, V2.B &#125;[4] , [x0]</span><br></pre></td></tr></table></figure></p><p><img src="/2024/01/02/Neon/image-20240104154024393.png" alt="image-20240104154024393" style="zoom:50%;"></p><p>[]可以指定地址偏移。为了方便下一次读写，指令后可以添加#imm，会直接给x0地址的值+imm。</p><p>除了上述的structure load and store，NEON也提供其他类型的LD和ST指令，详见Arm Architecture Reference Manual。</p><h3 id="3-4-Load-and-store-leftovers"><a href="#3-4-Load-and-store-leftovers" class="headerlink" title="3.4 Load and store - leftovers"></a>3.4 Load and store - leftovers</h3><p>有时输入数据不是向量寄存器lanes的整数倍。例如一个输入数组有21个16bit的元素。NEON寄存器可以一次处理8个元素，最后一次迭代只有5个元素，这5个元素无法填满寄存器。</p><p>有三种处理这种情况的办法，需要根据情况选择：</p><ul><li>Extend arrays with padding</li><li>Overlap data elements</li><li>Process leftovers as single elements</li></ul><p><strong>Extend arrays with padding</strong></p><p>如果数组长度可变，可以将其填充到vector size的倍数，这样就可以在不影响其他数据的情况下进行数据读写。padding值应该不影响计算的结果。</p><p><img src="/2024/01/02/Neon/image-20240104161852536.png" alt="image-20240104161852536" style="zoom:50%;"></p><p><strong>Overlap data elements</strong></p><p>如果操作合适，可以通过重叠元素处理多出来的元素。</p><p><img src="/2024/01/02/Neon/image-20240104162820857.png" alt="image-20240104162820857" style="zoom:50%;"></p><p><strong>Process leftovers as single elements</strong></p><p>NEON提供了可对向量中的单个元素操作的指令，最后的元素可以单独进行处理。这种方式比前两种都慢，并且会增加代码规模。 </p><p>还有一些其他需要关注的点：</p><ul><li>地址对齐：load and store指令的地址应该和缓存行的大小对齐，以实现更高效的访存。</li><li>可以使用A64的指令完成单独元素的的计算，但是要NEON和A64指令写入相同的内存，特别是相同的cache line。</li></ul><h3 id="3-5-Permutation-rearranging-vectors"><a href="#3-5-Permutation-rearranging-vectors" class="headerlink" title="3.5 Permutation - rearranging vectors"></a>3.5 Permutation - rearranging vectors</h3><p>在编写SIMD程序时，数据的顺序很重要，与性能直接相关，有时数据在内存中的位置可能不合适或不是最优的。</p><p>一个解决上述问题的方法是重新安排数据。这种方式的性能开销很高。更好的办法是在数据被处理时重新安排数据，重安排被称为permutation，NEON提供了一系列permute指令，实现以下操作：</p><ul><li>Take input data from one or more source registers</li><li>Rearrange the data</li><li>Write the result of the permutation to a destination register</li></ul><p><strong>Permutation guidelines</strong></p><ul><li>permuting data不是什么时候都有用。</li><li>permute指令会带来开销。</li><li>不同的指令使用不同的pipline。最优的方法是最大化pipline的使用。因此需要尽量少使用permute操作，选择执行时会利用空闲pipline的指令。</li></ul><h3 id="3-6-Permutation-NEON-instructions"><a href="#3-6-Permutation-NEON-instructions" class="headerlink" title="3.6 Permutation - NEON instructions"></a>3.6 Permutation - NEON instructions</h3><p>这一节介绍的permute指令包括：</p><ul><li>Move</li><li>Reverse</li><li>Extraction</li><li>Transpose</li><li>Interleave</li><li>Lookup table</li></ul><p>这里不一一说明这些指令了，需要时再查询。</p><h3 id="3-7-Matrix-multiplication"><a href="#3-7-Matrix-multiplication" class="headerlink" title="3.7 Matrix multiplication"></a>3.7 Matrix multiplication</h3><p>这一节是NEON实现矩阵乘法的例子。假定矩阵按照列顺序存储(OpenGL ES的存储格式)。每次计算4*4的矩阵。</p><p><img src="/2024/01/02/Neon/image-20240104165307145.png" alt="image-20240104165307145"></p><p>下图显示了使用NEON的FMUL指令实现向量和标量的相乘：</p><p><img src="/2024/01/02/Neon/image-20240104165519702.png" alt="image-20240104165519702" style="zoom: 80%;"></p><p>对应矩阵的计算为：</p><p><img src="/2024/01/02/Neon/image-20240104165611277.png" alt="image-20240104165611277"></p><p>NEON寄存器可以按照不同的格式存储数据，如下图：</p><p><img src="/2024/01/02/Neon/image-20240104165731965.png" alt="image-20240104165731965" style="zoom: 50%;"></p><p>矩阵乘法分三步完成：</p><ul><li>Load矩阵数据</li><li>矩阵乘法</li><li>存储结果</li></ul><p>load数据的指令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LD1 &#123;V0.4S, V1.4S, V2.4S, V3.4S&#125;, [X1]</span><br><span class="line">LD1 &#123;V4.4S, V5.4S, V6.4S, V7.4S&#125;, [X2]</span><br></pre></td></tr></table></figure><p>NEON提供32个128bit宽的寄存器。在这个实现中，V0-V3存储了第一个矩阵的16个元素，V4-V7存储了第二个矩阵的16个元素。每个寄存器存储一个矩阵行。</p><p>以下代码计算一列的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FMUL V8.4S, V0.4S, V4.S[0] // rslt col0 = (mat0 col0) * (mat1 col0 elt0)</span><br><span class="line">FMLA V8.4S, V1.4S, V4.S[1] // rslt col0 += (mat0 col1) * (mat1 col0 elt1)</span><br><span class="line">FMLA V8.4S, V2.4S, V4.S[2] // rslt col0 += (mat0 col2) * (mat1 col0 elt2)</span><br><span class="line">FMLA V8.4S, V3.4S, V4.S[3] // rslt col0 += (mat0 col3) * (mat1 col0 elt3)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完整的矩阵运算代码就略去了。只要按照以上代码计算每一列就可以了。每一列要四条指令，将其进行交错，可以提高流水线的ILP。</p><h3 id="3-8-Shifting-left-and-right"><a href="#3-8-Shifting-left-and-right" class="headerlink" title="3.8 Shifting left and right"></a>3.8 Shifting left and right</h3><p>本节介绍了NEON提供的shift操作。</p><p>NEON的向量shift和标量的操作很类似，将元素中的位左移或右移，移出的位会被舍弃，不会移到相邻的位置。移位数可以是指令指定的，也可以是一个移位向量。</p><p>下图是NEON的SSHL指令，V1是移位向量：</p><p><img src="/2024/01/02/Neon/image-20240104173138848.png" alt="image-20240104173138848"></p><p>在右移位操作时，要考虑处理的是有符号还是无符号的数据。SSHL是有符号的shift操作。相应的USHL是无符号的。</p><p>NEON还支持插入shift，如下图的SLI指令：</p><p><img src="/2024/01/02/Neon/image-20240104173449521.png" alt="image-20240104173449521"></p><p>此后是shift指令的一些其他可选项的介绍，以及一个例子，这里都略去了。</p><h2 id="Chapter-4-NEON-Intrinsics"><a href="#Chapter-4-NEON-Intrinsics" class="headerlink" title="Chapter 4 NEON Intrinsics"></a>Chapter 4 NEON Intrinsics</h2><h3 id="4-1-Overview"><a href="#4-1-Overview" class="headerlink" title="4.1 Overview"></a>4.1 Overview</h3><p>NEON Intrinsics提供了简单的NEON指令编写方式。有符合NEON的数据类型(D和Q寄存器的大小都有)，可以使用C变量来分配NEON寄存器。由编译器生成具体的代码。编译器也会进行优化，进行指令重排序来减少停顿，提高ILP。</p><p>NEON intrinsic的定义在<code>arm_neon.h</code>中。</p><h3 id="4-2-Vector-data-types-for-NEON-intrinsics"><a href="#4-2-Vector-data-types-for-NEON-intrinsics" class="headerlink" title="4.2 Vector data types for NEON intrinsics"></a>4.2 Vector data types for NEON intrinsics</h3><p>数据类型的pattern如下：</p><p>type    size    x    numberOfLanes    _t</p><p>例如int16x4_t是一个有4个16bit的short int的向量。float32x4_t是有4个32-bit浮点的向量。</p><p><img src="/2024/01/02/Neon/image-20240105150025326.png" alt="image-20240105150025326" style="zoom:50%;"></p><p>intrinsics的输入和输出可以是这些类型。有些intrinsics使用向量元素构成的数组，包含2,3,4个相同的向量元素，这样的类型为：</p><p>type    size    x    numberOfLanes    x    lengthOfArray    _t</p><p>这些类型是C结构体，包含一个val的数组。这样的类型可以通过NEON的指令一次加载或存储4个向量寄存器的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">int16x4x2_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int16x4_t</span> val[<span class="number">2</span>];</span><br><span class="line">&#125; &lt;var_name&gt;;</span><br></pre></td></tr></table></figure><p>这些类型只能使用load，store，transpose，interleave，deinterleave指令。可以通过下标访问单个寄存器，例如var_name.val[0]。</p><p>🔰initialize：vector data type不能赋值初始化，可以使用load指令初始化或使用vcreate intrinsic初始化。</p><h3 id="4-3-Prototype-of-NEON-Intrinsics"><a href="#4-3-Prototype-of-NEON-Intrinsics" class="headerlink" title="4.3 Prototype of NEON Intrinsics"></a>4.3 Prototype of NEON Intrinsics</h3><p>NEON intrinsics的指令格式如下：</p><p>opname    flags_type</p><p>例如：</p><ul><li>vmul_s16，将两个含16bit signed的向量相乘</li><li>vaddl_u8，将两个存储unsigned 8bit值的64bit向量相加，得到128bit的存储unsigned 16bit向量</li></ul><p>flag可以取q，表示计算操作是针对128bit向量的。</p><p>🔰Note：含有__fp16的指令只用于支持半精度扩展VFP的架构。</p><h3 id="4-4-Using-NEON-intrinsics"><a href="#4-4-Using-NEON-intrinsics" class="headerlink" title="4.4 Using NEON intrinsics"></a>4.4 Using NEON intrinsics</h3><p>intrinsics含q的表示在Q寄存器操作，不含q的表示在D寄存器操作。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint8x8_t vadd_u8(uint8x8_t a, uint8x8_t b); #64bit</span><br><span class="line">uint8x16_t vaddq_u8(uint8x16_t a, uint8x16_t b); #128bit</span><br></pre></td></tr></table></figure><p>有些指令没有q后缀，也是会使用Q寄存器的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint16x8_t vaddl_u8(uint8x8_t a, uint8x8_t b);</span><br></pre></td></tr></table></figure><p>一些NEON intrinsics指令会使用32bit的通用寄存器作为输入存储标量。例如以下这一些指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vget_lane_u8 #get single value</span><br><span class="line">vset_lane_u8 #set single value </span><br><span class="line">vcreate_u8 #create vector from literal value</span><br><span class="line">vdup_n_u8 #set all lanes to the same literal value</span><br></pre></td></tr></table></figure><p>使用intrinsics时，使用不同的类型操作会比较困难，因为编译器会跟踪寄存器存储的类型。寄存器也会调度程序流及调整程序加快执行。</p><p>以下是一个将4lane 32bit向量元素翻倍的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arm_neon.h&gt;</span></span></span><br><span class="line"><span class="type">uint32x4_t</span> <span class="title function_">double_elements</span><span class="params">(<span class="type">uint32x4_t</span> input)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>(vaddq_u32(input, input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-5-Variables-and-constants-in-NEON-code"><a href="#4-5-Variables-and-constants-in-NEON-code" class="headerlink" title="4.5 Variables and constants in NEON code"></a>4.5 Variables and constants in NEON code</h3><p>这一节主要是一些example code：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//declaring variable</span></span><br><span class="line"><span class="type">uint32x2_t</span> vec64a, vec64b;</span><br><span class="line"><span class="comment">//using constants</span></span><br><span class="line">uint8x8 start_value = vdup_n_u8(<span class="number">0</span>);</span><br><span class="line">uint8x8 start_value = vreinterpret_u8_u64(vcreate_u64(<span class="number">0x123456789ABCDEF</span>ULL));</span><br><span class="line"><span class="comment">//moving results back to C variables get_lane0/VST store to memory</span></span><br><span class="line">result = vget_lane_u32(vec64a, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//Accessing D registers from a Q register</span></span><br><span class="line">vec64a = vget_low_u32(vec128); <span class="comment">// split 128-bit vector </span></span><br><span class="line">vec64b = vget_high_u32(vec128); <span class="comment">// into 2x 64-bit vectors</span></span><br><span class="line"><span class="comment">//Casting NEON variables between different types</span></span><br><span class="line"><span class="type">uint8x8_t</span> byteval;</span><br><span class="line"><span class="type">uint32x2_t</span> wordval;</span><br><span class="line">byteval = vreinterpret_u8_u32(wordval);</span><br><span class="line"><span class="type">uint8x16_t</span> byteval2;</span><br><span class="line"><span class="type">uint32x4_t</span> wordval2;</span><br><span class="line">byteval2 = vreinterpretq_u8_u32(wordval2)</span><br></pre></td></tr></table></figure><h3 id="4-6-Accessing-vector-types-from-C"><a href="#4-6-Accessing-vector-types-from-C" class="headerlink" title="4.6 Accessing vector types from C"></a>4.6 Accessing vector types from C</h3><p>C中的数据格式正如上述，写为uint8x16_t或者int16x4_t这样的类型。标量和vector之间必须通过intrinsics指令处理，例如result = vget_lane_u32(vec64a, 0)。</p><h3 id="4-7-Loading-data-from-memory-into-vectors"><a href="#4-7-Loading-data-from-memory-into-vectors" class="headerlink" title="4.7 Loading data from memory into vectors"></a>4.7 Loading data from memory into vectors</h3><p>intrinsics使用vld1_datatype加载连续的数据，以下是一段示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arm_neon.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> A[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">// array with 4 elements</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">uint16x4_t</span> v; <span class="comment">// declare a vector of four 16-bit lanes</span></span><br><span class="line">    v = vld1_u16(A); <span class="comment">// load the array from memory into a vector</span></span><br><span class="line">    v = vadd_u16(v,v); <span class="comment">// double each element in the vector</span></span><br><span class="line">    vst1_u16(A, v); <span class="comment">// store the vector back to memory</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-8-Constructing-a-vector-from-a-literal-bit-pattern"><a href="#4-8-Constructing-a-vector-from-a-literal-bit-pattern" class="headerlink" title="4.8 Constructing a vector from a literal bit pattern"></a>4.8 Constructing a vector from a literal bit pattern</h3><p>NEON intrinsics通过vcreate_datatype来从常量值创建向量，以下是一段示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arm_neon.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">uint8x8_t</span> v; <span class="comment">// define v as a vector with 8 lanes of 8-bit data</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> A[<span class="number">8</span>]; <span class="comment">// allocate memory for eight 8-bit data</span></span><br><span class="line">    v = vcreate_u8(<span class="number">0x0102030405060708</span>); <span class="comment">// create a vector that contains the values</span></span><br><span class="line">    <span class="comment">// 1,2,3,4,5,6,7,8</span></span><br><span class="line">    vst1_u8(A, v); <span class="comment">// store the vector to memory, in this case, to array A</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-9-Constructing-multiple-vectors-from-interleaved-memory"><a href="#4-9-Constructing-multiple-vectors-from-interleaved-memory" class="headerlink" title="4.9  Constructing multiple vectors from interleaved memory"></a>4.9  Constructing multiple vectors from interleaved memory</h3><p>NEON支持交错load数据。交错模式由n指定，指令为vldn_datatype，正如在第三章介绍的那样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arm_neon.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">uint8x8x3_t</span> v; <span class="comment">// This represents 3 vectors. </span></span><br><span class="line">    <span class="comment">// Each vector has eight lanes of 8-bit data.</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> A[<span class="number">24</span>]; <span class="comment">// This array represents a 24-bit RGB image. </span></span><br><span class="line">    v = vld3_u8(A); <span class="comment">// This de-interleaves the 24-bit image from array A </span></span><br><span class="line">    <span class="comment">// and stores them in 3 separate vectors</span></span><br><span class="line">    <span class="comment">// v.val[0] is the first vector in V. It is for the red channel</span></span><br><span class="line">    <span class="comment">// v.val[1] is the second vector in V. It is for the green channel</span></span><br><span class="line">    <span class="comment">// v.val[2] is the third vector in V. It is for the blue channel.</span></span><br><span class="line">    <span class="comment">//Double the red channel</span></span><br><span class="line">    v.val[<span class="number">0</span>] = vadd_u8(v.val[<span class="number">0</span>],v.val[<span class="number">0</span>]);</span><br><span class="line">    vst3_u8(A, v); <span class="comment">// store the vector back into the array, with the red channel doubled.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-10-Programming-using-NEON-intrinsics"><a href="#4-10-Programming-using-NEON-intrinsics" class="headerlink" title="4.10 Programming using NEON intrinsics"></a>4.10 Programming using NEON intrinsics</h3><p>NEON编程需要考虑到算法怎样能够实现并行，以下是一个计算数组和的例子，假设n是4的倍数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arm_neon.h&gt;</span></span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">vector_add_of_n</span><span class="params">(<span class="type">uint32_t</span>* ptr, <span class="type">uint32_t</span> items)</span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> result,* i;</span><br><span class="line">    <span class="type">uint32x2_t</span> vec64a, vec64b;</span><br><span class="line">    <span class="type">uint32x4_t</span> vec128 = vdupq_n_u32(<span class="number">0</span>); <span class="comment">// clear accumulators</span></span><br><span class="line">    <span class="keyword">for</span> (i=ptr; i&lt;(ptr+(items/<span class="number">4</span>));i+=<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="type">uint32x4_t</span> temp128 = vld1q_u32(i); <span class="comment">// load four 32-bit values</span></span><br><span class="line">    vec128=vaddq_u32(vec128, temp128); <span class="comment">// add 128-bit vectors</span></span><br><span class="line">    &#125;</span><br><span class="line">    vec64a = vget_low_u32(vec128); <span class="comment">// split 128-bit vector</span></span><br><span class="line">    vec64b = vget_high_u32(vec128); <span class="comment">// into two 64-bit vectors</span></span><br><span class="line">    vec64a = vadd_u32 (vec64a, vec64b); <span class="comment">// add 64-bit vectors together</span></span><br><span class="line">    result = vget_lane_u32(vec64a, <span class="number">0</span>); <span class="comment">// extract lanes and</span></span><br><span class="line">    result += vget_lane_u32(vec64a, <span class="number">1</span>); <span class="comment">// add together scalars</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 高性能计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WISE：Predicting the Performance of Sparse Matrix</title>
      <link href="/2023/12/25/Predicting%20the%20Performance%20of%20Sparse%20Matrix/"/>
      <url>/2023/12/25/Predicting%20the%20Performance%20of%20Sparse%20Matrix/</url>
      
        <content type="html"><![CDATA[<h1 id="WISE：Predicting-the-Performance-of-Sparse-Matrix"><a href="#WISE：Predicting-the-Performance-of-Sparse-Matrix" class="headerlink" title="WISE：Predicting the Performance of Sparse Matrix"></a>WISE：Predicting the Performance of Sparse Matrix</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>稀疏矩阵向量乘法(SpMV)是一个重要的稀疏kernel。已经开发了许多方法来加速SpMV。然而，没有一种方法能够在各种矩阵中始终保持最高性能。因此，需要一个性能预测模型来预测给定稀疏矩阵的最佳SpMV方法。不幸的是，由于影响SpMV的因素多种多样，预测SpMV的性能具有挑战性。在这项工作中，作者开发了一个名为WISE的机器学习框架，它可以准确预测给定稀疏矩阵的不同SpMV方法相对于基线方法的加速幅度。 WISE依赖于一个新颖的功能集，该功能集总结了矩阵的大小、偏斜和局部性特征。然后，WISE可以为每个特定矩阵选择最佳的SpMV方法。通过一组近1,500个矩阵，与在24核服务器中使用英特尔MKL相比，使用WISE的平均速度提高了 2.4 倍。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>SpMV是最常用的计算kernel之一。在稀疏线性系统和多种图计算(例如PageRank和HITS(Hyperlink-Induced Topic Search))当中都会使用。许多应用都是迭代使用SpMV kernel，因此SpMV消耗相当多的执行周期，优化SpMV是非常有必要的。</p><p>有效执行SpMV的困难在于矩阵的特征复杂，这有时导致SpMV访存局部性很差，并且一些情况下的数据依赖也使优化更难。有许多现有的加速SpMV的方法，采用不同的方式存储矩阵，应对不规则的数据访问及利用SIMD指令。但是没有一种方法对于所有特征的稀疏矩阵都能实现最好性能，因此需要一种选择最好方法的机制。</p><p>传统的auto-tuners使用行，列数等基本特征来建立模型，选择方法，但是这对于复杂的不同特征的矩阵不能很好的预测性能。因为SpMV方法在<strong>不同的非零元素偏斜和局部性特征</strong>下表现不同。</p><p>本篇文章，作者使用机器学习建立的一个模型WISE来评估不同SpMV方法在一个矩阵上相对于baseline方法的加速比，从而选择最合适的方法。WISE使用一系列特征来总结矩阵的复杂特征。</p><p>作者还考虑了一些优化方法，包括0填充最小化、列重排序、分块。这些优化在流行的SELLPACK，SELL-C-σ，LAV等SpMV实现中使用。</p><p>对于偏斜，WISE使用平均值、标准差、基尼指数，以及表示0在行列分布的p-ratio体现特征。对于局部性特征，WISE使用0元素在一个2D子矩阵中的分布统计，以及一些其他统计值来体现。</p><p>🔰p-ratio：一种用来描述矩阵的特征之一，它表示矩阵中非零元素在行和列方向上的分布比例。p-ratio可以用来衡量矩阵的平衡性，即数据在行和列方向上的分布是否相等或相近。如果p-ratio为1，说明数据在行和列方向上的分布是均匀的；如果p-ratio大于1，说明数据在行方向上的分布是稠密的；如果p-ratio小于1，说明数据在列方向上的分布是稠密的。</p><p>作者分析了一组近 1,500 个不同位置和偏斜行为的矩阵。与在 24 核服务器中使用英特尔数学核心函数库 (MKL) 相比，使用 WISE 的平均加速速度提高了 2.4 倍。此外，WISE 比更先进的 Intel MKL inspector-executor平均加速 1.14 倍，而其预处理开销还不到 50%。得益于 WISE 对用户透明的方法，WISE 可以成为现有数学库的有效扩展。</p><p>本篇主要的工作包括：</p><ul><li><p>对SpMV性能预测的困难的分析</p></li><li><p>给出一组可用于机器学习模型的描述矩阵的特征</p></li><li>实现对给定矩阵选择最佳SpMV方法的框架WISE</li><li>对WISE进行一系列评估测试</li></ul><h2 id="2-Background-amp-SpMV-Optimization-Space"><a href="#2-Background-amp-SpMV-Optimization-Space" class="headerlink" title="2 Background &amp; SpMV Optimization Space"></a>2 Background &amp; SpMV Optimization Space</h2><h3 id="2-1-CSR-Format-and-SpMV-Implementation-with-CSR"><a href="#2-1-CSR-Format-and-SpMV-Implementation-with-CSR" class="headerlink" title="2.1 CSR Format and SpMV Implementation with CSR"></a>2.1 CSR Format and SpMV Implementation with CSR</h3><p>这里作者简单回顾了一下CSR格式，以及CSR以行为粒度并行的负载分配方式(静态交错分配，静态连续分配，动态分配)，就不再赘述了。</p><h3 id="2-2-Implementing-SpMV-with-Vectorization"><a href="#2-2-Implementing-SpMV-with-Vectorization" class="headerlink" title="2.2 Implementing SpMV with Vectorization"></a>2.2 Implementing SpMV with Vectorization</h3><p>作者考虑了三种向量化优化：</p><ul><li>减少0填充，方式是通过排序将0元素数相近的行放在一起。</li><li>列重排序：把非零元素比较多的列放在一起，提高向量访存的局部性</li><li>分块：将列分块，提高LLC局部性。</li></ul><p>作者选取了三种SpMV的方法，SELLPACK，SELL-C-σ和LAV来分析这些优化。</p><p>由于对SELLPACK和SELL-C-σ已经比较了解，这里只重点读了LAV格式。</p><p><strong>SELLPACK</strong></p><p>SELLPACK把c行作为一个CHUNK，一个CHUNK内的行宽相等，不足的用0填充。c的大小一般是向量长度。当0元素在行之间分布不均匀时，0填充会很多。</p><p><strong>SELL-C-σ</strong></p><p>SELL-C-σ对每σ行进行排序，这样能减少0填充，其他概念和SELLPACK一样。σ的最佳取值依赖于非零元素在行之间的分布。如果大多数行的0元素数都差不多，那么σ取较小就可以了，反之需要取较大值。在σ取大一些的情况，需要对许多行重排序，而相邻的行总是有相近的非零元素分布模式，重排序打乱了行顺序，可能导致时间局部性和空间局部性的损失。当nonzero分布非常不平衡时，σ可以取R(row_number)，这样被称为RFS(Row Frequency Reorder)，不过这样就要采用动态调度分配负载，因为靠前的CHUNKnonzero集中。</p><p><strong>LAV-1Seg</strong></p><p>在幂律图矩阵中，行和列中的零数量高度不平衡。因此，输入向量的时间和空间局部性较差，并且经常遭受LLC缺失。为了解决这个问题，LAV-1Seg(只有一个段的 LAV)根据非零数的递减对列进行排序，这是一种称为列频率排序(CFS)的技术。然后，它应用Sell-c-R的变换。使用 CFS，<strong>具有相似非零分布的列通常以紧密的时间顺序进行处理</strong>，提高向量x的元素重用。</p><p><strong>LAV</strong></p><p>如果矩阵很大，输入向量元素会在重新使用之前从 LLC 中逐出。因此，完整的 LAV 算法采用CFS之后的矩阵，并将其划分为称为段的连续列组。然后，它将Sell-C-R应用于每个段。段应该足够小，以便与该段相对应的输入向量元素适合 LLC 并得到重用。在实践中，LAV通常只需要将矩阵划分为两段。第一段中，取每列非零值的比例为T，最佳T通常≥0.7。它被称为密集段，因为它具有矩阵中填充最多的列。第二段称为稀疏段。</p><p>当处理一个段时，相应的输入向量元素被加载到 LLC 中并重用。由于LAV-1Seg和LAV都使用RFS，只选择动态调度。</p><p><img src="/2023/12/25/Predicting%20the%20Performance%20of%20Sparse%20Matrix/image-20231223120820448.png" alt="image-20231223120820448" style="zoom: 67%;"></p><p>上述这些方法的矩阵格式都不同，作者提出了一个统一的格式来实现SpMV，格式的描述在附录A。</p><h2 id="3-Challenges-Predicting-SpMV-Performance"><a href="#3-Challenges-Predicting-SpMV-Performance" class="headerlink" title="3 Challenges Predicting SpMV Performance"></a>3 Challenges Predicting SpMV Performance</h2><p>为了选择为每个输入矩阵提供最快 SpMV 执行的方法和参数。作者使用第 2 节中的不同方法和参数在各种矩阵上执行SpMV。</p><p>作者使用SuiteSparse矩阵集合中的136个大矩阵和使用RMAT图生成器创建的 408 个大矩阵。SuiteSparse主要包含科学计算矩阵，RMAT 被广泛使用，可以生成广泛的矩阵类型。为了确保矩阵足够大以获得有代表性的结果，作者使用具有 1-6700 万行和列的矩阵。nonzero限制在20亿内以能够在server的内存中存储。</p><p>作者的分析提供了五个方面的insight。</p><p><strong>最快的方法因矩阵而异</strong></p><p><img src="/2023/12/25/Predicting%20the%20Performance%20of%20Sparse%20Matrix/image-20231224094959219.png" alt="image-20231224094959219" style="zoom:50%;"></p><p>作者在136个矩阵上测试，如图4所示，每个方法在不同数量的矩阵上表现出最好的性能。此外，作者还测试了MKL，MKL没有在任何矩阵实现最佳性能。</p><p><strong>同一种方法中，相对CSR的加速比不同(考虑成本)</strong></p><p>即使某个方法对于一组矩阵来说是最快的，其实际相对CSR的加速比也有很大差异。如图2所示，1.0是CSR实现的基准，</p><img src="/2023/12/25/Predicting%20the%20Performance%20of%20Sparse%20Matrix/image-20231224095354814.png" class title="image-20231224095354814"><p>考虑 SELLPACK，它是 25 个连续放置的矩阵中最快的。在这些矩阵中，其加速比范围为 1.05 至 1.31×。另一方面，Sell-c-𝜎 对于 66 个矩阵来说是最快的，对于这些矩阵，加速范围为 1.00 到 1.76×。当稍后考虑方法的预处理成本时，预测加速的幅度可以帮助选择最佳的 SpMV 方法。</p><p><strong>选择一种方法的正确参数会显著影响加速比</strong></p><p>参数选择会显著影响加速比。例如调度策略。图3显示了使用动态、静态和静态连续调度的CSR实现的性能。对于136个SuiteSparse矩阵中的每一个，该图显示了它们在最佳调度下相对于 CSR 的加速(始终等于或小于 1)。</p><img src="/2023/12/25/Predicting%20the%20Performance%20of%20Sparse%20Matrix/image-20231224095839587.png" class title="image-20231224095839587"><p>从结果可以分析得到，动态调度对于网络和社交网络来说是最快的，而 静态调度在科学矩阵方面表现最好。该图还显示了MKL的性能。</p><p><strong>矩阵大小、局部性和偏斜之间的复杂关系决定了最佳方法</strong></p><p>为了分析这三个参数和最佳方法的关联，作者对两个使用RMAT生成的矩阵进行了实验。它们分别显示了nonzero偏斜和nonzero局部性的影响。</p><p>在第一个实验中，作者分析了稀疏矩阵的偏斜特性。根据稀疏矩阵行的非零分布来考虑偏斜。使用100个<strong>高偏斜(HighSkew，矩阵的非零元素在相对较少的行或列中高度集中)</strong>和100个<strong>低偏斜(LowSkew)</strong>矩阵。在第二个实验中，作者使用100个具有<strong>高非零局部性的矩阵(即大多数非零值位于靠近矩阵对角线的区域)(HighLoc)</strong>和100个具有<strong>低局部性的矩阵(即非零值遍布整个矩阵)(LowLoc)</strong>。4.5节描述了使用的 RMAT 参数。在每个 100 矩阵集中，作者改变行数和每行的平均非零值来模拟不同的特征。</p><p>首先考虑偏斜的影响。作者测量了第2节中LowSkew和HighSkew集的每个SpMV方法的执行时间。图5a和5b分别显示了LowSkew的最快方法及其相对于最佳CSR的加速。矩阵的特征在于行数和每行非零的平均数(Y 轴)。图5c和5d显示了HighSkew矩阵的相同数据。</p><p><img src="/2023/12/25/Predicting%20the%20Performance%20of%20Sparse%20Matrix/image-20231224100723522.png" alt="image-20231224100723522" style="zoom:50%;"></p><p>图中可得出LAV(1Seg)，SELL-C-R在大多数情况提供最大加速，当输入矩阵大于LLC(行数&gt;=2^22)，并且每行的平均nnz较高(&gt;16)时，LAV通常优于其他方法。LAV的加速取决于偏斜程度，HighSkew的加速比最高。对于行数较少，nnz较多，偏斜较大的矩阵，LAV-1Seg就够了；而行数较少且偏斜较低时，SELL-C-R通常最快，因为输入向量适合LLC，也不需要更高级的LAV和LAV-1Seg。对于每行平均nnz较低的大型矩阵，加速比很小。</p><p>图6展示了LowLoc和HighLoc的数据。SELL-C-σ是处理HighLoc的最好方法，对于LowLoc，SELL-C-σ通常最好，除了每行具有大量nnz的矩阵。这种情况下LAV是最好的，因为提供了分段。最后，HighLoc的Sell-c-𝜎加速幅度高于LowLoc。</p><p><img src="/2023/12/25/Predicting%20the%20Performance%20of%20Sparse%20Matrix/image-20231224101427524.png" alt="image-20231224101427524" style="zoom:50%;"></p><p><strong>SuiteSparse矩阵没有很多不同的行为</strong></p><p>图4显示SparseSuite矩阵中最快的方法通常是Sell-c-𝜎。然而，对图5中RMAT生成的矩阵进行的实验表明，LAV和LAV-1Seg通常是最快的。出现这种差异的原因是SuiteSparse矩阵主要来自科学领域或来自道路图等图；来自幂律图的并不多。</p><p>🔰幂率图：节点度(连接数)的分布符合幂律分布。在一个幂率图中，只有少数节点具有非常高的度，而大多数节点的度相对较低。对于一个具有幂律度分布的图，其邻接矩阵可能表现出一些特殊的结构。例如，那些连接度非常高的节点会在矩阵的特定行或列上具有很多非零元素，而大多数节点则在这个矩阵中具有相对较少的非零元素。实际上就是<strong>偏斜程度高</strong>。</p><p>可以通过绘制SuitSparce矩阵中每行非零元素的直方图来观察SuitSparce矩阵。<u>p-ratio表示p比例的行包含了矩阵中(1−p)比例的非零元素</u>。</p><p>图7显示了p-ratio的分布。可以看到大多数SuiteSparse矩阵的p-ratio高于0.4。这意味着许多矩阵的非零值到行的分布是平衡的。这一事实使得 SELLPACK和Sell-c-𝜎方法变得有效。此外，SuiteSparse矩阵的列数通常较少。它们中的大多数列数少于5M，允许输入向量适合LLC并减少对 LAV的需求。</p><p>总体而言，SuiteSparse更适合Sell-c-𝜎和SELLPACK等方法。如果想使用一组有代表性的矩阵来训练我们的预测模型，需要使用更广泛的矩阵来增强SuiteSparse。</p><p><img src="/2023/12/25/Predicting%20the%20Performance%20of%20Sparse%20Matrix/image-20231224103224146.png" alt="image-20231224103224146" style="zoom: 67%;"></p><h2 id="4-WISE-Picking-the-Best-SpMV-Method"><a href="#4-WISE-Picking-the-Best-SpMV-Method" class="headerlink" title="4 WISE: Picking the Best SpMV Method"></a>4 WISE: Picking the Best SpMV Method</h2><p>考虑到为给定输入矩阵选择最佳SpMV方法具有挑战性，作者开发了基于ML的框架WISE，可为给定的稀疏矩阵选择高性能SpMV方法。并设想WISE可以集成到GraphBLAS/BLAS框架中，例如英特尔的MKL。WISE的设计对程序员来说是透明的，并且可以轻松集成到现有系统中。</p><h3 id="4-1-Overall-Design"><a href="#4-1-Overall-Design" class="headerlink" title="4.1 Overall Design"></a>4.1 Overall Design</h3><p>WISE由一个新的稀疏矩阵特征集、一组基于ML的性能预测模型以及考虑性能预测模型的输出来选择最佳SpMV方法的启发式算法组成。</p><p>图8展示了WISE的工作过程。</p><ol><li>WISE从输入矩阵中提取某些特征的值：包括识别稀疏矩阵大小的特征，以及非零分布的偏斜和局部特征。</li><li>特征被传递到一组ML性能模型，该模型预测各个方法相对于最佳CSR的加速。</li><li>接下来，WISE 选择预计可实现最高加速的方法和参数值，同时包含预处理成本。</li><li>将矩阵布局从 CSR 转换为所选方法和参数对的布局。</li><li>最后，使用选定的方法、参数和矩阵布局运行SpMV。</li></ol><p><img src="/2023/12/25/Predicting%20the%20Performance%20of%20Sparse%20Matrix/image-20231224105255235.png" alt="image-20231224105255235" style="zoom:50%;"></p><h3 id="4-2-Sparse-Matrix-Features"><a href="#4-2-Sparse-Matrix-Features" class="headerlink" title="4.2 Sparse Matrix Features"></a>4.2 Sparse Matrix Features</h3><p>第三节已经分析过，系数矩阵的nnz偏斜及局部性特征影响SpMV的性能。基于此选取性能模型的特征。作者将矩阵划分为K^2块，每块nR/K行，nC/K列。基于系数矩阵的大小和L2缓存的大小，选取K=2048。作者将块的行和列分别称为行块和列块(图 9)。然后考虑nnz在行(R)、列(C)、块(T)、行块(RB)和列块(CB)上的分布。</p><p><img src="/2023/12/25/Predicting%20the%20Performance%20of%20Sparse%20Matrix/image-20231224170433492.png" alt="image-20231224170433492" style="zoom:50%;"></p><p>为了表征每个分布，作者使用平均值(𝜇)、标准差(𝜎)、方差(𝜎2)、最小值、最大值、基尼系数(G)和p-ratio(P)。G和P是计算分布中不平衡的统计度量。在最不平衡分布中(即所有非零值都在一个桶中)，G接近1，P接近0。完美平衡分布G=0且P=0.5。此外，还记录不为零的桶的数量(ne)。作者使用stat_dist作为这些统计量的命名约定，其中stat是汇总统计量的名称，dist是分布名称(R、C、T、RB和CB)。</p><p>接下来，描述如何使用这些汇总统计数据和附加统计数据为基于ML的性能预测器创建稀疏矩阵特征。表2显示了WISE从输入矩阵中提取的特征，分为矩阵大小、非零偏斜和非零局部性。</p><img src="/2023/12/25/Predicting%20the%20Performance%20of%20Sparse%20Matrix/image-20231224171004412.png" class title="image-20231224171004412"><p><strong>(1)矩阵大小性质</strong></p><p>WISE测量行数nR、列数nC和非零数。nC给出有关输入向量大小的信息，而非零数给出有关要完成的工作量的信息。</p><p><strong>(2)非零偏斜性质</strong></p><p>WISE使用测量行和列之间非零分布的偏斜程度的特征。收集的统计数据列于表2中。行分布的特征决定了矢量化的行调度和填充。 列分布的特征决定了对输入向量的内存访问的不规则性。因此，它们可以表明CFS在LAV-1Seg和LAV中的有效性。</p><p><strong>(3)非零元素局部性性质</strong></p><p>WISE使用T、RB和CB分布来捕获非零局部性特征，例如，T分布中的低p-ratio表明非零值集中在几个块中。因此，SpMV的内存访问具有较高的局部性。</p><p>WISE还收集了每个块内非零元素布局的信息。对于块i，uniqRi和uniqCi分别是包含非零元素的行数和列数。如果许多非零元素在同一行或同一列，那么访问就有可能利用局部性。此外，由于数据按照缓存行排列，如果非零元素相邻，它们可能共享缓存行并进一步增强局部性。因此，WISE还测量了块𝑖的GrX_uniqRi和GrX_uniqCi，它们是按照X个相邻行(或列)分组的包含非零元素的行数和列数。例如，如果𝑋=16，那么16个相邻的列(或行)将计为一个ID。WISE使用{4, 8, 16, 32, 64}这些值作为X。为了理解它们的用途，考虑64字节的缓存行。在这种情况下，一行可能容纳四个128位的元素(我们对𝑋=4感兴趣)或八个64位的元素(我们对𝑋=8感兴趣)。如果在相近的时间内访问了缓存行中的多个元素，我们就可以得到一个缓存命中。</p><p>WISE获取每个块的uniqRi，uniqCi，GrX_uniqRi , 和GrX_uniqCi。然后，它将所有块的这些值求和，并除以矩阵中的非零元素个数。得到的值，我们称之为uniqR，uniqC，GrX_uniqR和GrX_uniqC，被用作矩阵的特征。</p><p>最后，WISE测量每一行𝑖中至少有一个非零元素的块数(potReuseRi)。它也测量每一列𝑖的类似指标(potReuseCi)。如果这些指标很高，那么在LLC中有数据重用的潜力，因为数据在不同的块之间被重用。另外，WISE测量每𝑋个连续行的组𝑖中至少有一个非零元素的块数(GrX_potReuseRi)。对于每𝑋个连续列的组𝑖，它也测量一个类似的指标，叫做GrX_potReuseC𝑖。最后，WISE将这些测量值在所有行(potReuseR)、所有列(potReuseC)、所有𝑋个连续行的组(GrX_potReuseR)和所有𝑋个连续列的组(GrX_potReuseC)上求平均。这些平均值被用作矩阵的特征。 </p><p>注意，R，C，T，RB和CB的分布不是用来训练基于机器学习的性能预测模型的特征。使用从分布中计算出的汇总统计量作为训练特征。</p><h3 id="4-3-Performance-Prediction-Models"><a href="#4-3-Performance-Prediction-Models" class="headerlink" title="4.3 Performance Prediction Models"></a>4.3 Performance Prediction Models</h3><p>WISE使用决策树作为性能模型。因为每个特征都有不同的取值范围，难以归一化到一个范围。例如行列数可以高达百万但Gini-index只在0-1之间。</p><p>不同方法和对应参数之间产生多种组合，因此性能预测模型有共29个。</p><ul><li>CSR：三种不同调度</li><li>SELLPACK：静态连续和动态调度 + c的取值</li><li>SELL-C-σ：静态连续和动态调度 + c的取值 + σ的取值</li><li>SELL-C-R/LAV-1Seg：动态调度 + c的取值</li><li>LAV：动态调度 + c的取值 + T的取值</li></ul><p>以上所有c的取值都为{4,8}，为向量指令的长度。σ为{2^9,2^12,2^14}，2^9符合L1的大小，2^14符合L2的大小。T的取值为{0.7,0.8,0.9}，覆盖不同程度的nnz偏斜。</p><p>对于决策树可能会遇到的过拟合问题，作者将树的最大深度限制为 15，以避免创建仅包含少量样本的分支。并启用最小成本复杂度修剪，阈值为 0.005。树的最大深度和修剪阈值是使用网格搜索通过实验选择的。此外，决策树使用基尼系数作为分割标准。</p><p><strong>加速比分类</strong></p><p>每个模型都会预测相对于最快 CSR 方法的方法和参数值组合的执行时间。每个模型输出7个类(C0-C6)，对应7个执行时间范围。C0 = (∞ - 1.05], C1 = (1.05 - 0.95], C2 = (0.95 - 0.85], C3 = (0.85 - 0.75], C4 = (0.75 - 0.65], C5 = (0.65 - 0.55], C6 = (0.55 - 0]。C0 包括使用给定方法减速的所有矩阵，C6 包括加速超过 2 倍的所有矩阵。值低于 1 的类别表示加速。</p><h3 id="4-4-Choosing-the-SpMV-Method"><a href="#4-4-Choosing-the-SpMV-Method" class="headerlink" title="4.4 Choosing the SpMV Method"></a>4.4 Choosing the SpMV Method</h3><p>WISE会选择产生最大加速比的方法和参数对。如果有接近的，WISE会选择最小预处理开销的。预处理开销从低到高为：CSR, SELLPACK, Sell-c-𝜎, Sell-c-R, LAV-1Seg, LAV。而参数则从小到大选取，因为小参数预处理时间更少。</p><h3 id="4-5-Creating-a-Representative-Training-Set"><a href="#4-5-Creating-a-Representative-Training-Set" class="headerlink" title="4.5 Creating a Representative Training Set"></a>4.5 Creating a Representative Training Set</h3><p>机器学习模型需要具有代表性的训练集来执行预测。但第三节的分析表明SuitSparse中的矩阵没有很多不同的行为，因此作者使用了RMAT生成的一组矩阵补充。</p><p>RMAT 生成器有 3 个参数：节点数；平均节点度；边落入四个象限中每个象限的概率a，b，c，d。为了放置边，根据概率选择矩阵的象限。选定的象限再次分为四个象限，并且重复该过程直到最终形成单个矩阵单元。</p><p>为了获得偏斜矩阵，作者从Graph500参数开始，即 a=0.57、b=0.19、c=0.19 和 f=0.05(HighSkew)。他们生成幂律图。然后，减少a参数，同时增加b,c和d，以减少偏斜，同时仍然创建community structure(a&gt;d)。分析两种图形类型，参数为 𝑎=0.46、𝑏=0.22、𝑐=0.22 和 𝑑=0.10(MedSkew)，以及a=0.35、b=0.25、c=0.25 和 d=0.15 (LowSkew)。 HighSkew、MedSkew 和 LowSkew 图的行非零分布的p-ratio分别为 ≈0.1、≈0.2、≈0.3。</p><p>🔰community structure：指图中的节点可以被划分为若干个子集，每个子集内部的节点之间有较多的连接，而不同子集之间的节点之间有较少的连接。社区结构可以反映图中的一些潜在的模式或特征，例如社交网络中的兴趣群体，知识图谱中的语义类别，网络流量中的异常行为等。幂律图可以用四个参数a,b,c,d来描述，它们分别表示从一个节点出发，到达同一个社区，相邻社区，相邻社区的相邻社区，或者其他社区的概率。一般来说，a越大，表示同一个社区内部的连接越多，社区结构越明显；d越大，表示不同社区之间的连接越多，社区结构越模糊。</p><p>为了获得具有不同局部性的矩阵，从a=b=c=d=0.25(Erdos-Renyi)(LowLoc)开始，其中非零值均匀分布在所有列和行上。作者通过等量地增加a和d参数并以相同的量减少b和c来获得非零值聚集在对角线周围的矩阵。使用MedLoc(a=d=0.35, b=c=0.15)和HighLoc(a=d=0.45, b=c=0.05)，局部性上升。对于LowLoc、MedLoc和HighLoc图，行非零分布的p-ratio为0.4-0.5，显示出很小的偏差。</p><p>除了RMAT图，作者还加入了一些随机几何图(RGG)。RGG是无向空间图，在二维网格随机均匀放置n顶点来生成，如果两个顶点在网格中的距离小于r，就用一条边连接他们，r设置为：</p><p><img src="/2023/12/25/Predicting%20the%20Performance%20of%20Sparse%20Matrix/image-20231225111739467.png" alt="image-20231225111739467" style="zoom: 50%;"></p><p>其中degree是随机图的期望平均度数。作者使用RGG图来模拟具有空间结构的矩阵的行为。RGG图具有高度的局部性。</p><p><img src="/2023/12/25/Predicting%20the%20Performance%20of%20Sparse%20Matrix/image-20231225111902244.png" alt="image-20231225111902244" style="zoom:50%;"></p><h2 id="5-Experimental-Setup"><a href="#5-Experimental-Setup" class="headerlink" title="5 Experimental Setup"></a>5 Experimental Setup</h2><p>测试机器为2.6GHz的Intel Gold 6126 Skylake。处理器有两路，每路12核。每核32KB L1和1MB L2，每一路有一个共享19MB LLC。有192GB主存。使用4/8宽的向量指令。</p><p>为了训练和测试WISE，作者使用SuiteSparse中的136个矩阵和第4.5节中所述图生成的1326个矩阵。对于SuiteSparse矩阵，使用具有2^20-2^26行的大型矩阵，但非零值少于20亿个，以适应单台机器的内存。对于RMAT和RGG矩阵，使用具有2^20、2^21、2^22、2^23、2^24、2^24.58、2^25、2^25.30、2^25.58、2^25.80和2^26行的矩阵，每行的平均非零数为4-128。每个矩阵使用的非零总数不超过20亿个。</p><p>作者使用C++和OpenMP来实现并行性。依靠 OpenMP simd pragma进行矢量化。使用带有O3和vec标志的Intel编译器v2021。在执行过程中，运行24个线程，这些线程都固定到物理核心。使用numactl -i all在NUMA节点之间交错内存分配。</p><p>测试时作者采用k-fold，取k=10测试。</p><h2 id="6-Experimental-Results"><a href="#6-Experimental-Results" class="headerlink" title="6 Experimental Results"></a>6 Experimental Results</h2><h3 id="6-1-Characteristics-of-the-Matrix-Set"><a href="#6-1-Characteristics-of-the-Matrix-Set" class="headerlink" title="6.1 Characteristics of the Matrix Set"></a>6.1 Characteristics of the Matrix Set</h3><p>补充的RMAT矩阵和RGG矩阵使矩阵集更具代表性。原因有两个方面，首先是非零偏斜，通过随机矩阵中每行非零值的p-ratio分布来测量。图11中所示的这种分布应与图7中的 SuiteSparse 矩阵的分布进行对比。与图7不同。HS、MS 和 LS 的p-ratio值分别为 0.1、0.2和0.3。选择用于建模不同局部性特征的矩阵的p-ratio值约为≈0.4-0.5，这能够在不受偏斜行为干扰的情况下对局部性效果进行建模。</p><p><img src="/2023/12/25/Predicting%20the%20Performance%20of%20Sparse%20Matrix/image-20231225122910898.png" alt="image-20231225122910898" style="zoom:50%;"></p><p>第二个方面是每行非零的平均数量(μR)的分布，即在图中，节点的平均度数的分布。图12显示了随机矩阵和 SuiteSparse 矩阵的这种分布。可以看到随机矩阵涵盖了更广泛的 𝜇𝑅 值范围。随机矩阵集合包括具有较大𝜇𝑅值的矩阵，这导致向量单元的利用率更高。总体而言，两组矩阵的组合能够训练更有效的机器学习模型。</p><p><img src="/2023/12/25/Predicting%20the%20Performance%20of%20Sparse%20Matrix/image-20231225123209902.png" alt="image-20231225123209902" style="zoom:50%;"></p><h3 id="6-2-Classification-Accuracy-of-WISE"><a href="#6-2-Classification-Accuracy-of-WISE" class="headerlink" title="6.2 Classification Accuracy of WISE"></a>6.2 Classification Accuracy of WISE</h3><p>图10显示了WISE对加速区间预测的准确性。显示了五个代表型模型的矩阵。所有模型的c=8。垂直轴是正确的类别，水平轴是预测的类别。</p><img src="/2023/12/25/Predicting%20the%20Performance%20of%20Sparse%20Matrix/image-20231225123512257.png" class title="image-20231225123512257"><p>相邻类的性能间隔是10%，可以看到大多数预测类和正确类之间的距离在0-1之间，意味着大部分WISE估计值在正确执行时间的10%以内。具体来说，WISE对于SELLPACK、Sell-c-𝜎、Sell-c-R、LAV-1Seg和LAV的准确率分别为87%、92%、87%、84%和83%。此外，在分类错误的矩阵中，大多数分类与正确类别的距离仅一。这样的矩阵分别占SELLPACK、Sell-c-𝜎、Sell-c-R、LAV-1Seg和LAV错误分类矩阵的94%、89%、90%、91%和92%。一般来说，高估和低估加速比的矩阵数量是相当的。</p><p>未显示的其他模型的结果与图 10 中的结果相当。总的来说，可得出结论，WISE 可以高精度预测不同方法的加速。</p><h3 id="6-3-WISE-Speedup-and-Preprocessing-Overhead"><a href="#6-3-WISE-Speedup-and-Preprocessing-Overhead" class="headerlink" title="6.3 WISE: Speedup and Preprocessing Overhead"></a>6.3 WISE: Speedup and Preprocessing Overhead</h3><p>图13a显示了在所有矩阵的MKL基准上使用 WISE 获的加速分布。</p><img src="/2023/12/25/Predicting%20the%20Performance%20of%20Sparse%20Matrix/image-20231225151731686.png" class title="image-20231225151731686"><p>WISE对大多数矩阵都有加速效果，最高可达4-8x，平均加速比是2.4x。13b展现了选择每个矩阵对应最快的方法的加速比，平均加速比是2.5x，WISE的结果与之非常相近。</p><p>这些加速数字不包括预处理时间开销。后者由CSR的格式转换和特征计算组成。图13c显示了WISE预处理时间开销的分布。以花费相同时间的MKL的SpMV迭代次数来报告开销。从图中可以计算出WISE的平均开销为8.33次MKL SpMV迭代。</p><h3 id="6-4-Comparison-to-MKL-Inspector-Executor"><a href="#6-4-Comparison-to-MKL-Inspector-Executor" class="headerlink" title="6.4 Comparison to MKL Inspector-Executor"></a>6.4 Comparison to MKL Inspector-Executor</h3><p>接下来作者还与Intel的MKL inspector-executor(IE)进行了比较。IE也会在许多方法中选择最合适的，但是具体细节是隐藏的。MKL IE可以减少SpMV的时间，但是会带来高昂的预处理开销。</p><p>作者测量后，发现MKL IE有平均相对与MKL基本方法的2.11x加速比，不包括预处理时间，而预处理时间为17.43MKL SpMV迭代。因此WISE的加速比相对于MKL IE为1.14x，并且预处理时间也比MKL IE少50%。</p><h3 id="6-5-Choosing-Decision-Tree-Parameters"><a href="#6-5-Choosing-Decision-Tree-Parameters" class="headerlink" title="6.5 Choosing Decision Tree Parameters"></a>6.5 Choosing Decision Tree Parameters</h3><p>决策树中的两个重要参数是树的最大深度D和修剪程度ccp_alpha(缩写为ccp)。对于D，作者测试{5, 10, 15, 20}值；对于ccp，测试{0, 0.001, 0.005, 0.01, 0.05, 0.1}值。表4显示了WISE在具有不同D和ccp值的MKL上获得的平均加速。可以得出ccp应该很低(即低于0.05)，而D应该很高(即10或更高)。总的来说，为WISE选择D=15和ccp=0.005。</p><p><img src="/2023/12/25/Predicting%20the%20Performance%20of%20Sparse%20Matrix/image-20231225153245728.png" alt="image-20231225153245728" style="zoom:50%;"></p><h2 id="7-Related-Work"><a href="#7-Related-Work" class="headerlink" title="7 Related Work"></a>7 Related Work</h2><p>之前的一些工作已经使用自动调整来加速稀疏矩阵运算。此类系统每次处理矩阵时都会增加潜在的高自动调整开销。使用WISE，创建模型后，每个矩阵的预处理开销很小。</p><p>之前的其他工作已经利用机器学习进行方法选择，即选择为给定稀疏矩阵提供最高性能的方法。 WISE 与之前的工作有两个不同之处。首先，WISE中ML模型的输出不是SpMV方法；它是给定方法的潜在加速。结果是一个可扩展的框架，可以在不改变现有模型的情况下添加新方法。其次，WISE不仅考虑给定方法，而且还考虑给定方法的参数。例如，WISE选择给定c和T参数值的 LAV 方法。</p><p>赵等人[43]使用一种新颖的汇总技术，将稀疏矩阵表示为小二维图像。然后，他们在该图像上使用 CNN 来确定矩阵的最佳格式。 WISE也使用矩阵的2D块表示。然而，它用它来建模矩阵的局部特征。此外，WISE使用决策树作为ML模型，并使用大一个数量级的矩阵来训练和测试ML模型。</p><p>一些方法(例如，SMAT [23])使用由实际使用的SpMV方法驱动的ML特征。例如，一些特征是所使用的特定矩阵格式的存储器开销。相比之下，WISE选择作为ML模型输入的特征不受所使用的 SpMV 方法的影响。</p><p>SpMV和图处理的局部优化示例有很多。例如，Cagra[42]预处理一个图，将其划分为较小的 LLC 大小的子图。其他示例包括分箱技术[4, 8]。对于所有这些技术，WISE可以通过新的性能模型进行扩展。 Milk[19]是一组语言扩展，旨在提高间接内存访问的局部性，也可用于SpMV计算。还有编译时和运行时技术来加速具有间接内存访问的程序[31, 33]。此外，分区技术也可以用来改善局部性[10]。</p><p>之前的工作目标是重新标记图的顶点以提供更好的局部性[2,3,6,37]。这些技术实现了高局部性，但会产生大量开销。在这项工作中，我们只考虑RFS和CFS重新排序机制。然而，WISE 可以作为第一步来决定是否应用更先进的重新排序技术，从而可能消除开销。</p><p>已经提出了许多不同的SpMV向量化方法[12,21,24,25,32,38]。他们的主要目标是最大化向量单元的利用率。刘等人[25]建议使用有限窗口排序，它与 RFS 类似，但只考虑一小部分行。 VHCC[32]设计了一种2D锯齿状格式，用于SpMV的有效向量化。WISE的功能可以有效评估这些技术的潜力。</p><h2 id="8-Conclusions"><a href="#8-Conclusions" class="headerlink" title="8 Conclusions"></a>8 Conclusions</h2><p>为了加速SpMV，本文开发了一个名为WISE的ML框架，该框架可以预测给定稀疏矩阵的不同SpMV方法相对于baseline方法的加速幅度。 WISE依赖于一个新颖的特征集，该特征集总结了矩阵的大小、非零偏斜和非零局部性。 WISE能够以高精度选择最佳的SpMV方法及其参数。对于一组近1,500个矩阵以及几种流行的方法和优化，WISE在24核服务器中实现了比英特尔MKL平均2.4倍的加速。此外，WISE 的平均加速比英特尔的MKL IE提高了1.14倍，而其预处理开销还不到50%。得益于WISE对用户透明的方法，具有更多方法和优化的扩展WISE是对MKL等GraphBLAS/BLAS库的有效补充。</p><h2 id="Appendix-A：Unified-Matrix-Format"><a href="#Appendix-A：Unified-Matrix-Format" class="headerlink" title="Appendix A：Unified Matrix Format"></a>Appendix A：Unified Matrix Format</h2><p>为了能够快速提取出各种格式向量化计算的信息，作者提出了一个矩阵表示格式，称为<strong>Segmented Reordered Vector Packing(SRVPack)</strong>。</p><p>SRVPack支持将矩阵数据分为LAV中提到的两段(segment)，密集的段和稀疏的段。每一部分都存储RFS+SELL-C-R格式的数据。每个segment有一个row_order数组记录新的行顺序。每个Chunk内的行按row_order顺序存储，行长度不足Chunk宽度的进行0填充。类似CSR，有一个val数组存储元素和一个col_id存储列号。这些二维数组有一个长度为c的Y维，一个长度为segment中的Chunk总长的x维，另外有一个offset数组存储每个Chunk的第一个nonzero元素。创建这种统一格式的开销是预处理开销的一部分。</p><p><img src="/2023/12/25/Predicting%20the%20Performance%20of%20Sparse%20Matrix/image-20231223150603210.png" alt="image-20231223150603210" style="zoom: 50%;"></p><p><img src="/2023/12/25/Predicting%20the%20Performance%20of%20Sparse%20Matrix/image-20231223150825121.png" alt="image-20231223150825121" style="zoom: 33%;"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] Walid Abu-Sufah and Asma Abdel Karim. 2013. Auto-tuning of Sparse Matrix-Vector Multiplication on Graphics Processors. In Supercomputing, Julian Martin Kunkel, Thomas Ludwig, and Hans Werner Meuer (Eds.). Springer Berlin Heidelberg, Berlin, Heidelberg, 151–164.<br>[2] R. C. Agarwal, F. G. Gustavson, and M. Zubair. 1992. A high performance algorithm using pre-processing for the sparse matrix-vector multiplication. In Supercomputing ’92:Proceedings of the 1992 ACM/IEEE Conference on Supercomputing. 32–41.<br>[3] J. Arai, H. Shiokawa, T. Yamamuro, M. Onizuka, and S. Iwamura. 2016. Rabbit Order: Just-in-Time Parallel Reordering for Fast Graph Analysis. In 2016 IEEE International Parallel and Distributed Processing Symposium (IPDPS). 22–31. <a href="https://doi.org/10.1109/IPDPS.2016.110">https://doi.org/10.1109/IPDPS.2016.110</a><br>[4] S. Beamer, K. Asanovic, and D. Patterson. 2017. Reducing Pagerank Communication via Propagation Blocking. In 2017 IEEE International Parallel and Distributed Processing Symposium (IPDPS). 820–831. <a href="https://doi.org/10.1109/IPDPS.2017.112">https://doi.org/10.1109/IPDPS.2017.112</a></p><p>[5] Scott Beamer, Krste Asanovic, and David A. Patterson. 2015. The GAP Benchmark Suite. CoRR abs/1508.03619 (2015). arXiv:1508.03619 <a href="http://arxiv.org/abs/1508.03619">http://arxiv.org/abs/1508.03619</a><br>[6] Paolo Boldi, Marco Rosa, Massimo Santini, and Sebastiano Vigna. 2011. Layered Label Propagation: A Multiresolution Coordinate-free Ordering for Compressing Social Networks. In Proceedings of the 20th International Conference on World Wide Web (Hyderabad, India) (WWW ’11). ACM, New York, NY, USA, 587–596. <a href="https://doi.org/10.1145/1963405.1963488">https://doi.org/10.1145/1963405.1963488</a><br>[7] Sergey Brin and Lawrence Page. 1998. The Anatomy of a Large-scale Hypertextual Web Search Engine. Comput. Netw. ISDN Syst. 30, 1-7 (April 1998), 107–117. <a href="https://doi.org/10.1016/S0169-7552(98)00110-X">https://doi.org/10.1016/S0169-7552(98)00110-X</a><br>[8] Daniele Buono, Fabrizio Petrini, Fabio Checconi, Xing Liu, Xinyu Que, Chris Long, and Tai-Ching Tuan. 2016. Optimizing Sparse Matrix-Vector Multiplication for Large-Scale Data Analytics. In Proceedings of the 2016 International Conference on Supercomputing (Istanbul, Turkey) (ICS ’16). ACM, New York, NY, USA, Article 37, 12 pages. <a href="https://doi.org/10.1145/2925426.2926278">https://doi.org/10.1145/2925426.2926278</a><br>[9] Alfredo Buttari, Victor Eijkhout, Julien Langou, and Salvatore Filip-pone. 2007. Performance Optimization and Modeling ofBlocked Sparse Kernels. Int. J. High Perform. Comput. Appl. 21, 4 (Nov. 2007), 467–484. <a href="https://doi.org/10.1177/1094342007083801">https://doi.org/10.1177/1094342007083801</a><br>[10] U. V. Catalyurek and C. Aykanat. 1999. Hypergraph-partitioning-based decomposition for parallel sparse-matrix vector multiplication. IEEE Transactions on Parallel and Distributed Systems 10, 7 (July 1999), 673–693. <a href="https://doi.org/10.1109/71.780863">https://doi.org/10.1109/71.780863</a><br>[11] Deepayan Chakrabarti, Yiping Zhan, and Christos Faloutsos. 2004. R-MAT: A Recursive Model for Graph Mining. In Proceedings of the 2004 SIAM International Conference on Data Mining (SDM). 442–446. <a href="https://doi.org/10.1137/1.9781611972740.43">https://doi.org/10.1137/1.9781611972740.43</a><br>[12] Linchuan Chen, Peng Jiang, and Gagan Agrawal. 2016. Exploiting Recent SIMD Architectural Advances for Irregular Applications. In Proceedings of the 2016 International Symposium on Code Generation and Optimization (Barcelona, Spain) (CGO ’16). ACM, New York, NY, USA, 47–58. <a href="https://doi.org/10.1145/2854038.2854046">https://doi.org/10.1145/2854038.2854046</a><br>[13] Intel Corp. 2015. Intel Math Kernel Library Inspector-executor Sparse BLAS Routines. <a href="https://software.intel.com/en-us/articles/intel-math-kernel-library-inspector-executor-sparse-blas-routines">https://software.intel.com/en-us/articles/intel-math-kernel-library-inspector-executor-sparse-blas-routines</a>.<br>[14] Intel Corp. 2015. Sparse BLAS CSR Matrix Storage Format. <a href="https://www.intel.com/content/www/us/en/develop/documentation/onemkl-developer-reference-c/top/appendix-a-linear-solvers-basics/sparse-matrix-storage-formats/sparse-blas-csr-matrix-storage-format">https://www.intel.com/content/www/us/en/develop/documentation/onemkl-developer-reference-c/top/appendix-a-linear-solvers-basics/sparse-matrix-storage-formats/sparse-blas-csr-matrix-storage-format</a>.<br>[15] Timothy A. Davis and Yifan Hu. 2011. The University ofFlorida Sparse Matrix Collection. ACMTrans. Math. Softw. 38, 1, Article 1 (Dec. 2011), 25 pages. <a href="https://doi.org/10.1145/2049662.2049663">https://doi.org/10.1145/2049662.2049663</a><br>[16] Daniel Funke, Sebastian Lamm, Ulrich Meyer, Peter Sanders, Manuel Penschuck, Christian Schulz, Darren Strash, and Moritz von Looz. 2019. Communication-free Massively Distributed Graph Generation. J. Parallel and Distrib. Comput. 131, C (2019).<br>[17] Eun-Jin Im, Katherine Yelick, and Richard Vuduc. 2004. Sparsity: Optimization Framework for Sparse Matrix Kernels. The International Journal of High Performance Computing Applications 18, 1 (2004), 135–158. <a href="https://doi.org/10.1177/1094342004041296">https://doi.org/10.1177/1094342004041296</a> arXiv:<a href="https://doi.org/10.1177/1094342004041296">https://doi.org/10.1177/1094342004041296</a><br>[18] Z. Jia, L. Wang, J. Zhan, L. Zhang, and C. Luo. 2013. Characterizing data analysis workloads in data centers. In 2013 IEEE International Symposium on Workload Characterization (IISWC). 66–76. <a href="https://doi.org/10.1109/IISWC.2013.6704671">https://doi.org/10.1109/IISWC.2013.6704671</a><br>[19] Vladimir Kiriansky, Yunming Zhang, and Saman Amarasinghe. 2016. Optimizing Indirect Memory References with Milk. In Proceedings of the 2016 International Conference on Parallel Architectures and Compi-lation (Haifa, Israel) (PACT’16). ACM, New York, NY, USA, 299–312. <a href="https://doi.org/10.1145/2967938.2967948">https://doi.org/10.1145/2967938.2967948</a></p><p>[20] Jon M. Kleinberg. 1999. Authoritative Sources in a Hyperlinked Environment. J. ACM 46, 5 (Sept. 1999), 604–632. <a href="https://doi.org/10.1145/324133.324140">https://doi.org/10.1145/324133.324140</a><br>[21] Moritz Kreutzer, Georg Hager, Gerhard Wellein, Holger Fehske, and Alan R. Bishop. 2014. A Unified Sparse Matrix Data Format for Efficient General Sparse Matrix-Vector Multiplication on Modern Processors with Wide SIMD Units. SIAM Journal on Scientific Computing 36, 5 (Jan 2014), C401–C423. <a href="https://doi.org/10.1137/130930352">https://doi.org/10.1137/130930352</a><br>[22] Jérôme Kunegis and Julia Preusse. 2012. Fairness on the Web: Alternatives to the Power Law. In Proceedings of the 4th Annual ACM Web Science Conference (Evanston, Illinois) (WebSci ’12). Association for Computing Machinery, New York, NY, USA, 175–184. <a href="https://doi.org/10.1145/2380718.2380741">https://doi.org/10.1145/2380718.2380741</a><br>[23] Jiajia Li, Guangming Tan, Mingyu Chen, and Ninghui Sun. 2013. SMAT: An Input Adaptive Auto-Tuner for Sparse Matrix-Vector Multiplication. In Proceedings of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation (Seattle, Washington, USA) (PLDI’13). Association for Computing Machinery, New York, NY, USA, 117–126. <a href="https://doi.org/10.1145/2491956.2462181">https://doi.org/10.1145/2491956.2462181</a><br>[24] Weifeng Liu and Brian Vinter. 2015. CSR5: An Efficient Storage Format for Cross-Platform Sparse Matrix-Vector Multiplication. In Proceedings of the 29th ACM on International Conference on Supercomputing (Newport Beach, California, USA) (ICS ’15). ACM, New York, NY, USA, 339–350. <a href="https://doi.org/10.1145/2751205.2751209">https://doi.org/10.1145/2751205.2751209</a><br>[25] Xing Liu, Mikhail Smelyanskiy, Edmond Chow, and Pradeep Dubey. 2013. Efficient Sparse Matrix-vector Multiplication on x86-based Many-core Processors. In Proceedings of the 27th International ACM Conference on International Conference on Supercomputing (Eugene, Oregon, USA) (ICS ’13). ACM, New York, NY, USA, 273–282. <a href="https://doi.org/10.1145/2464996.2465013">https://doi.org/10.1145/2464996.2465013</a><br>[26] Ke Meng, Jiajia Li, Guangming Tan, and Ninghui Sun. 2019. A Pattern Based Algorithmic Autotuner for Graph Processing on GPUs. In Proceedings of the 24th Symposium on Principles and Practice of Parallel Programming (Washington, District of Columbia) (PPoPP ’19). Association for Computing Machinery, New York, NY, USA, 201–213. <a href="https://doi.org/10.1145/3293883.3295716">https://doi.org/10.1145/3293883.3295716</a><br>[27] Robert Meusel, Sebastiano Vigna, Oliver Lehmberg, and Christian Bizer. 2014. Graph Structure in the Web — Revisited: A Trick of the Heavy Tail. In Proceedings of the 23rd International Conference on World Wide Web (Seoul, Korea) (WWW’14 Companion). ACM, New York, NY, USA, 427–432. <a href="https://doi.org/10.1145/2567948.2576928">https://doi.org/10.1145/2567948.2576928</a><br>[28] Alexander Monakov, Anton Lokhmotov, and Arutyun Avetisyan. 2010. Automatically Tuning Sparse Matrix-Vector Multiplication for GPU Architectures. In High Performance Embedded Architectures and Compilers, Yale N. Patt, Pierfrancesco Foglia, Evelyn Duesterwald, Paolo Faraboschi, and Xavier Martorell (Eds.). Springer Berlin Heidelberg, Berlin, Heidelberg, 111–125.<br>[29] Richard C Murphy, Kyle B Wheeler, Brian W Barrett, and James A Ang. 2010. Introducing the Graph 500. Cray Users Group (CUG) 19 (2010), 45–74.<br>[30] Naser Sedaghati, Te Mu, Louis-Noel Pouchet, Srinivasan Parthasarathy, and P. Sadayappan. 2015. Automatic Selection of Sparse Matrix Representation on GPUs. In Proceedings of the 29th ACM on International Conference on Supercomputing (Newport Beach, California, USA) (ICS ’15). Association for Computing Machinery, New York, NY, USA, 99–108. <a href="https://doi.org/10.1145/2751205.2751244">https://doi.org/10.1145/2751205.2751244</a><br>[31] Michelle Mills Strout, Alan LaMielle, Larry Carter, Jeanne Ferrante, Barbara Kreaseck, and Catherine Olschanowsky. 2016. An Approach for Code Generation in the Sparse Polyhedral Framework. Parallel Comput. 53, C (April 2016), 32–57. <a href="https://doi.org/10.1016/j.parco.2016.02.004">https://doi.org/10.1016/j.parco.2016.02.004</a></p><p>[32] W. T. Tang, R. Zhao, M. Lu, Y. Liang, H. P. Huyng, X. Li, and R. S. M. Goh. 2015. Optimizing and auto-tuning scale-free sparse matrix-vector multiplication on Intel Xeon Phi. In 2015 IEEE/ACM International Symposium on Code Generation and Optimization (CGO). 136–145. <a href="https://doi.org/10.1109/CGO.2015.7054194">https://doi.org/10.1109/CGO.2015.7054194</a><br>[33] Anand Venkat, Manu Shantharam, Mary Hall, and Michelle Mills Strout. 2014. Non-Affine Extensions to Polyhedral Code Generation. In Proceedings of Annual IEEE/ACM International Symposium on Code Generation and Optimization (Orlando, FL, USA) (CGO’14). Association for Computing Machinery, New York, NY, USA, 185–194. <a href="https://doi.org/10.1145/2544137.2544141">https://doi.org/10.1145/2544137.2544141</a><br>[34] R. Vuduc, J. W. Demmel, K. A. Yelick, S. Kamil, R. Nishtala, and B. Lee. 2002. Performance Optimizations and Bounds for Sparse Matrix-Vector Multiply. In SC ’02: Proceedings of the 2002 ACM/IEEE Conference on Supercomputing. 26–26. <a href="https://doi.org/10.1109/SC.2002.10025">https://doi.org/10.1109/SC.2002.10025</a><br>[35] Hao Wang, Liang Geng, Rubao Lee, Kaixi Hou, Yanfeng Zhang, and Xiaodong Zhang. 2019. SEP-Graph: Finding Shortest Execution Paths for Graph Processing under a Hybrid Framework on GPU. In Proceedings of the 24th Symposium on Principles and Practice of Parallel Programming (Washington, District of Columbia) (PPoPP ’19). Association for Computing Machinery, New York, NY, USA, 38–52. <a href="https://doi.org/10.1145/3293883.3295733">https://doi.org/10.1145/3293883.3295733</a><br>[36] L. Wang, J. Zhan, C. Luo, Y. Zhu, Q. Yang, Y. He, W. Gao, Z. Jia, Y. Shi, S. Zhang, C. Zheng, G. Lu, K. Zhan, X. Li, and B. Qiu. 2014. BigDataBench: A big data benchmark suite from internet services. In 2014 IEEE 20th International Symposium on High Performance Computer Architecture (HPCA). 488–499. <a href="https://doi.org/10.1109/HPCA.2014.6835958">https://doi.org/10.1109/HPCA.2014.6835958</a><br>[37] HaoWei, Jeffrey Xu Yu, Can Lu, and Xuemin Lin. 2016. Speedup Graph Processing by Graph Ordering. In Proceedings of the 2016 International Conference on Management of Data (San Francisco, California, USA) (SIGMOD ’16). ACM, New York, NY, USA, 1813–1828. <a href="https://doi.org/10.1145/2882903.2915220">https://doi.org/10.1145/2882903.2915220</a><br>[38] Biwei Xie, Jianfeng Zhan, Xu Liu, Wanling Gao, Zhen Jia, Xiwen He, and Lixin Zhang. 2018. CVR: Efficient Vectorization of SpMV on x86 Processors. In Proceedings of the 2018 International Symposium on Code Generation and Optimization (Vienna, Austria) (CGO 2018). ACM, New York, NY, USA, 149–162. <a href="https://doi.org/10.1145/3168818">https://doi.org/10.1145/3168818</a><br>[39] Zhen Xie, Guangming Tan, Weifeng Liu, and Ninghui Sun. 2019. IA-SpGEMM: An Input-Aware Auto-Tuning Framework for Parallel Sparse Matrix-Matrix Multiplication. In Proceedings of the ACM International Conference on Supercomputing (Phoenix, Arizona) (ICS ’19). Association for Computing Machinery, New York, NY, USA, 94–105. <a href="https://doi.org/10.1145/3330345.3330354">https://doi.org/10.1145/3330345.3330354</a><br>[40] Serif Yesil, Azin Heidarshenas, Adam Morrison, and Josep Torrellas. 2020. Speeding Up SpMV for Power-Law Graph Analytics by Enhancing Locality and Vectorization. In SC20: International Conference for High Performance Computing, Networking, Storage and Analysis. <a href="https://doi.org/10.1109/SC41405.2020.00090">https://doi.org/10.1109/SC41405.2020.00090</a><br>[41] Buse Yilmaz, Bariş Aktemur, María J. Garzarán, SamKamin, and Furkan Kiraç. 2016. Autotuning Runtime Specialization for Sparse Matrix-Vector Multiplication. ACMTrans. Archit. Code Optim. 13, 1, Article 5 (March 2016), 26 pages. <a href="https://doi.org/10.1145/2851500">https://doi.org/10.1145/2851500</a><br>[42] Y. Zhang, V. Kiriansky, C. Mendis, S. Amarasinghe, and M. Zaharia. 2017. Making caches work for graph analytics. In 2017 IEEE International Conference on Big Data (Big Data). 293–302. <a href="https://doi.org/10.1109/BigData.2017.8257937">https://doi.org/10.1109/BigData.2017.8257937</a><br>[43] Yue Zhao, Jiajia Li, Chunhua Liao, and Xipeng Shen. 2018. Bridging the Gap between Deep Learning and Sparse Matrix Format Selection. In Proceedings of the 23rd ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (Vienna, Austria) (PPoPP ’18). Association for Computing Machinery, New York, NY, USA, 94–108. <a href="https://doi.org/10.1145/3178487.3178495">https://doi.org/10.1145/3178487.3178495</a></p><p>[44] Yue Zhao, Weijie Zhou, Xipeng Shen, and Graham Yiu. 2018. Overhead-Conscious Format Selection for SpMV-Based Applications. In 2018 IEEE International Parallel and Distributed Processing Symposium (IPDPS). 950–959. <a href="https://doi.org/10.1109/IPDPS.2018.00104">https://doi.org/10.1109/IPDPS.2018.00104</a><br>[45] Weijie Zhou, Yue Zhao, Xipeng Shen, and Wang Chen. 2020. Enabling Runtime SpMV Format Selection through an Overhead Conscious Method. IEEE Transactions on Parallel and Distributed Systems 31, 1 (2020), 80–93. <a href="https://doi.org/10.1109/TPDS.2019.2932931">https://doi.org/10.1109/TPDS.2019.2932931</a></p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Efficiently Running SpMV on Long Vector Architectures</title>
      <link href="/2023/12/22/Efficiently%20Running%20SpMV%20on%20Long%20Vector%20Architectures/"/>
      <url>/2023/12/22/Efficiently%20Running%20SpMV%20on%20Long%20Vector%20Architectures/</url>
      
        <content type="html"><![CDATA[<h1 id="Efficiently-Running-SpMV-on-Long-Vector-Architectures"><a href="#Efficiently-Running-SpMV-on-Long-Vector-Architectures" class="headerlink" title="Efficiently Running SpMV on Long Vector Architectures"></a>Efficiently Running SpMV on Long Vector Architectures</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>稀疏矩阵-向量乘法（SpMV）是并行数值应用的一个重要核心。SpMV中存在稀疏和不规则的数据访问，这使得它的向量化变得复杂。这些困难使得SpMV在运行于利用SIMD并行性的长向量ISA时，经常出现非最优的结果。在这种情况下，开发新的优化方法成为了使SpMV在新兴的长向量架构上实现高性能执行的基础。本文通过提出几种新的优化方法，改进了最先进的SELL-C-𝜎稀疏矩阵格式。作者针对长向量架构，如NEC Vector Engine。通过结合多种优化方法，在考虑24个异构矩阵的情况下，平均比SELL-C-𝜎提高了12%。作者的优化方法提高了长向量架构的性能，因为它们实现了高度的SIMD并行性。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>SpMV是HPC中常见的一个计算kernel。在线性系统中通常通过迭代方法求解，在这个执行过程中使用SpMV kernel。此外数据分析领域的工作负载需要通过SpMV来操作高度不规则和稀疏的矩阵。因此，有效地执行这个基本的线性代数核心是至关重要的。</p><p>SpMV的性能影响因素很多。一些提升性能的困难为：</p><ul><li>对向量x的访问与矩阵A的稀疏模式有关，对x的访问不规则且难以预测。</li><li>𝑥是SpMV中涉及的唯一一个可以利用一定程度的数据重用的数据结构，但其访问的不规则性使得很难充分利用这些重用机会。</li><li>由于矩阵中的不同的非零值分布，会带来<strong>控制流分歧</strong>(多个线程或处理单元同时执行指令。当在执行中需要根据条件进行不同的操作时，就会发生控制流分歧。这可能导致一些线程需要等待其他线程完成它们的工作，从而影响整体性能)而影响性能。在GPU或长向量处理单元上这样的问题会显著限制性能。</li></ul><p>对于最常见的稀疏矩阵存储格式CSR，对x的访问是不规则的，并且控制流分歧严重。因此有一些其他方式通过增加数据存储来换取对x访问的局部性的提升。SELL-C-σ和ESB是另外两种格式，通过分块和行排序来提高对x访问的局部性。许多方法提供了很好的性能，但是仍然可以针对长向量架构进行优化，本篇文章作者的工作主要有：</p><ul><li>作者针对长向量架构改进了SELL-C-σ，在<strong>NEC SX-Aurora Vector Engine</strong>实现了117GFlops的78%的峰值内存带宽。展示了如何在新兴的向量ISA（如Arm SVE或RISC-V向量扩展）上处理稀疏数据结构。</li><li>实现评估了一些优化方法在长向量架构机器的优化效果。</li><li>与一些针对多核CPU或GPU设备的先进SpMV实现进行了比较。证明了作者的方法分别实现了3.02x和1.72x的加速比。</li></ul><p>🔰NEC SX-Aurora Vector Engine：高性能向量处理器，向量长为16 kbit，支持谓词操作，可以执行基于条件的向量操作。</p><p>🔰Arm SVE：SVE是ARM在其v8-A架构中引入的较新的向量指令集，它的设计更为灵活，支持可变长度的向量。这使得SVE能够更好地适应不同应用和硬件的需求。SVE引入了矢量长度的概念，允许程序在运行时选择不同的矢量长度，而不是被限制在固定长度的向量上。这种可伸缩性使SVE能够更好地适应不同计算需求。早期的NEON指令集主要专注于嵌入式系统和移动设备上的加速，而SVE则更为灵活，适用于各种不同类型的计算，包括高性能计算和服务器领域。</p><h2 id="2-Background"><a href="#2-Background" class="headerlink" title="2 Background"></a>2 Background</h2><p>稀疏矩阵的常见存储格式有以下这些。</p><p><strong>CSR</strong></p><p>压缩稀疏行（CSR）是一种最常用的表示稀疏矩阵的格式。它按行顺序将非零（NNZ）元素的值和列索引分别存储在两个数组中。第三个数组保存了每一行在这些数组中的起始位置的指针。CSR的主要优点是它对任何类型的矩阵元素分布都有很大的压缩比，以及可以顺序地访问𝐴的值和列索引的可能性。它的主要缺点是不适合向量架构，以及𝑥访问的局部性差。</p><p><strong>ELLPACK</strong></p><p>是为了在GPU和向量架构中高效地执行而设计的。与CSR相比，它通过以列顺序存储和访问非零元素，以增加存储的代价，提高了对𝑥的内存访问的局部性。对于一个大小为𝑀 × 𝑁的矩阵𝐴，如果每行的最大长度为𝐾，它需要一个大小为𝑀 × 𝐾的数组来存储𝐴。ELLPACK的主要缺点是它只有在存储的矩阵具有规则的每行NNZ元素时，才能提供良好的性能和压缩。尽管两个压缩矩阵是二维的，实际计算中会将其按列存储为一维，然后由GPU的threads进行计算，每个thread一行。</p><p><img src="/2023/12/22/Efficiently%20Running%20SpMV%20on%20Long%20Vector%20Architectures/image-20231220170940366.png" alt="image-20231220170940366" style="zoom:50%;"></p><p>Sliced ELLPACK是ELLPACK的改进，将矩阵的行按照非零元素的个数排序，再将整个矩阵划分为固定行数的切片，这样每一切片中的行长度相近，可以更好的利用缓存局部性。适用于非零元素数分布不均匀的稀疏矩阵。</p><p><strong>SELL-C-σ</strong></p><p>SELL-C-σ是基于Sliced ELLPCAK的改进。将矩阵按行分为指定大小的CHUNK，并只对指定σ行进行排序，避免大规模排序的性能开销。下图中C=4，σ为8。在GPU上，最小的C为32，即一个warp的大小，在CPU上则应该为向量单元的长度。</p><p><img src="/2023/12/22/Efficiently%20Running%20SpMV%20on%20Long%20Vector%20Architectures/image-20231220172438014.png" alt="image-20231220172438014" style="zoom:50%;"></p><p><strong>ESB(ELLPACK Sparce Block)</strong></p><p>ESB引入了两个额外的优化来降低带宽需求：列阻塞和使用位数组来屏蔽指令。为了提高访问的局部性，ESB将矩阵拆分为列块或片块。ESB使用位数组数据结构为切片的每一列存储一位掩码。对于列中的每个非零元素，位被设置为1。该信息稍后用于屏蔽SIMD操作的元素。它实现了大的压缩率，因为它不需要零填充(在”针对长向量架构的优化-通过调整向量长度应对控制流分歧”部分说明这是如何实现的)。</p><p><img src="/2023/12/22/Efficiently%20Running%20SpMV%20on%20Long%20Vector%20Architectures/image-20231220173305208.png" alt="image-20231220173305208" style="zoom: 50%;"></p><p>作者给出的该图中，最右侧的是采用了控制流分歧优化的SELL-C-σ，不需要0填充。</p><h2 id="3-Contributions"><a href="#3-Contributions" class="headerlink" title="3 Contributions"></a>3 Contributions</h2><h3 id="3-1-SELL-C-σ格式的实现"><a href="#3-1-SELL-C-σ格式的实现" class="headerlink" title="3.1 SELL-C-σ格式的实现"></a>3.1 SELL-C-σ格式的实现</h3><p>SELL-C-σ是向量架构下高效的稀疏矩阵格式。因此作者以SELL-C-σ为基础来实现SpMV。首先作者使用了一些已有的优化手段，并针对长向量架构做了调整，主要是三个部分：</p><ul><li>选择随着σ参数的增加，同时考虑性能和预处理开销的合适的排序策略。</li><li>使用不同粒度的任务大小来调整任务并行中格式缩放的影响。</li><li>使用列分块提升访问向量x的局部性。</li></ul><p><strong>排序策略</strong></p><p>SELL-C-σ格式需要矩阵行根据NNZ元素个数排序，这开销可能很大。作者采用基数排序降低开销。矩阵被分为不同的子集部分，在内部进行排序，而各子集的排序可以并行完成，使用OpenMP就可以实现。子集被称为reorder window，大小为σ。在使用了控制流分歧优化的基础上，作者测试了排序的性能及最佳的σ值。σ取16K可达到最佳性能，比σ取256性能提高30%，但在预处理阶段需要40%-50%的额外时间。在测试时，将矩阵转换为SELL-C-σ格式需要10到15次迭代。作者使用row_order[num_rows]存储矩阵的行顺序。</p><p><strong>任务并行</strong></p><p>作者将工作负载分成不同的任务，并行执行，使用OpenMP来处理任务。理想中的任务粒度取决于输入矩阵，因此作者进行了可扩展性测试，最多8个线程，任务数量为8-256。任务处理类似工作量但稀疏程度不同的矩阵。结果说明最佳的工作负载性能不应创造过多的任务。工作负载划分为8-64个任务最好。后续实验也采用了8-64个任务的配置。</p><p><strong>列分块</strong></p><p>已有工作分析了列分块对SpMV的影响，不过仅限于Xeon Phi，SIMD宽度为512位。作者扩展了SELL-C-σ，实现了类似的分块，测试这样优化的效果。</p><h3 id="3-2-针对长向量架构的优化"><a href="#3-2-针对长向量架构的优化" class="headerlink" title="3.2 针对长向量架构的优化"></a>3.2 针对长向量架构的优化</h3><p>作者针对SX-aurora类似的长向量架构做了一些优化：</p><ul><li>通过缓存分配提升x的重用以及减少存储依赖(降低存储指令之间的依赖关系的优先级，从而允许一些不违反内存顺序的加载指令提前发出，而不用等待之前未解决的存储地址。)。</li><li>自适应向量长度的控制流，避免存储和计算0填充元素。</li><li>使用部分循环融合❓在SELL-C-σ中实现循环展开。</li><li>使用特殊指令实现高效的gather和scatter操作。</li></ul><p>作者所有的优化都是基于以下的基本实现代码的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sell_c_sigma_mv</span><span class="params">(mtx, x, y, num_rows)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> maxvl = <span class="number">256</span>;<span class="comment">//每次计算的行数，即Slice的行数</span></span><br><span class="line"><span class="comment">/* Outer loop: iterates over rows in the mtx */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; num_rows; row += maxvl) &#123;</span><br><span class="line"><span class="type">int</span> vl=((num_rows - row) &lt; maxvl)? (num_rows - row): maxvl;<span class="comment">//当前迭代的行数</span></span><br><span class="line">        vr res = <span class="built_in">vxor</span>(res, res, vl);<span class="comment">//清0结果</span></span><br><span class="line">        <span class="comment">/* Set pointers to values and column indices */</span></span><br><span class="line">        <span class="type">int</span> sli = row / maxvl;<span class="comment">//slice编号</span></span><br><span class="line">        <span class="type">int</span> nnz_idx = mtx.slices_ptr[sli]<span class="comment">//slice的起始位置</span></span><br><span class="line">        <span class="type">double</span> *values = &amp;mtx.values[nnz_idx];<span class="comment">//数据的起始地址</span></span><br><span class="line">        <span class="type">int</span> *col_indices = &amp;mtx.column_indices[nnz_idx];</span><br><span class="line">        <span class="comment">/* Compute scatter addresses */</span></span><br><span class="line">        vr y_sc_addr = <span class="built_in">vload</span>(<span class="number">8</span>, &amp;mtx.vrow_order[row], vl);<span class="comment">//以8为步长，把结果的行号存储到向量中</span></span><br><span class="line">        y_sc_addr = <span class="built_in">vshiftadd</span>(y_sc_addr, <span class="number">3UL</span>, y, maxvl);<span class="comment">//结果的地址，索引*8+y</span></span><br><span class="line">        <span class="comment">/* Inner loop: iterates over columns in the slice */</span></span><br><span class="line">        <span class="type">int</span> swidth = mtx.slices_width[sli];<span class="comment">//切片宽度，即有多少列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; swidth; i++) &#123;</span><br><span class="line">            <span class="comment">/* Load mtx values and column index */</span></span><br><span class="line">            vr val = <span class="built_in">vload</span>(<span class="number">8</span>, values, vl);</span><br><span class="line">            vr col = <span class="built_in">vload</span>(<span class="number">8</span>, col_indices, vl);</span><br><span class="line">            vr xgather_addr = <span class="built_in">vshiftadd</span>(col, <span class="number">3</span>, x, vl);<span class="comment">//x的相应位置地址gather到向量中</span></span><br><span class="line">            <span class="comment">/* Gather and multiply */</span></span><br><span class="line">            vr x_val = <span class="built_in">vgather</span>(xgather_addr, vl);</span><br><span class="line">            res = <span class="built_in">vmultiplyadd</span>(res, x_val, val, vl);</span><br><span class="line">            values += maxvl; col_indices += maxvl;<span class="comment">//更新values和col_indices的地址</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vscatter</span>(res, y_sc_addr, vl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🔰TIP：这里要注意的是，前述的SELL-C-σ格式，每个切片内的元素的按照列存储的，切片是按顺序存储的。所有的切片行数相同，最后一个切片的长度也是，在values和col_indices也是这样对齐存储的，这样做是为了方便向量化操作，因此更新values的地址时要+maxvl，多余的部分也要跳过。</p><p><strong>缓存分配和存储放松</strong></p><p>在SpMV中，对矩阵A的访问和复用特性与对x的有很大差异。访问A的数据结构时步长是1且不会重用，而对x的访问是随机的但会重复使用。为了实现更好的性能，需要尽可能的实现数据的重用，来减少内存带宽的压力。长向量架构通常提供显式的缓存替换策略选择。充分利用这个特性，可以设定<strong>含有values和col_indices的缓存行最先被换出</strong>，从而降低向量x被换出的可能性。这被称为<strong>非缓存加载(Non-Cacheable load)</strong>。</p><p>另一个方面是存储策略。作者使用一个向量寄存器存储一个slice内的中间结果，结束后通过scatter指令存储数据。分散存储指令会根据地址范围计算依赖性，这可能导致尽管具体地址不同，但延迟访问该地址范围的后续存储指令。由于我们知道scatter之后的指令不会访问相同的内存地址，所以可以<strong>指示硬件不要检查scatter和后续指令之间的依赖关系</strong>，这被称为<strong>Store Overtake</strong>。在这部分relaxation<br>period结束后再插入memory fence指令。现代向量处理器支持这样的依赖放松。</p><p><img src="/2023/12/22/Efficiently%20Running%20SpMV%20on%20Long%20Vector%20Architectures/image-20231221152527298.png" alt="image-20231221152527298" style="zoom:50%;"></p><p><strong>通过调整向量长度应对控制流分歧</strong></p><p>每行的非零元素数量不一样，会导致循环迭代时的每行数据控制流分歧。例如假设有4列4行，前两行有4个非零元素，后两行只有2个非零元素，按列计算的迭代共有4轮，但后两行在最后两轮迭代其实没有计算，浪费了计算资源。</p><p>一个处理控制流分歧的流行技术是使用<strong>谓词寄存器</strong>。这种寄存器包含了一个位数组指出哪些元素为0。AVX，SVE都支持这样的寄存器，使编译器能够向量化不规则的循环。但是这需要大量的存储空间，因为每个向量元素都需要一个相应的mask，而且有许多实现不是不处理0元素，而只是处理后忽略无意义的结果。</p><p>作者提出了一种新方法来应对控制流分歧，这种方法依赖于向量元素数量(Ve)和向量通道(Vl)的比率，这种方法被作者称为<strong>Divergent Flow Control (DFC)</strong>。计算向量需要Ve/Vl个batch，作者的方法就是只要求硬件处理MAXnnz/Vl个batch，而且MAXnnz的大小受到向量寄存器的限制，对于SX-Aurora，向量寄存器存储256元素，因此MAXnnz在1~256之间，用一个字节就可以存储MAXnnz的信息。这里不明白作者命名MAXnnz中MAX表示什么，不过优化的操作如下：</p><p>回顾上文，由于切片内数据是按列计算的，因此<strong>向量存储的是一列的数据</strong>，假设我们有一个如下的Slice，Vl是2，如果未优化，那么向量长度(列长)是4，计算需要两个batch，而最后一行的最后一个batch的计算是没有意义的，因此额外添加一个数组，记录每一列的NNZ数量分别为4 4 4 4 2，这样最后一列(最后一个向量)就只计算一个batch，从而实现性能的优化。而一个slice的行最多有256个(SX-Aurora的向量长度限制)，因此每一列NNZ元素数量只要一个字节就可以记录。作者使用一个active_lanes来实现这种优化，这个数据结构包含每个切片要执行的每个列向量操作的值。</p><p><img src="/2023/12/22/Efficiently%20Running%20SpMV%20on%20Long%20Vector%20Architectures/image-20231221154729269.png" alt="image-20231221154729269" style="zoom: 80%;"></p><p><strong>循环展开</strong></p><p>循环展开是一种常见优化，可以减少控制流开销。在这里作者增加列向量长度来提高向量x的局部性，同时最大限度提高寄存器文件上的数据重用。</p><p><img src="/2023/12/22/Efficiently%20Running%20SpMV%20on%20Long%20Vector%20Architectures/image-20231221162358667.png" alt="image-20231221162358667" style="zoom:50%;"></p><p>但是这种循环展开在这里的有效实现并不简单，展开的问题在于每个切片具有不同的宽度，每个切片的宽度都小于或等于前一个切片的宽度。因此需要在最后额外计算slice1的最后几列，同时计算slice1和slice2循环的列数是slice2的列数(行宽swidth)。此外，σ应该是展开的所有切片行数的倍数。</p><p>展开大小受向量寄存器数量的限制。由于每次展开时局部变量的数量都会增加，因此重要的是要在使用它们的最直接的上下文中声明它们，这使得编译器更容易管理寄存器依赖项、应用特定于体系结构的优化并避免溢出。作者的实现能够在具有192个架构寄存器的向量架构上最多展开8次，而不会产生任何溢出访问。</p><p>作者进行两次展开的示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sell_c_sigma_mv_unroll</span><span class="params">(mtx, x, y, num_rows)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> maxvl = <span class="number">256</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; (num_rows - <span class="number">511</span>); row += <span class="number">512</span>) &#123;</span><br><span class="line">    <span class="type">int</span> sli = row / maxvl;</span><br><span class="line">    <span class="comment">/* Set pointers to values and column indices */</span></span><br><span class="line">    <span class="type">double</span> *values1 = &amp;mtx.values[slices_ptr[sli]];</span><br><span class="line">    <span class="type">double</span> *values2 = &amp;mtx.values[slices_ptr[sli+<span class="number">1</span>]];</span><br><span class="line">    <span class="type">int</span> *col_indices1 = &amp;mtx.col_idx[slices_ptr[sli]];</span><br><span class="line">    <span class="type">int</span> *col_indices2 = &amp;mtx.col_idx[slices_ptr[sli+<span class="number">1</span>]];</span><br><span class="line">    vr res1 = <span class="built_in">vxor</span>(res1, res1, maxvl);</span><br><span class="line">    vr res2 = <span class="built_in">vxor</span>(res2, res2, maxvl);</span><br><span class="line">    <span class="type">int</span> swidth = mtx.slices_width[sli];</span><br><span class="line">    <span class="type">int</span> swidth2 = mtx.slices_width[sli + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> al1 = active_lanes[sli];</span><br><span class="line">    <span class="type">int</span> al2 = active_lanes[sli + <span class="number">1</span>];</span><br><span class="line">    vr y_sc_addr = <span class="built_in">vload</span>(<span class="number">8</span>, &amp;mtx.vrow_order[row], maxvl);</span><br><span class="line">    y_sc_addr1 = <span class="built_in">vshiftadd</span>(y_sc_addr1, <span class="number">3</span>, y, maxvl);</span><br><span class="line">    vr y_sc_addr2 = <span class="built_in">vload</span>(<span class="number">8</span>, &amp;mtx.vrow_order[row+maxvl], maxvl);</span><br><span class="line">    y_sc_addr2 = <span class="built_in">vshiftadd</span>(y_sc_addr2, <span class="number">3UL</span>, y, maxvl);</span><br><span class="line">    <span class="comment">/* Partial loop fusion: Slices 1 &amp; 2 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; swidth2; i++) &#123;</span><br><span class="line">      <span class="comment">/* Compute slice 1 */</span></span><br><span class="line">      <span class="type">int</span> nl_1 = vactive_lanes[al1++] + <span class="number">1</span>;</span><br><span class="line">      vr val1 = <span class="built_in">vload</span>(<span class="number">8</span>, values1, nl_1);</span><br><span class="line">      vr col1 = <span class="built_in">vload</span>(<span class="number">8</span>, col_indices1, nl_1);</span><br><span class="line">      vr xgather_addr1 = <span class="built_in">vshiftadd</span>(col1, <span class="number">3</span>, x, nl_1);</span><br><span class="line">      vr x_val1 = <span class="built_in">vgather</span>(xgather_addr1, nl_1);</span><br><span class="line">      res1 = <span class="built_in">vmultiplyadd</span>(res1, x_val1, val1, nl_1);</span><br><span class="line">      <span class="comment">/* Compute slice 2 */</span></span><br><span class="line">      <span class="type">int</span> nl_2 = vactive_lanes[al2++] + <span class="number">1</span>;</span><br><span class="line">      vr val2 = <span class="built_in">vload</span>(<span class="number">8</span>, values2, nl_2);</span><br><span class="line">      vr col2 = <span class="built_in">vload</span>(<span class="number">8</span>, col_indices2, nl_2);</span><br><span class="line">      vr xgather_addr2 = <span class="built_in">vshiftadd</span>(col2, <span class="number">3</span>, x, nl_2);</span><br><span class="line">      vr x_val2 = <span class="built_in">vgather</span>(xgather_addr2, nl_2);</span><br><span class="line">      res2 = <span class="built_in">vmultiplyadd</span>(res2, x_val2, val2, nl_2);</span><br><span class="line">      <span class="comment">/* Advance pointers */</span></span><br><span class="line">      values1 += nl_1; values2 += nl_2;</span><br><span class="line">      col_indices1 += nl_1; col_indices2 += nl_2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Finish computing the remaining vector ops in slice 1*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = swidth2; i &lt; swidth; i++) &#123;</span><br><span class="line">      <span class="comment">/* Same code as above but only for slice 1 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vscatter</span>(res1, y_sc_addr1, maxvl);</span><br><span class="line">    <span class="built_in">vscatter</span>(res2, y_sc_addr2, maxvl);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>gather/scatter地址的高效计算</strong></p><p>在SpMV中，gather用于获取非连续的x元素，而scatter存储元素到结果向量y中时，是通过起始地址+行索引*数据大小计算的。对此进行优化，跟有加法运算的乘法指令可以被单个移位和加法指令取代。这在上面的代码中已经应用了。</p><p>为了评估优化效果，作者创建了五种实现，进行了测试，在此后的章节进行评估，这五种实现为：</p><p><img src="/2023/12/22/Efficiently%20Running%20SpMV%20on%20Long%20Vector%20Architectures/image-20231221164225131.png" alt="image-20231221164225131" style="zoom:50%;"></p><h2 id="4-Methodology"><a href="#4-Methodology" class="headerlink" title="4 Methodology"></a>4 Methodology</h2><p>这一章描述了评估的实验设置。作者的实现是在NEC SX-Aurora上的，用于比较的系统有：</p><ul><li>Intel Xeon Platinum 8160 CPU：24核2.10GHz。L1缓存32KB，L2缓存1024KB，L3是所有核共享的，大小为33792KB。每个核都有AVX-512SIMD单元，支持512bits即16floats，8doubles的向量计算。</li><li>NVIDIAV100 (Volta) GP-GPU：84SM，最大1.5GHz。84SM共享6144KB的L2缓存，4096GB的高带宽存储器(HBM2)。</li></ul><h3 id="4-1-SX-Aurora-VE"><a href="#4-1-SX-Aurora-VE" class="headerlink" title="4.1 SX-Aurora VE"></a>4.1 SX-Aurora VE</h3><p>NEC SX-Aurora VE是NEC长向量架构的最新实现，结合了SIMD和流水线。向量单元和向量寄存器在8周期深的流水线中使用32*64位宽的SIMD，最大向量长度为256×64位或512×32位元素。本文的VE10B处理器2018年发布，并进行了性能评估。VE的6层每层8个HBM2的48GB总容量的内存接口可以提供172.4 GB/s的内存带宽，8核共享。</p><p>SpMV运算的性能优势在于大内存带宽，但同样重要的是处理器的其他特性，如内存延迟隐藏或缓存机制。8个VE核心的每一个都有一个标量处理单元(SPU)和一个向量处理单元(VPU)，连接到共用的16MBLLC(末级缓存)。核到LLC的带宽是406.9GB/s，是双向的。因此4个内核可以实现内存带宽的饱和。每个VPU有64个256 ×64位元素的架构向量寄存器，硬件中有三倍的寄存器，用于寄存器重命名。三个融合乘加向量单元在1.4 GHz时可提供每核269 GFLOPS（双精度）的峰值性能，在1.6 GHz时可提供307 GFLOPS(VE 10A型号)。所使用的VE变体的峰值性能为2.15 TFLOPS。具有8个核心的粗粒度并行性和向量级别的细粒度并行性。</p><p>VE作为PCIe卡集成到其主机中，并将操作系统功能完全卸载到主机。它们以多任务和多处理模式运行，像标准CPU一样，程序可以运行在VE上，将部分代码卸载到主机(反向卸载)，或在主机上运行，并将计算内核卸载到VE（加速器，卸载模型）。异构程序也可以使用NEC提供的混合MPI构建，该混合MPI连接在主机和VE上运行的进程。在所有情况下，程序员都可以使用C、C++、Fortran等语言，并与MPI和OpenMP并行化，而加速器代码仍然可以透明地使用几乎任何Linux系统调用。</p><p>NEC的专有编译器在指令的帮助下支持自动向量化。它们能够使用高级语言循环构造的扩展向量引擎ISA的大部分功能。对于本文提出的工作，我们需要更严格地控制VE功能，如向量掩码生成和控制、向量寄存器和数据的LLC缓存亲和性。因此，作者使用开源的LLVM-VE项目，它支持允许完全控制生成的代码的内部函数。</p><h3 id="4-2-Experimental-Setup"><a href="#4-2-Experimental-Setup" class="headerlink" title="4.2 Experimental Setup"></a>4.2 Experimental Setup</h3><p>作者使用了在最近的文献中频繁使用的代表广泛HPC应用问题的矩阵来评估。下表列出了矩阵及一些特征，这些内容可在<a href="https://sparse.tamu.edu/">SuiteS-parse Matrix Collection repository</a>找到。</p><p><img src="/2023/12/22/Efficiently%20Running%20SpMV%20on%20Long%20Vector%20Architectures/image-20231221171424212.png" alt="image-20231221171424212" style="zoom:50%;"></p><p>对于作者在VE中的Sell-C-𝜎实现，作者使用LLVM-VE v1.8进行编译，并链接NEC的专有编译器NCC v3.0.1。作者还使用一些专有的数学库进行平台间的性能比较：适用于上述VE、NVIDIA V100和Intel Xeon系统的NLC 2.0、cuSPARSE v10.2和MKL v2020.0。所有这些库都是在2019年或2020年发布的。所有代码都是使用-03优化级别编译的。为了便于重现，作者的<a href="https://repo.hca.bsc.es/gitlab/cgomez/spmv-long-vector">资源库</a>中提供了所有SpMV实现、开发的基准测试工具和用于每个系统的确切环境配置文件。</p><h2 id="5-Evaluation"><a href="#5-Evaluation" class="headerlink" title="5 Evaluation"></a>5 Evaluation</h2><h3 id="5-1-Performance-of-Long-Vector-Optimizations"><a href="#5-1-Performance-of-Long-Vector-Optimizations" class="headerlink" title="5.1 Performance of Long Vector Optimizations"></a>5.1 Performance of Long Vector Optimizations</h3><p>作者测试了在第三章提到的不同实现的性能。SpMV的性能与稀疏矩阵的结构高度关联。因此并不期望优化在所有评估的矩阵上都有相同的性能提升。作者考虑了矩阵的大小和密度，以及硬件性能监控计数器(PMC)提供的事件信息。PMC能提供VE的一些指标包括：标量和向量指令数，平均向量指令长，缓存未命中率。作者测量了采用提到的优化之前与之后的这些指标，来分析优化的效果。</p><p>图4显示了考虑所有矩阵的GFLOP/s性能结果。共评估了六种实现。其中NLC表示使用NEC的数学库的结果。所有的测量都具有第三章所述的最佳σ和任务分配配置。</p><p>图4中的dense2和nlptkk240矩阵缺少值。在dense2的情况下，包含8切片展开优化的实现需要至少2048行才能正确执行，而该矩阵只有2000行。在nlptkk240的情况下，使用 NLC 在尝试分配数据结构时会耗尽内存。尽管存在这些问题，作者仍然包含这些矩阵，因为作者认为它们对于评估目的很有价值。</p><img src="/2023/12/22/Efficiently%20Running%20SpMV%20on%20Long%20Vector%20Architectures/image-20231222095912701.png" class title="image-20231222095912701"><p>从图中可以看出，有两个矩阵(<strong>mip1和torso1</strong>)的测量性能，作者的实现明显比NEC数学库差。作者测试后发现8核运行时比单核运行时，执行的标量指令数大了一个数量级，这是因为OpenMP的工作负载分配不均衡导致的。</p><p><strong>DFC evaluation </strong></p><p>对于大多数矩阵，DFC的效果基本可以忽略，但对于高度不规则或非常稀疏的矩阵(<strong>webbase-1M和bundle-adj</strong>)，DFC能有效降低向量长度，提高性能。对于webbase-1M，采用DFC比不采用DFC快了50%，平均向量指令长度从256降到了148。</p><p><strong>Unrollling by 8 evaluation</strong></p><p>作者将SELLCS-DFC和SELLCS-U8-DFC比较，评估循环展开效果。13/24的矩阵使用循环展开后带来了1%~15%的性能提升，也有特例如nlpkkt240带来了51%的性能下降。</p><p>循环展开引入了将slices分配给不同任务的限制。作者的实现要求循环展开的每一个slice都小于等于上一个slice。为了保证这一点，不允许两个排序窗口的slice出现在一个循环展开当中。在一个窗口中，slice一定是长度减小的。每个任务的slice数是8的倍数。这导致任务分配的粒度比较大，最终可能导致核心之间负载分配的不平衡。<strong>bundle-adj</strong>循环展开后的情况就是由于上述原因，第一组slices的NNZ数量非常不均匀，由于上述限制，全部分配到一个task当中了。</p><p>图4表明采用循环展开，行数较少的矩阵优化效果比较好，行数较多的则受益不大。PMC数据指出了性能的提升来源于向量指令计算时间的减少。对于MLGEER和MLLaplcace，循环展开带来了14%和7%的向量负载吞吐量，这不仅来源于对x访问的局部性的提升，也来源于向量指令的并行度提升。</p><p><strong>Cache allocation and store relaxation policies</strong></p><p>将SELLCS-U8-NC-DFC和SELLCS-U8-DFC比较，可以评估缓存分配策略和存储放松的优化效果。有2/3的矩阵都有5%~12%的性能提升。作者选取了ldoor和pwtk进行进一步的分析，这两个矩阵优化后分别提高了8%和6%的LLC命中率，并提高了10%和8%的单周期向量加载元素。并且所有的矩阵都有最大50%的L1缓存缺失的减少。没有任何一种采用优化后性能会降低的情况，这说明缓存分配策略和存储放松优化适用于任何情景。</p><p><strong>Applying all optimizations</strong></p><p>所有的优化可以在所有的矩阵取得平均90.3GFLOPs的性能，这比基本的SELL-CL-σ和NEC数学库的性能分别提升了12%和17%。这证明了作者优化的重要性。</p><p><strong>Applicability of column blocking</strong></p><p>作者还尝试了列分块，但是列分块没有任何性能的提升。一些前期的在SIMD架构的的研究表明只有在有很长的行的矩阵才有效。所以作者又测试了另外两个矩阵spal_004和12month1，这两个矩阵有很长的行。如图5,12month1可以通过16分块得到2x的性能途胜，但是在spal_004，性能随着分块增加而降低。因此可以说明，虽然列分块在长向量架构中的适用性似乎有限，但在某些特定情况下它可能会对性能产生巨大的影响。</p><p><img src="/2023/12/22/Efficiently%20Running%20SpMV%20on%20Long%20Vector%20Architectures/image-20231222111632405.png" alt="image-20231222111632405" style="zoom:50%;"></p><h3 id="5-2-Comparison-with-state-of-the-art-HPC-architectures"><a href="#5-2-Comparison-with-state-of-the-art-HPC-architectures" class="headerlink" title="5.2 Comparison with state-of-the-art HPC architectures"></a>5.2 Comparison with state-of-the-art HPC architectures</h3><p>作者比较了在VE上运行采用全部优化的SpMV和在Intel和NVIDIA平台使用对应数学库的SpMV的性能和能耗。测试选取了每个矩阵在每个平台的最好结果，并包含了矩阵加载和预处理的时间。能耗测试时SpMV算法运行600K次迭代，使预处理和加载矩阵的总占比时间小于10%。</p><p>图6展示了这三个平台的性能对比。下方的图表示与MKL结果相比的归一化能耗。平均而言，SELLCS-U8-NC 分别比 cuSPARSE 和 MKL 提高了 1.72𝑥 和 3.02𝑥。在能源效率方面，SELLCS-U8-NC 与 cuSPARSE 相比能耗降低 22%，与 MKL 相比能耗降低 9.09 倍。</p><p>此外，图 6 上半部分所示的 VE 性能数据略低于图 4 所示的性能数据。不匹配平均低于 5%，这是引入了VE的能耗检测带来的开销。作者从比较中排除了两个矩阵：dense2，因为与展开优化不兼容；和 nlpkkt240，由于库中的内存管理错误。在表 4 中，作者给出了三种架构各自实现的双精度峰值性能的百分比。</p><img src="/2023/12/22/Efficiently%20Running%20SpMV%20on%20Long%20Vector%20Architectures/image-20231222122551281.png" class title="image-20231222122551281"><p><img src="/2023/12/22/Efficiently%20Running%20SpMV%20on%20Long%20Vector%20Architectures/image-20231222123334076.png" alt="image-20231222123334076" style="zoom:50%;"></p><h2 id="6-Related-work"><a href="#6-Related-work" class="headerlink" title="6 Related work"></a>6 Related work</h2><p>由于 SpMV 是多种科学计算算法中至关重要的核心，因此在过去 20 年中已经发表了大量关于许多架构上的 SpMV 优化的研究。最近，研究社区正专注于开发高效的 SpMV 实现，针对具有不同并行度的新兴架构，例如大量内核和长 SIMD 或向量单元。然而，大多数研究仅限于 CPU 中的 8 元素 SIMD 单元或 GPU 中的 32 元素扭曲 [4,8,9,13,14,16]。即使这些方法考虑了具有 AVX-512 扩展功能的最先进的英特尔 CPU 和最新的 GPU，但与作者在研究中考虑的 256 个双精度元素矢量平台 SX-Aurora 相比，它们还是有差距。</p><p>多项研究提出了能够利用 SIMD/向量单元的新格式。他们通过添加零填充来创建连续元素块。然而，由于这些格式依赖于拥有足够大的彼此靠近的 NNZ 元素组才能高效，因此它们不适合长向量架构。</p><p>有一些研究提出了一种两步 SpMV 算法，该算法对大数据矩阵显示出良好的性能改进。使用前一项工作(Implement-<br>ing a Sparse Matrix Vector Product for the SELL-C/SELL-C-𝜎 formats on NVIDIA GPUs.)的作者提供的代码，作者能够在类似于他们研究中使用的 x86 系统中重现结果。但作者无法使用性能接近 VE 中 SELL-C-𝜎 代码的内在函数来开发有效的实现。</p><h2 id="7-Conclusion"><a href="#7-Conclusion" class="headerlink" title="7 Conclusion"></a>7 Conclusion</h2><p>作者针对SX-Aurora长向量架构的SpMV实现显示了非常有竞争力的性能结果，大部分超过了NEC库集合中的高度优化的专有实现。作者使用开源编译器LLVM作为计算内核，并讨论了各种也可以应用于其他算法的优化。该实现适用于VE本机库，可从VE程序调用，可以轻松转换为可直接从主机上运行的程序调用的卸载库，以加速主机本机程序。该用例实际上将为预处理步骤带来调整机会，而该步骤在优化方面受到的关注较少。通过在主机端运行排序，作者预计会减少矩阵设置时间。</p><p>与其他高端架构相比，图6中的性能结果表明SX-Aurora性能非常有竞争力，平均胜过竞争架构Xeon Skylake Platinum和Skylake Platinum的两个标准库MKL和cuSparse。尽管VE的峰值性能最低，为2.15 TFLOPS，而Skylake的峰值性能为3.2 TFLOPS，V100的峰值性能为7.8 TFLOPS，但它可以利用其卓越的内存带宽，实现比竞争对手更高的SpMV性能。表4中的结果表明SX-Aurora是一个平衡良好的架构。其0.567 byte/FLOP与以显式并行的长向量 ISA 配合使用，可实现最高的最大和平均性能效率百分比，分别为峰值的5.38% 和4.19%。</p><p>从能耗考虑，加速器优于通用CPU，即便是使用了SIMD和高度优化的库的CPU。此外，性能测量表明长向量架构符合内存带宽要求的数据并行工作负载（例如 SpMV）的要求。</p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS149-Assignment-4(2023FALL)</title>
      <link href="/2023/12/21/CS149-Assignment-4/"/>
      <url>/2023/12/21/CS149-Assignment-4/</url>
      
        <content type="html"><![CDATA[<p>CS149-Assignment-4(2023FALL)。</p><p>CS149：<a href="https://gfxcourses.stanford.edu/cs149/fall23/">https://gfxcourses.stanford.edu/cs149/fall23/</a></p><h2 id="Assignment-4-NanoGPT149"><a href="#Assignment-4-NanoGPT149" class="headerlink" title="Assignment 4: NanoGPT149"></a>Assignment 4: NanoGPT149</h2><p>该Asst的任务是实现和优化一个基于transformer的神经网络模型的核心部分。这个DNN非常小，但是和ChatGPT这样的大模型的基本原理是一样的。具体而言，需要实现模型的注意力层，并专注于优化提升计算强度，减少内存占用，利用CPU的多核和SIMD并行能力。</p><p>这个Asst会接触DNN的实现细节，类似于One API或CuDNN的内核实现。并展现循环分块和循环融合等关键局部性优化的价值。</p><p>本任务中执行的NanoGPT模块是一个序列到序列的模型。输入是一系列单词，例如短语 “The course of true love never did run smooth”。模型的输出是一个新的单词序列，可能是根据已经在大量莎士比亚文本上进行训练的模型确定的输入后续。例如，给定上述前缀，模型的输出可能是 “whispered cs149 students whilst coding on assignments”。</p><p>NanoGPT模型使用一种称为transformer的流行深度神经网络模块，而其关键组件是被称为注意机制的块。在此任务中，任务是实现这个注意机制。从一个简单的顺序注意力实现开始，在任务的过程中，指导书会引导添加一些优化，如循环分块、循环融合和基本并行化。</p><h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>注意力机制的输入是三个矩阵Q，K和V，分别对应query，key，value向量。每个矩阵都是N×d大小。N是输入序列的token数(单词数)，每一行都是一个向量，是单词的神经编码。</p><p>为了提高模型的效率和表达能力，该注意机制通常会并行运行多次，因为存在多个注意头和批处理中的多个输入。确切了解为什么这样做并不重要，在这个简单的实现中，这些矩阵将呈现为 4D 张量，其中只需关注其中的两个维度（对应于N和d）。</p><p>注意力模型的第一步是计算单词之间的interactions，这是通过Q和K的相乘完成的：</p><script type="math/tex; mode=display">S = QK^T</script><p>第二步是对S的每一行进行softmax，softmax会产生每一行的归一化概率。假设是对1维向量计算：</p><script type="math/tex; mode=display">softmax(x) = \frac {f(x)}{l(x)}    \\f(x) = [e^{x1} \ e^{x2} \ e^{x3} ...\ e^{xN}] \\l(x) = \sum^N_{i=1} {f(x)_i}</script><p>通常，为了提高数值稳定性，Softmax 操作的计算中会减去输入向量中的最大值。这样做可以防止指数函数的过度增长，避免数值上溢。不过为了实现的简单，恶意只使用上述的公式。上述的计算会产生一个<strong>注意力权重矩阵P</strong>。</p><p>最终，利用上述的注意力权重汇总出一组学习值向量，形式还是N×d的矩阵。</p><script type="math/tex; mode=display">O = PV</script><p>总之，注意力层由昂贵的矩阵乘法、softmax和另外一个矩阵乘法组成。这三个部分将是实现过程中的主要部分。</p><h3 id="Warm-Up-Accessing-Tensors"><a href="#Warm-Up-Accessing-Tensors" class="headerlink" title="Warm-Up: Accessing Tensors"></a>Warm-Up: Accessing Tensors</h3><p>tensor(张量)是python中的一种数据抽象，实际上是多维数组。python将多维数组抽象为张量，在PyTorch时就不用关注访问数值或矩阵乘法等内部问题。并且Python的张量可轻松移植到GPU。在本次的程序中，只使用CPU，因此使用C++ vector，而不是张量。</p><p>理解tensor的核心是知道如何访问tensor。在Warm-Up中，需要编写一个4Dtensor的访问器。程序框架包含一个formatTensor函数，将tensor转换为C++Vector，还有函数将输出Vector转换为tensor。</p><p><strong>Step 1: Understand a 2D Accessor</strong></p><p>2D的数据访问很好理解，数据是以1D的形式存储的。因此访问2D数组，(i，j)的位置就是[i*num_col+j]。</p><p><strong>Step 2: Implement a 4D Accessor</strong></p><p>在需要实现的LLM模型中，数组是4维的，因此需要实现4D的数据访问。和2D的原理实际上是一样的。首先考虑3D的情况，(x，y，z)的位置应该是[x*SIZE_X*SIZE_Y+y*SIZE_Y+z]，其中的SIZE_X，SIZE_Y对应的是列长度和y方向上的长度，那么4D也是同理。因此访问4D的(x，y，z，b)的方式应该为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step #2: Implement Read/Write Accessors for a 4D Tensor</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">float</span> <span class="title">fourDimRead</span><span class="params">(std::vector&lt;<span class="type">float</span>&gt; &amp;tensor, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y, <span class="type">int</span> &amp;z, <span class="type">int</span> &amp;b, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">int</span> &amp;sizeX, <span class="type">const</span> <span class="type">int</span> &amp;sizeY, <span class="type">const</span> <span class="type">int</span> &amp;sizeZ)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tensor[x*sizeX*sizeY*sizeZ+y*sizeY*sizeZ+z*sizeZ+b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fourDimWrite</span><span class="params">(std::vector&lt;<span class="type">float</span>&gt; &amp;tensor, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y, <span class="type">int</span> &amp;z, <span class="type">int</span> &amp;b, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">int</span> &amp;sizeX, <span class="type">const</span> <span class="type">int</span> &amp;sizeY, <span class="type">const</span> <span class="type">int</span> &amp;sizeZ, <span class="type">float</span> &amp;val)</span> </span>&#123;</span><br><span class="line">    tensor[x*sizeX*sizeY*sizeZ+y*sizeY*sizeZ+z*sizeZ+b] = val;</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4D张量的布局应该是按照b，z，y，x的顺序一维展开，这样更符合局部性，相邻元素是连续存储的。</p><h3 id="Part-1-A-Simple-But-Not-So-Efficient-Implementation-of-Attention"><a href="#Part-1-A-Simple-But-Not-So-Efficient-Implementation-of-Attention" class="headerlink" title="Part 1: A Simple (But Not So Efficient) Implementation of Attention"></a>Part 1: A Simple (But Not So Efficient) Implementation of Attention</h3><p>第一步首先要实现没有优化的串行注意力层。框架中给出了如何访问4Dtensor的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Here is an example of how to read/write 0&#x27;s to  Q (B, H, N, d) using the 4D accessors</span></span><br><span class="line"><span class="comment">//loop over Batch Size</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; B; b++) &#123;</span><br><span class="line">    <span class="comment">//loop over Heads</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> h = <span class="number">0</span>; h &lt; H; h++) &#123;</span><br><span class="line">        <span class="comment">//loop over Sequence Length</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">//loop over Embedding Dimensionality</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; d; j++) &#123;</span><br><span class="line">                <span class="type">float</span> val = <span class="built_in">fourDimRead</span>(Q, b, h, i, j, H, N, d);</span><br><span class="line">                val = <span class="number">0.0</span>;</span><br><span class="line">                <span class="built_in">fourDimWrite</span>(Q, b, h, i, j, H, N, d, val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意，正如2D数组访问需要使用的是num_cols，即第二维的SIZE一样，传入4Dtensor访问(b，h，n，d)的SIZE X Y Z应该是H N d，而不需要知道Batch SIZE。</p><p>对于需要实现的注意力层，步骤如下：</p><p><strong>STEP1</strong></p><p>For each Batch: For each Head: 遍历 Q 和 K，并将Q与K^t相乘，将结果存储在 QK^t 中。QK^t已经预先分配，并作为参数传递给 myNaiveAttention。经过Batch和Head索引后得到的是(N, d)的Q和K的2D矩阵。还要注意K的维度为(N, d)，而想要的K^t的维度为(d, N)。可以不进行转置，直接调整矩阵相乘时的行列顺序就可以了。</p><p><strong>STEP2</strong></p><p>在获得QK^t(N, N)之后，遍历每一行。对于每一行，获取每个行元素的指数。然后，将每个结果指数除以其行中所有指数的总和，然后将其存储回 QK^t。</p><p><strong>STEP3</strong></p><p>最后，将QK^t与V进行矩阵乘法，并将结果存储到O中。与Q和K一样，索引Batch和Head后，V和O将具有形状(N, d)。在将QK^t(N, N)与V(N, d)相乘后直接存入O。此外O张量会初始化为0。</p><p>下面按照上述注意力层步骤一步一步完成注意力层的计算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">torch::Tensor <span class="title">myNaiveAttention</span><span class="params">(torch::Tensor QTensor, torch::Tensor KTensor, torch::Tensor VTensor, torch::Tensor QK_tTensor,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> B, <span class="type">int</span> H, <span class="type">int</span> N, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Q, K, V are passed in with Shape: (B, H, N, d)</span></span><br><span class="line">    <span class="comment">//QK^t Intermediate Tensor has Shape (N, N)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Make O Tensor with Shape (B, H, N, d) </span></span><br><span class="line">    at::Tensor OTensor = at::<span class="built_in">zeros</span>(&#123;B, H, N, d&#125;, at::kFloat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Format O, Q, K, and V tensors into 4D vectors</span></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; O = formatTensor(OTensor);</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; Q = formatTensor(QTensor);</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; K = formatTensor(KTensor);</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; V = formatTensor(VTensor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Format QK_t Tensor into a 2D vector.</span></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; QK_t = formatTensor(QK_tTensor);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -------- YOUR CODE HERE  -------- //</span></span><br><span class="line">    <span class="comment">//caculate QK_t = Q(N,d) * K^t(d, N)</span></span><br><span class="line">    <span class="comment">//loop over Batch Size</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> b = <span class="number">0</span>; b &lt; B; b++)&#123;</span><br><span class="line">    <span class="comment">//loop over Heads</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> h = <span class="number">0</span>; h &lt; H; h++)&#123;</span><br><span class="line">    <span class="comment">//loop over Sequence Length ijk calculate S(i,j) = Q(i,k)*Q(j,k)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)&#123;</span><br><span class="line">                    <span class="type">float</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; d; k++)&#123;</span><br><span class="line">val += <span class="built_in">fourDimRead</span>(Q, b, h, i, k, H, N, d) * <span class="built_in">fourDimRead</span>(K, b, h, j, k, H, N, d);</span><br><span class="line">&#125;</span><br><span class="line">                    <span class="built_in">twoDimWrite</span>(QK_t, i, j, N, val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//softmax</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N ; i++)&#123;</span><br><span class="line">                <span class="type">float</span> sum = <span class="number">0.0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)&#123;</span><br><span class="line">                    sum += <span class="built_in">exp</span>(<span class="built_in">twoDimRead</span>(QK_t, i, j, N));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)&#123;</span><br><span class="line">                <span class="type">float</span> val =  <span class="built_in">exp</span>(<span class="built_in">twoDimRead</span>(QK_t, i, j, N))/sum;</span><br><span class="line">                <span class="built_in">twoDimWrite</span>(QK_t, i, j, N, val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">//loop over Sequence Length ikj calculate O(i,j) = QK_t(i,k)*V(k,j)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; N; k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; d; j++)&#123;</span><br><span class="line">                        <span class="type">float</span> val = <span class="built_in">fourDimRead</span>(O, b, h, i, j, H, N, d);</span><br><span class="line">val += <span class="built_in">twoDimRead</span>(QK_t, i, k, N) * <span class="built_in">fourDimRead</span>(V, b, h, k, j, H, N, d);</span><br><span class="line">                        <span class="built_in">fourDimWrite</span>(O, b, h, i, j, H, N, d, val);</span><br><span class="line">                    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// DO NOT EDIT THIS RETURN STATEMENT //</span></span><br><span class="line">    <span class="comment">// It formats your C++ Vector O back into a Tensor of Shape (B, H, N, d) and returns it //</span></span><br><span class="line">    <span class="keyword">return</span> torch::<span class="built_in">from_blob</span>(O.<span class="built_in">data</span>(), &#123;B, H, N, d&#125;, torch::<span class="built_in">TensorOptions</span>().<span class="built_in">dtype</span>(torch::kFloat32)).<span class="built_in">clone</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后通过python3 gpt149.py part1 -N 1000进行测试，因为循环的顺序选择了更符合局部性的，所以比reference的性能更好，CPU时间小于reference的50%。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">REFERENCE - NAIVE ATTENTION statistics</span><br><span class="line">cpu time:  171.365ms</span><br><span class="line">mem usage:  4512000 bytes</span><br><span class="line"></span><br><span class="line">STUDENT - NAIVE ATTENTION statistics</span><br><span class="line">cpu time:  83.875ms</span><br><span class="line">mem usage:  4512000 bytes</span><br></pre></td></tr></table></figure><h3 id="Part-2-Blocked-Matrix-Multiply-and-Unfused-Softmax"><a href="#Part-2-Blocked-Matrix-Multiply-and-Unfused-Softmax" class="headerlink" title="Part 2: Blocked Matrix Multiply and Unfused Softmax"></a>Part 2: Blocked Matrix Multiply and Unfused Softmax</h3><p>part2要改进上面的实现，采用分块矩阵乘法。这里<code>getconf LEVEL1_DCACHE_LINESIZE</code>看了一下缓存行是64字节，能存16个浮点，所以分块的行可以取16个元素，每次取64行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">torch::Tensor <span class="title">myUnfusedAttentionBlocked</span><span class="params">(torch::Tensor QTensor, torch::Tensor KTensor, torch::Tensor VTensor, torch::Tensor QK_tTensor,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> B, <span class="type">int</span> H, <span class="type">int</span> N, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Q, K, V are passed in with Shape: (B, H, N, d)</span></span><br><span class="line">    <span class="comment">//QK^t Intermediate Tensor has Shape (N, N)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Make O Tensor with Shape (B, H, N, d) </span></span><br><span class="line">    at::Tensor OTensor = at::<span class="built_in">zeros</span>(&#123;B, H, N, d&#125;, at::kFloat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Format O, Q, K, and V tensors into 4D vectors</span></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; O = formatTensor(OTensor);</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; Q = formatTensor(QTensor);</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; K = formatTensor(KTensor);</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; V = formatTensor(VTensor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Format QK_t Tensor into a 2D vector.</span></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; QK_t = formatTensor(QK_tTensor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------- YOUR CODE HERE  -------- //</span></span><br><span class="line">    <span class="comment">//caculate QK_t = Q(N,d) * K^t(d, N)</span></span><br><span class="line">    <span class="comment">//loop over Batch Size</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> b = <span class="number">0</span>; b &lt; B; b++)&#123;</span><br><span class="line">    <span class="comment">//loop over Heads</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> h = <span class="number">0</span>; h &lt; H; h++)&#123;</span><br><span class="line">    <span class="comment">//loop over Sequence Length ijk calculate S(i,j) = Q(i,k)*Q(j,k)</span></span><br><span class="line">            std::<span class="built_in">fill</span>(QK_t.<span class="built_in">begin</span>(), QK_t.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> bsize_H, bsize_W;</span><br><span class="line">            bsize_W = <span class="number">16</span>, bsize_H = <span class="number">64</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> is = <span class="number">0</span>; is &lt; N; is += bsize_H)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> js = <span class="number">0</span>; js &lt; N; js += bsize_W)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ks = <span class="number">0</span>; ks &lt; d; ks += bsize_W)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> i = is; i &lt; std::<span class="built_in">min</span>(is+bsize_H, N); i++)&#123;</span><br><span class="line">                            <span class="keyword">for</span>(<span class="type">int</span> j = js; j &lt; std::<span class="built_in">min</span>(js+bsize_W, N); j++)&#123;</span><br><span class="line">                                <span class="type">float</span> val = <span class="built_in">twoDimRead</span>(QK_t, i, j, N);</span><br><span class="line">                                <span class="keyword">for</span>(<span class="type">int</span> k = ks; k &lt; std::<span class="built_in">min</span>(ks+bsize_W, d); k++)&#123;</span><br><span class="line">                                    val += <span class="built_in">fourDimRead</span>(Q, b, h, i, k, H, N, d) * <span class="built_in">fourDimRead</span>(K, b, h, j, k, H, N, d);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="built_in">twoDimWrite</span>(QK_t, i, j, N, val);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//softmax</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N ; i++)&#123;</span><br><span class="line">                <span class="type">float</span> sum = <span class="number">0.0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)&#123;</span><br><span class="line">                    sum += <span class="built_in">exp</span>(<span class="built_in">twoDimRead</span>(QK_t, i, j, N));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)&#123;</span><br><span class="line">                <span class="type">float</span> val =  <span class="built_in">exp</span>(<span class="built_in">twoDimRead</span>(QK_t, i, j, N))/sum;</span><br><span class="line">                <span class="built_in">twoDimWrite</span>(QK_t, i, j, N, val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//loop over Sequence Length ikj calculate O(i,j) = QK_t(i,k)*V(k,j)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> is = <span class="number">0</span>; is &lt; N; is += bsize_H)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> js = <span class="number">0</span>; js &lt; d; js += bsize_W)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> ks = <span class="number">0</span>; ks &lt; N; ks += bsize_W)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> i = is; i &lt; std::<span class="built_in">min</span>(is+bsize_H, N); i++)&#123;</span><br><span class="line">                            <span class="keyword">for</span>(<span class="type">int</span> k = ks; k &lt; std::<span class="built_in">min</span>(ks+bsize_W ,N); k++)&#123;</span><br><span class="line">                                <span class="keyword">for</span>(<span class="type">int</span> j = js; j &lt; std::<span class="built_in">min</span>(js+bsize_W, d); j++)&#123;</span><br><span class="line">                                    <span class="type">float</span> val = <span class="built_in">fourDimRead</span>(O, b, h, i, j, H, N, d);</span><br><span class="line">                                    val += <span class="built_in">twoDimRead</span>(QK_t, i, k, N) * <span class="built_in">fourDimRead</span>(V, b, h, k, j, H, N, d);</span><br><span class="line">                                    <span class="built_in">fourDimWrite</span>(O, b, h, i, j, H, N, d, val);</span><br><span class="line">                                &#125;</span><br><span class="line">                                </span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// DO NOT EDIT THIS RETURN STATEMENT //</span></span><br><span class="line">    <span class="comment">// It formats your C++ Vector O back into a Tensor of Shape (B, H, N, d) and returns it //</span></span><br><span class="line">    <span class="keyword">return</span> torch::<span class="built_in">from_blob</span>(O.<span class="built_in">data</span>(), &#123;B, H, N, d&#125;, torch::<span class="built_in">TensorOptions</span>().<span class="built_in">dtype</span>(torch::kFloat32)).<span class="built_in">clone</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仍然取N = 1000，测试结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">REFERENCE - BLOCKED MATMUL + UNFUSED SOFTMAX statistics</span><br><span class="line">cpu time:  <span class="number">148.424</span>ms</span><br><span class="line">mem usage:  <span class="number">4512000</span> bytes</span><br><span class="line">    </span><br><span class="line">STUDENT - BLOCKED MATMUL + UNFUSED SOFTMAX statistics</span><br><span class="line">cpu time:  <span class="number">99.278</span>ms</span><br><span class="line">mem usage:  <span class="number">4512000</span> bytes</span><br></pre></td></tr></table></figure><p>比起之前，原reference版本有性能提升，但是自己的版本没有，猜测和计算方式有关。不过无论如何都比reference更快，就不做修改了。</p><h3 id="Part-3-Fused-Attention"><a href="#Part-3-Fused-Attention" class="headerlink" title="Part 3: Fused Attention"></a>Part 3: Fused Attention</h3><p>在计算过程中要先计算一个矩阵乘法，再进行softmax，最后再进行一个矩阵乘法，这对缓存性能表现很不利。</p><p>解决这个问题的办法是融合计算，这样就只需要一个Nx1的临时向量，而不是NxN的矩阵。在计算Q*K^T的一行后，可以直接进行softmax，然后乘上V，只需要重复这个过程完成计算。在以上基础上还可以进行并行，使用OpenMP进行多线程计算。</p><p>融合优化后的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">torch::Tensor <span class="title">myFusedAttention</span><span class="params">(torch::Tensor QTensor, torch::Tensor KTensor, torch::Tensor VTensor, torch::Tensor temp,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> B, <span class="type">int</span> H, <span class="type">int</span> N, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Q, K, V are passed in with Shape: (B, H, N, d)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Make O Tensor with Shape (B, H, N, d)</span></span><br><span class="line">    <span class="comment">//and O Row Tensor with Shape (N)</span></span><br><span class="line">    at::Tensor OTensor = at::<span class="built_in">zeros</span>(&#123;B, H, N, d&#125;, at::kFloat);</span><br><span class="line">    at::Tensor ORowTensor = at::<span class="built_in">zeros</span>(&#123;N&#125;, at::kFloat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Format Y, Q, K, and V tensors into 4D vectors</span></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; O = formatTensor(OTensor);</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; Q = formatTensor(QTensor);</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; K = formatTensor(KTensor);</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; V = formatTensor(VTensor);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Format ORow Tensor into a 1D vector</span></span><br><span class="line">    <span class="comment">// You can simply access this as ORow[i]</span></span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; ORow = formatTensor(ORowTensor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------- YOUR CODE HERE  -------- //</span></span><br><span class="line">    <span class="comment">// We give you a template of the first three loops for your convenience</span></span><br><span class="line">    <span class="comment">//loop over batch</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for collapse(3)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; B; b++)&#123;</span><br><span class="line">        <span class="comment">//loop over heads</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> h = <span class="number">0</span>; h &lt; H; h++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N ; i++)&#123;</span><br><span class="line">        <span class="comment">// YRow is moved inside so each OpenMP thread gets a local copy.</span></span><br><span class="line">                at::Tensor ORowTensor = temp.<span class="built_in">index</span>(&#123;torch::indexing::<span class="built_in">Slice</span>(<span class="built_in">omp_get_thread_num</span>(), torch::indexing::None)&#125;);      </span><br><span class="line">                std::vector&lt;<span class="type">float</span>&gt; ORow = formatTensor(ORowTensor);</span><br><span class="line">                std::<span class="built_in">fill</span>(ORow.<span class="built_in">begin</span>(), ORow.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">                <span class="type">float</span> sum = <span class="number">0.0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)&#123;</span><br><span class="line">                    <span class="type">float</span> val = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; d; k++)&#123;</span><br><span class="line">                        val += <span class="built_in">fourDimRead</span>(Q, b, h, i, k, H, N, d) * <span class="built_in">fourDimRead</span>(K, b, h, j, k, H, N, d);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">float</span> tmp = <span class="built_in">exp</span>(val);</span><br><span class="line">                    ORow[j] = tmp;</span><br><span class="line">                    sum += tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//softmax</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) ORow[j] =  ORow[j]/sum;</span><br><span class="line">                <span class="comment">//calculate O</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; N; k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; d; j++)&#123;</span><br><span class="line">                        <span class="type">float</span> val = <span class="built_in">fourDimRead</span>(O, b, h, i, j, H, N, d);</span><br><span class="line">val += ORow[k] * <span class="built_in">fourDimRead</span>(V, b, h, k, j, H, N, d);</span><br><span class="line">                        <span class="built_in">fourDimWrite</span>(O, b, h, i, j, H, N, d, val);</span><br><span class="line">                    &#125;</span><br><span class="line">&#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// DO NOT EDIT THIS RETURN STATEMENT //</span></span><br><span class="line">    <span class="comment">// It formats your C++ Vector O back into a Tensor of Shape (B, H, N, d) and returns it //</span></span><br><span class="line">    <span class="keyword">return</span> torch::<span class="built_in">from_blob</span>(O.<span class="built_in">data</span>(), &#123;B, H, N, d&#125;, torch::<span class="built_in">TensorOptions</span>().<span class="built_in">dtype</span>(torch::kFloat32)).<span class="built_in">clone</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">REFERENCE - FUSED ATTENTION statistics</span><br><span class="line">cpu time:  36.62ms</span><br><span class="line">mem usage:  544000 bytes</span><br><span class="line"></span><br><span class="line">STUDENT - FUSED ATTENTION statistics</span><br><span class="line">cpu time:  20.223ms</span><br><span class="line">mem usage:  544000 bytess</span><br></pre></td></tr></table></figure><h3 id="Part-4-Putting-it-all-Together-Flash-Attention"><a href="#Part-4-Putting-it-all-Together-Flash-Attention" class="headerlink" title="Part 4 : Putting it all Together - Flash Attention"></a>Part 4 : Putting it all Together - Flash Attention</h3><p>由于几个原因，注意力公式的融合非常困难。请注意，该公式包括一个矩阵乘法，然后是softmax的逐行计算，最后是另一个矩阵乘法。将这三个运算融合成块之所以困难，是因为softmax必须对整行进行运算。因此，如果想绕过这种依赖关系，就必须跳出框架。这就是Flash Attention的作用所在。</p><p>最后这一part主要是按照给出的伪代码完成Flash Attention。因为时间有限且这个part意义不大，就不做了。</p>]]></content>
      
      
      <categories>
          
          <category> HPCLAB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>An OpenMP Runtime for Transparent Work Sharing across Cache-Incoherent Heterogeneous Nodes</title>
      <link href="/2023/12/06/An%20OpenMP%20Runtime%20for%20Transparent%20Work%20Sharing%20across/"/>
      <url>/2023/12/06/An%20OpenMP%20Runtime%20for%20Transparent%20Work%20Sharing%20across/</url>
      
        <content type="html"><![CDATA[<h1 id="An-OpenMP-Runtime-for-Transparent-Work-Sharing-across-Cache-Incoherent-Heterogeneous-Nodes"><a href="#An-OpenMP-Runtime-for-Transparent-Work-Sharing-across-Cache-Incoherent-Heterogeneous-Nodes" class="headerlink" title="An OpenMP Runtime for Transparent Work Sharing across Cache-Incoherent Heterogeneous Nodes"></a>An OpenMP Runtime for Transparent Work Sharing across Cache-Incoherent Heterogeneous Nodes</h1><p>Key Words: Heterogeneous systems,Heterogeneous-ISA CPUs,OpenMP, work sharing</p><h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1.INTRODUCTION"></a>1.INTRODUCTION</h2><p>本文考虑的系统是一种异构系统，每个CPU有自己的物理存储和ISA，这些CPU之间没有缓存一致性，因此软件上的内存一致性以及数据的移动是必须要考虑的问题，并且数据必须使用通用的格式或动态转换。传统的编程模型如MPI不能很好的处理复杂的数据处理和动态转换，且需要手动管理存储一致性和工作分配，因此不适合异构服务器。</p><p>近期出现了一些使用分布式共享存储(DSM)的异构系统(Popcorn Linux)，提供透明的跨节点的数据处理，这样异构系统的并行计算就可以在此基础上完成。</p><p>对于紧密耦合的异构系统，挑战在于如何分配并行工作，以平衡CPU性能及DSM通信开销。</p><p><img src="/2023/12/06/An%20OpenMP%20Runtime%20for%20Transparent%20Work%20Sharing%20across/image-20231121223830858.png" alt="image-20231121223830858" style="zoom:50%;"></p><p>作者实现的libHetMP是基于OpenMP的，但可以自动完成合适的工作分配，而开发者可以按照OpenMP的方式去编写并行程序。</p><p>libHetMP 包含了一个新的 HetProbe 循环迭代调度器，针对的是每次循环计算量相同的循环迭代计算。分析了一小部分初始循环迭代的行为，并确定剩余的迭代是否应该在多个节点上执行。如果跨节点执行有利，那么 HetProbe 调度器根据每个 CPU 的相对性能分配工作给线程。如果跨节点的工作共享导致了太多的通信，那么 HetProbe 调度器就在一组最适合给定计算的缓存一致的同构 CPU 上执行所有的工作。分配工作的复杂过程由 libHetMP 透明地自动化。</p><p>如果循环中计算是不规则的，预测执行行为就会更加困难，为了处理不规则的工作负载，libHetMP 包含了一个 HetProbe 调度器的扩展，称为 HetProbe-I。HetProbe-I 通过将一个工作共享区域逻辑地分成多个较小的工作共享区域来处理不规则的计算内核，每个区域都有自己的探测和工作负载分配决策。</p><p>作者使用OpenMP 基准测试套件的一些benchmark来评估libHetMP，在不对称CPU 上得到几何平均 41% 的加速比。而HetProbe-I 的评估表明，它可以通过触发周期性的分配决策进一步提高不规则计算的加速，某些情况下高达 24%。</p><h2 id="2-BACKGROUND"><a href="#2-BACKGROUND" class="headerlink" title="2.BACKGROUND"></a>2.BACKGROUND</h2><p><strong>OpenMP</strong></p><p>OpenMP是常用于并行计算的编程模型，针对的是共享内存系统。只需要在程序中添加指导语句，编译器会创建线程，分配并行任务并提供同步能力。最常用的就是通过<code>pragma omp for</code>将循环迭代分配给线程完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">vecsum</span> <span class="params">( <span class="type">const</span> <span class="type">int</span> ∗ vec , <span class="type">size_t</span> num)</span> </span>&#123;</span><br><span class="line"><span class="type">size_t</span> i ;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for reduction(+:sum)</span></span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; num ; i ++) sum += ve c [ i ] ;</span><br><span class="line"><span class="keyword">return</span> sum ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OpenMP不适用于异构ISA的CPU，因此系统软件(编译器和OS)需要提供共享内存的抽象，并且并行工作的分配也需要重新设计。</p><p>以下是现有的工作怎样实现跨异构ISACPU执行程序的方式，假定节点是单ISA的具有缓存一致性的处理器。</p><p><strong>Heterogeneous-ISA Execution</strong></p><p>想要将不对称的处理器结合在一起必须集成不同ISA的CPU，系统软件必须处理ISA的异构性和内存一致性。以往有一些工作实现了在运行时将编译好的共享内存应用程序在异构ISA的CPU之间迁移的系统软件，但作者使用的是Popcorn Linux作为系统软件，因为Popcorn Linux是可用的。其他的一些工作关注GPU/CPU的交互，但作者的工作关注的是通用计算应用。</p><blockquote id="fn_Popcorn Linux"><sup>Popcorn Linux</sup>. Popcorn Linux<sup><a href="#fn_1" id="reffn_1">1</a></sup>是一个基于Linux内核的软件栈，它可以让应用程序在分布式的主机上执行，而且可以在运行时在不同的主机之间迁移。Popcorn Linux可以支持不同ISA的主机，例如x86和ARM。可以作为模块加载到不同的Linux发行版上。<a href="#reffn_Popcorn Linux" title="Jump back to footnote [Popcorn Linux] in the text."> &#8617;</a></blockquote><p><img src="/2023/12/06/An%20OpenMP%20Runtime%20for%20Transparent%20Work%20Sharing%20across/image-20231124183039451.png" alt="image-20231124183039451" style="zoom:50%;"></p><p><strong>Multi-ISA Binaries</strong></p><p>Popcorn Linux的编译器会构建能够跨ISA执行的多ISA二进制文件。多ISA二进制文件由一个对齐的数据段和多个每个ISA的代码段组成。编译器安排程序的全局地址空间在不同ISA之间对齐，使全局数据和函数都有相同的地址。编译器也会生成描述函数栈的数据，在等价点重建栈帧。</p><blockquote id="fn_等价点"><sup>等价点</sup>. 是指在应用程序执行过程中，可以在不同ISA的CPU之间切换的点。等价点通常是函数的入口或者出口，因为这时候栈帧是完整的，而且没有任何寄存器的依赖。<a href="#reffn_等价点" title="Jump back to footnote [等价点] in the text."> &#8617;</a></blockquote><p><strong>Thread Migration</strong></p><p>线程在迁移点时在节点之间迁移，迁移点是等价点的子集。libHetMP在OpenMP运行时内部添加了迁移点，以自动地在节点之间分配线程。为了在节点之间迁移，线程需要进入一个状态转换的过程，这个过程会检查线程的栈，并把它转换成目标节点的指令集架构（ISA）的格式。转换完成后，线程会把一个转换后的寄存器集合传递给一个系统调用，然后在目标节点的CPU上继续执行。</p><p><strong>Page-level Distributed Shared Memory</strong></p><p>一旦线程迁移到新的节点，它们就必须能够访问应用程序数据。操作系统级的DSM，如Kerrighed<sup><a href="#fn_2" id="reffn_2">2</a></sup>和Popcorn Linux，通过在页故障处理中观察远程内存访问，并根据类似于缓存一致性协议的方式迁移数据页。通过仔细地操作页权限，操作系统强制应用程序在访问远程数据时发生故障。当发生故障时，源节点（即发生故障的节点）的内核从当前拥有该页的远程节点请求该页。该页从远程节点传输到源节点，并映射到应用程序的地址空间。内存访问重新开始，应用程序线程不知道数据是远程获取的，数据在节点之间透明地和按需地进行调度。</p><blockquote id="fn_Kerrighed"><sup>Kerrighed</sup>. 单系统映像集群软件项目，实现针对高性能计算的操作系统，扩展了Linux的模块。Kerrighed支持多线程和基于消息传递的应用程序，并提供分布式共享内存，进程迁移和检查点等功能。<a href="#reffn_Kerrighed" title="Jump back to footnote [Kerrighed] in the text."> &#8617;</a></blockquote><p><strong>Cross-node Execution Challenges</strong></p><p>比起传统的共享内存多处理器系统，DSM共享数据的粒度更大，以页面粒度共享数据，并且数据管理的成本远高于传统的内存访问，页面迁移需要几十微秒。由于这两个特点，不同节点上的线程访问的数据应该以页面进行划分，并且需要有足够的计算来摊销DSM成本。</p><p><strong>Irregular workloads</strong></p><p>不是所有循环在迭代中都有相同的行为，在内存访问模式，功能单元的压力等方面可能都有不同。这些被称为不规则的工作负载。对于这样的工作负载，静态分配可能是有问题的。</p><p>OpenMP是可以进行动态负载分配的，但是DSM系统的通信开销和内存一致性协议，以及异构ISA的二进制不兼容性会导致动态工作分配的正确性。</p><h2 id="3-DESIGN"><a href="#3-DESIGN" class="headerlink" title="3.DESIGN"></a>3.DESIGN</h2><p>libHetMP基于Popcorn Linux，自动确定在异构系统中将并行计算放在哪里，以最大化性能。libHetMP在OpenMP的基础上加入了两个组件：</p><ul><li>在异构ISA CPU之间执行并行化计算需要的机制，包括线程迁移到不同的节点，以及并行工作分配给线程的机制。</li><li>新的循环迭代调度器，分析 CPU 之间的互连上的 DSM 活动和性能计数器，自动化工作分配决策。</li></ul><h3 id="3-1-扩展OpenMP"><a href="#3-1-扩展OpenMP" class="headerlink" title="3.1 扩展OpenMP"></a><strong>3.1 扩展OpenMP</strong></h3><p>libHetMP在启动程序时会查询系统，确定节点的特征(可用CPU的类型和数量)，在启动线程时插入迁移点，在线程迁移分配后，将运行时的工作(性能监控，同步，工作分配)分为节点和全局操作。libHetMP会把线程组织成层次结构以减少DSM流量，并使用层次结构进行工作分配，规约，同步，以及初始化每个节点的数据结构，如循环迭代调度器元数据，barrier。每个节点选择一个线程领导者，由该领导者处理节点的同步和规约等操作。</p><p><img src="/2023/12/06/An%20OpenMP%20Runtime%20for%20Transparent%20Work%20Sharing%20across/image-20231124190908223.png" alt="image-20231124190908223" style="zoom:50%;"></p><p>libHetMP在OpenMP已有的循环迭代调度器的基础上进行扩展，并引入了HetProb调度器。假设每个节点包含一组具有相同微架构和缓存一致性的CPU核。为了量化性能差异，libHetMP定义了一个核速度比(CSR)，例如与ThnderX核相比，Xeon核有3:1的核速度比，则Xeon被认为是ThunderX计算速度三倍，将获得ThunderX线程的3倍的循环迭代。CSR是针对每个工作共享区域的。</p><p>对于OpenMP的各个调度器，libHetMP进行了扩展。静态调度器扩展后允许开发者指定每个节点的CSR，但是手动配置理想的CSR难度很大。动态调度器原本是由线程不断地从工作池中抓取用户定义的批量迭代，并使用原子操作。扩展后基于层次结构，线程首先从节点本地工作抓取迭代，如果本地池为空，该线程作为领导者将批量迭代从全局池转移到节点池。但是不停地抓取工作批量会对性能产生负面影响，并且循环迭代到线程的非确定性映射可能导致DSM中的抖动。</p><blockquote id="fn_DSM中的抖动"><sup>DSM中的抖动</sup>. 对于多次执行相同工作共享区域的程序，如果映射是确定的，数据可能在第一次调用后稳定，因为节点获取了适当的页面，反之则会产生抖动。<a href="#reffn_DSM中的抖动" title="Jump back to footnote [DSM中的抖动] in the text."> &#8617;</a></blockquote><p>综上，扩展OpenMP的调度器的问题是需要找到最佳的工作负载分配配置，包括每个新的异构平台的CSR或批量大小，还要考虑到DSM开销。</p><h3 id="3-2-HetProbe调度器"><a href="#3-2-HetProbe调度器" class="headerlink" title="3.2 HetProbe调度器"></a><strong>3.2 HetProbe调度器</strong></h3><h4 id="3-2-1-HetProbe和HetProbe-I"><a href="#3-2-1-HetProbe和HetProbe-I" class="headerlink" title="3.2.1 HetProbe和HetProbe-I"></a>3.2.1 <strong>HetProbe和HetProbe-I</strong></h4><p>HetProbe调度器可以像其他调度方式一样通过schedule子句指定。该调度器会先在所有节点执行一小部分迭代，这个期间为探测期，衡量各个节点的单核执行时间，跨节点的页错误处理。由于Hetprobe是针对有相同行为的迭代的，因此用循环迭代本身就可以探测。</p><p>此外libHetMP还实现了一个probe cache，这样对于执行同一个工作共享区域多次的程序，可以避免多次探测，而且会使探测结果更加平滑，采用指数加权平均来处理测量数据，这样不准确的测量值会被快速修正。因为一开始执行时DSM可能需要跨节点复制数据，而此后的可能少一些，所以采用这种方式更准确。</p><p>HetProbe的扩展HetProbe-I用于处理不规则的工作负载，HetProbe-I会触发一个新的探测期来适应不规则的工作负载，使用新探测期的性能指标来计算新的CSR，并重新分配工作。</p><p>下图说明了HetProbe-I的一个调度过程，有100个迭代，而初始探测已经完成。在第一次分配后，经过一定数量的迭代后，进入新的探测期，探测结束后，剩余的迭代被合并，生成新的工作队列(称为<strong>Jump</strong>)。调度器会确保执行过的迭代不会再次被执行。</p><p><img src="/2023/12/06/An%20OpenMP%20Runtime%20for%20Transparent%20Work%20Sharing%20across/image-20231127172237384.png" alt="image-20231127172237384" style="zoom:50%;"></p><p>在这个过程中，有两个问题要解决：</p><ul><li>在什么情况触发重新探测。频繁的重新探测能带来更细粒度的工作分配，但会影响性能。</li><li>重新探测时，必须重新确认未完成的迭代并放入全局工作。</li></ul><p>对于第一个问题，HetProbe-I将在初次探测后只分配一部分迭代，当线程下一次获取迭代时，HetProbe-I检查是否重新进行探测。目前HetProbe-I会在用户定义的百分比迭代后触发重新探测，默认比例为10%(所有线程的完成的迭代达到分配出去的所有迭代的10%，每个线程完成部分迭代后，会重新获取迭代，更新已完成的迭代数)。在执行过程中，将按这个比例反复进行重新探测。例如有100000个迭代，初次探测已经完成，按照测量的CSR进行分配，每次只分给节点一部分，节点完成后再获取一部分，此时更新全局已完成的迭代数，达到1000个时触发重新探测。10%这个值作者没有给出选定原因。</p><p>对于第二个问题，HetProbe-I会通过barrier等待所有节点完成此前的迭代计算，然后将所有节点的工作重新整理得到待完成的工作，再进行分配。</p><h4 id="3-2-2-负载分配机制"><a href="#3-2-2-负载分配机制" class="headerlink" title="3.2.2 负载分配机制"></a>3.2.2 <strong>负载分配机制</strong></h4><p>HetProbe调度器使用测量的执行时间，页错误和性能计数器来确定调度决策。解决的问题主要有三个。</p><p><strong>1.运行时是否应该利用多个节点进行并行执行？</strong></p><p>由于数据处理和跨节点的存储一致性的代价，不是所有情况下程序都能从跨节点执行中受益。作者使用了一个测试观察DSM的开销，实验设置如下图：</p><p><img src="/2023/12/06/An%20OpenMP%20Runtime%20for%20Transparent%20Work%20Sharing%20across/image-20231127185538393.png" alt="image-20231127185538393" style="zoom:50%;"></p><p>而系统使用的协议采用两种，TCP/IP和RDMA。测试为每个节点的每个核心建立一个线程，然后运行一个循环，主线程运行在源节点Xeon上，源节点访问所有的页面，这样就强制DSM将所有页面带回源节点的内存，模拟了应用程序的初始状态。接下来其他节点的线程开始计时执行，每个ThunderX线程访问不同页面，强制DSM将页面传输到ThunderX内存，模拟数据访问。计算结束后，测试程序计算循环需要的时间，计算每秒的操作数，评估DSM的开销和跨节点执行的效率。以下两图显示了测试结果，两图的横坐标均为compute operation per byte of data transferred，即完成1byte字节传输时间内的计算操作，横坐标越大，计算越多。(TCP/IP需要更多计算摊销DSM)。</p><blockquote id="fn_RDMA"><sup>RDMA</sup>. 远程内存直接访问技术。核心技术是零拷贝，内核旁路，协议卸载。零拷贝：HCA(网卡)可以直接与应用内存传输数据。内核旁路：执行RDMA请求不需要执行内核调用，可直接向网卡发送命令。协议卸载：网卡硬件中部署可靠的传输协议。<a href="#reffn_RDMA" title="Jump back to footnote [RDMA] in the text."> &#8617;</a></blockquote><p><img src="/2023/12/06/An%20OpenMP%20Runtime%20for%20Transparent%20Work%20Sharing%20across/image-20231127190817087.png" alt="image-20231127190817087" style="zoom: 50%;"></p><p>从这张图可以看出，RDMA的延迟要小于TCP/IP，即TCP/IP需要更多计算才能摊销DSM。</p><p><img src="/2023/12/06/An%20OpenMP%20Runtime%20for%20Transparent%20Work%20Sharing%20across/image-20231127191830152.png" alt="image-20231127191830152" style="zoom: 50%;"></p><p>这张图则体现了处理页错误的时间，纵坐标为一个计算周期中，触发页错误的间隔时间，RDMA处理页错误的间隔时间更短，因为RDMA的访存延迟更低。</p><p>从以上两图可以看出跨节点执行是否有益的临界点，对于RDMA，从第一张图可以看出每字节传输时操作超过512后性能变化不大，提升到足够高，因此对应第二张图作者将阈值设置为100，只要测量的页错误间隔大于100，就可以跨节点执行，TCP/IP也是类似的。如果这个时间太小，就说明跨节点执行的开销太大，页错误的时间难以摊销。以上的这个测试可以作为一个工具重复使用，以自动确定跨节点执行变得有益的阈值。</p><p><strong>2.如果利用跨节点执行，那么应该将多少工作分配给每个节点？</strong></p><p><img src="/2023/12/06/An%20OpenMP%20Runtime%20for%20Transparent%20Work%20Sharing%20across/image-20231127193301290.png" alt="image-20231127193301290" style="zoom:50%;"></p><p>如前述，使用测量的CSR来分配工作。</p><p><strong>3.如果不使用跨节点执行，该使用哪个节点执行？</strong></p><p>这个问题的解决需要依赖在探测期测量的性能，在测量期间会使用硬件性能计数器，根据结果和程序计算特点来决定。例如上述例子，Xeon有更大的核心和缓存，而ThunderX有更多的核心以及两倍于Xeon的带宽，但只有简单的两级缓存，如果程序有非常多的缓存未命中，则可能无法利用ThunderX的多核心。HetProbe调度器在探测期间测量的是缓存未命中率，据此设定阈值(每千条指令三次缓存未命中，这是一个实验值)来确定使用Xeon还是ThunderX，用户也可以指定其他性能计数器。<strong>HetProbe调度器必须使用性能计数器，不能简单地使用探测期间的执行时间来决定一个节点，探测期间测量的执行时间包含了在单个节点上执行时不存在的DSM开销。</strong></p><p>一旦选择了一个节点，调度器就回退到OpenMP调度器，进行单节点进行工作分配。并且确定单节点工作后，可以把多余的线程结束掉。</p><h4 id="3-2-3-实现"><a href="#3-2-3-实现" class="headerlink" title="3.2.3 实现"></a>3.2.3 <strong>实现</strong></h4><p>在HetProbe调度器中，线程在三个场合调用libHetMP。在第一次调用运行时，HetProbe分配了用于探测的迭代。在第二次，HetProbe存储性能指标，并计算CSR来在节点之间分配工作。在最后一次调用中，HetProbe利用动态调度器来分配之前计算出的分配中的剩余迭代。在HetProbe-I中，通过检查是否满足重新探测的条件，在必要时重新探测。因为HetProbe-I需要线程定期调用这个函数，所以它只分配了它们应该根据它们的CSR接收的迭代的一部分，每次迭代分配较小的块，其块大小与计算出的速度比成正比。例如，如果一个节点应该有0到30的迭代，那么HetProbe-I将这些注册为真实的下一个和结束，并在第一次调用运行时时分配0到5的迭代，在下一次时分配5到10，依此类推，直到任何一个线程获取迭代时，整体完成数量达到了阈值(10%)。</p><p>HetProbe-I在需要重新探测时可能面临三种潜在的情况：</p><ul><li>只有一个节点在执行工作。触发重新探测期间的线程属于唯一一个被HetProbe分配了迭代的节点——根据探测期间收集的指标，跨节点执行被认为是不有益的。如果没有分配工作，那么不执行迭代的节点的领导线程将被停止，阻塞该节点上的所有线程，停滞在一个层次化的barrier中。因此，每当在这些情况下触发重新探测时，HetProbe-I只需要恢复在非活动节点上的执行，并分配探测迭代。让停止的领导线程在一个全局变量上旋转是不昂贵的，因为该节点没有执行任何其他工作。</li><li>所有节点上都有工作在运行。因为有跨多个节点的工作在执行，触发重新探测的线程属于一个有一部分迭代的节点。这个节点的领导线程将不得不等待其他节点完成工作。</li><li>一个节点没有剩余的迭代。HetProbe-I也必须考虑到这种不太常见的情况，即即使没有触发重新探测，节点也耗尽了工作。HetProbe-I停止那些耗尽了工作的线程，等待其他节点完成工作。</li></ul><p>一旦触发重新探测，HetProbe-I都必须重新开始性能统计，并生成新的全局工作队列。为了防止重复执行已经完成的工作，HetProbe-I必须为线程提供连续的迭代范围。当HetProbe-I生成一个新的工作队列，迭代可能是不连续的，HetProbe-I需要考虑跳转来给线程标记和分配工作。 当分配给线程的工作在分配函数中包含一个跳转时，第一半被分配，线程被标记，以便在下一次调用函数时接收另一半。第二部分也可能包含跳转，所以这个过程可能会重复几次，在最坏的情况下会有非常多次。</p><h2 id="4-EVALUATION"><a href="#4-EVALUATION" class="headerlink" title="4.EVALUATION"></a>4.EVALUATION</h2><h4 id="4-1对HetProbe的评估及结果分析"><a href="#4-1对HetProbe的评估及结果分析" class="headerlink" title="4.1对HetProbe的评估及结果分析"></a>4.1对HetProbe的评估及结果分析</h4><p>对libHetMP的评估主要关注以下问题：</p><ul><li>能否有效利用非对称的异构平台的计算能力</li><li>能否准确测量运行时行为并作出合理的负载分配决策</li><li>各调度器最适合什么类型的运行时行为</li></ul><p>实验平台为一个Xeon服务器和一个ThunderX服务器组成的异构平台，通过InfiniBand进行连接，提供低延迟和高吞吐量。两台机器都运行Popcorn Linux。选择了十个基准测试，每个测试采用三次运行的平均值。</p><p>用于评估的工作负载配置有以下几种：</p><ul><li>Xeon：Xeon单节点执行</li><li>ThunderX：ThunderX单节点执行</li><li>理想CSR：收集调度器运行时的CSR，作为环境变量手动提供，使用扩展的静态调度器，在两个节点并行执行</li><li>跨节点动态执行：使用扩展的动态调度器</li><li>HetProbeMP：使用HetProbeMP调度器执行，探测期间使用10%的循环迭代</li><li>HetProbeMP(Xeon)：使用HetProbe调度器但强制在Xeon上单节点执行</li></ul><p><img src="/2023/12/06/An%20OpenMP%20Runtime%20for%20Transparent%20Work%20Sharing%20across/image-20231128213809162.png" alt="image-20231128213809162" style="zoom:67%;"></p><p>基准测试可以分为两类，blackscholes、EP-C、kmeans和lavaMD可以从跨节点执行中受益，而其他的则不受益。而在这些测试当中，动态跨节点执行都获得了最高的加速比，这是因为测试采用的块为细粒度，工作在节点之间几乎完美地平衡分配，并且由于线程层次结构，全局同步较少。在这四个基准测试当中，跨节点动态的执行平均加速比为2.68x，其次是理想CSR，加速比为2.55x，HetProbMP由于探测期间的开销，加速比为2.4x，低于前两种。理想CSR和HetProbe之间的差值就是探测的开销，这个开销平均为5.5%，表明HetProbe调度器提供了竞争力的性能和很小的开销。</p><p>对于无法从跨节点执行受益的基准测试，理想CSR和跨节点动态执行会显著降低性能，因为DSM的开销过大，计算不足以摊销DSM页错误的成本。而HetProbe调度器通过测量页错误触发间隔时间判断跨节点执行不利，成功地避免了这些基准测试的跨节点执行。下图中，如第3节提到的，阈值为100微秒，小于100微秒的不适合跨节点执行。</p><p><img src="/2023/12/06/An%20OpenMP%20Runtime%20for%20Transparent%20Work%20Sharing%20across/image-20231128222531571.png" alt="image-20231128222531571" style="zoom: 67%;"></p><p>不适合跨节点执行的测试，HetProbe根据每1000条指令的缓存缺失来确定是在Xeon还是ThunderX上执行工作共享区域，对于测试，以每千条指令3次缺失为阈值，将BT-C，cfd和lud放在ThunderX上，其他的放在Xeon上执行。对于这些测试，直接在单节点执行和HetProbe之间的差值就是探测开销，对于放在Xeon上的三个基准测试，平均开销为6.1%，开销很小。而ThunderX上的测试有特殊的行为。</p><img src="/2023/12/06/An%20OpenMP%20Runtime%20for%20Transparent%20Work%20Sharing%20across/image-20231128223448913.png" class title="image-20231128223448913"><p>cfd和CG-C在Xeon和ThunderX上的性能大致相同，但在缓存缺失上有很大的不同。并且cfd在Xeon上更快。这是因为cfd的并行部分在ThunderX上更快，但有一个长的串行I/O阶段，在Xeon上更快(1.83s，在ThunderX上是13.72s)，因此总体时间在Xeon更快。</p><p>对于BT-C、cfd和lud，由于操作系统的限制，在ThunderX上执行并行区域的性能比预期的差。Popcorn Linux的内核目前只支持在应用程序启动的节点上产生线程，即使在工作共享区域在ThunderX上执行时，也必须有一个线程保留在Xeon上。这些基准测试执行了数百到数千个工作共享区域，导致了大量的跨节点同步。因此测试了强制在Xeon上单节点执行，探测开销很小。</p><p>没有任何一种负载分配在所有情况下是最好的，这说明了HetProbe的必要性，在所有的基准测试中提供了平均41%的性能提高，高于其他所有分配方式(ThunderX提供11%)。理想情况下，如果开发者对所有的配置进行了广泛的分析，并为所有的基准测试选择了最佳的配置，那么可以获得60%的平均加速比。</p><p>从跨节点执行中受益的四个应用程序都有足够高的计算与跨节点通信的比例，而适合单节点执行的测试无法摊销数据传输的成本。例如，BT-C和SP-C在连续的工作共享区域中沿着不同的维度访问多维数组，导致DSM在节点之间移动大量的数据。以及大量的伪共享问题。作者也对其他几个基准测试的计算进行了一些分析。都存在各自的无法摊销DSM开销的原因。</p><h4 id="4-2-对-HetProbe-I的评估"><a href="#4-2-对-HetProbe-I的评估" class="headerlink" title="4.2 对 HetProbe-I的评估"></a>4.2 对 HetProbe-I的评估</h4><p>作者加入了一个新的基准测试，接收工作负载的不规则程度作为参数，合并streamcluster和BT-C的源代码(分别在Xeon和ThunderX上有最佳性能)，来评估HetProbe。新的基准测试将两个基准测试的迭代混合，60%的不规则程度表示10个迭代中有6个是streamcluster的调用。当不规则程度较小时，由于重新探测的开销，HetProbe-I的性能不如HetProbe，但当不规则程度大于50时，HetProbe-I的性能就超过了HetProbe。</p><p><img src="/2023/12/06/An%20OpenMP%20Runtime%20for%20Transparent%20Work%20Sharing%20across/image-20231129095842207.png" alt="image-20231129095842207" style="zoom: 50%;"></p><p>对各个基准测试(包括新加入的一些SPEC基准测试)的结果如下图，对于比较规则的工作(streamcluster)，重新探测的开销导致了性能的下降，但对于不规则的工作，HetProbe-I的性能更好，并且对于这些工作，HetProbe-I的性能比Cross-Node Dynamic还要好。因为重新探测的开销没有那么大，而动态调度中线程补充迭代的开销更大。整体来说，HetProbe-I在包含高度不规则性的工作共享区域中表现出色。</p><p><img src="/2023/12/06/An%20OpenMP%20Runtime%20for%20Transparent%20Work%20Sharing%20across/image-20231201183150807.png" alt="image-20231201183150807" style="zoom:67%;"></p><blockquote id="fn_SPEC"><sup>SPEC</sup>. Standard Performance Evaluation Corporation，为不同类型的计算机系统提供公平、可靠和可重复的性能测试方法，以帮助用户和开发者选择和优化合适的硬件和软件配置<a href="#reffn_SPEC" title="Jump back to footnote [SPEC] in the text."> &#8617;</a></blockquote><h4 id="4-3-局限性"><a href="#4-3-局限性" class="headerlink" title="4.3 局限性"></a>4.3 局限性</h4><p>libHetMP还有许多可以扩展的地方。HetProbe-I的一种替代方案是在工作共享区域内持续监测页面错误，如果页面错误的数量开始上升，就回退到单节点执行。反之可以在另外一个节点启动额外的线程。</p><p>此外，libHetMP目前也只关注实现最大的性能，而不是能效。第一代ThunderX CPU消耗大量的电力，跨节点执行提供最好的性能，但能耗更大。</p><p>HetProbe-I的潜在性能下降方面，重新探测的行为会带来一定的开销。并且所有评估的基准测试的缓存未命中次数都有所增加。这种增加可能是因为迭代的空间局部性可能不会被下一个工作分配的节点利用。</p><p>下图显示了与HetProbe相比，每个基准测试的缓存未命中次数的百分比增加。最大的增加来自streamcluster（缓存未命中次数增加了55%）与HetProbe相比，性能下降了35%。因此循环调度器在这种情况下会降低性能，对循环调度器的内存管理进行改进，可能会减轻HetProbe-I产生的开销。</p><p><img src="/2023/12/06/An%20OpenMP%20Runtime%20for%20Transparent%20Work%20Sharing%20across/image-20231129103806917.png" alt="image-20231129103806917" style="zoom:50%;"></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>作者实现了针对使用DSM的异构平台的一个OpenMP运行时版本，提供了跨节点执行的工作分配机制。通过新的调度器，自动进行工作负载分配，包括是否跨节点执行或单节点执行，并针对不规则的工作负载设计了一个更好的版本。</p><p>作者的创新点主要在于该设计是针对异构DSM系统的，基于OpenMP实现，使开发者可以以使用OpenMP的方式实现此类平台的并行工作自动的负载分配，并且对于不规则的工作负载也有良好的效果。并使用页面错误间隔衡量是否使用跨节点执行。</p><p>作者的局限性和可改进的内容主要有：</p><ul><li>只测试了两个节点的系统，没有对多节点的情况进行测试</li><li>只关注最大性能，还可以针对不同的效率指标来进行工作负载分配</li><li>HetProbe-I的重新探测行为会造成一定的开销，可能增加缓存未命中次数和内存访问延迟，且重新探测的阈值的确定还有待考量。如果对循环调度器的内存管理进行改进，可能可以减轻HetProbe-I产生的开销</li></ul><p>最后，本篇文章也启发了对缓存一致的互连系统的关注，以及相关技术例如CXL<sup><a href="#fn_3" id="reffn_3">3</a></sup>，OpenCAPI<sup><a href="#fn_4" id="reffn_4">4</a></sup>等，以及对异构平台的关注。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]Popcorn Linux - Replicated-kernel Linux[EB/OL]. popcornlinux.org. /2023-11-29. <a href="http://popcornlinux.org/index.php/replicated-kernel-linux#:~:text=Popcorn">http://popcornlinux.org/index.php/replicated-kernel-linux#:~:text=Popcorn</a>.</p><p>[2]Kerrighed[EB/OL]. Wikipedia. 2023-07-24/2023-11-29. <a href="https://en.wikipedia.org/wiki/Kerrighed">https://en.wikipedia.org/wiki/Kerrighed</a>.</p><p>[3]NVLink 和 NVSwitch 互联技术[EB/OL]. NVIDIA. /2023-11-29. <a href="https://www.nvidia.cn/data-center/nvlink/">https://www.nvidia.cn/data-center/nvlink/</a>.</p><p>[4]HOME[EB/OL]. Compute Express Link. <a href="https://www.computeexpresslink.org/">https://www.computeexpresslink.org/</a>.</p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU15-418notes(19-23)</title>
      <link href="/2023/11/21/CMU15-418notes(19-23)/"/>
      <url>/2023/11/21/CMU15-418notes(19-23)/</url>
      
        <content type="html"><![CDATA[<p>视频：<a href="https://www.bilibili.com/video/BV1Rh4y1F7aU/?spm_id_from=333.788&amp;vd_source=463e5b3e4b18e5453477b57388c2e427">https://www.bilibili.com/video/BV1Rh4y1F7aU/?spm_id_from=333.788&amp;vd_source=463e5b3e4b18e5453477b57388c2e427</a></p><p>课程主页：<a href="http://15418.courses.cs.cmu.edu/spring2016/lectures">http://15418.courses.cs.cmu.edu/spring2016/lectures</a></p><!--more---><h2 id="Lecture-19-Heterogeneous-Parallelism-and-Hardware-Specialization"><a href="#Lecture-19-Heterogeneous-Parallelism-and-Hardware-Specialization" class="headerlink" title="Lecture 19: Heterogeneous Parallelism and Hardware Specialization"></a>Lecture 19: Heterogeneous Parallelism and Hardware Specialization</h2><p>Amdahl定律说明了并行优化的效果与并行的部分有关，如果在一个处理器上，所有的核都用于并行的部分，串行部分的影响就可能很大。在处理器上使用不一样的核，例如一个fat core处理串行部分，一些小核处理并行部分，会有更好的效果。如下图，perf(r)是fat core的性能，他也承担了一些并行计算的部分。</p><p><img src="/2023/11/21/CMU15-418notes(19-23)/image-20231121172533888.png" alt="image-20231121172533888" style="zoom: 50%;"></p><p>所以异构实现的系统可以更好的分配任务，提高计算效率，这个思想很早就在现代处理器中应用了。例如Intel主力Skylake处理器(2015年时，6代i7)，处理器包含了GPU(核显)，多级缓存及多个核，采用异构核心设计。</p><p><img src="/2023/11/21/CMU15-418notes(19-23)/image-20231121173205509.png" alt="image-20231121173205509" style="zoom:50%;"></p><p>移动的系统也有类似的结构，而且整体不再被称为处理器，而是SoC(systemonchips)；超算可以也采用异构方式搭建。</p><p>本节剩余的部分介绍了一些系统设计的问题，主要是在设计计算机时需要考虑功耗和散热问题。GPU，DSP等专用处理器可以在特定情景提供高性能和低功耗。降低功耗的方式有两种：使用专用的处理器；减少数据移动(数据传输也是计算的重要成本，减少数据传输既能提高性能，也能降低功耗。)</p><p>最后是关于异构系统的挑战，异构系统带来了软件迁移和维护上的问题，调度问题也变得更加复杂，设计合适的算法将计算映射到合适的处理器本身也有很大的难度，还不能适应新算法等变化。</p><h2 id="Lecture-20-Domain-Specific-Programming-Systems"><a href="#Lecture-20-Domain-Specific-Programming-Systems" class="headerlink" title="Lecture 20: Domain-Specific Programming Systems"></a>Lecture 20: Domain-Specific Programming Systems</h2><p>由于有多种并行编程模型，多种硬件，软件的编写和维护变得更加困难。本节的内容就是关于使用特定领域的编程系统，实现高性能的同时提供高可扩展性(SQL是一个例子)。本节介绍的特定领域程序系统有两个，Liszt(用于科学计算)和Halide(用于图像处理)。</p><p>由于本节都是对上述两个系统的大致介绍。直接来到总结部分：</p><ul><li>现代机器有更多的并行化和异构</li><li>许多软件只使用机器的一小部分性能<ul><li>为这些机器调整程序很有挑战性</li><li>调整程序的工作在机器之间不能迁移</li></ul></li><li>使用特定领域编程环境实现更好的性能和可移植性</li></ul><h2 id="Lecture-21-Domain-Specific-Programming-on-Graphs"><a href="#Lecture-21-Domain-Specific-Programming-on-Graphs" class="headerlink" title="Lecture 21: Domain-Specific Programming on Graphs"></a>Lecture 21: Domain-Specific Programming on Graphs</h2><p>如果要设计一个新的编程系统，要考虑的问题至少有两个：</p><ul><li>需要简便表达和高效执行的最基本的操作是什么</li><li>对于这些操作，最关键的优化是怎样的</li></ul><p>本节以图计算为例，继续介绍领域专用编程模型。</p><p>PageRank是图计算的一个重要算法。PageRank的基本思想就是rank由相邻点的rank决定。</p><p><img src="/2023/11/21/CMU15-418notes(19-23)/image-20231123165802985.png" alt="image-20231123165802985" style="zoom: 50%;"></p><p>GraphLab是描述图中的迭代计算的系统，嵌入C++中，运行在共享内存机器或集群，定义了一个图系统和顶点上的计算。</p><p><img src="/2023/11/21/CMU15-418notes(19-23)/image-20231123172628822.png" alt="image-20231123172628822" style="zoom:33%;"></p><p>使用GraphLab只需要定义怎样更新顶点，调度和并行化由系统完成。顶点通过signal来更新，直到收敛。</p><p><img src="/2023/11/21/CMU15-418notes(19-23)/image-20231123173002270.png" alt="image-20231123173002270" style="zoom:67%;"></p><p>Summary：</p><p><img src="/2023/11/21/CMU15-418notes(19-23)/image-20231123173227057.png" alt="image-20231123173227057" style="zoom:50%;"></p><p>考虑图计算的实现，实际上有一个问题是图的计算总是低计算强度的，并且对于大图来说，数据可能无法放到内存中，优化很困难。有两个方式对大图计算来优化：</p><ul><li>重新组织图结构来增加局部性</li><li>压缩图</li></ul><p>为了增加局部性，一种方式是将图分为多个块，并将其数据按照顶点id进行排序，这样每个块的相邻数据都是连续的数据：</p><p><img src="/2023/11/21/CMU15-418notes(19-23)/image-20231123174255501.png" alt="image-20231123174255501" style="zoom:50%;"></p><p><img src="/2023/11/21/CMU15-418notes(19-23)/image-20231123174350929.png" alt="image-20231123174350929" style="zoom:50%;"></p><p>当需要计算时，将与本块相关的数据全部都加载到内存，就拥有了全部的需要的信息。</p><p><img src="/2023/11/21/CMU15-418notes(19-23)/image-20231123174535086.png" alt="image-20231123174535086" style="zoom:50%;"></p><p>GraphChi系统就以这样的方式实现，采用滑动窗口，每次从磁盘读入需要的数据。并在更新后广播数据。</p><p><img src="/2023/11/21/CMU15-418notes(19-23)/image-20231123174658077.png" alt="image-20231123174658077" style="zoom:50%;"></p><p>另一个优化图计算的方式是进行压缩。例子是将边进行排序，通过计算diff来减少边的出顶点需要的字节，然后进行存储：</p><p><img src="/2023/11/21/CMU15-418notes(19-23)/image-20231123175142779.png" alt="image-20231123175142779" style="zoom: 50%;"></p><h2 id="Lecture-22-Parallel-Deep-Neural-Networks"><a href="#Lecture-22-Parallel-Deep-Neural-Networks" class="headerlink" title="Lecture 22: Parallel Deep Neural Networks"></a>Lecture 22: Parallel Deep Neural Networks</h2><p>深度神经网络已经彻底改变了人工智能和机器学习领域，取得了巨大的成功。</p><p><img src="/2023/11/21/CMU15-418notes(19-23)/image-20231124163420947.png" alt="image-20231124163420947" style="zoom:50%;"></p><p>深度神经网络和神经网络的区别在于有更多的隐藏层。各个层的功能不同，有卷积层，池化层，全连接层等。</p><p><img src="/2023/11/21/CMU15-418notes(19-23)/image-20231124163821788.png" alt="image-20231124163821788" style="zoom:50%;"></p><p>卷积层的最简单实现就是嵌套循环完成运算，但是这样并不能最大利用局部性，在矩阵乘法中我们就学过使用分块来提高局部性，卷积也可以通过修改计算方式提高局部性。如果嵌套循环，每个卷积block的数据只算一次，下次计算会有新的一列，如果将每个卷积block的数据排列为一行，行与行之间存在关联性，有更好的局部性(这里没太理解比起嵌套循环的优势)，将权重矩阵转为向量，原计算就转为矩阵向量乘；如果有多个权重矩阵，就有多个向量，转为了矩阵乘法。</p><p><img src="/2023/11/21/CMU15-418notes(19-23)/image-20231124165559623.png" alt="image-20231124165559623" style="zoom:50%;"></p><p><img src="/2023/11/21/CMU15-418notes(19-23)/image-20231124170256087.png" alt="image-20231124170256087" style="zoom:50%;"></p><p>为了减少网络的访存，有很多对网络数据压缩的方式。</p><p><img src="/2023/11/21/CMU15-418notes(19-23)/image-20231124170725210.png" alt="image-20231124170725210" style="zoom:50%;"></p><p>采用以上的这些压缩可以显著减少model size。</p><p>Summary：</p><p><img src="/2023/11/21/CMU15-418notes(19-23)/image-20231124171149592.png" alt="image-20231124171149592" style="zoom:50%;"></p><p>深度神经网络训练需要大量的数据，DNN有初始的权重，将数据输入后，计算输出的损失值并求和，然后调整权重，使损失值更小来提高模型的准确性。梯度下降是一种寻找最小值的方法，通过不断更新参数来降低损失。在计算时通常分成小的批次，进行并行计算，并使用反向传播来计算参数的导数。</p><p><img src="/2023/11/21/CMU15-418notes(19-23)/image-20231124172435483.png" alt="image-20231124172435483" style="zoom:50%;"></p><p>在深度神经网络领域，仍然存在很多未解决的问题，例如网络结构的设计、数据表示的精度等。</p><p>TensorFlow和其他类似的框架为构建和训练深度神经网络提供了便利。</p><h2 id="Lecture-23-Implementing"><a href="#Lecture-23-Implementing" class="headerlink" title="Lecture 23: Implementing"></a>Lecture 23: Implementing</h2><h3 id="Implementing-Message-Passing"><a href="#Implementing-Message-Passing" class="headerlink" title="Implementing Message Passing"></a>Implementing Message Passing</h3><p>本节介绍MPI系统中的一些实现细节。</p><p>首先是消息传输的发送和接收有同步和异步两种选择。</p><p><img src="/2023/11/21/CMU15-418notes(19-23)/image-20231125214541355.png" alt="image-20231125214541355" style="zoom:50%;"></p><p><img src="/2023/11/21/CMU15-418notes(19-23)/image-20231125214610881.png" alt="image-20231125214610881" style="zoom:50%;"></p><p>上面的这种异步存在的问题是如果不断有消息传输，接收者就需要非常大的缓冲区。保守的方式是先发送一个信号，接收者准备好接收后，发送者再通过一个软件中断来进行传输数据。</p><p><img src="/2023/11/21/CMU15-418notes(19-23)/image-20231125215241019.png" alt="image-20231125215241019" style="zoom:50%;"></p><p>不过对于保守方式，消息传递的速度会降低，即使传输一个非常简短的消息，也需要三次消息才能传输。当然，可以结合以上两种方式，预先分配一个限定大小的缓冲区，然后根据消息的大小决定是使用缓冲区，还是采用保守方式发送数据。</p><p>最后是实现MPI的挑战总结：</p><p><img src="/2023/11/21/CMU15-418notes(19-23)/image-20231125215924217.png" alt="image-20231125215924217" style="zoom:50%;"></p><h3 id="Implementing-Parallel-Runtimes"><a href="#Implementing-Parallel-Runtimes" class="headerlink" title="Implementing Parallel Runtimes"></a>Implementing Parallel Runtimes</h3><p>这一部分的内容主要是关于以下两个问题：</p><ul><li>使用并行API的开销</li><li>运行时并行是如何工作的</li></ul><p>本节的内容是基于OpenMP和cilk的。这两个都是基于pthread实现的。提供了更高级、更丰富的描述并行性的方式。</p><p>这部分的内容很宽泛零散，不做记录了。</p>]]></content>
      
      
      <categories>
          
          <category> 高性能计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS149-Assignment-1&amp;2</title>
      <link href="/2023/11/19/CS149-Assignment-1&amp;2/"/>
      <url>/2023/11/19/CS149-Assignment-1&amp;2/</url>
      
        <content type="html"><![CDATA[<p>CS149-Assignment-1&amp;2。</p><p>CS149：<a href="https://gfxcourses.stanford.edu/cs149/fall23/">https://gfxcourses.stanford.edu/cs149/fall23/</a></p><h2 id="Assignment-1-Performance-Analysis-on-a-Quad-Core-CPU"><a href="#Assignment-1-Performance-Analysis-on-a-Quad-Core-CPU" class="headerlink" title="Assignment 1: Performance Analysis on a Quad-Core CPU"></a>Assignment 1: Performance Analysis on a Quad-Core CPU</h2><h3 id="program-1-Parallel-Fractal-Generation-Using-Threads"><a href="#program-1-Parallel-Fractal-Generation-Using-Threads" class="headerlink" title="program 1: Parallel Fractal Generation Using Threads"></a><strong>program 1: Parallel Fractal Generation Using Threads</strong></h3><p>需要用std::thread并行化mandelbrot程序，该程序对二维的数据进行处理得到图像数据，直接改mandelbrotThread中的代码。由于框架已经写好，直接将height分配一下，调用串行函数就可以了。</p><p>尝试使用不同数量的线程，比较加速比，本机是6核12逻辑处理器。</p><div class="table-container"><table><thead><tr><th>线程数</th><th>加速比</th></tr></thead><tbody><tr><td>2</td><td>1.99</td></tr><tr><td>3</td><td>1.65</td></tr><tr><td>4</td><td>2.46</td></tr><tr><td>5</td><td>2.50</td></tr><tr><td>6</td><td>3.26</td></tr><tr><td>7</td><td>3.44</td></tr><tr><td>8</td><td>4.06</td></tr></tbody></table></div><p><img src="/2023/11/19/CS149-Assignment-1&2/image-20231120084028462.png" alt="image-20231120084028462" style="zoom: 50%;"></p><p>显然加速比不是线性的，而且在奇数个线程时，线程增加没有明显的变化。在3个线程时，还比只有两个线程更慢。原因是负载不均衡的问题。为了验证，记录线程的计算时间，结果为：</p><p><img src="/2023/11/19/CS149-Assignment-1&2/image-20231120090146813.png" alt="image-20231120090146813" style="zoom:80%;"></p><p>线程1即第二个线程的计算时间更长，看来图像中间行的计算量比上下要大很多。从图像也看的出来：</p><p><img src="/2023/11/19/CS149-Assignment-1&2/image-20231120090250446.png" alt="image-20231120090250446" style="zoom: 25%;"></p><p>同理对view2进行测量，8线程的加速比是4.09x，但是图像上方的计算量更大，线程0和1的工作负载更大。</p><p>为了实现题目要求的7-8x的加速比，需要通过静态分配来实现负载的均衡。因此尝试每个线程不计算连续的行，而是交替进行分配来进行均衡。进行尝试以后view1的6线程加速比达到了5.70x，但是7和8线程反而加速比下降了。不知道在虚拟机上跑该程序，是不是没有用到超线程。view2的6线程加速比为4.60x。应该是机器的问题。</p><p>题中最后还问了16线程运行程序会不会有性能提升，显然在我的机器上不会了，6线程就是最佳性能了。</p><h3 id="Program-2-Vectorizing-Code-Using-SIMD-Intrinsics"><a href="#Program-2-Vectorizing-Code-Using-SIMD-Intrinsics" class="headerlink" title="Program 2: Vectorizing Code Using SIMD Intrinsics"></a><strong>Program 2: Vectorizing Code Using SIMD Intrinsics</strong></h3><p>该任务的要求是使用cs149intrin.h中的fake SIMD指令对一个程序进行向量化。提供了一个向量化abs为参考。这个向量化的abs是不完整的，N%VECTOR_WIDTH的部分没有计算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">absVector</span><span class="params">(<span class="type">float</span>* values, <span class="type">float</span>* output, <span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">  __cs149_vec_float x;</span><br><span class="line">  __cs149_vec_float result;</span><br><span class="line">  __cs149_vec_float zero = _cs149_vset_float(<span class="number">0.f</span>);</span><br><span class="line">  __cs149_mask maskAll, maskIsNegative, maskIsNotNegative;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Note: Take a careful look at this loop indexing.  This example</span></span><br><span class="line"><span class="comment">//  code is not guaranteed to work when (N % VECTOR_WIDTH) != 0.</span></span><br><span class="line"><span class="comment">//  Why is that the case?</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i+=VECTOR_WIDTH) &#123;</span><br><span class="line">    <span class="comment">// All ones</span></span><br><span class="line">    maskAll = _cs149_init_ones();</span><br><span class="line">    <span class="comment">// All zeros</span></span><br><span class="line">    maskIsNegative = _cs149_init_ones(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Load vector of values from contiguous memory addresses</span></span><br><span class="line">    _cs149_vload_float(x, values+i, maskAll);               <span class="comment">// x = values[i];</span></span><br><span class="line">    <span class="comment">// Set mask according to predicate</span></span><br><span class="line">    _cs149_vlt_float(maskIsNegative, x, zero, maskAll);     <span class="comment">// if (x &lt; 0) &#123;</span></span><br><span class="line">    <span class="comment">// Execute instruction using mask (&quot;if&quot; clause)</span></span><br><span class="line">    _cs149_vsub_float(result, zero, x, maskIsNegative);      <span class="comment">//   output[i] = -x;</span></span><br><span class="line">    <span class="comment">// Inverse maskIsNegative to generate &quot;else&quot; mask</span></span><br><span class="line">    maskIsNotNegative = _cs149_mask_not(maskIsNegative);     <span class="comment">// &#125; else &#123;</span></span><br><span class="line">    <span class="comment">// Execute instruction (&quot;else&quot; clause)</span></span><br><span class="line">    _cs149_vload_float(result, values+i, maskIsNotNegative); <span class="comment">//   output[i] = x; &#125;</span></span><br><span class="line">    <span class="comment">// Write results back to memory</span></span><br><span class="line">    _cs149_vstore_float(output+i, result, maskAll);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未向量化的程序为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clampedExpSerial</span><span class="params">(<span class="type">float</span>* values, <span class="type">int</span>* exponents, <span class="type">float</span>* output, <span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">    <span class="type">float</span> x = values[i];</span><br><span class="line">    <span class="type">int</span> y = exponents[i];</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>) &#123;</span><br><span class="line">      output[i] = <span class="number">1.f</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">float</span> result = x;</span><br><span class="line">      <span class="type">int</span> count = y - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        result *= x;</span><br><span class="line">        count--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (result &gt; <span class="number">9.999999f</span>) &#123;</span><br><span class="line">        result = <span class="number">9.999999f</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      output[i] = result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仿照abs中的内容进行向量化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clampedExpVector</span><span class="params">(<span class="type">float</span>* values, <span class="type">int</span>* exponents, <span class="type">float</span>* output, <span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    __cs149_vec_float x, maxVal;</span><br><span class="line">    __cs149_vec_int exp, zero, one;</span><br><span class="line">    __cs149_vec_float result;</span><br><span class="line">    __cs149_mask maskAll, maskCal, maskGtMax;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    zero = _cs149_vset_int(<span class="number">0</span>);</span><br><span class="line">    one = _cs149_vset_int(<span class="number">1</span>);</span><br><span class="line">    maxVal = _cs149_vset_float(<span class="number">9.999999f</span>);</span><br><span class="line">    maskAll = _cs149_init_ones();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i+VECTOR_WIDTH&lt;=N;i+=VECTOR_WIDTH)&#123;</span><br><span class="line">      <span class="comment">//load data and set result = 1</span></span><br><span class="line">      _cs149_vload_float(x, values+i, maskAll);</span><br><span class="line">      _cs149_vload_int(exp, exponents+i, maskAll);</span><br><span class="line">      result = _cs149_vset_float(<span class="number">1.f</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//if exp &gt; 0, maskCal = true</span></span><br><span class="line">      _cs149_vgt_int(maskCal, exp, zero, maskAll);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//while(exp&gt;0) result*=x exp--</span></span><br><span class="line">      <span class="keyword">while</span>(_cs149_cntbits(maskCal)!=<span class="number">0</span>)&#123;</span><br><span class="line">        _cs149_vmult_float(result, result, x, maskCal);</span><br><span class="line">        _cs149_vsub_int(exp, exp, one, maskCal);</span><br><span class="line">        _cs149_vgt_int(maskCal, exp, zero, maskCal);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//if result &gt; 9.999999f </span></span><br><span class="line">      _cs149_vgt_float(maskGtMax, result, maxVal, maskAll);</span><br><span class="line">      _cs149_vset_float(result, <span class="number">9.999999f</span>, maskGtMax);</span><br><span class="line">      </span><br><span class="line">      _cs149_vstore_float(output+i, result, maskAll);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i!=N)&#123;</span><br><span class="line">      i -= VECTOR_WIDTH;</span><br><span class="line">      <span class="built_in">clampedExpSerial</span>(values+i, exponents+i, output+i, N-i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在size为10000下，将向量宽度改为2,4,8,16，向量利用率为79.8%，72.1%，68.1%，66.3%，因为在向量宽度很大时，会有很多lanes是disabled，计算就失去了向量化的优势。</p><p>extra bonus是array_sum的计算，主要是多了使用hadd和interleave指令。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// returns the sum of all elements in values</span></span><br><span class="line"><span class="comment">// You can assume N is a multiple of VECTOR_WIDTH</span></span><br><span class="line"><span class="comment">// You can assume VECTOR_WIDTH is a power of 2</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">arraySumVector</span><span class="params">(<span class="type">float</span>* values, <span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// CS149 STUDENTS <span class="doctag">TODO:</span> Implement your vectorized version of arraySumSerial here</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  __cs149_vec_float result;</span><br><span class="line">  __cs149_vec_float value;</span><br><span class="line">  __cs149_mask maskAll;</span><br><span class="line">  result = _cs149_vset_float(<span class="number">0</span>);</span><br><span class="line">  maskAll = _cs149_init_ones();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i+=VECTOR_WIDTH) &#123;</span><br><span class="line">    _cs149_vload_float(value, values+i, maskAll);</span><br><span class="line">    _cs149_vadd_float(result, value, result, maskAll);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> width = VECTOR_WIDTH;</span><br><span class="line">  <span class="keyword">while</span>(width/=<span class="number">2</span>)&#123;</span><br><span class="line">    _cs149_hadd_float(result,result);</span><br><span class="line">    _cs149_interleave_float(result,result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">float</span> tmp[VECTOR_WIDTH];</span><br><span class="line">  _cs149_vstore_float(tmp,result,maskAll);</span><br><span class="line">  <span class="keyword">return</span> tmp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Program-3-Parallel-Fractal-Generation-Using-ISPC"><a href="#Program-3-Parallel-Fractal-Generation-Using-ISPC" class="headerlink" title="Program 3: Parallel Fractal Generation Using ISPC"></a><strong>Program 3: Parallel Fractal Generation Using ISPC</strong></h3><p>program3仍然是一个计算图形的程序，但这次要使用ISPC进行并行化。ISPC用于描述<strong>独立计算</strong>，图形计算中每个像素点是独立的，因此可以采用ISPC。提供的程序有一些问题，根据说明，修改之后应该能实现32x的加速比。</p><p>尽管和C/C++ code很像，但ISPC的实现是不同的，程序实例会在CPU的SIMD执行单元并行执行，实例的数量由编译器器根据具体机器决定，可以通过变量programCount获取，每个实例有自己的programIndex。调用ISPC函数相当于创建了一组程序实例，运行结束后将控制返回caller。</p><p>ISPC也有两种实现，一种是命令式的，指明任务的分配，另一种是声明式的，用于计算独立的情况，可以专注于将问题分解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//imperative</span></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="title">sum</span><span class="params">(uniform <span class="type">int</span> N, uniform <span class="type">float</span>* a, uniform <span class="type">float</span>* b, uniform <span class="type">float</span>* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Assumption programCount divides N evenly.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i+=programCount)</span><br><span class="line">  &#123;</span><br><span class="line">    c[programIndex + i] = a[programIndex + i] + b[programIndex + i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//declarative</span></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="title">sum2</span><span class="params">(uniform <span class="type">int</span> N, uniform <span class="type">float</span>* a, uniform <span class="type">float</span>* b, uniform <span class="type">float</span>* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  foreach (i = <span class="number">0</span> ... N)</span><br><span class="line">  &#123;</span><br><span class="line">    c[i] = a[i] + b[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给出的mandelbrot图像计算程序可以达到5.74x的加速比，由于ISPC会转换程序为宽度为8的AVX向量指令，理想的加速比是8x，没有达到理想加速比的原因是计算负载的不均衡。与program1不同的是，这次的计算是利用向量化在单核上进行的。</p><p>ISPC也提供了利用多核的方法，可以使用launch命令来创建并行任务，任务可以在不同的核中以任意顺序并行执行。使用—tasks参数启动给出的程序，可以达到11.27x的加速比。</p><p>在给出的代码中，task数是2，虚拟机是8核的，如果创建8个task的话，加速比可以达到24.45x；创建10个task，加速比达到30.30x。本来到这里就应该差不多了，因为在program1时6线程就是最佳性能了，即使假设用到超线程，也只是取12，但奇怪的是，我将task改为20(因为height是800，这样可以整除)，加速比又有了一点提升，将task改为50，加速比竟然上升到了36.44x。这个加速比本身不算特别大，因为说明中已经告诉了加速比可以超过32x，但为什么task加到这么多才达到最大加速比，暂时我还没有想法。</p><p>ISPC以非常便捷的方式实现了最大性能，向量化只要使用foreach语句就可以实现，线程也只需要launch命令就可以开启，极大提高了并行编程的效率。</p><p>作为参考学习，这个program的多核并行ISPC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slightly different kernel to support tasking</span></span><br><span class="line"><span class="function">task <span class="type">void</span> <span class="title">mandelbrot_ispc_task</span><span class="params">(uniform <span class="type">float</span> x0, uniform <span class="type">float</span> y0, </span></span></span><br><span class="line"><span class="params"><span class="function">                               uniform <span class="type">float</span> x1, uniform <span class="type">float</span> y1,</span></span></span><br><span class="line"><span class="params"><span class="function">                               uniform <span class="type">int</span> width, uniform <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                               uniform <span class="type">int</span> rowsPerTask,</span></span></span><br><span class="line"><span class="params"><span class="function">                               uniform <span class="type">int</span> maxIterations,</span></span></span><br><span class="line"><span class="params"><span class="function">                               uniform <span class="type">int</span> output[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// taskIndex is an ISPC built-in</span></span><br><span class="line">    </span><br><span class="line">    uniform <span class="type">int</span> ystart = taskIndex * rowsPerTask;</span><br><span class="line">    uniform <span class="type">int</span> yend = ystart + rowsPerTask;</span><br><span class="line">    </span><br><span class="line">    uniform <span class="type">float</span> dx = (x1 - x0) / width;</span><br><span class="line">    uniform <span class="type">float</span> dy = (y1 - y0) / height;</span><br><span class="line">    </span><br><span class="line">    foreach (j = ystart ... yend, i = <span class="number">0</span> ... width) &#123;</span><br><span class="line">            <span class="type">float</span> x = x0 + i * dx;</span><br><span class="line">            <span class="type">float</span> y = y0 + j * dy;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> index = j * width + i;</span><br><span class="line">            output[index] = <span class="built_in">mandel</span>(x, y, maxIterations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">mandelbrot_ispc_withtasks</span><span class="params">(uniform <span class="type">float</span> x0, uniform <span class="type">float</span> y0,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      uniform <span class="type">float</span> x1, uniform <span class="type">float</span> y1,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      uniform <span class="type">int</span> width, uniform <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      uniform <span class="type">int</span> maxIterations,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      uniform <span class="type">int</span> output[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    uniform <span class="type">int</span> rowsPerTask = height / <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create 2 tasks</span></span><br><span class="line">    launch[<span class="number">50</span>] <span class="built_in">mandelbrot_ispc_task</span>(x0, y0, x1, y1,</span><br><span class="line">                                     width, height,</span><br><span class="line">                                     rowsPerTask,</span><br><span class="line">                                     maxIterations,</span><br><span class="line">                                     output); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Program-4-Iterative-sqrt"><a href="#Program-4-Iterative-sqrt" class="headerlink" title="Program 4: Iterative sqrt"></a><strong>Program 4: Iterative sqrt</strong></h3><p>program4给出了一个迭代计算根号值的程序。首先需要做的是比较ISPC的单核SIMD并行和多核并行加速比。</p><p>得到的结果如下，task数为64：</p><p><img src="/2023/11/19/CS149-Assignment-1&2/image-20231122200018021.png" alt="image-20231122200018021" style="zoom:80%;"></p><p>第二个任务是通过修改数组的值来提高加速比，可以将数组的值改为相同的值，这样SIMD计算时速度会更快，并且通过给出的图可以看出，在接近3时迭代计算是最多的，这样可以最大化加速比。修改后单核加速比达到8.90x，多核并行达到59.55x。</p><p><strong>Program 5: BLAS saxpy</strong></p><p>program5给出了一个saxpy计算的实现，saxpy的计算为result = scale*X+Y，result，X和Y都是向量。运行程序，多核并行对单核并行的加速比只有1.23x，原因是向量的SIZE是20M，超过了memory的带宽，因此性能受到了限制。保持这个SIZE可能没法有性能提升了。</p><h2 id="Assignment-2-Building-A-Task-Execution-Library-from-the-Ground-Up"><a href="#Assignment-2-Building-A-Task-Execution-Library-from-the-Ground-Up" class="headerlink" title="Assignment 2: Building A Task Execution Library from the Ground Up"></a>Assignment 2: Building A Task Execution Library from the Ground Up</h2><p>Assignment2的任务是完成一个并行库(类似ISPC LAUNCH)，以线程池的方式实现并行任务执行接口，并能够进行工作的同步和协调，还要能够对工作进行合理调度。</p><h3 id="Part-A-Synchronous-Bulk-Task-Launch"><a href="#Part-A-Synchronous-Bulk-Task-Launch" class="headerlink" title="Part A: Synchronous Bulk Task Launch"></a>Part A: Synchronous Bulk Task Launch</h3><p>任务执行的接口定义在抽象类itasksys.h中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IRunnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">IRunnable</span>();</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">runTask</span><span class="params">(<span class="type">int</span> task_id, <span class="type">int</span> num_total_tasks)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ITaskSystem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">ITaskSystem</span>(<span class="type">int</span> num_threads);</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">ITaskSystem</span>();</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">name</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//执行一组任务，全部执行后返回</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">run</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">执行一组依赖于先前任务的异步任务，只有deps中的任务完成后才会开始执行这一组任务，</span></span><br><span class="line"><span class="comment">调用者必须使用sync()保证该组任务完成，</span></span><br><span class="line"><span class="comment">返回的TaskID用于后续有依赖的任务的创建</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> TaskID <span class="title">runAsyncWithDeps</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> std::vector&lt;TaskID&gt;&amp; deps)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//阻塞直到所有先前的任务完成</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sync</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>runTask是由具体的testcase实现的，只需要TaskID就会执行自己部分的工作，TaskSystem只需要指定线程启动Task。</p><p>需要实现的TaskSystem有三个，复杂度是递增的：</p><ul><li>TaskSystemParallelSpawn</li><li>TaskSystemParallelThreadPoolSpinning</li><li>TaskSystemParallelThreadPoolSleeping</li></ul><p>完成后通过runtasks进行测试，最简单的一个用来debug的测试是SimpleTest。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-n指定最大线程数 有许多testcase，定义在test.h中</span></span><br><span class="line">./runtasks -n 8 mandelbrot_chunked</span><br></pre></td></tr></table></figure><p>test程序会准备Task，然后使用TaskSystem启动Task。在simpleTest中，将<strong>相同的Tasks</strong>执行了两次，并且在异步执行中按照顺序执行两次Tasks。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TestResults <span class="title">simpleTest</span><span class="params">(ITaskSystem* t, <span class="type">bool</span> do_async)</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义task相关的一些数据...</span></span><br><span class="line"><span class="comment">//下面的Task继承自Runnable，会启动Task, 但是还需要指定TaskID才能启动</span></span><br><span class="line">    SimpleMultiplyTask first = <span class="built_in">SimpleMultiplyTask</span>(num_elements, array);</span><br><span class="line">    SimpleMultiplyTask second = <span class="built_in">SimpleMultiplyTask</span>(num_elements, array);</span><br><span class="line">    <span class="comment">//进行测试</span></span><br><span class="line">    <span class="comment">// Run the test</span></span><br><span class="line">    <span class="type">double</span> start_time = CycleTimer::<span class="built_in">currentSeconds</span>();</span><br><span class="line">    <span class="keyword">if</span> (do_async) &#123;</span><br><span class="line">        std::vector&lt;TaskID&gt; firstDeps;</span><br><span class="line">        TaskID first_task_id = t-&gt;<span class="built_in">runAsyncWithDeps</span>(&amp;first, num_tasks, firstDeps);</span><br><span class="line">        std::vector&lt;TaskID&gt; secondDeps;</span><br><span class="line">        secondDeps.<span class="built_in">push_back</span>(first_task_id);</span><br><span class="line">        t-&gt;<span class="built_in">runAsyncWithDeps</span>(&amp;second, num_tasks, secondDeps);</span><br><span class="line">        t-&gt;<span class="built_in">sync</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t-&gt;<span class="built_in">run</span>(&amp;first, num_tasks);</span><br><span class="line">        t-&gt;<span class="built_in">run</span>(&amp;second, num_tasks);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> end_time = CycleTimer::<span class="built_in">currentSeconds</span>();</span><br><span class="line">    <span class="comment">//验证正确性..</span></span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先从最简单的串行来理解TaskSystem，run函数启动了total_task次Task，而异步执行和sync函数在串行情况下都不需要实现。对于并行版本，应该使用不同线程调用runnable的runTask函数，来并行启动Task。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemSerial::run</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_total_tasks; i++) &#123;</span><br><span class="line">        runnable-&gt;<span class="built_in">runTask</span>(i, num_total_tasks);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TaskSystemParallelSpawn"><a href="#TaskSystemParallelSpawn" class="headerlink" title="TaskSystemParallelSpawn"></a>TaskSystemParallelSpawn</h4><p>这个版本只需要创建线程，分配Task。在该类中需要在构造时保存最大线程数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TaskSystemParallelSpawn::<span class="built_in">TaskSystemParallelSpawn</span>(<span class="type">int</span> num_threads): <span class="built_in">ITaskSystem</span>(num_threads) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;num_threads = num_threads;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任务是根据TaskID在runnable中分好的，线程只需要调用runTask，并传入TaskID。Task的分配可以是静态的，也可以是动态的。静态的分配如下(交错分配)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemParallelSpawn::run</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks)</span> </span>&#123;</span><br><span class="line">    std::thread threads[num_threads];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num_threads;i++)&#123;</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>([runnable, num_total_tasks, i](<span class="type">int</span> num_threads)&#123;</span><br><span class="line">            <span class="type">int</span> id = i;</span><br><span class="line">            <span class="keyword">while</span>(id&lt;num_total_tasks)&#123;</span><br><span class="line">                runnable-&gt;<span class="built_in">runTask</span>(id, num_total_tasks);</span><br><span class="line">                id += num_threads;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, num_threads);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num_threads;i++) threads[i].<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/11/19/CS149-Assignment-1&2/image-20231208000441970.png" alt="image-20231208000441970" style="zoom: 67%;"></p><p>动态分配如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemParallelSpawn::run</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks)</span> </span>&#123;</span><br><span class="line">    std::thread threads[num_threads];</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">taskID</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;thread: threads)&#123;</span><br><span class="line">        thread = std::<span class="built_in">thread</span>([&amp;taskID, runnable,num_total_tasks]&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> id=taskID++;id&lt;num_total_tasks;id=taskID++) runnable-&gt;<span class="built_in">runTask</span>(id, num_total_tasks);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;thread: threads)&#123;</span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这个测试来说，动态分配和静态分配的结果差不多。有一些testcase使用动态分配的话会比串行时间更长，应该是由于获取task时的原子操作开销大，Task数量多但计算少导致的。</p><p><img src="/2023/11/19/CS149-Assignment-1&2/image-20231208000851380.png" alt="image-20231208000851380" style="zoom:67%;"></p><h4 id="TaskSystemParallelThreadPoolSpinning"><a href="#TaskSystemParallelThreadPoolSpinning" class="headerlink" title="TaskSystemParallelThreadPoolSpinning"></a>TaskSystemParallelThreadPoolSpinning</h4><p>在这个版本中，需要实现线程池，在TaskSystem构造或第一次调用run时创建线程。线程创建后进入自旋，并持续检查是否有工作需要完成(通过当前task_id和total_task值)。相应的需要使用同步机制确认所有task完成，这里直接让主线程在条件变量上休眠，等待所有线程完成任务后，由最后一个线程来唤醒主线程。</p><p>核心的部分就是线程的工作以及TaskSystem的Run，所有的线程在TaskSystem构造时启动，析构时修改flag，然后等待线程结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Thread Start</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemParallelThreadPoolSpinning::ThreadFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> my_task_id, num_total_tasks;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(shut_down) <span class="keyword">break</span>;</span><br><span class="line">        mtx.<span class="built_in">lock</span>();</span><br><span class="line">        my_task_id = tasks-&gt;next_task_id++;</span><br><span class="line">        num_total_tasks = tasks-&gt;num_total_tasks;</span><br><span class="line">        mtx.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">if</span>(my_task_id&lt;num_total_tasks)&#123;</span><br><span class="line">            tasks-&gt;runnable-&gt;<span class="built_in">runTask</span>(my_task_id, num_total_tasks);</span><br><span class="line">            mtx.<span class="built_in">lock</span>();</span><br><span class="line">            tasks-&gt;task_finished++;</span><br><span class="line">            <span class="keyword">if</span>(tasks-&gt;task_finished==num_total_tasks)&#123;</span><br><span class="line">                mtx.<span class="built_in">unlock</span>();</span><br><span class="line">                condition_mtx.<span class="built_in">lock</span>();</span><br><span class="line">                done = <span class="literal">true</span>;<span class="comment">//防止子线程先notify，用变量标记task完成</span></span><br><span class="line">                condition_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">                task_done.<span class="built_in">notify_all</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> mtx.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TaskSystem Run</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemParallelThreadPoolSpinning::run</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks)</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;tasks-&gt;runnable = runnable;</span><br><span class="line">    <span class="keyword">this</span>-&gt;tasks-&gt;next_task_id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;tasks-&gt;num_total_tasks = num_total_tasks;</span><br><span class="line">    <span class="keyword">this</span>-&gt;tasks-&gt;task_finished = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;done = <span class="literal">false</span>;</span><br><span class="line">    mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(<span class="keyword">this</span>-&gt;condition_mtx)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(!done) task_done.<span class="built_in">wait</span>(lk);</span><br><span class="line">    lk.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试通过，时间和之前的版本差不多。</p><p><img src="/2023/11/19/CS149-Assignment-1&2/image-20231209202712962.png" alt="image-20231209202712962" style="zoom:67%;"></p><h4 id="TaskSystemParallelThreadPoolSleeping"><a href="#TaskSystemParallelThreadPoolSleeping" class="headerlink" title="TaskSystemParallelThreadPoolSleeping"></a>TaskSystemParallelThreadPoolSleeping</h4><p>在这个版本中，要让线程在没有工作的时候休眠，而不是自旋等待。实际上就是实现消费者-生产者模型，用两个条件变量进行同步。需要注意在析构时，必须唤醒所有线程，为了保证线程在唤醒后不会再次进入睡眠，要把flag也修改掉。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">TaskSystemParallelThreadPoolSleeping::~<span class="built_in">TaskSystemParallelThreadPoolSleeping</span>() &#123;</span><br><span class="line">    shut_down = <span class="literal">true</span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(cmtx)</span></span>;<span class="comment">//这一个锁可以不上，去掉之后就和reference版本时间一样了</span></span><br><span class="line">    done = <span class="literal">false</span>;</span><br><span class="line">    sleeping_queue.<span class="built_in">notify_all</span>();</span><br><span class="line">    lk.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num_threads;i++) threads_pool[i].<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">delete</span>[] threads_pool;</span><br><span class="line">    <span class="keyword">delete</span> tasks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemParallelThreadPoolSleeping::ThreadFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> my_task_id, num_total_tasks;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(shut_down) <span class="keyword">break</span>;</span><br><span class="line">        mtx.<span class="built_in">lock</span>();</span><br><span class="line">        my_task_id = tasks-&gt;next_task_id++;</span><br><span class="line">        num_total_tasks = tasks-&gt;num_total_tasks;</span><br><span class="line">        mtx.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">if</span>(my_task_id&lt;num_total_tasks)&#123;</span><br><span class="line">            tasks-&gt;runnable-&gt;<span class="built_in">runTask</span>(my_task_id, num_total_tasks);</span><br><span class="line">            mtx.<span class="built_in">lock</span>();</span><br><span class="line">            tasks-&gt;task_finished++;</span><br><span class="line">            <span class="keyword">if</span>(tasks-&gt;task_finished==num_total_tasks)&#123;</span><br><span class="line">                mtx.<span class="built_in">unlock</span>();</span><br><span class="line">                cmtx.<span class="built_in">lock</span>();</span><br><span class="line">                done = <span class="literal">true</span>;</span><br><span class="line">                cmtx.<span class="built_in">unlock</span>();</span><br><span class="line">                task_done.<span class="built_in">notify_all</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> mtx.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            std::unique_lock&lt;std::mutex&gt; <span class="built_in">lk</span>(cmtx);</span><br><span class="line">            <span class="keyword">while</span>(done) sleeping_queue.<span class="built_in">wait</span>(lk);</span><br><span class="line">            lk.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemParallelThreadPoolSleeping::run</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks)</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();</span><br><span class="line">    done = <span class="literal">false</span>;</span><br><span class="line">    tasks-&gt;runnable = runnable;</span><br><span class="line">    tasks-&gt;num_total_tasks = num_total_tasks;</span><br><span class="line">    tasks-&gt;task_finished = <span class="number">0</span>;</span><br><span class="line">    tasks-&gt;next_task_id = <span class="number">0</span>;</span><br><span class="line">    mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(cmtx)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(!done) &#123;</span><br><span class="line">        sleeping_queue.<span class="built_in">notify_all</span>();</span><br><span class="line">        task_done.<span class="built_in">wait</span>(lk);</span><br><span class="line">    &#125;</span><br><span class="line">    lk.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试通过。</p><p><img src="/2023/11/19/CS149-Assignment-1&2/image-20231210163325468.png" alt="image-20231210163325468" style="zoom:67%;"></p><h4 id="与reference的比较测试"><a href="#与reference的比较测试" class="headerlink" title="与reference的比较测试"></a>与reference的比较测试</h4><p>只有一个math_operations_in_tight_for_loop_fewer_tasks的testcase的perf结果是1.35不合格，大部分都不超过1。不过这个testcase单独跑可以过，每次运行性能都有一点变化。</p><h3 id="Part-B-Supporting-Execution-of-Task-Graphs"><a href="#Part-B-Supporting-Execution-of-Task-Graphs" class="headerlink" title="Part B: Supporting Execution of Task Graphs"></a>Part B: Supporting Execution of Task Graphs</h3><p>partB需要实现能够异步执行任务，并且可以保证任务之间的依赖关系。给出的提示是创建两个队列分别处理仍然存在依赖的task bulk和可以执行的task bulk。任务组数量不超过int范围。</p><p>这个PartB对于不熟悉并发编程的我来说遇到了非常多的困难，改了很多次都没办法跑通。于是看了一些其他人的实现，奇怪的是在github上找的两个实现也跑不通(不是无法通过，而是完全跑不出来)，其中这位HUST同学的<a href="https://blog.lfalive.top/2022/01/28/CS149-asst2/#part-a">实现</a>是正确的，但是对于他的实现我有一些不理解的地方，主要是将等待的TaskBulk放入ready_queue的过程，为什么是放在sync()当中的，这样只有sync()调用后才会转移有依赖的bulk进入待执行队列，感觉更应该把转移工作放在线程中，而不是要等到sync()调用后才处理。此外还看到了单独使用一个线程进行调度的实现，那一种应该更好实现一些，只需要调度器和主线程进行同步，不过性能就差了。</p><p>尽管参考了一些他人的实现，最后还是按照自己的思路完成的，在经历了两天的重写和修改后，终于能跑通了。在这个过程中其实思路没什么问题，在debug的过程中熟悉了一下gdb调试多线程程序，找到了一直无法运行的原因是主线程结束并析构TaskSystem时join子线程，而子线程休眠在条件变量上。要注意的问题主要有：</p><ul><li>有哪些数据结构需要上锁，哪些不需要</li><li>每个线程在条件变量被唤醒有哪些可能的原因</li><li>当前线程条件变量的锁可能是从谁手中获得的，有哪些可能</li><li>是否能保证状态的改变可以被看到，需要重点考虑目标线程不是从休眠状态唤醒的情况，如果刚好对方休眠，那么唤醒对方后，对方应该检查状态，这样就一定能看到状态的改变，但如果对方没有休眠，需要确保对方在任何一个位置都能继续执行并到达检查状态的位置</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>为了方便管理任务组，建立了一个结构体，保存任务组的所有信息，包括依赖的任务组ID以及一个用于原子读写num_tasks_done和next_task_id的锁，这两个数据会被多个线程访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskBulk</span>&#123;</span><br><span class="line">    TaskID id;</span><br><span class="line">    IRunnable *runnable;</span><br><span class="line">    <span class="type">int</span> num_total_tasks = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num_tasks_done = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> next_task_id = <span class="number">0</span>;</span><br><span class="line">    std::unordered_set&lt;TaskID&gt; dependencies;</span><br><span class="line">    std::mutex bulk_mtx;</span><br><span class="line">    <span class="built_in">TaskBulk</span>(TaskID _id, IRunnable *_runnable, <span class="type">int</span> _num_total_tasks, <span class="type">const</span> std::vector&lt;TaskID&gt; &amp;_deps): <span class="built_in">id</span>(_id), <span class="built_in">runnable</span>(_runnable), <span class="built_in">num_total_tasks</span>(_num_total_tasks), <span class="built_in">dependencies</span>(_deps.<span class="built_in">begin</span>(), _deps.<span class="built_in">end</span>())&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TaskSystem类如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskSystemParallelThreadPoolSleeping</span>: <span class="keyword">public</span> ITaskSystem &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> num_threads;</span><br><span class="line">        TaskID next_id;<span class="comment">//主线程读写，子线程会多次读(确认所有任务完成时)，不需要加锁</span></span><br><span class="line">        <span class="type">bool</span> done;<span class="comment">//所有任务完成，主/子线程据此休眠</span></span><br><span class="line">        <span class="type">bool</span> terminate;   </span><br><span class="line">        std::atomic&lt;<span class="type">int</span>&gt; num_bulk_done;     <span class="comment">//多个线程更新</span></span><br><span class="line">        std::thread *thread_pool;</span><br><span class="line">        std::vector&lt;TaskBulk*&gt; waiting;</span><br><span class="line">        std::vector&lt;TaskBulk*&gt; ready;</span><br><span class="line">        std::unordered_set&lt;TaskBulk*&gt; all_bulks;<span class="comment">//用于析构</span></span><br><span class="line">        std::unordered_set&lt;TaskID&gt; finished_bulk;<span class="comment">//用于依赖关系判断</span></span><br><span class="line">        std::condition_variable sleeping_cv;</span><br><span class="line">        std::condition_variable waiting_cv;</span><br><span class="line">        std::mutex qmtx;<span class="comment">//队列的锁</span></span><br><span class="line">        std::mutex cmtx;<span class="comment">//读写done的锁，用于两个条件变量</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">ThreadFunc</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">CheckWaiting</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">TaskSystemParallelThreadPoolSleeping</span>(<span class="type">int</span> num_threads);</span><br><span class="line">        ~<span class="built_in">TaskSystemParallelThreadPoolSleeping</span>();</span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks)</span></span>;</span><br><span class="line">        <span class="function">TaskID <span class="title">runAsyncWithDeps</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">const</span> std::vector&lt;TaskID&gt;&amp; deps)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">sync</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TaskSystem的构造：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TaskSystemParallelThreadPoolSleeping::<span class="built_in">TaskSystemParallelThreadPoolSleeping</span>(<span class="type">int</span> num_threads): <span class="built_in">ITaskSystem</span>(num_threads), <span class="built_in">num_bulk_done</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;num_threads = num_threads;</span><br><span class="line">    terminate = <span class="literal">false</span>;</span><br><span class="line">    done = <span class="literal">true</span>;</span><br><span class="line">    next_id = <span class="number">0</span>;</span><br><span class="line">    thread_pool = <span class="keyword">new</span> std::thread[num_threads];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num_threads;i++) thread_pool[i] = std::<span class="built_in">thread</span>(&amp;TaskSystemParallelThreadPoolSleeping::ThreadFunc, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TaskSystem的析构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TaskSystemParallelThreadPoolSleeping::~<span class="built_in">TaskSystemParallelThreadPoolSleeping</span>() &#123;</span><br><span class="line">    <span class="built_in">sync</span>();</span><br><span class="line">    terminate = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//唤醒所有线程并终止</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(cmtx)</span></span>;</span><br><span class="line">    done = <span class="literal">false</span>;</span><br><span class="line">    sleeping_cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    lk.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num_threads;i++) thread_pool[i].<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> bulk: all_bulks) <span class="keyword">delete</span> bulk;</span><br><span class="line">    <span class="keyword">delete</span>[] thread_pool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步任务的启动：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TaskID <span class="title">TaskSystemParallelThreadPoolSleeping::runAsyncWithDeps</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="type">const</span> std::vector&lt;TaskID&gt;&amp; deps)</span> </span>&#123;</span><br><span class="line">    TaskID the_id = next_id++;</span><br><span class="line">    TaskBulk *new_bulk = <span class="keyword">new</span> <span class="built_in">TaskBulk</span>(the_id, runnable, num_total_tasks, std::<span class="built_in">move</span>(deps));</span><br><span class="line">    all_bulks.<span class="built_in">insert</span>(new_bulk);</span><br><span class="line">    <span class="comment">//enqueue task_bulk</span></span><br><span class="line">    qmtx.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span>(deps.<span class="built_in">size</span>()==<span class="number">0</span>) ready.<span class="built_in">push_back</span>(new_bulk);</span><br><span class="line">    <span class="keyword">else</span> waiting.<span class="built_in">push_back</span>(new_bulk);</span><br><span class="line">    qmtx.<span class="built_in">unlock</span>();</span><br><span class="line">    cmtx.<span class="built_in">lock</span>();</span><br><span class="line">    done = <span class="literal">false</span>;</span><br><span class="line">    cmtx.<span class="built_in">unlock</span>();</span><br><span class="line">    sleeping_cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="keyword">return</span> the_id;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>同步，每次被唤醒后要重新检查是否所有任务都完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemParallelThreadPoolSleeping::sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(cmtx)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(!done)&#123;</span><br><span class="line">        <span class="comment">//sleeping_cv.notify_all();</span></span><br><span class="line">        waiting_cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        <span class="keyword">if</span>(num_bulk_done==next_id) done = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            done = <span class="literal">false</span>;</span><br><span class="line">            sleeping_cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lk.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从等待队列转移任务到就绪队列，调用需要保证持有锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemParallelThreadPoolSleeping::CheckWaiting</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::vector&lt;TaskBulk*&gt; move;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> waiting_bulk: waiting)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = waiting_bulk-&gt;dependencies.<span class="built_in">begin</span>(); it != waiting_bulk-&gt;dependencies.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (finished_bulk.<span class="built_in">find</span>(*it) != finished_bulk.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                it = waiting_bulk-&gt;dependencies.<span class="built_in">erase</span>(it);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> ++it;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(waiting_bulk-&gt;dependencies.<span class="built_in">size</span>()==<span class="number">0</span>) move.<span class="built_in">push_back</span>(waiting_bulk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> remov: move)&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(waiting.<span class="built_in">begin</span>(), waiting.<span class="built_in">end</span>(), remov);</span><br><span class="line">        waiting.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> enqueue: move) &#123;</span><br><span class="line">        ready.<span class="built_in">push_back</span>(enqueue); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程函数，这里我把将任务组从就绪队列删除的工作放在了任务组结束后，这样的话，如果默认选取就绪队列的第一个任务组，会有一些线程拿到大于num_total_task的任务而无效等待，相应的我将选择任务组改为随机，来减少这种无效的等待。其实可以在获取任务时，就将已经全部分配的任务组从就绪队列删除，但是我尝试这样做后，在极少数的情况下会有coredump或者疑似死锁的情况，由于出现的次数非常少，很难调试，我就直接放弃了这一种，还是用一开始写的这一种，只要任务组的数量稍多一些，应该很少有线程拿到id&gt;=num_total_task的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemParallelThreadPoolSleeping::ThreadFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> my_id, num_done;</span><br><span class="line">    TaskBulk *my_bulk;</span><br><span class="line">    <span class="keyword">while</span>(!terminate)&#123;</span><br><span class="line">        <span class="comment">//检查是否所有bulk都已经完成</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(cmtx)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(terminate) <span class="keyword">return</span>;   <span class="comment">//此时可能主线程已经在析构中join了，此时线程获取cmtx，要检查terminate</span></span><br><span class="line">        <span class="keyword">if</span>(next_id==num_bulk_done)&#123;</span><br><span class="line">            done = <span class="literal">true</span>;</span><br><span class="line">            waiting_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> done = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(done)&#123;</span><br><span class="line">            waiting_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">            sleeping_cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">            <span class="keyword">if</span>(terminate) <span class="keyword">return</span>;<span class="comment">//被唤醒的原因：被终止或有新任务</span></span><br><span class="line">            <span class="keyword">if</span>(next_id==num_bulk_done)&#123;</span><br><span class="line">                done = <span class="literal">true</span>;</span><br><span class="line">                waiting_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> done = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lk.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="comment">//尝试获取task</span></span><br><span class="line">        my_id = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        my_bulk = <span class="literal">nullptr</span>;</span><br><span class="line">        qmtx.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(ready.<span class="built_in">empty</span>()) <span class="built_in">CheckWaiting</span>();<span class="comment">//检查是否有就绪任务组</span></span><br><span class="line">        <span class="keyword">if</span>(!ready.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            my_bulk = ready[<span class="built_in">rand</span>()%ready.<span class="built_in">size</span>()];   <span class="comment">//通过随机选择减少等在同一个bulk</span></span><br><span class="line">            my_bulk-&gt;bulk_mtx.<span class="built_in">lock</span>();</span><br><span class="line">            my_id = my_bulk-&gt;next_task_id++;</span><br><span class="line">            my_bulk-&gt;bulk_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        qmtx.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="comment">//执行task</span></span><br><span class="line">        <span class="keyword">if</span>(my_bulk &amp;&amp; my_id &lt; my_bulk-&gt;num_total_tasks)&#123;</span><br><span class="line">            my_bulk-&gt;runnable-&gt;<span class="built_in">runTask</span>(my_id, my_bulk-&gt;num_total_tasks);</span><br><span class="line">            my_bulk-&gt;bulk_mtx.<span class="built_in">lock</span>();</span><br><span class="line">            num_done = ++my_bulk-&gt;num_tasks_done;</span><br><span class="line">            my_bulk-&gt;bulk_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">if</span>(num_done==my_bulk-&gt;num_total_tasks)&#123;</span><br><span class="line">                <span class="comment">//从ready队列删除bulk</span></span><br><span class="line">                qmtx.<span class="built_in">lock</span>();</span><br><span class="line">                num_bulk_done++;</span><br><span class="line">                <span class="keyword">auto</span> it = <span class="built_in">find_if</span>(ready.<span class="built_in">begin</span>(), ready.<span class="built_in">end</span>(), </span><br><span class="line">                    [my_bulk](<span class="type">const</span> TaskBulk* ptr) &#123;<span class="keyword">return</span> ptr == my_bulk;&#125;);</span><br><span class="line">                <span class="keyword">if</span>(it!=ready.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    ready.<span class="built_in">erase</span>(it);</span><br><span class="line">                &#125;</span><br><span class="line">                finished_bulk.<span class="built_in">insert</span>(my_bulk-&gt;id);</span><br><span class="line">                sleeping_cv.<span class="built_in">notify_all</span>();</span><br><span class="line">                qmtx.<span class="built_in">unlock</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="与reference的比较测试-1"><a href="#与reference的比较测试-1" class="headerlink" title="与reference的比较测试"></a>与reference的比较测试</h4><p>所有的测试都通过了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">y@ubuntu:~/桌面/CS149/asst2/part_b$ python ../tests/run_test_harness.py -a</span><br><span class="line">================================================================================</span><br><span class="line">Running task system grading harness... (22 total tests)</span><br><span class="line">  - Detected CPU with 8 execution contexts</span><br><span class="line">  - Task system configured to use at most 8 threads</span><br><span class="line">================================================================================</span><br><span class="line">================================================================================</span><br><span class="line">Executing test: super_super_light...</span><br><span class="line">Reference binary: ./runtasks_ref_linux</span><br><span class="line">Results for: super_super_light</span><br><span class="line">                                        STUDENT   REFERENCE   PERF?</span><br><span class="line">[Parallel + Thread Pool + Sleep]        51.694    49.241      1.05  (OK)</span><br><span class="line">================================================================================</span><br><span class="line">Executing test: super_super_light_async...</span><br><span class="line">Reference binary: ./runtasks_ref_linux</span><br><span class="line">Results for: super_super_light_async</span><br><span class="line">                                        STUDENT   REFERENCE   PERF?</span><br><span class="line">[Parallel + Thread Pool + Sleep]        10.132    20.943      0.48  (OK)</span><br><span class="line">================================================================================</span><br><span class="line">Executing test: super_light...</span><br><span class="line">Reference binary: ./runtasks_ref_linux</span><br><span class="line">Results for: super_light</span><br><span class="line">                                        STUDENT   REFERENCE   PERF?</span><br><span class="line">[Parallel + Thread Pool + Sleep]        67.003    61.637      1.09  (OK)</span><br><span class="line">================================================================================</span><br><span class="line">Executing test: super_light_async...</span><br><span class="line">Reference binary: ./runtasks_ref_linux</span><br><span class="line">Results for: super_light_async</span><br><span class="line">                                        STUDENT   REFERENCE   PERF?</span><br><span class="line">[Parallel + Thread Pool + Sleep]        42.82     45.168      0.95  (OK)</span><br><span class="line">================================================================================</span><br><span class="line">Executing test: ping_pong_equal...</span><br><span class="line">Reference binary: ./runtasks_ref_linux</span><br><span class="line">Results for: ping_pong_equal</span><br><span class="line">                                        STUDENT   REFERENCE   PERF?</span><br><span class="line">[Parallel + Thread Pool + Sleep]        201.44    235.962     0.85  (OK)</span><br><span class="line">================================================================================</span><br><span class="line">Executing test: ping_pong_equal_async...</span><br><span class="line">Reference binary: ./runtasks_ref_linux</span><br><span class="line">Results for: ping_pong_equal_async</span><br><span class="line">                                        STUDENT   REFERENCE   PERF?</span><br><span class="line">[Parallel + Thread Pool + Sleep]        181.643   224.728     0.81  (OK)</span><br><span class="line">================================================================================</span><br><span class="line">Executing test: ping_pong_unequal...</span><br><span class="line">Reference binary: ./runtasks_ref_linux</span><br><span class="line">Results for: ping_pong_unequal</span><br><span class="line">                                        STUDENT   REFERENCE   PERF?</span><br><span class="line">[Parallel + Thread Pool + Sleep]        297.235   287.366     1.03  (OK)</span><br><span class="line">================================================================================</span><br><span class="line">Executing test: ping_pong_unequal_async...</span><br><span class="line">Reference binary: ./runtasks_ref_linux</span><br><span class="line">Results for: ping_pong_unequal_async</span><br><span class="line">                                        STUDENT   REFERENCE   PERF?</span><br><span class="line">[Parallel + Thread Pool + Sleep]        275.763   281.908     0.98  (OK)</span><br><span class="line">================================================================================</span><br><span class="line">Executing test: recursive_fibonacci...</span><br><span class="line">Reference binary: ./runtasks_ref_linux</span><br><span class="line">Results for: recursive_fibonacci</span><br><span class="line">                                        STUDENT   REFERENCE   PERF?</span><br><span class="line">[Parallel + Thread Pool + Sleep]        247.546   262.125     0.94  (OK)</span><br><span class="line">================================================================================</span><br><span class="line">Executing test: recursive_fibonacci_async...</span><br><span class="line">Reference binary: ./runtasks_ref_linux</span><br><span class="line">Results for: recursive_fibonacci_async</span><br><span class="line">                                        STUDENT   REFERENCE   PERF?</span><br><span class="line">[Parallel + Thread Pool + Sleep]        246.797   267.185     0.92  (OK)</span><br><span class="line">================================================================================</span><br><span class="line">Executing test: math_operations_in_tight_for_loop...</span><br><span class="line">Reference binary: ./runtasks_ref_linux</span><br><span class="line">Results for: math_operations_in_tight_for_loop</span><br><span class="line">                                        STUDENT   REFERENCE   PERF?</span><br><span class="line">[Parallel + Thread Pool + Sleep]        335.786   309.661     1.08  (OK)</span><br><span class="line">================================================================================</span><br><span class="line">Executing test: math_operations_in_tight_for_loop_async...</span><br><span class="line">Reference binary: ./runtasks_ref_linux</span><br><span class="line">Results for: math_operations_in_tight_for_loop_async</span><br><span class="line">                                        STUDENT   REFERENCE   PERF?</span><br><span class="line">[Parallel + Thread Pool + Sleep]        260.238   241.34      1.08  (OK)</span><br><span class="line">================================================================================</span><br><span class="line">Executing test: math_operations_in_tight_for_loop_fewer_tasks...</span><br><span class="line">Reference binary: ./runtasks_ref_linux</span><br><span class="line">Results for: math_operations_in_tight_for_loop_fewer_tasks</span><br><span class="line">                                        STUDENT   REFERENCE   PERF?</span><br><span class="line">[Parallel + Thread Pool + Sleep]        355.964   309.96      1.15  (OK)</span><br><span class="line">================================================================================</span><br><span class="line">Executing test: math_operations_in_tight_for_loop_fewer_tasks_async...</span><br><span class="line">Reference binary: ./runtasks_ref_linux</span><br><span class="line">Results for: math_operations_in_tight_for_loop_fewer_tasks_async</span><br><span class="line">                                        STUDENT   REFERENCE   PERF?</span><br><span class="line">[Parallel + Thread Pool + Sleep]        94.946    95.299      1.00  (OK)</span><br><span class="line">================================================================================</span><br><span class="line">Executing test: math_operations_in_tight_for_loop_fan_in...</span><br><span class="line">Reference binary: ./runtasks_ref_linux</span><br><span class="line">Results for: math_operations_in_tight_for_loop_fan_in</span><br><span class="line">                                        STUDENT   REFERENCE   PERF?</span><br><span class="line">[Parallel + Thread Pool + Sleep]        80.797    76.612      1.05  (OK)</span><br><span class="line">================================================================================</span><br><span class="line">Executing test: math_operations_in_tight_for_loop_fan_in_async...</span><br><span class="line">Reference binary: ./runtasks_ref_linux</span><br><span class="line">Results for: math_operations_in_tight_for_loop_fan_in_async</span><br><span class="line">                                        STUDENT   REFERENCE   PERF?</span><br><span class="line">[Parallel + Thread Pool + Sleep]        52.42     53.054      0.99  (OK)</span><br><span class="line">================================================================================</span><br><span class="line">Executing test: math_operations_in_tight_for_loop_reduction_tree...</span><br><span class="line">Reference binary: ./runtasks_ref_linux</span><br><span class="line">Results for: math_operations_in_tight_for_loop_reduction_tree</span><br><span class="line">                                        STUDENT   REFERENCE   PERF?</span><br><span class="line">[Parallel + Thread Pool + Sleep]        54.942    54.193      1.01  (OK)</span><br><span class="line">================================================================================</span><br><span class="line">Executing test: math_operations_in_tight_for_loop_reduction_tree_async...</span><br><span class="line">Reference binary: ./runtasks_ref_linux</span><br><span class="line">Results for: math_operations_in_tight_for_loop_reduction_tree_async</span><br><span class="line">                                        STUDENT   REFERENCE   PERF?</span><br><span class="line">[Parallel + Thread Pool + Sleep]        47.468    48.073      0.99  (OK)</span><br><span class="line">================================================================================</span><br><span class="line">Executing test: spin_between_run_calls...</span><br><span class="line">Reference binary: ./runtasks_ref_linux</span><br><span class="line">Results for: spin_between_run_calls</span><br><span class="line">                                        STUDENT   REFERENCE   PERF?</span><br><span class="line">[Parallel + Thread Pool + Sleep]        300.939   311.881     0.96  (OK)</span><br><span class="line">================================================================================</span><br><span class="line">Executing test: spin_between_run_calls_async...</span><br><span class="line">Reference binary: ./runtasks_ref_linux</span><br><span class="line">Results for: spin_between_run_calls_async</span><br><span class="line">                                        STUDENT   REFERENCE   PERF?</span><br><span class="line">[Parallel + Thread Pool + Sleep]        302.373   315.376     0.96  (OK)</span><br><span class="line">================================================================================</span><br><span class="line">Executing test: mandelbrot_chunked...</span><br><span class="line">Reference binary: ./runtasks_ref_linux</span><br><span class="line">Results for: mandelbrot_chunked</span><br><span class="line">                                        STUDENT   REFERENCE   PERF?</span><br><span class="line">[Parallel + Thread Pool + Sleep]        45.19     45.303      1.00  (OK)</span><br><span class="line">================================================================================</span><br><span class="line">Executing test: mandelbrot_chunked_async...</span><br><span class="line">Reference binary: ./runtasks_ref_linux</span><br><span class="line">Results for: mandelbrot_chunked_async</span><br><span class="line">                                        STUDENT   REFERENCE   PERF?</span><br><span class="line">[Parallel + Thread Pool + Sleep]        45.8      44.917      1.02  (OK)</span><br><span class="line">================================================================================</span><br><span class="line">Overall performance results</span><br><span class="line">[Parallel + Thread Pool + Sleep]        : All passed Perf</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HPCLAB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能优化工具</title>
      <link href="/2023/11/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/11/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p> 关于常用的性能优化工具的一些笔记。主要内容是perf，vtune。</p><p>perf的参考文档：</p><p><a href="https://perf.wiki.kernel.org/index.php/Tutorial">https://perf.wiki.kernel.org/index.php/Tutorial</a></p><span id="more"></span><h2 id="一-Linux-Perf"><a href="#一-Linux-Perf" class="headerlink" title="一.Linux Perf"></a>一.Linux Perf</h2><p>Perf可以直接用以下命令安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install linux-tools-common</span><br></pre></td></tr></table></figure><p>如果安装后perf —version找不到，就下载内核版本的源码(uname -r看版本)，在源码的/tools/perf下执行<code>make</code>，<code>make install</code>，执行完以后可能还是没有perf，将文件夹里面的perf移动到/bin和/home/user_name/bin里面就可以了。</p><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>Perf是Linux系统上的一个性能分析工具，是基于Linux内核的perf_events实现的。</p><p><strong>命令</strong></p><p>最常用的perf命令有stat，record和report，还有许多其他命令，直接运行perf就可以看到了。每个命令的具体选项通过<code>perf cmd -h</code>查看。</p><p><strong>Events</strong></p><p>perf支持一系列可测量的事件。测量接口来自内核，内核计数器触发的事件称为<strong>软事件</strong>，包括上下文切换等。还有硬件触发的来自Performance Monitoring Unit(PMU)的事件。这些事件是微体系结构下的，包括时钟数，缓存未命中，退役指令等。这样的事件称为<strong>PMU硬件事件</strong>。还有一些tracepoint事件是内核的ftrace实现的，只有2.6.3x以后的内核才支持。</p><p>PMU硬件事件是每个CPU可能不同的，intel的PMU events table: <a href="http://www.intel.com/Assets/PDF/manual/253669.pdf">Appendix A</a>，AMD的: <a href="https://www.amd.com/system/files/TechDocs/31116.pdf">Section 3.14</a>。</p><p>执行<code>perf list</code>可以得到支持的事件列表。</p><h3 id="2-使用perf-stat"><a href="#2-使用perf-stat" class="headerlink" title="2.使用perf stat"></a>2.使用perf stat</h3><h4 id="Options-controlling-event-selection"><a href="#Options-controlling-event-selection" class="headerlink" title="Options controlling event selection"></a>Options controlling event selection</h4><p>对于支持的事件，perf可以在进程执行时进行计数，并产生分析数据。</p><p>直接执行<code>perf stat program_name</code>会输出一些常见的事件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/y/hpc/perf# perf stat ./case0</span><br><span class="line"></span><br><span class="line"> Performance counter stats for &#x27;./case0&#x27;:</span><br><span class="line"></span><br><span class="line">             17.77 msec task-clock                #    0.968 CPUs utilized          </span><br><span class="line">                 0      context-switches          #    0.000 /sec                   </span><br><span class="line">                 0      cpu-migrations            #    0.000 /sec                   </span><br><span class="line">             2,073      page-faults               #  116.640 K/sec                  </span><br><span class="line">        52,643,081      cycles                    #    2.962 GHz                      (32.65%)</span><br><span class="line">                 0      stalled-cycles-frontend                                       (32.75%)</span><br><span class="line">                 0      stalled-cycles-backend    #    0.00% backend cycles idle      (59.92%)</span><br><span class="line">                 0      instructions              #    0.00  insn per cycle           (67.35%)</span><br><span class="line">                 0      branches                  #    0.000 /sec                     (67.25%)</span><br><span class="line">                 0      branch-misses             #    0.00% of all branches          (40.08%)</span><br><span class="line"></span><br><span class="line">       0.018352520 seconds time elapsed</span><br><span class="line"></span><br><span class="line">       0.013756000 seconds user</span><br><span class="line">       0.004585000 seconds sys</span><br></pre></td></tr></table></figure><p>这里随便选了一个程序，比较简单，而且和tutorial中的比起来，该版本的perf默认没给出缓存相关的数据。</p><p><code>perf stat -e events:u/k</code>可以指定事件，后面的u/k表示测量用户的部分或内核的部分，默认是这两部分都测量，或者显式events:uk指定两部分都测量。</p><p>要测量多个事件，直接写在-e后面就可以了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perf stat -e cycles,instructions,cache-misses [...]</span><br></pre></td></tr></table></figure><p>这里发现虚拟机怎么测cache-misses之类的数据都是0，可能是虚拟机没有正常提供PMU接口(存疑)。</p><p><strong>multiplexing and scaling events</strong></p><p>如果事件比counters多，内核会使用时分复用，给每个事件监测硬件事件的机会。这个复用是只针对硬件事件的。事件的count计算的方式如下：</p><p>final_count = raw_count * time_enabled/time_running</p><p>每个事件只在一定的时间段被测量，所以数据并不是完全准确的，而是估计值。perf会根据事件占用counter的时间比例来对数据进行缩放，得到更接近真实值的结果。</p><p>例如stat结果是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2,809,725,593 cycles                    (scaled from 74.98%)</span><br></pre></td></tr></table></figure><p>后面的缩放因子74.98%就表示该事件只被测量了74.98%的时间。</p><p>时间复用会增加事件切换的开销，会影响程序的执行，要得到更准确的数据，应该尽量减少想要测量的事件数量。</p><p><strong>repeated measurement</strong></p><p>perf stat可以重复多次测量，只需要添加<code>-r round</code>就可以了。</p><h4 id="Options-controlling-environment-selection"><a href="#Options-controlling-environment-selection" class="headerlink" title="Options controlling environment selection"></a>Options controlling environment selection</h4><p>perf可以统计事件的不同范围，比如单个线程，单个进程，单个CPU。单个线程下，只监测指定线程的执行，单个进程下只监测进程及其子进程的执行。以下选项可以控制这些模式：</p><ul><li>-i,—no-inherit：只统计进程本身的事件，不包括子进程</li><li>-p,—pid <n\>：统计指定进程id的进程的事件</n\></li><li>-t,—tid <n\>：统计指定线程的事件</n\></li><li>-a,—all-cpus：统计所有CPU事件</li></ul><p>以下是一些示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">perf stat -e cycles -C 0 ./test#统计在CPU0上的事件</span><br><span class="line">perf stat -e cache-misses -p 1234#统计进程1234及子进程的事件</span><br><span class="line">perf stat -e instructions -t 5678 -C 1 -i#统计线程5678在CPU1的事件，不包括子线程</span><br><span class="line">perf stat -a sleep 10</span><br></pre></td></tr></table></figure><h4 id="Options-controlling-output"><a href="#Options-controlling-output" class="headerlink" title="Options controlling output"></a>Options controlling output</h4><p>-B可以输出US-style的数值(按千进行分位)，-x可以输出CSV格式的数据。</p><h3 id="3-使用perf-record"><a href="#3-使用perf-record" class="headerlink" title="3.使用perf record"></a>3.使用perf record</h3><p>record命令可以产生一个perf.data文件，可以进一步进行分析(使用report和annotate)。</p><h4 id="Event-based-sampling-overview"><a href="#Event-based-sampling-overview" class="headerlink" title="Event-based sampling overview"></a>Event-based sampling overview</h4><p>perf events是基于事件采样的，当采样计数器溢出时，就会记录一个样本。在计数器溢出时，内核记录了程序执行的信息，即一个样本。记录什么取决于测量的类型。这些都由用户和工具指定。但是所有样本中共有的关键信息是指令指针，即程序被中断时所在的位置。</p><p>基于中断的采样会发生偏移，因为样本中的指针是处理PMU中断的位置，而不是计数器实际溢出时的位置，所以在指令级别分析结果是，要注意<strong>偏移</strong>。</p><p>默认情况下，perf record使用cycles作为采样事件。以每个线程模式运行，会监测子线程。</p><h3 id="4-使用perf-report进行分析"><a href="#4-使用perf-report进行分析" class="headerlink" title="4.使用perf report进行分析"></a>4.使用perf report进行分析</h3><p>perf report可以读入perf record的结果进行分析。默认情况下采样是按照函数排序的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">perf report</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Events: 1K cycles</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Overhead          Command                   Shared Object  Symbol</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">........  ...............  ..............................  .....................................</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">    28.15%      firefox-bin  libxul.so                       [.] 0xd10b45</span></span><br><span class="line">     4.45%          swapper  [kernel.kallsyms]               [k] mwait_idle_with_hints</span><br><span class="line">     4.26%          swapper  [kernel.kallsyms]               [k] read_hpet</span><br><span class="line">     2.13%      firefox-bin  firefox-bin                     [.] 0x1e3d</span><br><span class="line">     1.40%  unity-panel-ser  libglib-2.0.so.0.2800.6         [.] 0x886f1</span><br><span class="line">     [...]</span><br></pre></td></tr></table></figure><p>Overhead列表示在相应函数中收集的总样本数的百分比。“Command”列报告了收集样本的进程。“Shared Object”列显示了样本来自的ELF镜像的名称。如果一个程序是动态链接的，那么这可能会显示共享库的名称。当样本来自内核时，那么使用伪ELF镜像名称[kernel.kallsyms]。“Symbol”列指示了采样时的特权级别，即程序在被中断时运行的级别：</p><ul><li>.：用户级</li><li>k：内核级</li><li>g：客户机内核级别</li><li>u：客户机操作系统用户空间</li><li>H：hypervisor</li></ul><p>Overhead可以有两个列，分别为children和self，self是函数自身的采样周期占比，而children是将所有子函数相加来计算的。添加<code>--children</code>选项就可以开启self这一列，默认的Overhead是children，即包含调用子函数的内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Children      Self  Symbol</span><br><span class="line">........  ........  ....................</span><br><span class="line"> 100.00%     0.00%  __libc_start_main</span><br><span class="line">          |</span><br><span class="line">          --- __libc_start_main</span><br><span class="line"></span><br><span class="line"> 100.00%     0.00%  main</span><br><span class="line">          |</span><br><span class="line">          --- main</span><br><span class="line">              __libc_start_main</span><br><span class="line"></span><br><span class="line"> 100.00%    40.00%  bar</span><br><span class="line">          |</span><br><span class="line">          --- bar</span><br><span class="line">              main</span><br><span class="line">              __libc_start_main</span><br><span class="line"></span><br><span class="line">  60.00%    60.00%  foo</span><br><span class="line">          |</span><br><span class="line">          --- foo</span><br><span class="line">              bar</span><br><span class="line">              main</span><br><span class="line">              __libc_start_main</span><br></pre></td></tr></table></figure><h3 id="5-使用perf-annotate进行源码级别的分析"><a href="#5-使用perf-annotate进行源码级别的分析" class="headerlink" title="5.使用perf annotate进行源码级别的分析"></a>5.使用perf annotate进行源码级别的分析</h3><p>为了使perf找到源码和符号信息，<strong>编译时要添加-g选项。</strong></p><p>perf annotate可以显示每一行代码或指令在采样事件中的占比及相关数据。</p><p>使用perf annotate需要先使用perf record命令保存数据，然后就可以用perf annotate来读取perf.data文件，并显示注释后的代码，-s选项可以指定函数或符号，也可以使用默认的最热点的函数和符号。</p><p>一些控制选项包括：-stdio可以输出纯文本格式，-source可以显示源码而不是汇编代码。</p><h3 id="6-尝试使用perf"><a href="#6-尝试使用perf" class="headerlink" title="6.尝试使用perf"></a>6.尝试使用perf</h3><p>阅读tutorial后，最重要的还是要实际尝试一下使用perf。重点需要尝试的是report和annotate。</p><p>首先进行record：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perf record -F 999 ./a#-F指定的是采样频率，每秒999次，不选整数是提高随机性，避免采样与周期性事件重合</span><br></pre></td></tr></table></figure><p>然后report看分析结果，这里又出现了问题，report的结果没有显示函数名，而是显示地址，发现是组件没有安装完全。回到perf的源码进行make，根据提示安装组件。然后再report，这次终于正确的进入了perf。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Samples: 26  of event &#x27;cycles&#x27;, Event count (approx.): 48071029</span><br><span class="line">Overhead  Command  Shared Object      Symbol</span><br><span class="line">  41.01%  a        a                  [.] initialize</span><br><span class="line">  20.74%  a        libc-2.31.so       [.] __random</span><br><span class="line">  12.78%  a        libc-2.31.so       [.] __random_r</span><br><span class="line">  12.44%  a        a                  [.] dot_product</span><br><span class="line">   6.48%  a        [kernel.kallsyms]  [k] page_mapping</span><br><span class="line">   6.34%  a        [kernel.kallsyms]  [k] sync_regs</span><br><span class="line">   0.20%  a        [kernel.kallsyms]  [k] set_root</span><br><span class="line">   0.02%  perf-ex  [kernel.kallsyms]  [k] native_write_msr</span><br></pre></td></tr></table></figure><p>光标可以移动，enter后再选择annotate就可以进入函数，看汇编级的hot code了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ea     0x0(,%rax,4),%rdx                         </span><br><span class="line">       │      mov     -0x18(%rbp),%rax                                                            </span><br><span class="line">       │      lea     (%rdx,%rax,1),%rsi</span><br><span class="line">       │      movslq  %ecx,%rax                                                                    </span><br><span class="line"> 15.71 │      imul    $0x66666667,%rax,%rax                                                        </span><br><span class="line">       │      shr     $0x20,%rax                                                                   </span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><p>如果想要直接找到在函数中的位置，而不是汇编级指令，单独执行命令perf annotate —stdio —symbol=函数名就可以看到函数中的hotcode数据(编译时需要添加-g)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">      : 17   long long dot_product(int *a, int *b)&#123;</span><br><span class="line"> 0.00 :   1257:   endbr64</span><br><span class="line"> 0.00 :   125b:   push   %rbp</span><br><span class="line"> 0.00 :   125c:   mov    %rsp,%rbp</span><br><span class="line"> 0.00 :   125f:   mov    %rdi,-0x18(%rbp)</span><br><span class="line"> 0.00 :   1263:   mov    %rsi,-0x20(%rbp)</span><br><span class="line">      : 13   long long res = 0;</span><br><span class="line"> 0.00 :   1267:   movq   $0x0,-0x8(%rbp)</span><br><span class="line">      : 14   for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line"> 0.00 :   126f:   movl   $0x0,-0xc(%rbp)</span><br><span class="line"> 0.00 :   1276:   cmpl   $0xf423f,-0xc(%rbp)</span><br><span class="line"> 0.00 :   127d:   jg     12ba &lt;dot_product(int*, int*)+0x63&gt;</span><br><span class="line">      : 15   res += a[i]*b[i];</span><br><span class="line"> 0.00 :   127f:   mov    -0xc(%rbp),%eax</span><br><span class="line"> 0.00 :   1282:   cltq</span><br><span class="line"> 0.00 :   1284:   lea    0x0(,%rax,4),%rdx</span><br><span class="line"> 0.00 :   128c:   mov    -0x18(%rbp),%rax</span><br><span class="line">50.02 :   1290:   add    %rdx,%rax</span><br><span class="line"> 0.00 :   1293:   mov    (%rax),%edx</span><br><span class="line">49.98 :   1295:   mov    -0xc(%rbp),%eax</span><br><span class="line"> 0.00 :   1298:   cltq</span><br><span class="line"> 0.00 :   129a:   lea    0x0(,%rax,4),%rcx</span><br><span class="line"> 0.00 :   12a2:   mov    -0x20(%rbp),%rax</span><br><span class="line"> 0.00 :   12a6:   add    %rcx,%rax</span><br><span class="line"> 0.00 :   12a9:   mov    (%rax),%eax</span><br></pre></td></tr></table></figure><h2 id="二-Vtune-Profiler"><a href="#二-Vtune-Profiler" class="headerlink" title="二.Vtune Profiler"></a>二.Vtune Profiler</h2><p>Vtune是intel开发的性能分析工具。支持windows，linux，macos平台。</p><p>在自己的PC安装Vtune，提示以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This analysis type is not applicable to the system because VTune Profiler cannot recognize the processor. If this is an old Intel processor, please refer to the minimum hardware requirements in the release note. If this is a new Intel processor, please check for an updated version of VTune Profiler. If this is an unreleased Intel processor, please contact Online Service Center for an NDA product package.</span><br></pre></td></tr></table></figure><p>想起来自己的笔记本是AMD处理器，问了一下new bing Vtune是否支持AMD处理器，回答是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">根据我搜索到的信息，AMD Ryzen 5 4600H 处理器是一款基于 Zen 2 微架构的 7 纳米处理器，它支持 SMT（同时多线程）技术，拥有 6 个物理核心和 12 个逻辑核心1。它的主频为 3.0 GHz，最大睿频为 4.0 GHz2。它还集成了 Radeon RX Vega 6 图形核心，拥有 6 个计算单元和 384 个流处理器2。</span><br><span class="line">根据 VTune Profiler 的官方文档3，该工具支持 AMD Ryzen 处理器，但是需要满足以下条件：</span><br><span class="line">安装了最新版本的 VTune Profiler（2021.3.0 或更高）4。</span><br><span class="line">在 BIOS 中启用了 AMD Core Performance Boost（CPB）和 AMD Hardware Prefetcher（HWP）。</span><br><span class="line">在 Windows 10 中安装了 AMD Ryzen Master 驱动程序。</span><br><span class="line">如果你的处理器满足了这些条件，那么你应该可以使用 VTune Profiler 来分析你的应用程序性能。如果你仍然遇到问题，你可以尝试以下步骤：</span><br><span class="line">检查你的 VTune Profiler 是否已经更新到最新版本，如果没有，你可以从 [Intel 官网] 下载并安装。</span><br><span class="line">检查你的 BIOS 设置是否正确，如果不确定，你可以参考 [AMD 官方指南] 来配置。</span><br><span class="line">检查你的 AMD Ryzen Master 驱动程序是否正常工作，如果没有，你可以从 [AMD 官网] 下载并安装。</span><br><span class="line">重启你的电脑，然后再次尝试使用 VTune Profiler。</span><br></pre></td></tr></table></figure><p>先下载个<a href="https://www.amd.com/zh-hans/technologies/ryzen-master">AMD Ryzen Master</a>。结果是不支持当前处理器，去查了一下，移动端是不能使用这个工具的(?不能随便超频)，因此没办法尝试了。</p>]]></content>
      
      
      <categories>
          
          <category> 高性能计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenMP</title>
      <link href="/2023/10/27/OpenMP/"/>
      <url>/2023/10/27/OpenMP/</url>
      
        <content type="html"><![CDATA[<p>OpenMP笔记。由于曾经学习过，这一遍就简单过一下。</p><p>学习内容来自：</p><p><a href="https://lemon-412.github.io/imgs/20200516OpenMP_simple_Program.pdf">https://lemon-412.github.io/imgs/20200516OpenMP_simple_Program.pdf</a></p><p><a href="https://hpc-wiki.info/hpc/OpenMP">https://hpc-wiki.info/hpc/OpenMP</a></p><p><a href="https://www.easyhpc.net/course/10/lesson/107/material/128">https://www.easyhpc.net/course/10/lesson/107/material/128</a></p><p>常看手册：<a href="https://www.openmp.org/wp-content/uploads/openmp-examples-4.5.0.pdf">https://www.openmp.org/wp-content/uploads/openmp-examples-4.5.0.pdf</a></p><p>主要的内容来自第一个文档，第三个文档有一些数据相关的条件下寻找并行性的例子，没有做笔记但是值得看一下。</p><span id="more"></span><p>OpenMP是一组编译制导语句和库函数，用来表达程序中的并行性。</p><p>OpenMP面向共享存储体系结构，特别是SMP系统，</p><h2 id="一-OpenMP的使用"><a href="#一-OpenMP的使用" class="headerlink" title="一.OpenMP的使用"></a>一.OpenMP的使用</h2><p>OpenMP在IDE中配置属性中通常有选择项可开启，如果直接编译，只需要在编译时添加<strong>-fopenmp</strong>。</p><h3 id="1-并行执行模式"><a href="#1-并行执行模式" class="headerlink" title="1.并行执行模式"></a>1.并行执行模式</h3><p>OpenMP采用fork/join模式，开始时只有一个主线程，串行部分都由主线程执行，并行部分产生其他线程来执行。</p><p><img src="/2023/10/27/OpenMP/image-20231027205749814.png" alt="image-20231027205749814" style="zoom:33%;"></p><h3 id="2-制导指令"><a href="#2-制导指令" class="headerlink" title="2.制导指令"></a>2.制导指令</h3><p>在C/C++中，OpenMP的格式均为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp 指令 子句</span></span><br></pre></td></tr></table></figure><p>其中指令有以下一些：</p><ul><li>parallel</li><li>for</li><li>parallel for</li><li>sections</li><li>parallel sections</li><li>critical</li><li>single</li><li>barrier</li><li>atomic</li><li>master</li><li>ordered</li><li>threadprivate</li></ul><p>子句有：</p><ul><li>private：线程私有变量</li><li>firstprivate：线程有变量私有副本，并且要继承主线程中的初值</li><li>lastprivate：将私有变量的值并行处理结束后复制回主线程的变量</li><li>reduce：一个或多个变量私有，最后要执行特定操作</li><li>nowait：忽略默认的等待</li><li>num_threads：指定线程的个数</li><li>schedule：指定如何调度</li><li>shared：指定共享变量</li><li>ordered：指定循环顺序执行</li><li>copyprivate：single的指定变量变为多个线程共享</li><li>copyin：指定threadprivate的变量的值用主线程的值初始化</li></ul><p>而库函数包括：</p><ul><li>omp_get_num_procs</li><li>omp_get_num_threads</li><li>omp_get_thread_num</li><li>omp_set_num_threads</li><li>omp_init_lock</li><li>omp_set_lock</li><li>omp_unset_lock</li><li>omp_destroy_lock</li></ul><h3 id="3-并行子句的使用"><a href="#3-并行子句的使用" class="headerlink" title="3.并行子句的使用"></a>3.并行子句的使用</h3><p><strong>parallel</strong></p><p>parallel子句可构造一个并行块：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel num_threads(8)</span></span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;parallel\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于重复调用创建线程完成并行块中的内容。</p><p><strong>for</strong></p><p>要与parallel结合使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#prama omp parallel for</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt;i&lt;&lt; <span class="string">&quot; Threadid=&quot;</span> &lt;&lt;<span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>for语句中的三个子句必须符合规范，第一个是赋值，第二个是与边界值比较，第三个是i++，i—等。</p><p><strong>sections</strong></p><p>sections将块中代码划分为不同section，然后并行执行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel sections &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line"><span class="built_in">printf</span>(“section <span class="number">1</span> ThreadId = %d\n”, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line"><span class="built_in">printf</span>(“section <span class="number">2</span> ThreadId = %d\n”, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line"><span class="built_in">printf</span>(“section <span class="number">3</span> ThreadId = %d\n”, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line"><span class="built_in">printf</span>(“section <span class="number">4</span> ThreadId = %d\n”, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用sections划分要保证各个section中的代码执行时间相差不大，才能保证并行执行的效果。</p><p><strong>barrier</strong></p><p>barrier是同步指令，插入barrier后，所有线程都到达barrier后才会向后继续执行。</p><p>例如以下程序，没有barrier就可能会有线程提前访问sum，输出不稳定的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel  </span></span><br><span class="line"><span class="built_in">cal_sum</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp barrier</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i=%d, thread_id=%d\n&quot;</span>, sum,<span class="built_in">omp_get_thread_num</span>());</span><br></pre></td></tr></table></figure><p>一些指令是会隐式同步的，如for，single，parallel，可以使用nowait子句来消除隐式同步。</p><h3 id="4-数据处理子句的使用"><a href="#4-数据处理子句的使用" class="headerlink" title="4.数据处理子句的使用"></a>4.数据处理子句的使用</h3><p><strong>private</strong></p><p>private子句用于将一个或多个变量声明成线程私有变量，指定每个线程都有私有副本。(同名共享变量将在并行区不起作用)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k = <span class="number">100</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for private(k)</span></span><br><span class="line"><span class="keyword">for</span> ( k=<span class="number">0</span>; k &lt; <span class="number">10</span>; k++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;k=%d\n&quot;</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;last k=%d\n&quot;</span>, k);</span><br></pre></td></tr></table></figure><p>最终输出的k是100，而并行区域中的k也不会继承共享变量k的值。</p><p><strong>firstprivate</strong></p><p>如果需要私有变量继承共享变量的值，可以使用firstprivate子句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k = <span class="number">100</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for firstprivate(k)</span></span><br><span class="line"><span class="keyword">for</span> ( i=<span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">    k+=i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;k=%d\n&quot;</span>,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;last k=%d\n&quot;</span>, k);</span><br></pre></td></tr></table></figure><p>最终会输出k=100(101，102，103) last k = 100。即私有的k继承了共享的k值，但不会修改共享的k。</p><p><strong>lastprivate</strong></p><p>如果要在退出并行区域时将最终的私有变量取值赋值给对应共享变量，可使用lastprivate子句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k = <span class="number">100</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for firstprivate(k),lastprivate(k)</span></span><br><span class="line"><span class="keyword">for</span> ( i=<span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">    k+=i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;k=%d\n&quot;</span>,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;last k=%d\n&quot;</span>, k);</span><br></pre></td></tr></table></figure><p>最后last k = 103。如果是循环迭代，则是最后一次循环的值，如果是sections，则是最后一个section中的值。</p><p><strong>threadprivate</strong></p><p>该子句指定各个线程都复制一个全局变量的私有拷贝：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp threadprivate(counter)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">increment_counter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">    <span class="keyword">return</span>(counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>shared</strong></p><p>shared子句用来声明变量为共享变量。如果要写变量，需要注意对其进行保护。</p><p><strong>default</strong></p><p>default(shared|none)可指定默认情况下，变量是否被视为共享变量。如果取值为none，则必须明确指定使用到的变量是共享的还是私有的。</p><p><strong>reduction</strong></p><p>reduction指定对一个或多个参数指定一个操作符，线程首先创建一个私有拷贝进行计算，在并行区域结束处对值进行指定计算，更新原始参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, sum = <span class="number">100</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for reduction(+: sum)</span></span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ )&#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;sum = %ld\n&quot;</span>, sum);</span><br></pre></td></tr></table></figure><p><strong>copyin</strong></p><p>copyin中的参数必须被声明为threadprivate，并有明确的拷贝赋值，用于将主线程中threadprivate的值拷贝到并行区域中的threadprivate变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> iterator;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel sections copyin(counter)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> count1;</span><br><span class="line">            <span class="keyword">for</span> ( iterator = <span class="number">0</span>; iterator &lt; <span class="number">100</span>; iterator++ )&#123;</span><br><span class="line">                count1 = <span class="built_in">increment_counter</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;count1 = %ld\n&quot;</span>, count1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> count2;</span><br><span class="line">            <span class="keyword">for</span> ( iterator = <span class="number">0</span>; iterator &lt; <span class="number">200</span>; iterator++ )&#123;</span><br><span class="line">            count2 = <span class="built_in">increment_counter</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;count2 = %ld\n&quot;</span>, count2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;counter = %ld\n&quot;</span>, counter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">打印结果如下：</span></span><br><span class="line"><span class="comment">count1 = 100</span></span><br><span class="line"><span class="comment">count2 = 200</span></span><br><span class="line"><span class="comment">counter = 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>copyprivate</strong></p><p>该子句可将一个私有变量值广播到执行同一并行区域的其他线程。copyprivate子句可以关联single构造，可以对private和threadprivate子句中的变量进行操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp threadprivate(counter)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">increment_counter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">    <span class="keyword">return</span>(counter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp single copyprivate(counter)</span></span><br><span class="line">    &#123;</span><br><span class="line">    counter = <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    count = <span class="built_in">increment_counter</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ThreadId: %ld, count = %ld\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">打印结果为：</span></span><br><span class="line"><span class="comment">ThreadId: 2, count = 51</span></span><br><span class="line"><span class="comment">ThreadId: 0, count = 51</span></span><br><span class="line"><span class="comment">ThreadId: 3, count = 51</span></span><br><span class="line"><span class="comment">ThreadId: 1, count = 51</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="5-任务调度"><a href="#5-任务调度" class="headerlink" title="5.任务调度"></a>5.任务调度</h3><p>OpenMP中的任务调度主要用于并行for循环，因为循环中迭代的计算量常常不相等，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>][<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=i;j&lt;<span class="number">100</span>;j++)&#123;</span><br><span class="line">    a[i][j] = i*j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最外层并行化后，假设有4个线程，每个线程执行25次循环，i为0-25和i为75-99显然计算量有很大差别，出现较大的负载不平衡问题。OpenMP通过schedule子句进行任务调度。</p><p>schedule子句的格式为<strong>schedule(type[,size])</strong>，size参数是可选的，调度类型有：</p><ul><li>dynamic</li><li>guided</li><li>runtime</li><li>static</li></ul><p>runtime是根据环境变量选择另外三种之一。</p><p>size参数表示循环迭代次数，必须是整数，可以不使用该参数。</p><p><strong>静态调度</strong></p><p>没有schedule子句时，默认使用静态调度，通常使用平均分配n/t个循环给每个线程。如果指定size，会依次给每个线程分配size次连续迭代计算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for schedule(static, 2)</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i=%d, thread_id=%d\n&quot;</span>, i, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>thread1分配到迭代0,1,4,5,8,9。</p><p><strong>动态调度</strong></p><p>动态调度动态地将迭代分配到各个线程，可使用size参数，使用size后会每次分配给线程指定size次迭代。</p><p><strong>guided</strong></p><p>guided调度时一种启发式自调度方法，开始时每个线程会分配到较大的迭代块，之后分配到的迭代块会逐渐递减，指数下降到size(未指定则降到1)。</p><h3 id="6-锁"><a href="#6-锁" class="headerlink" title="6.锁"></a>6.锁</h3><p>参考文档的作者给出了一份测试OpenMP中锁和原子操作性能的比较，测试代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestAtomic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">clock_t</span> t1, t2;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> LONG a = <span class="number">0</span>;</span><br><span class="line">    t1 = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2000000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">InterlockedIncrement</span>(&amp;a);</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;SingleThread, InterlockedIncrement 2,000,000: a = %ld, time = %ld\n&quot;</span>,</span><br><span class="line">        a, t2 - t1);</span><br><span class="line">    t1 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2000000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">InterlockedIncrement</span>(&amp;a);</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MultiThread, InterlockedIncrement 2,000,000: a = %ld, time = %ld\n&quot;</span>,</span><br><span class="line">           a, t2 - t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestOmpLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">clock_t</span> t1, t2;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">omp_lock_t</span> mylock;</span><br><span class="line">    <span class="built_in">omp_init_lock</span>(&amp;mylock);</span><br><span class="line">    t1 = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2000000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">omp_set_lock</span>(&amp;mylock);</span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">omp_unset_lock</span>(&amp;mylock);</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SingleThread,omp_lock 2,000,000:a = %ld, time = %ld\n&quot;</span>, a, t2 - t1);</span><br><span class="line">    t1 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2000000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">omp_set_lock</span>(&amp;mylock);</span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">omp_unset_lock</span>(&amp;mylock);</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MultiThread,omp_lock 2,000,000:a = %ld, time = %ld\n&quot;</span>, a, t2 - t1);</span><br><span class="line">    <span class="built_in">omp_destroy_lock</span>(&amp;mylock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestCriticalSection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">clock_t</span> t1, t2;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    CRITICAL_SECTION cs;</span><br><span class="line">    <span class="built_in">InitializeCriticalSection</span>(&amp;cs);</span><br><span class="line">    t1 = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2000000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">EnterCriticalSection</span>(&amp;cs);</span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">LeaveCriticalSection</span>(&amp;cs);</span><br><span class="line">    &#125;</span><br><span class="line">    t2 = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SingleThread, Critical_Section 2,000,000:a = %ld, time = %ld\n&quot;</span>, a,</span><br><span class="line">           t2 - t1);</span><br><span class="line">    t1 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2000000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">EnterCriticalSection</span>(&amp;cs);</span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">LeaveCriticalSection</span>(&amp;cs);</span><br><span class="line">        <span class="number">24</span> / <span class="number">28</span></span><br><span class="line">    &#125;</span><br><span class="line">    t2 = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MultiThread, Critical_Section, 2,000,000:a = %ld, time = %ld\n&quot;</span>, a,</span><br><span class="line">           t2 - t1);</span><br><span class="line">    <span class="built_in">DeleteCriticalSection</span>(&amp;cs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">TestAtomic</span>();</span><br><span class="line">    <span class="built_in">TestCriticalSection</span>();</span><br><span class="line">    <span class="built_in">TestOmpLock</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行了一下，结果是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SingleThread, InterlockedIncrement 2,000,000: a = 2000000, time = 16</span><br><span class="line">MultiThread, InterlockedIncrement 2,000,000: a = 4000000, time = 64</span><br><span class="line">SingleThread, Critical_Section 2,000,000:a = 2000000, time = 34</span><br><span class="line">MultiThread, Critical_Section, 2,000,000:a = 4000000, time = 331</span><br><span class="line">SingleThread,omp_lock 2,000,000:a = 2000000, time = 111</span><br><span class="line">MultiThread,omp_lock 2,000,000:a = 4000000, time = 11315</span><br></pre></td></tr></table></figure><p>锁明显更慢，不过这个测试结果和作者的不一样，显然是受一些其他因素影响的。</p><h3 id="7-性能优化"><a href="#7-性能优化" class="headerlink" title="7.性能优化"></a>7.性能优化</h3><p><strong>动态设置并行循环的线程数量</strong></p><p>并行循环的线程数量应该考虑到，循环次数比较少时，不应使用过多线程，且线程数量不应该远大于CPU核数。</p><p>以下是一个例子(在学习std::thread时，也有一个类似的例子，使用std::thread::hard_concurrency()来确定线程数量)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> g_ncore = <span class="built_in">omp_get_num_procs</span>(); <span class="comment">//获取执行核的数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dtn</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> min_n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> max_tn = n / min_n;</span><br><span class="line">    <span class="type">int</span> tn = max_tn &gt; g_ncore ? g_ncore : max_tn; <span class="comment">// tn 表示要设置的线程数量</span></span><br><span class="line">    <span class="keyword">if</span> (tn &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        tn = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每次并行化时直接使用函数来获取合适的线程数量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for num_threads(dtn(n, MIN_ITERATOR_NUM))</span></span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n; i++ )&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread Id = %ld\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>嵌套循环的并行化</strong></p><p>嵌套循环中，如果外层循环迭代次数较少时，很难通过调度达到负载的平衡，有时可以通过将外层循环和内层的一层循环合并来提高外层循环的迭代次数。参考文档中给出了一个矩阵乘法的优化例子。</p><p><strong>其他</strong></p><ul><li>减少创建线程的开销：使用线程池</li><li>提高对局部性的利用：使用线程私有变量，复制数据副本为多线程使用</li><li>用尽可能大的并行区，减小启动开销；消除不必要的隐式同步(nowait)</li><li>最小化数据依赖：使用私有变量消除依赖，选择合适的同步方式，尽可能少的使用同步，减少临界区，尽量使用reduction或原子性操作</li><li>选择合适的调度策略</li></ul><p><strong>核绑定</strong></p><p>有三种方式：spread，close，master，详见<a href="https://www.openmp.org/wp-content/uploads/openmp-examples-4.5.0.pdf。">https://www.openmp.org/wp-content/uploads/openmp-examples-4.5.0.pdf。</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#prama omp parallel for proc_bind(close)</span></span><br></pre></td></tr></table></figure><p>除了程序中绑定，也可以使用环境变量绑定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export OMP_NUM_THREADS=8</span><br><span class="line">export OMP_PROC_BIND=close#false spread</span><br><span class="line">export OMP_PLACES=cores#sockets threads numa_domains..</span><br></pre></td></tr></table></figure><h2 id="二-练习"><a href="#二-练习" class="headerlink" title="二.练习"></a>二.练习</h2><h3 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e8</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MIN_SIZE = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cores = <span class="built_in">omp_get_num_procs</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dtn</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> max_tn = N/MIN_SIZE;</span><br><span class="line">    <span class="type">int</span> tn = max_tn &gt; cores ? cores : max_tn;</span><br><span class="line">    <span class="keyword">if</span>(tn&lt;<span class="number">1</span>) tn = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> tn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        a[i] = <span class="built_in">rand</span>()%<span class="number">100</span>;</span><br><span class="line">        b[i] = <span class="built_in">rand</span>()%<span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dot_product_serial</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        sum += a[i]*b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dot_product_parallel</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, i;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for reduction(+:sum) num_threads(dtn())</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        sum += a[i]*b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> *a = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    <span class="type">int</span> *b = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line">    <span class="type">int</span> res_serial, res_parallel;</span><br><span class="line">    <span class="type">clock_t</span> start,end;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">initialize</span>(a,b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//串行计算</span></span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    res_serial = <span class="built_in">dot_product_serial</span>(a,b,N);</span><br><span class="line">    end = <span class="built_in">clock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;serial calculation time is &quot;</span> &lt;&lt; (<span class="type">double</span>)(end-start)/CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//并行计算</span></span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    res_parallel = <span class="built_in">dot_product_parallel</span>(a,b,N);</span><br><span class="line">    end = <span class="built_in">clock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;parallel calculation time is &quot;</span> &lt;&lt; (<span class="type">double</span>)(end-start)/CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span>[] a;</span><br><span class="line">    <span class="keyword">delete</span>[] b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><p>serial calculation time is 0.325s<br>parallel calculation time is 0.045s</p><p>如果将reduction改为原子性操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dot_product_parallel</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; sum;                </span><br><span class="line">    <span class="built_in">atomic_init</span>(&amp;sum, <span class="number">0</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for num_threads(dtn())</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        sum.<span class="built_in">fetch_add</span>(a[i]*b[i]);   <span class="comment">//原子+=</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则结果为：</p><p>serial calculation time is 0.315s<br>parallel calculation time is 1.552s</p><p>使用锁的时间当然更长：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dot_product_parallel</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;                </span><br><span class="line">    <span class="type">omp_lock_t</span> mtx;</span><br><span class="line">    <span class="built_in">omp_init_lock</span>(&amp;mtx);</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for num_threads(dtn())</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="built_in">omp_set_lock</span>(&amp;mtx);</span><br><span class="line">        sum += a[i]*b[i]; </span><br><span class="line">        <span class="built_in">omp_unset_lock</span>(&amp;mtx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于反复上锁，比串行时间长得多。(太久了因此手动中断了计算)。</p><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>由于对矩阵的初始化也可以并行完成，这里尝试一下不同并行方式的时间，首先是只对for循环并行化，静态调度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize_parallel</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for num_threads(dtn())</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;r_a;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;c_a;j++)&#123;</span><br><span class="line">            a[i*c_a+j] = <span class="built_in">rand</span>()%<span class="number">100</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for num_threads(dtn())</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;r_b;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;c_b;j++)&#123;</span><br><span class="line">            b[i*c_b+j] = <span class="built_in">rand</span>()%<span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间为0.076s。</p><p>尝试修改为动态调度，时间为0.068s，因为这里对外层均分后，负载是均衡的，因此静态分配就可以了。</p><p>最后让两个矩阵的初始化并行执行，时间为0.25s，明显快多了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize_parallel</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel sections</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> omp parallel for num_threads(dtn()) </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;r_a;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;c_a;j++)&#123;</span><br><span class="line">                    a[i*c_a+j] = <span class="built_in">rand</span>()%<span class="number">100</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> omp parallel for num_threads(dtn()) </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;r_b;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;c_b;j++)&#123;</span><br><span class="line">                    b[i*c_b+j] = <span class="built_in">rand</span>()%<span class="number">100</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并行化计算的完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_COL = <span class="number">1e6</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MIN_SIZE = <span class="number">1e4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cores = <span class="built_in">omp_get_num_procs</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> r_a = <span class="number">1e3</span>, c_a = <span class="number">1e4</span>, r_b = <span class="number">1e4</span>, c_b = <span class="number">1e3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dtn</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> max_tn = MAX_COL/MIN_SIZE;</span><br><span class="line">    <span class="type">int</span> tn = max_tn &gt; cores ? cores : max_tn;</span><br><span class="line">    <span class="keyword">if</span>(tn&lt;<span class="number">1</span>) tn = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> tn;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize_parallel</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel sections</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> omp parallel for num_threads(dtn()) </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;r_a;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;c_a;j++)&#123;</span><br><span class="line">                    a[i*c_a+j] = <span class="built_in">rand</span>()%<span class="number">100</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> omp parallel for num_threads(dtn()) </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;r_b;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;c_b;j++)&#123;</span><br><span class="line">                    b[i*c_b+j] = <span class="built_in">rand</span>()%<span class="number">100</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">verify</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;r_a;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;c_b;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i*c_b+j]!=b[i*c_b+j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">matrix_multiple_ser</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> *c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;r_a;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;c_b;j++)&#123;</span><br><span class="line">            <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;c_a;k++)&#123;</span><br><span class="line">                val += a[i*c_a+k]*b[k*c_b+j];</span><br><span class="line">            &#125;</span><br><span class="line">            c[i*c_b+j] = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">matrix_multiple_par</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> *c)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,val,num_threads;</span><br><span class="line">    num_threads = <span class="built_in">dtn</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num of threads is &quot;</span> &lt;&lt; num_threads &lt;&lt; std::endl; </span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for num_threads(num_threads) private(val,j)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;r_a;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;c_b;j++)&#123;</span><br><span class="line">            val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;c_a;k++)&#123;</span><br><span class="line">                val += a[i*c_a+k]*b[k*c_b+j];</span><br><span class="line">            &#125;</span><br><span class="line">            c[i*c_b+j] = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> *matrix_a = <span class="keyword">new</span> <span class="type">int</span>[r_a*c_a];</span><br><span class="line">    <span class="type">int</span> *matrix_b = <span class="keyword">new</span> <span class="type">int</span>[r_b*c_b];</span><br><span class="line">    <span class="type">int</span> *matrix_c = <span class="keyword">new</span> <span class="type">int</span>[r_a*c_b];</span><br><span class="line">    <span class="type">int</span> *matrix_d = <span class="keyword">new</span> <span class="type">int</span>[r_a*c_b];</span><br><span class="line">    <span class="type">clock_t</span> start,end;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//initialize</span></span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">initialize_parallel</span>(matrix_a, matrix_b);</span><br><span class="line">    end = <span class="built_in">clock</span>();</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;initialize_parallel time is &quot;</span> &lt;&lt; (<span class="type">double</span>)(end-start)/CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//calculation</span></span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">matrix_multiple_ser</span>(matrix_a, matrix_b, matrix_c);</span><br><span class="line">    end = <span class="built_in">clock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;serial calculation time is &quot;</span> &lt;&lt; (<span class="type">double</span>)(end-start)/CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">matrix_multiple_par</span>(matrix_a,matrix_b,matrix_d);</span><br><span class="line">    end = <span class="built_in">clock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;parallel calculation time is &quot;</span> &lt;&lt; (<span class="type">double</span>)(end-start)/CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//verify</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">verify</span>(matrix_c,matrix_d)) std::cout &lt;&lt; <span class="string">&quot;correct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;wrong anwser!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] matrix_a;</span><br><span class="line">    <span class="keyword">delete</span>[] matrix_b;</span><br><span class="line">    <span class="keyword">delete</span>[] matrix_c;</span><br><span class="line">    <span class="keyword">delete</span>[] matrix_d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initialize_parallel time is 0.242s</span><br><span class="line">serial calculation time is 33.917s</span><br><span class="line">num of threads is 12</span><br><span class="line">parallel calculation time is 7.139s</span><br><span class="line">correct</span><br></pre></td></tr></table></figure><p>再尝试循环展开，基本不影响计算时间。</p><p>将循环顺序调整为ikj：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">matrix_multiple_par</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> *c)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k,val,num_threads;</span><br><span class="line">    num_threads = <span class="built_in">dtn</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num of threads is &quot;</span> &lt;&lt; num_threads &lt;&lt; std::endl; </span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for num_threads(num_threads) private(val,j,k)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;r_a;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;c_a;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;c_b;j++)&#123;</span><br><span class="line">                c[i*c_b+j] += a[i*c_a+k]*b[k*c_b+j];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initialize_parallel time is 0.238s</span><br><span class="line">serial calculation time is 33.101s</span><br><span class="line">num of threads is 12</span><br><span class="line">parallel calculation time is 5.274s</span><br><span class="line">correct</span><br></pre></td></tr></table></figure><p>尝试一下O3优化，结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initialize_parallel time is 0.149s</span><br><span class="line">serial calculation time is 13.204s</span><br><span class="line">num of threads is 12</span><br><span class="line">parallel calculation time is 0.495s</span><br><span class="line">correct</span><br></pre></td></tr></table></figure><p>整体时间大幅减少。这也可以看出上面的并行版本还有非常大的优化空间，包括使用AVX，缓存优化及转置等。</p><h2 id="三-问题"><a href="#三-问题" class="headerlink" title="三.问题"></a>三.问题</h2><p>这部分内容来自<a href="https://heptagonhust.github.io/HPC-roadmap/：">https://heptagonhust.github.io/HPC-roadmap/：</a></p><ul><li>什么是OpenMP？有什么作用？<ul><li>OpenMP是一套支持跨平台共享内存方式的多线程并发的编程API。</li><li>OpenMP可用于并行算法的多线程实现。</li></ul></li><li>什么是数据依赖？什么是数据冲突？如何解决？(这里还有一个概念是数据相关，和数据依赖是基本一致的概念。)<ul><li>数据相关是流水线中操作数之间的依赖关系。对应三种数据依赖。</li><li>数据依赖是指一条指令依赖于另外一条指令执行的结果，有三种类型(WAR反相关，RAW真相关，WAW输出相关)，是数据相关的根源。(在Tomasulo算法中，反相关和输出相关都是可以靠保留站实现寄存器重命名而避免冲突的)</li><li>数据冲突是在流水线中由于数据依赖(数据相关)导致的冲突。</li><li>解决数据冲突的方式有：指令重排序，暂停流水线，转发，寄存器重命名。</li></ul></li><li>什么是原子操作？为什么需要原子操作？<ul><li>原子操作是不会被打断的操作，可以保证数据的一致性，避免竞态条件，在多线程程序对共享资源的访问中需要保证操作的原子性。</li><li>对原子变量的操作可以使用std::atomic，在OpenMP中也可以使用atomic子句，只能用于单条赋值语句，但是比锁更高效。</li></ul></li><li>我该选择多少线程来运行呢？线程数量越多越好吗？<ul><li>线程数不应远大于核数，并且单个线程的工作不能太小。</li></ul></li><li>我的代码运行正确吗？如何检验优化后代码运行的正确性？<ul><li>在编写代码时，一定要先实现最简单的串行算法，以验证结果的正确性。</li></ul></li><li>和pthread的区别与联系？<ul><li>OpenMP是基于<strong>编译器指令</strong>的并行编程模型，而pthread是基于POSIX标准的线程库。</li><li>OpenMP简单易用，但是功能有限，不能使用条件变量，信号量等，不能表达复杂的线程交互与同步。用于简单的数据并行或任务并行。</li><li>OpenMP可以使用pthread作为底层实现(gcc就是这样做的)。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 高性能计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超算竞赛导引</title>
      <link href="/2023/10/27/%E8%B6%85%E7%AE%97%E7%AB%9E%E8%B5%9B%E5%AF%BC%E5%BC%95/"/>
      <url>/2023/10/27/%E8%B6%85%E7%AE%97%E7%AB%9E%E8%B5%9B%E5%AF%BC%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p> 超算竞赛导引。</p><span id="more"></span><h2 id="第一课-超算的发展与应用"><a href="#第一课-超算的发展与应用" class="headerlink" title="第一课 超算的发展与应用"></a>第一课 超算的发展与应用</h2><p>研究超级计算机的目的：</p><ul><li>促进计算机科学和技术的发展</li><li>推动交叉学科发展，解决巨大挑战性问题</li><li>反映经济与科技的综合实力</li></ul><p><strong>超算的发展</strong></p><p>SIMD阵列处理机→流水结构向量机→MIMD共享主存多处理机→并行向量处理机(采用超标量)→MPP系统(高度并行，多至上万的处理机组成，可用NUMA、超节点或向量+超标量构成)→集群系统(早期同构，现在多采用异构，CPU+GPU或CPU+MIC(many integrated core))</p><p>当今主流的超算是集群系统，但MPP仍占有相当的比例。目前P级(每秒10^15次计算)的计算机已经成熟，E级超算已在2022年由美国推出的Frontier实现，国内的E级超算好像没有明确的消息。</p><p><strong>超算架构</strong></p><p>超算的架构分类可按并行计算方式是SIMD还是MIMD，存储器是共享的还是分布的加以分类。当今的超算大多以MIMD工作，存储器共享的有MVP(多向量机)和SMP(多处理器)两种，又称为UMA系统，处理器对任何存储单元有相同的访问时间。相对的有NUMA系统，存储器是分布的，但是<strong>处理器可对远程存储器以load-store形式直接访问</strong>，根据硬件是否支持缓存一致性，还可以继续进行分类。</p><p>如果并行处理器必须以消息传递方式访问远程存储器，就是NOARMA(no remote memory access)系统，这种系统中每个处理器是一个独立的计算机。MPP和集群系统都属于NOARMA系统。</p><p>MPP使用大量商用处理节点，用高带宽低时延的网络连接。而集群系统的每个节点是一个完整计算机，也可以是一台SMP或PC，每个节点有OS和支持单一系统映像的中间件。</p><p><strong>并行程序设计算法</strong></p><p>并行算法已经发展出了一些基本范例：</p><ul><li>阶段并行：每个阶段有计算阶段和交互阶段构成，多个阶段完成全部任务。</li><li>分治并行：将问题分解后并行计算。</li><li>宏流水并行：将问题分解为若干子任务，如流水线一样分别执行子任务，数据只在相邻阶段间传送。</li><li>主从并行：主进程完成基本顺序部分和协调操作，通常使用静态负载平衡方法。</li><li>工作池并行算法：使用全局数据结构，空闲进程从进程池获取任务，这种算法是动态分配负载的，但实现比较困难。</li></ul><p>还有三种并行编程模型：</p><ul><li>共享变量</li><li>消息传递</li><li>数据并行</li></ul><p>一些程序设计方法，需要练习使用：</p><ul><li>增量式改进</li><li>存储空间换取性能</li><li>Cache行的垫衬消除假共享</li><li>共享变量变为私有变量，设置重叠区域</li><li>选择适当的数据块分配方式</li></ul><h2 id="第二课-超算集群系统的构建及功耗管理"><a href="#第二课-超算集群系统的构建及功耗管理" class="headerlink" title="第二课 超算集群系统的构建及功耗管理"></a>第二课 超算集群系统的构建及功耗管理</h2><h3 id="1-集群组成"><a href="#1-集群组成" class="headerlink" title="1.集群组成"></a>1.集群组成</h3><p>典型的HPC集群由五类计算设备和三类网络组成：</p><ul><li>登录节点：访问集群的唯一入口，为了保证用户数据安全性，至少采用RAID或双机热备份容错</li><li>管理节点：监控集群中节点和网络的运行状态，集群的管理软件也运行在这个节点上</li><li>计算节点：分为两种，痩节点主要用于执行并行计算，主流采用刀片服务器；胖节点用于数据划分或对内存需求大的特殊应用运算等，内存容量大，价格也比较昂贵</li><li>异构节点：通常使用CPU，GPU或MIC</li><li>交换设备：通常为有几百个端口的大型交换机</li><li>I/O节点和存储设备：由于高性能计算需要较大存储空间及高带宽，因此存储设备一般是专业的文件存储系统</li><li>管理网络：用于管理节点和节点互连</li><li>计算网络：并行任务执行时的进程间通信专用网络，对网络的带宽和延迟要求都很高，因此一般选用千兆网，IB或万兆网</li><li>存储网络：向HPC集群的节点提供数据访问服务</li></ul><h3 id="2-功耗监控与管理"><a href="#2-功耗监控与管理" class="headerlink" title="2.功耗监控与管理"></a>2.功耗监控与管理</h3><p>常见的低功耗技术分为两类：</p><ul><li>动态资源休眠(DRS)：休眠或关闭空闲资源，需要时再动态唤醒</li><li>动态速率调节(DSS)：动态调节设备的运行速率</li></ul><p>目前的商用处理器都支持这两种低功耗机制。</p><p>对于集群的能耗监控，第一个层次是对整集群监控，单位是每个机柜，第二个层次是以节点为单位。</p><h3 id="3-构建性能均衡的超算系统"><a href="#3-构建性能均衡的超算系统" class="headerlink" title="3.构建性能均衡的超算系统"></a>3.构建性能均衡的超算系统</h3><p>这一部分介绍了考虑系统性能均衡的一些方面，以及管理系统的一些概念性内容。</p><h2 id="第三课-超算系统的网络通信"><a href="#第三课-超算系统的网络通信" class="headerlink" title="第三课 超算系统的网络通信"></a>第三课 超算系统的网络通信</h2><p>主流网络互连技术包括以太网，FC和InfiniBand，FC是用于存储互连网络的，而以太网和InfiniBand都是用于开放网络互连，但InfiniBand拥有性能优势，且具备SDN属性，目前已是高性能计算领域最为广泛应用的网络。</p><h3 id="1-概要"><a href="#1-概要" class="headerlink" title="1.概要"></a>1.概要</h3><p>InfiniBand可以以极低的CPU负荷来实现多种网络流量类型的高性能网络。架构介绍如下：</p><p><strong>HCA</strong></p><p>网络最终节点，实现服务器、存储与网络的连接。HCA之间通过通道互通，称为队列组，由发送队列和接收队列组成，应用可以直接访问HCA资源，不需要依赖OS。</p><p><strong>TCA</strong></p><p>内嵌系统定义的适配器架构，只用于很小的领域。</p><p><strong>网络交换机</strong></p><p>InfiniBand采用直通转发技术，实现网络流量的快速传递，交换机实现链路层数据流控制机制保证数据包不丢失。</p><p><strong>路由器</strong></p><p>InfiniBand路由器可实现多子网直接互连，随着计算系统规模增加越来越重要。</p><h3 id="2-InfiniBand技术核心-RDMA"><a href="#2-InfiniBand技术核心-RDMA" class="headerlink" title="2.InfiniBand技术核心-RDMA"></a>2.InfiniBand技术核心-RDMA</h3><p>InfiniBand实现高带宽与低延迟的核心是支持优化的网络传输协议，使用<strong>RDMA远程内存直接访问技术</strong>。支持RDMA的方式有多种，大体分为两种：卸载与加载，卸载是将网络协议处理过程内置在网卡芯片，加载借助CPU来处理网络协议。</p><p>TCP/IP网络通信协议是因特网最基本的协议，采取分层结构，每一层通过下层提供的服务来实现自己的协议，应用程序需要多次缓存复制，并需要内核介入来完成协议处理。高性能计算和大数据的相关应用是数据传输型应用，系统不能以软件方式持续处理通信协议，CPU资源必须专注于应用处理。</p><p>RDMA使应用可以从远程应用的内存读数据或写数据，远程应用程序在本地网卡中有内存缓冲区，CPU在整个操作过程中不提供服务。发布RDMA的应用需要提供正确的类型，内存地址，远程应用会将相关数据提供给发布RDMA的应用。</p><p><strong>RDMA技术的核心</strong></p><ul><li>零拷贝：HCA(网卡)可以直接与应用内存传输数据</li><li>内核旁路：执行RDMA请求不需要执行内核调用，可直接向网卡发送命令</li><li>协议卸载：网卡硬件中部署可靠的传输协议</li></ul><p>InfiniBand为应用层直接提供RDMA消息传输服务，应用层通过软件接口Verbs与传输层交互。为了使通用应用受益于RDMA，而且不用学习Verbs，现在已有许多上层接口，包括SRP，SDP，NFDoRDMA，MPI等。</p><h3 id="3-基于InfiniBand的HPC应用优化"><a href="#3-基于InfiniBand的HPC应用优化" class="headerlink" title="3.基于InfiniBand的HPC应用优化"></a>3.基于InfiniBand的HPC应用优化</h3><p>MPI已成为并行程序设计的标准，实现包括MPICH和OPENMPI。在HPC领域，并行应用程序一般都基于MPI开发。</p><p><strong>MPI通信协议</strong></p><p>MPI通信协议分为两类：Eager和Rendezvous协议</p><p>Eager协议下发送进程主动发送信息给接收进程，不会考虑对方是否有能力接收，非常适合对延迟要求高的小消息发送。</p><p>Rendezvous协议会在接收端协调缓存来接收信息，适用于发送较大的信息，发送进程通过协议和接收端协调缓存后才发送信息，但可能增加通信延迟。</p><p><strong>MPI函数</strong></p><p>MPI函数包括点对点通信和集群通信函数，每个MPI实现都有不同的调试参数。需要运行程序分析工具了解程序在每个MPI函数上占用的事件和所使用的消息大小，给出合适的参数。</p><p><strong>MPI应用优化</strong></p><p>不同MPI实现有不同特性分析工具，如OPENMPI有IPM，Allinea可以分析多种MPI。一个典型的例子是分析消息的大小，调整Eager和Rendezvous参数，小于一个阈值采用Eager模式，来降低通信延迟。</p>]]></content>
      
      
      <categories>
          
          <category> 高性能计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp并发编程(thread)</title>
      <link href="/2023/10/24/cpp%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(thread)/"/>
      <url>/2023/10/24/cpp%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(thread)/</url>
      
        <content type="html"><![CDATA[<p>C++并发编程一书的笔记，主要是关于std::thread的内容。</p><p>除了阅读英文原版书外，还参考了以下视频：</p><p><a href="https://www.bilibili.com/video/BV1FP411x73X/?share_source=copy_web&amp;vd_source=0c2cff6853488b7418da35239bf7b3c1">C++ 并发编程(1) 线程基础，为什么线程参数默认传参方式是值拷贝?</a></p><span id="more"></span><h2 id="一-线程控制"><a href="#一-线程控制" class="headerlink" title="一.线程控制"></a>一.线程控制</h2><h3 id="1-启动线程与等待结束"><a href="#1-启动线程与等待结束" class="headerlink" title="1.启动线程与等待结束"></a>1.启动线程与等待结束</h3><p>可以直接传入函数，重载()的类<strong>(注意如果直接初始化一个类对象传入，要加括号)</strong>，或lambda表达式创建线程，也可以绑定类的函数。参数也直接在后面传入。通过join等待线程运行结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(func,arg1,arg2)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><p>示例程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">bg_task</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::cout&lt;&lt; <span class="string">&quot;bg_task running...&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">const</span> std::string a)</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;a&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(func1,<span class="string">&quot;thread t1 call func1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// std::thread t2(bg_task());   这会被认为是一个函数！ 参数是函数指针，返回值是thread</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">((bg_task()))</span></span>;    <span class="comment">//使用括号，里面就是初始化一个变量，就可以正常定义线程了</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">([](std::string s)&#123;std::cout&lt;&lt;s&lt;&lt;std::endl;&#125;, <span class="string">&quot;thread t3 running...&quot;</span>)</span></span>;    <span class="comment">//lambda表达式</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">problem1</span>();</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了保证主线程发生异常时，子线程也能回收，需要使用try catch来捕获主线程的异常。为了方便编写程序，通常使用RAII思想，封装一个类来保证子线程一定可以回收：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">thread_guard</span>&#123;</span><br><span class="line">    std::thread &amp;t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">thread_guard</span><span class="params">(std::thread &amp;<span class="type">_t</span>)</span>: t(_t)&#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">thread_guard</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(t.<span class="built_in">joinable</span>())&#123;<span class="comment">//需要确认可以join</span></span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">thread_guard</span>(thread_guard <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    thread_guard&amp; <span class="keyword">operator</span>=(thread_guard <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    <span class="function">thread_guard <span class="title">g</span><span class="params">(t)</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以不使用join回收线程，只需要设置其为detach状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.<span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure><p>绑定类的函数的示例如下，如果有需要，参数补在后面就可以：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_lengthy_work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;do_lengthy_work &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bind_class_oops</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X my_x;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(&amp;X::do_lengthy_work, &amp;my_x)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-传参"><a href="#2-传参" class="headerlink" title="2.传参"></a>2.传参</h3><p>和一般的函数传参一样，要注意保证传进去的变量在运行期间存在：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        a = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">problem1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(func2, std::ref(x))</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();         <span class="comment">//x会被回收，func2就不应该使用x了</span></span><br><span class="line">    <span class="comment">//解决方式有：使用智能指针；传值；join</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中可以看到，thread的构造需要将引用参数使用std::ref封装，因为thread会将所有参数作为按值移动处理，再调用函数。</p><p>还有下面这种传指针的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i, std::string <span class="type">const</span> &amp;s)</span></span>;</span><br><span class="line"><span class="comment">//错误的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">oops</span><span class="params">(<span class="type">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer,<span class="string">&quot;%i&quot;</span>,arg);</span><br><span class="line">    std::<span class="built_in">thread</span>(f,<span class="number">3</span>,buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正确的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">oops</span><span class="params">(<span class="type">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer,<span class="string">&quot;%i&quot;</span>,arg);</span><br><span class="line">    std::<span class="built_in">thread</span>(f,<span class="number">3</span>,std::<span class="built_in">string</span>(buffer));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在传递参数时，有些需要传递的参数是不可复制的，这时可以通过move将其传递(move将左值转换为右值，使用移动构造函数)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deal_unique</span><span class="params">(std::unique_ptr&lt;<span class="type">int</span>&gt; p)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unique ptr data is &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">    (*p)++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;after unique ptr data is &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move_oops</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(deal_unique, std::move(p))</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">//不能再使用p了，p已经被move废弃</span></span><br><span class="line">   <span class="comment">// std::cout &lt;&lt; &quot;after unique ptr data is &quot; &lt;&lt; *p &lt;&lt; std::endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-所有权转移"><a href="#3-所有权转移" class="headerlink" title="3.所有权转移"></a>3.所有权转移</h3><p>线程管理变量没有拷贝构造和赋值函数，线程的所有权通过move进行转移：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//创建线程并转移所有权</span></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">std::thread t2 = std::<span class="built_in">move</span>(t1);</span><br></pre></td></tr></table></figure><h3 id="4-运行时决定线程数"><a href="#4-运行时决定线程数" class="headerlink" title="4.运行时决定线程数"></a>4.运行时决定线程数</h3><p>在选定线程数时，通常希望线程数不大于硬件核数。可以使用std::thread::harware_concurrency()来确定线程数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MIN_SIZE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;thread&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; running...&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">    <span class="type">int</span> max_threads = N/MIN_SIZE;</span><br><span class="line">    <span class="type">int</span> num_threads = std::<span class="built_in">min</span>(k!=<span class="number">0</span>?k:<span class="number">2</span>, max_threads);</span><br><span class="line">    std::thread threads[num_threads<span class="number">-1</span>];</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;hardware_concurrency is &quot;</span>&lt;&lt;k&lt;&lt;<span class="string">&quot; and num_threads is &quot;</span>&lt;&lt;num_threads&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num_threads<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(func,i);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;main thread running...&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num_threads<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        threads[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不均匀的部分由主线程来完成，创建num_threads-1个线程。</p><h2 id="二-共享数据"><a href="#二-共享数据" class="headerlink" title="二.共享数据"></a>二.共享数据</h2><h3 id="1-使用锁保护共享数据"><a href="#1-使用锁保护共享数据" class="headerlink" title="1.使用锁保护共享数据"></a>1.使用锁保护共享数据</h3><p><strong>锁的使用</strong></p><p>C++提供了锁来在多线程时保护共享数据，并提供了<font color="blue">lock_guard</font>类，实现锁的RAII，还提供了一个<font color="blue">unique_lock</font>类来配合条件变量的使用，unique_lock可以手动解锁或用于条件变量中解锁：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; li;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_list</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="comment">//lock_guard只有构造和析构函数，在构造时上锁，析构时解锁</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    li.<span class="built_in">push_back</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//std::unique_lock的例子</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait_fn</span><span class="params">(ThreadState* thread_state)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// A lock must be held in order to wait on a condition variable.</span></span><br><span class="line">    <span class="comment">// This lock is atomically released before the thread goes to sleep</span></span><br><span class="line">    <span class="comment">// when `wait()` is called. The lock is atomically re-acquired when</span></span><br><span class="line">    <span class="comment">// the thread is woken up using `notify_all()`.</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(*thread_state-&gt;mutex_)</span></span>;</span><br><span class="line">    thread_state-&gt;condition_variable_-&gt;<span class="built_in">wait</span>(lk);</span><br><span class="line">    <span class="comment">// Increment the shared counter with the lock re-acquired to inform the</span></span><br><span class="line">    <span class="comment">// signaling thread that this waiting thread has successfully been</span></span><br><span class="line">    <span class="comment">// woken up.</span></span><br><span class="line">    thread_state-&gt;counter_++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Lock re-acquired after wait()...\n&quot;</span>);</span><br><span class="line">    lk.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并不是添加了锁，就可以保护共享数据，通常锁会封装到需要操作的类里，而如果函数返回指针或引用，就会导致锁无法控制对数据的修改和访问。不仅是返回指针和引用，调用函数也有风险，如果作为参数将指针或引用传入，函数就可以不需要锁也能访问共享数据。</p><p>除了以上情况，还有一种情况也不能保证对共享数据的访问不会导致竞态，这种情况是由于接口本身的设计导致的。如果多个线程对一个栈进行操作，栈只有一个元素，两个栈轮流调用empty()判断栈不空，然后都pop()出栈，就会产生错误。类似的情况是都在判空后调用top()，两个线程看到相同的值，然后各pop一次，导致一个值丢失。这是设计上的问题，考虑stack<vector<int\>>，vector的复制是要开辟空间然后复制数据的，如果空间开辟不够，就会产生std:bad_alloc，如果pop直接获取元素，可能会在复制时失败，而元素也出栈，这个元素就丢失了。为了解决这个问题，stl设计者将操作分为top和pop，这样top没有取到值会先产生std::bad_alloc，数据不会丢失。</vector<int\></p><p>解决上述竞态问题有不同的方案：</p><p><strong>Option 1</strong>：传递引用。这种方式的局限性在于需要在调用pop之前进行构造，这是消耗时间与资源的，并且对于用户定义的类可能不支持赋值操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">s.<span class="built_in">pop</span>(result);</span><br></pre></td></tr></table></figure><p><strong>Option2：</strong>使用会抛出异常的拷贝构造和移动构造。确定是不可能在编译时找出不抛出异常的这两种构造。</p><p><strong>Option3：</strong>返回pop item的指针。返回指针能有效解决传值失败的问题，如果采用这种方法，最好使用shared_ptr，可以避免内存泄露。</p><p>以上的方案也可以同时采用，书中给出了线程安全的栈的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">empty_stack</span> : std::exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::stack&lt;T&gt; data;</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_stack</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">threadsafe_stack</span>(<span class="type">const</span> threadsafe_stack&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;</span><br><span class="line">        <span class="comment">//①在构造函数的函数体（constructor body）内进行复制操作</span></span><br><span class="line">        data = other.data;   </span><br><span class="line">    &#125;</span><br><span class="line">    threadsafe_stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        data.<span class="built_in">push</span>(std::<span class="built_in">move</span>(new_value));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="comment">//②试图弹出前检查是否为空栈</span></span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();</span><br><span class="line">        <span class="comment">//③改动栈容器前设置返回值</span></span><br><span class="line">            <span class="function">std::shared_ptr&lt;T&gt; <span class="type">const</span> <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data.top()))</span></span>;    </span><br><span class="line">            data.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();</span><br><span class="line">        value = data.<span class="built_in">top</span>();</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 高性能计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU15-418notes(10-18)</title>
      <link href="/2023/10/23/CMU15-418notes(10-18)/"/>
      <url>/2023/10/23/CMU15-418notes(10-18)/</url>
      
        <content type="html"><![CDATA[<p>视频：<a href="https://www.bilibili.com/video/BV1Rh4y1F7aU/?spm_id_from=333.788&amp;vd_source=463e5b3e4b18e5453477b57388c2e427">https://www.bilibili.com/video/BV1Rh4y1F7aU/?spm_id_from=333.788&amp;vd_source=463e5b3e4b18e5453477b57388c2e427</a></p><p>课程主页：<a href="http://15418.courses.cs.cmu.edu/spring2016/lectures">http://15418.courses.cs.cmu.edu/spring2016/lectures</a></p><!--more---><h2 id="Lecture-10-Snooping-Based-Cache-Coherence"><a href="#Lecture-10-Snooping-Based-Cache-Coherence" class="headerlink" title="Lecture 10: Snooping-Based Cache Coherence"></a>Lecture 10: Snooping-Based Cache Coherence</h2><p>本节主要介绍监听式缓存一致性协议，在量化研究方法里面已经学习过了，直接回顾当时的笔记。</p><p>为多个处理器保持缓存⼀致性的协议被称为缓存⼀致性协议，协议的关键在于跟踪数据块的共享状态。缓存一致性的问题要在极短的时间解决，因此需要采取硬件方法。</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231023110311286.png" alt="image-20231023110311286" style="zoom:50%;"></p><p>实现监听⼀致性协议有两种⽅法，⼀种是<strong>写⼊失效协议</strong>，处理器执⾏写⼊操作时使其他副本失效；另⼀种是<strong>写⼊更新协议</strong>，处理器执⾏写⼊时更新所有缓存副本，这种⽅法要占⽤相当多的带宽(写⼊操作要⼴播到共享缓存线)，因此不常⽤，多处理器都选择实现写⼊失效协议。</p><p>监听⼀致性协议通常是通过有限状态控制器实施的，控制器可以改变所选缓存块的状态，并使⽤总线访问数据或使其失效。可以看作每⼀个块有⼀个关联的独⽴控制器。<br>在协议中，规定每个CPU的每个块有三种状态：</p><ul><li>⽆效：所有缓存中都没有此块的有效副本</li><li>已修改(独占)：该块仅在该CPU缓存中有副本，并且被修改过</li><li>共享：该块在⼀个或多个缓存中有副本且未修改过</li></ul><p>每个CPU都独⽴控制每个块的状态，通过监听总线转换块的状态，并进⾏读写操作。</p><p>假设⼀个CPUA中产⽣了⼀个对⼀个缓存块的读写请求，根据读写是否命中，CPU会有不同的处理⽅式，并改变该块的状态。已修改状态直接称为独占。</p><ul><li>读命中：状态不需要发⽣改变。⽆效态不会产⽣读命中，⽽独占和共享态，读⾃⼰缓存中的块不会引起⼀致性的问题。</li><li>读不命中：发⽣读不命中，则CPUA要从主存读取该块，但是主存中的块不⼀定是最新的，所以CPU还会向总线发送⼀个读不命中信号和当前块的地址，其他CPU的控制器监听到该信号，如果都没有这个块或者有共享态的该块，说明主存中是最新的，那么从主存中读取到该块，并将其设置为共享态；如果⼀个CPUB发现⾃⼰有独占的该块，则终⽌CPUA读取主存，因为⾃⼰的数据是最新的，CPUB将提供给A这个块，并将其写回内存，此时A和B都有块的最新版本，且主存中的也是最新版本，A和B中该块的状态设置为共享态。(注意，CPUB是独占该块的，A和B以外的CPU⼀定是没有这个块的，所以也不需要改变状态。)</li><li>写命中：如果该块在CPUA上是共享态，那么要修改为独占态，且向总线发出写⼊失效信号，其他CPU中的该块都将⽆效；如果该块在CPUA是独占态，那么状态不变。</li><li>写不命中：将该块设置为独占态，并向总线发出写⼊失效信号，使其他CPU的该块⽆效，如果其他CPU独占该块，则要写回内存(这保证了写⼊操作的串⾏化)。</li></ul><p>通过以上的分析，CPU改变⼀个块的信号的原因可能是读写事件，也可能是从总线监听到的其他CPU的读写事件。⼀个块在被写⼊后就会被修改为独占态，通过向总线发送信号使其他CPU的该块失效。在读取时，如果发⽣了不命中，则读不命中和地址被⼴播，独占块的CPU要给出该块，并将该块写回。这两个关键的⼯作保证了任何CPU总是能读取到最新的块，保证了⼀致性。</p><p>最后，以上所有的操作都没有考虑缓存替换的问题，如果发⽣了缓存替换，被替换的块如果是独占态，则要写回主存，只有⾃⼰有被替换块的数据，不需要发出其他信号。</p><h2 id="Lecture-11-Directory-Based-Cache-Coherence"><a href="#Lecture-11-Directory-Based-Cache-Coherence" class="headerlink" title="Lecture 11: Directory-Based Cache Coherence"></a>Lecture 11: Directory-Based Cache Coherence</h2><p>总线式系统的带宽存在限制，采⽤分布式系统可以降低对存储器的带宽要求。在分布式系统中，采⽤分布式的存储器，多个节点可以同时读取或写⼊数据，提⾼了存储器的带宽，不受单⼀存储器总线的限制。分布式系统没有总线，通过⽹络互连，为了避免监听式⼀致性协议的⼴播，分布式存储器系统采⽤⽬录式协议替代监听式⼀致性协议。</p><p>⽬录式⼀致性协议中，每个处理器都有⼀个⽬录，⽬录中保存了每个可缓存块的状态，信息包括哪些缓存拥有这个块的副本，是否需要更新等等。存储器的每⼀块都在⽬录中有对应的⼀项，每个⽬录项由访问状态和位向量组成，位向量记录了各个处理器是否有这个块的副本。</p><p>在⽬录式⼀致性协议中，仍然使⽤三种状态，采⽤写失效策略。状态转换也和监听式是⼀样的，只是不再通过⼴播告知其他处理器⼀个块失效，⽽是根据位向量，通知相应的CPU该块失效或完成更新该块的⼯作。并且由块所在的存储器所属的CPU作为宿主与需要沟通的处理器沟通，完成写失效通知和写回的操作。</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231023162232842.png" alt="image-20231023162232842" style="zoom:50%;"></p><p>监听法基于总线，通过⼴播信号来实现写失效，优点是不需要额外的存储空间维护⼀致性信息，缺点是可扩展性差，处理器数量越多，总线通信的压⼒就越⼤。</p><p>⽬录法采⽤集中式的⽬录维护⼀致性信息，增加了存储开销。⼀致性信息是集中式的存储在⽬录中，但⽬录结构本⾝是分布式的，因此具有可拓展性。⽬录法最⼤的优点是可以实现在分布式的系统中，不需要总线。</p><h2 id="Lecture-12-A-Basic-Snooping-Based-Multi-Processor-Implementation"><a href="#Lecture-12-A-Basic-Snooping-Based-Multi-Processor-Implementation" class="headerlink" title="Lecture 12: A Basic Snooping-Based Multi-Processor Implementation"></a>Lecture 12: A Basic Snooping-Based Multi-Processor Implementation</h2><p>本节的主要内容是监听式多处理器的实现细节。</p><h3 id="L1和L2的一致性"><a href="#L1和L2的一致性" class="headerlink" title="L1和L2的一致性"></a><strong>L1和L2的一致性</strong></h3><p>第一个问题是处理器内部缓存的一致性：</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231026151311594.png" alt="image-20231026151311594" style="zoom:50%;"></p><p>L1缓存有一致性协议的状态，L2中相应的块也必须有相同的状态。但是L2的内容并不总是包含L1，假设下图中发生了一次L1和L2的B miss，B块从内存中读入L1和L2，接下来有多次对A的访问，且都在L1命中，假设set0还映射了块C，当访问C不命中时，L1选择换出B，而L2则选择换出A，这样L1的块就不是都在L2中包含了，就会影响缓存一致性的状态更新。</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231026151551657.png" alt="image-20231026151551657" style="zoom:50%;"></p><p>解决方式是在L2中加一个in L1位，当从L2换出块时，根据这个位也使L1中的该块无效，就可以保证L1中的块在L2中一定存在。不过假设采取写回策略，L2中块的内容和L1可能不一致，因此还需要一个位，表明一个块修改过，但L2不拥有：</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231026152312268.png" alt="image-20231026152312268" style="zoom:50%;"></p><p>当监听到对X的读写时，L2从L1中读取该块，再根据协议进行相应处理。</p><h3 id="总线上的并发问题"><a href="#总线上的并发问题" class="headerlink" title="总线上的并发问题"></a>总线上的并发问题</h3><p>课程在这里还回顾了一些常见的并发问题的概念，包括活锁，死锁，饥饿问题，这里不再赘述了。</p><p><strong>原子性总线</strong></p><p>保证原子性的总线，在访存等操作前要先获取总线权限，然后再发送数据和命令，并接收响应。</p><p>对于缓存中的行，处理器和监听控制器都需要检查行的Tags和State位，为了保证不发生冲突，在两端都保存一份Tags和State，并保持这两份数据的一致(可以同时读，写时要同步)。(这里图里还放个snoop dog)</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231026163944287.png" alt="image-20231026163944287" style="zoom:50%;"></p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231026164200869.png" alt="image-20231026164200869" style="zoom:50%;"></p><p>为了实现一致性协议，还需要一些信号线：</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231026164536294.png" alt="image-20231026164536294" style="zoom: 33%;"></p><p>如果缓存能提供数据，memory就不需要响应，否则memory就要发送数据。</p><p>对于写回的情况，需要写入内存替换的块，读出需要的块，这两个操作会消耗更多时间，为了加快读取数据，在内存和缓存之间会有一个缓冲区，在写回时立即返回读取的数据，将写入的数据flush到缓冲区稍后写入内存：</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231026165100407.png" alt="image-20231026165100407" style="zoom:50%;"></p><p>在总线上会发生并发问题：</p><ul><li>死锁：P1在等待总线权限，而P2需要P1修改过的块B，而P1无法响应，就会发生死锁。</li><li>活锁：P1和P2都要写同一个块，发出写入信号后互相使对方的操作无效。</li><li>饥饿：有处理器一直无法获取总线权限。</li></ul><p><strong>非原子性的总线</strong></p><p>使用非原子性的总线，一个操作会被分为请求和响应两个部分来完成，因此产生了一些新的问题：</p><ul><li>如何匹配请求和响应</li><li>怎么处理请求的冲突</li><li>最多可以有多少未处理的请求</li><li>监听结果应该在请求时还是响应时确定</li></ul><p>考虑到以上问题，一个基本的设计为：</p><ul><li>请求和响应分别处理</li><li><p>使用request table来匹配请求和响应，每个cache都有request table的副本</p></li><li><p>最多同时有8个请求</p></li><li>响应不需要和请求的顺序相同，系统的整体顺序是按照请求顺序</li><li>cache和缓存都有buffer来接收总线的数据，如果buffer满了就发送NACK稍后重试</li><li>避免冲突，如果有一个对块A读的请求，那么同时对块A的写请求就会被阻塞或放入队列等待(不要让冲突发生，请求和响应的顺序对于监听结果就无所谓了)</li></ul><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231026173625163.png" alt="image-20231026173625163" style="zoom:50%;"></p><p>由于请求和响应是分别处理，可以进行流水线化：</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231026173958152.png" alt="image-20231026173958152" style="zoom:50%;"></p><p>再回到总线的并发问题，可以采用队列来保存请求，这样在请求的同时就可以继续监听(这里不是很理解)。然而如果队列满了，又会发生死锁：</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231026174520454.png" alt="image-20231026174520454" style="zoom:50%;"></p><p>解决方法是区分出request和response队列：</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231026174635177.png" alt="image-20231026174635177" style="zoom:50%;"></p><p>最后是一个访存时发生的事件练习：</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231026174902748.png" alt="image-20231026174902748" style="zoom: 80%;"></p><h3 id="False-sharing"><a href="#False-sharing" class="headerlink" title="False sharing"></a>False sharing</h3><p>缓存是以行为单位存储的，通常为64字节。存在一种情况，多个线程操作不同的成员变量，但是这些变量在相同的缓存行，这样二者都需要改动时，就会导致不同核都要修改这一行，然后都要另一个缓存的该行失效，这就导致了两个变量没有关联，但每次修改一个变量时，下次访问另一个变量都要重新从下一级缓存或memory读取，导致性能下降。</p><p>解决伪共享的方式就是进行填充，将变量填充为64个字节，这样就能避免上述情况的发生，不过伪共享这种情况很难发现，也并不是都需要解决。</p><h2 id="Lecture-13-Memory-Consistency"><a href="#Lecture-13-Memory-Consistency" class="headerlink" title="Lecture 13: Memory Consistency"></a>Lecture 13: Memory Consistency</h2><p>本节所描述的Memory Consistency是处理器在对不同的位置进行读写的行为，这不是保证一个位置的值的正确，而是保证处理器在修改不同值时，能够在不改变语义的同时通过重排序来优化性能，并且重排序不影响其他线程的行为。</p><p>如果能保证读后写，读后读，写后写，写后写这四个情况都是顺序发生的，那么可以说访存保证串行一致性，内存中的值始终是和程序中的顺序相同。为了提高性能，可以适当放松一致性的四个要求。最常见的操作就是使用写缓冲区，这样就可以减少写的延迟。</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231030204046049.png" alt="image-20231030204046049" style="zoom:50%;"></p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231030204101062.png" alt="image-20231030204101062" style="zoom:50%;"></p><p>在多线程程序中，读写的重排序会导致其他线程看到的读写顺序和程序中是不一致的，因此需要由程序员和编译器来保证必要的同步。</p><p>对于四种顺序情况，有不同的要求，越是放松对四种顺序的要求，一致性就越弱。</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231031205545584.png" alt="image-20231031205545584" style="zoom:50%;"></p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231031205621457.png" alt="image-20231031205621457" style="zoom:50%;"></p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231031205640559.png" alt="image-20231031205640559" style="zoom: 67%;"></p><p>C++的atomic库提供了原子性操作，可以保证一致性。</p><h2 id="Lecture-14-Performance-Monitoring-Tools"><a href="#Lecture-14-Performance-Monitoring-Tools" class="headerlink" title="Lecture 14: Performance Monitoring Tools"></a>Lecture 14: Performance Monitoring Tools</h2><p>通过测量才能分析程序，找到程序中最有价值可优化的部分。 </p><p>time和top可以看到CPU的占用率，以及是否有其他人在使用CPU。</p><p>辅助分析程序运行时间的工具有两种，一种是编译时注入代码，一种是在程序运行时工作，对于程序优化，有这样一些工具：</p><ul><li>程序优化<ul><li>Gprof</li><li>Perf</li><li>VTune</li></ul></li><li>debug<ul><li>Valgrind</li><li>Santizers</li></ul></li><li>Advanced Analysis<ul><li>Pin</li><li>Contech</li></ul></li></ul><p>根据Amadahl’s Law，应该找到程序运行时间占比最大的部分进行优化，以最快的提升程序性能。因此需要找到程序中的hot code部分。</p><p>Gprof可以统计各个函数被调用的次数和时间，是编译时注入的工具，只需要在编译时添加-pg选项，然后运行程序，运行后会出现一个统计文件，再运行<code>gprof progname</code>就可以查看统计结果。</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/CMU15-418notes(10-18" alt="image-20231101150226101">/image-20231101150226101.png)</p><p>Perf则是基于现代体系结构的性能分析，可以得出缓存命中，分支预测的情况等。而粒度最细可达指令级。Vtune也是一个类似的工具。</p><p>这一节只是一些概述，所以这些工具详细的使用单独开一篇笔记再学习记录。</p><h2 id="Lecture-15-Interconnection-Networks"><a href="#Lecture-15-Interconnection-Networks" class="headerlink" title="Lecture 15: Interconnection Networks"></a>Lecture 15: Interconnection Networks</h2><p>本节的内容是内部节点之间的网络结构，这些网络连接了不同内核，核与内存，缓存与缓存等，I/O设备等。</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231103121641659.png" alt="image-20231103121641659" style="zoom: 50%;"></p><p>网络结构决定着系统的扩展性，也影响着系统的性能。在设计网络时，要考虑的问题有：</p><ul><li>拓扑结构：影响路由，延迟，复杂度等</li><li>路由：消息是怎么传递的，是静态路径还是动态确定路径</li><li>缓存和流量控制</li></ul><p>共有两种拓扑结构，一种是直接的，一种是间接的，间接的需要switch。同时还有blocking和non-blocking的选择(假设同时只能传递一条消息)。</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231103122615879.png" alt="image-20231103122615879" style="zoom:50%;"></p><h3 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h3><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231103122724662.png" alt="image-20231103122724662" style="zoom: 67%;"></p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231103122755516.png" alt="image-20231103122755516" style="zoom: 67%;"></p><p>这里看起来是网格，但实际上是全连接的。</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231103122839359.png" alt="image-20231103122839359" style="zoom: 67%;"></p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231103122948300.png" alt="image-20231103122948300" style="zoom: 67%;"></p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231103123102784.png" alt="image-20231103123102784" style="zoom:67%;"></p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231103123128153.png" alt="image-20231103123128153" style="zoom:67%;"></p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231103123212338.png" alt="image-20231103123212338" style="zoom:67%;"></p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231103123309085.png" alt="image-20231103123309085" style="zoom:67%;"></p><p>本节的最后一下部分是介绍缓存和流控制的，讨论了分组交换和电路交换，和计网的概念是完全一样的。</p><p>最后的总结，interconnection网络对于现代多处理器是非常重要的，因为bus扩展性差，并且现今都开始在芯片上设计网络了。不同的拓扑结构的性能表现不同，开销等其他方面也不同。</p><h2 id="Lecture-16-Implementing-Synchronization"><a href="#Lecture-16-Implementing-Synchronization" class="headerlink" title="Lecture 16: Implementing Synchronization"></a>Lecture 16: Implementing Synchronization</h2><p>在本节的开始首先复习了超线程。超线程技术下，每个核的两个线程指令流执行是由硬件处理的，有两个上下文同时存在。例如一个支持超线程技术的两个CPU(每个六核)的系统，显示的processor数量有24个，实际上是有12个核，24个执行执行上下文，因此逻辑上有24个核。</p><p>本节的内容是关于同步的实现的。</p><p>最简单的同步方式是忙等待和阻塞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//忙等待</span><br><span class="line">while (condition X not true)&#123;&#125;</span><br><span class="line">logic that assumes X is true;</span><br><span class="line">//阻塞</span><br><span class="line">if(conditionXnottrue)</span><br><span class="line">block until true;</span><br></pre></td></tr></table></figure><p>如果是短时锁，使用自旋锁更好，因为不会等待太长时间，阻塞调度会产生开销浪费时间。</p><h3 id="Implementing-Locks"><a href="#Implementing-Locks" class="headerlink" title="Implementing Locks"></a>Implementing Locks</h3><p>最基本的锁是test-and-set原语实现的自旋锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock: </span><br><span class="line">ts R0,mem[addr]//loadwordintoR0</span><br><span class="line">bnz R0,lock//if0,lockobtained</span><br></pre></td></tr></table></figure><p>因为lock值是volatile的，其他处理器的线程会持续请求从内存读写lock数据并独占lock，占用总线资源，如果刚好持有锁的处理器释放锁，也可能被其他线程占用总线而延迟释放锁。</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231114123051118.png" alt="image-20231114123051118" style="zoom:50%;"></p><p>解决方式是等有机会获得锁再进行testandset操作，这种锁称为TTAS锁。尽管读取lock的值仍然要从内存获取，但不会再产生独占缓存行的流量了。</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231114123537445.png" alt="image-20231114123537445" style="zoom:50%;"></p><p>避免持续尝试获得锁的流量，可以进行退避：</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231114125214306.png" alt="image-20231114125214306" style="zoom:50%;"></p><p>TTAS实现的锁释放后，其他处理器都会尝试TAS写操作来独占锁，也会引起总线的大量流量。并且上述锁都不保证公平性，可能会有饥饿产生，更公平的锁是使用队列：</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231114125515943.png" alt="image-20231114125515943" style="zoom:50%;"></p><p>这样每个锁的获取只需要一次原子操作，此后就不需要其他原子操作了。不过释放锁的时候会使所有处理器的l-&gt;now_serving缓存行失效，还可以进一步优化：</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231114125827816.png" alt="image-20231114125827816" style="zoom:50%;"></p><p>这样每个尝试获取锁的处理器就只等待一个内存地址的值的修改了，进一步减少了总线流量。</p><h3 id="Additional-primitive-atomic-operations"><a href="#Additional-primitive-atomic-operations" class="headerlink" title="Additional primitive atomic operations"></a>Additional primitive atomic operations</h3><p><strong>LL/SC指令</strong></p><p>链接加载和条件存储指令，在arm架构中同样的是LDREX and STREX指令。LL指令加载后的地址如果没有被修改过，SC指令会完成store操作，如果被修改过，就不会进行store操作。</p><p><strong>C++ 11 atomic</strong></p><p>提供原子性读写，实现方式可能是锁，如果类型是基本类型，也可能是硬件原语。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">atomic&lt;<span class="type">int</span>&gt;i;</span><br><span class="line">i++;<span class="comment">//atomically increment i</span></span><br><span class="line"><span class="type">int</span>a = i;</span><br><span class="line"><span class="comment">//do stuff</span></span><br><span class="line">i.<span class="built_in">compare_exchange_strong</span>(a, <span class="number">10</span>);<span class="comment">//if i has same value as a, set i to 10</span></span><br><span class="line"><span class="type">bool</span> b = i.<span class="built_in">is_lock_free</span>();<span class="comment">//true if implementation of atomicity is lock free</span></span><br></pre></td></tr></table></figure><h3 id="Implementing-Barriers"><a href="#Implementing-Barriers" class="headerlink" title="Implementing Barriers"></a>Implementing Barriers</h3><p>以下是一个错误的barrier实现，由第一个到达的线程清空flag，最后一个线程设定flag，但是如果最后一个线程设定后，有线程没有离开barrier，其他线程就到达了下一个barrier，又清空了flag，这个线程就被卡在第一个barrier里了。</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231114171014406.png" alt="image-20231114171014406" style="zoom:67%;"></p><p>解决问题的一个办法是设定leave_counter，等所有线程离开barrier再重新清空flag。</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231114171304690.png" alt="image-20231114171304690" style="zoom:67%;"></p><p>以上是正确的barrier实现，但是有两个忙等待，更好的方式是更改flag的定义，让flag在一个barrier中为0表示未全部到达，在下一个barrier中为0表示已全部到达，线程需要知道自己在的临界区中barrier对应flag的值应该是多少才可以继续，这样通过一个barrier后，第一个进入下一个barrier的线程修改flag的值，不会导致其他线程卡在barrier当中：</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231114171703649.png" alt="image-20231114171703649" style="zoom:67%;"></p><p>以上的barrier都是中心化的，需要通过counter值判断是否全部到达barrier，这就导致写counter必须上锁，如果改为树形结构，就可以减少延迟(获取每个锁的线程少了)：</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231114171930682.png" alt="image-20231114171930682" style="zoom: 50%;"></p><h2 id="Lecture-17-Fine-grained-synchronization-amp-lock-free-programming"><a href="#Lecture-17-Fine-grained-synchronization-amp-lock-free-programming" class="headerlink" title="Lecture 17: Fine-grained synchronization &amp; lock-free programming"></a>Lecture 17: Fine-grained synchronization &amp; lock-free programming</h2><p>以链表为例，如果对整个操作上锁，数据结构就会编程串行操作。如果采用细粒度的锁，让每个节点都有锁，在操作时只上操作节点的锁，就可以提高并发度，在移动过程中，只有持有当前节点的锁，才能获取下一个节点的锁，获取后再释放这个节点的锁：</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231116095141967.png" alt="image-20231116095141967" style="zoom:80%;"></p><p>细粒度的锁仍然是基于锁的，在某些情况下，可以实现无锁的数据结构。以一个队列为例，如果已知只有一个读者和一个写者，就可以实现无锁队列，方法是将唯一修改节点的能力写在push中，而pop操作只移动指针，另外增加一个reclaim指针用于释放节点：</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231116100350476.png" alt="image-20231116100350476" style="zoom: 50%;"></p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231116100506216.png" alt="image-20231116100506216" style="zoom:50%;"></p><p>再考虑栈的无锁实现，对于一个基于链表的栈，所有的操作都是对表头指针进行的，即栈的top，最基本的处理方式就是用原子指令判断top是不是进入操作时的top，如果是就可以完成操作，不是就重新获取栈顶元素指针：</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231116103647907.png" alt="image-20231116103647907" style="zoom: 80%;"></p><p>但是这种方法会出现<strong>ABA问题</strong>，即指针被复用了，但指向的节点不同了：</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/CMU15-418notes(10-18" alt="image-20231116103832471">/image-20231116103832471.png)</p><p>解决方式是添加pop_count，以防止中间发生pop后，指针复用导致的ABA问题，不过这需要硬件对DOUBLE CAS的支持，才能同时对pop_count和top进行CAS：</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231116104137914.png" alt="image-20231116104137914" style="zoom: 67%;"></p><p>另外一个问题是在进行pop时，要修改栈指针为old_top-&gt;next，然而此时old_top可能已经被释放掉了(对应上述代码，还Node* new_top = top-&gt;next)，解决方式是加一个harzard ptr，把pop掉的节点通过harzard ptr添加到一个队列，足够多了再一起进行释放，这样就延迟了old_top的释放，不会出现上述问题。(下面的实现使用doubleword CAS，直接对oldstack和newstack进行CAS，逻辑和上面的代码是一样的。)</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/CMU15-418notes(10-18" alt="image-20231116104636333">/image-20231116104636333.png)</p><p>无锁数据结构可以避免锁的开销，但仍然需要memory fence保证内存的一致性，并且具体的使用情况要根据情况决定，并不能消除竞争。</p><h2 id="Lecture-18-Transaction-Memory"><a href="#Lecture-18-Transaction-Memory" class="headerlink" title="Lecture 18: Transaction Memory"></a>Lecture 18: Transaction Memory</h2><p>事务内存是为了实现事务的原子性，隔离性，可串行化。这是源自数据库领域的做法。事务内存是一种声明式抽象，即不需要说明具体的实现，只需要说明应该做什么。具体而言，事务所实现的原子性不需要说明是锁实现的，只需要说明事务本身是原子性的。</p><p>实现事务内存的简单方式是LL/SC(LDREX和STREX)指令，事务只有两种可能，完整发生和不发生。这两条指令是符合事务的定义的。</p><h3 id="Implementing-transactional-memory"><a href="#Implementing-transactional-memory" class="headerlink" title="Implementing transactional memory"></a>Implementing transactional memory</h3><p>从数据写入的角度有两种TM的实现，Eager版本和Lazer版本。</p><p>Eager版本会立即完成数据的更新，保持undo log来终止事务。快速提交，但是终止比较慢，因为要重新写入。</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231119203750676.png" alt="image-20231119203750676" style="zoom:67%;"></p><p>Lazy版本则是使用flush缓冲区，当事务提交时进行写入。快速终止，但提交慢。</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231119203814879.png" alt="image-20231119203814879" style="zoom:67%;"></p><p>除了数据写入的策略，另一个要考虑的是冲突的检测。事务在读写时可能产生冲突。同样有两种方式，一种是悲观检测，另一种是乐观检测。</p><p>悲观方法是检测每一步可能发生的冲突并restart或stall。</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231119204539031.png" alt="image-20231119204539031" style="zoom:67%;"></p><p>乐观方法则只在事务提交的时候进行冲突检测。并且优先处理提交的事务，将其他冲突的事务终止撤销。</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231119204734484.png" alt="image-20231119204734484" style="zoom:67%;"></p><p>两者的比较：</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231119205705073.png" alt="image-20231119205705073" style="zoom: 67%;"></p><p>从硬件实现TM的角度来说，为了完成undo，所有寄存器的数据会被记录，修改的数据会先写入缓存，然后需要有一些支持TM的位。R/W位表示cache line在事务的读写集合中。</p><p><img src="/2023/10/23/CMU15-418notes(10-18)/image-20231119205615648.png" alt="image-20231119205615648" style="zoom: 50%;"></p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ul><li>原子构造：对原子行为的声明，目的是为了简化同步</li><li>事务内存的实现：<ul><li>eager/lazer数据更新</li><li>悲观/乐观冲突检测</li></ul></li><li>硬件事务内存支持：<ul><li>版本数据更新在缓存中，提交时确认更新</li><li>基于一致性协议实现冲突检测</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 高性能计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU15-418notes(1-9)</title>
      <link href="/2023/10/13/CMU15-418notes(1-9)/"/>
      <url>/2023/10/13/CMU15-418notes(1-9)/</url>
      
        <content type="html"><![CDATA[<p>视频：<a href="https://www.bilibili.com/video/BV1Rh4y1F7aU/?spm_id_from=333.788&amp;vd_source=463e5b3e4b18e5453477b57388c2e427">https://www.bilibili.com/video/BV1Rh4y1F7aU/?spm_id_from=333.788&amp;vd_source=463e5b3e4b18e5453477b57388c2e427</a></p><p>课程主页：<a href="http://15418.courses.cs.cmu.edu/spring2016/lectures">http://15418.courses.cs.cmu.edu/spring2016/lectures</a></p><!--more---><h2 id="Lecture-1-Why-Parallelism"><a href="#Lecture-1-Why-Parallelism" class="headerlink" title="Lecture 1: Why Parallelism"></a>Lecture 1: Why Parallelism</h2><ul><li>功率墙导致的摩尔定律的失效让性能的提升方向转向并行。</li><li>并行计算是同时使用多种计算资源解决计算问题的过程。</li><li>快不等同于高效。</li><li>使用加速比衡量性能提升。</li></ul><h2 id="Lecture-2-A-Modern-Multi-Core-Processor"><a href="#Lecture-2-A-Modern-Multi-Core-Processor" class="headerlink" title="Lecture 2: A Modern Multi-Core Processor"></a>Lecture 2: A Modern Multi-Core Processor</h2><p>现代处理器实现并行的方式：</p><ul><li>多核：使用多核来实现线程并行，每个核执行不同的指令流。</li><li>SIMD：在一个核的指令流中使用多个ALU。向量化可以通过编译器显式使用SIMD，也可以由硬件运行时进行。</li><li>超标量：在单指令流提高指令级并行度，并行处理多条指令。</li></ul><p>关于访存：</p><ul><li>提高带宽比降低延迟简单。</li><li>为了利用访存延迟的时间，可以在发生访存的Stall时切换执行另一个线程的指令(本线程的指令可能存在依赖，不能充分利用超标量下的ILP)。这需要在一个周期发射多个不同线程的指令，因此称为同时多线程，即<strong>超线程(SMT)</strong>。但是多线程会导致每个线程的存储空间减少，因此需要更高的带宽。</li><li>CPU使用大缓存，较少的线程，适中的带宽，依靠缓存和预取减少访存时间。而GPU使用小的缓存，较多线程，大带宽，通过多线程提高运算效率。所以GPU有自己的存储。</li></ul><p><img src="/2023/10/13/CMU15-418notes(1-9)/image-20231013211703143.png" alt="image-20231013211703143" style="zoom:50%;"></p><h2 id="Lecture-3-Parallel-Programming-Models"><a href="#Lecture-3-Parallel-Programming-Models" class="headerlink" title="Lecture 3: Parallel Programming Models"></a>Lecture 3: Parallel Programming Models</h2><h3 id="ISPC"><a href="#ISPC" class="headerlink" title="ISPC"></a>ISPC</h3><p>ISPC是intel开发的SPMD(single program multiple data)编译器。程序中的并行程序实例，实际上是转化为了SIMD向量指令。</p><p><img src="/2023/10/13/CMU15-418notes(1-9)/image-20231016111743728.png" alt="image-20231016111743728" style="zoom: 80%;"></p><p>ISPC程序中，数据可以选择交错分配给program instance，也可以选择按块分配，但由于ISPC实际上是使用SIMD指令，因此交错的方式更快。</p><p><img src="/2023/10/13/CMU15-418notes(1-9)/image-20231016111859590.png" alt="image-20231016111859590" style="zoom:50%;"></p><p><img src="/2023/10/13/CMU15-418notes(1-9)/image-20231016111918243.png" alt="image-20231016111918243" style="zoom:50%;"></p><h3 id="三种通信模型"><a href="#三种通信模型" class="headerlink" title="三种通信模型"></a>三种通信模型</h3><ul><li><p>共享内存</p><ul><li>需要使用同步和互斥原语</li><li>需要硬件支持来提高访存效率(NUMA)</li></ul><p><img src="/2023/10/13/CMU15-418notes(1-9)/image-20231016112314303.png" alt="image-20231016112314303" style="zoom:50%;"></p></li><li><p>消息传递模型：通过发送和接收消息传递数据</p></li><li><p>数据并行模型：有严格的要求(例如SPMD)，通常需要使用流式编程模型</p><ul><li>数据流是数据的集合，数据可以独立处理，没有依赖</li><li>处理数据不会产生副作用</li></ul></li></ul><h2 id="Lecture-4-Parallel-Programming-Basics"><a href="#Lecture-4-Parallel-Programming-Basics" class="headerlink" title="Lecture 4: Parallel Programming Basics"></a>Lecture 4: Parallel Programming Basics</h2><p>并行程序运行的基本过程：</p><p><img src="/2023/10/13/CMU15-418notes(1-9)/image-20231016165252335.png" alt="image-20231016165252335" style="zoom: 50%;"></p><ul><li>分解：是程序员的工作，将问题分解为多个任务。</li><li>分配：可以由程序员静态完成(例如pthread指定线程分配任务)，也可以运行时完成(ISPC)。</li><li>编排：安排同步，通信等。</li><li>映射：由OS/硬件/编译器完成，将线程或程序实例安排给具体的硬件。</li></ul><p>Amdahl定律：</p><p><img src="/2023/10/13/CMU15-418notes(1-9)/image-20231017085601390.png" alt="image-20231017085601390" style="zoom:80%;"></p><p>本节的后半段是海洋模拟程序的并行计算实例：</p><p>共享内存模型，可以用多线程实现，需要锁来保护共享数据：</p><p><img src="/2023/10/13/CMU15-418notes(1-9)/image-20231017085737284.png" alt="image-20231017085737284" style="zoom: 50%;"></p><p>数据并行：</p><p><img src="/2023/10/13/CMU15-418notes(1-9)/image-20231017085847901.png" alt="image-20231017085847901" style="zoom: 50%;"></p><p>消息传递模型的例子在后续节中。</p><h2 id="Lecture-5-Performance-Optimization-I-Work-Distribution-and-Scheduling"><a href="#Lecture-5-Performance-Optimization-I-Work-Distribution-and-Scheduling" class="headerlink" title="Lecture 5: Performance Optimization I: Work Distribution and Scheduling"></a>Lecture 5: Performance Optimization I: Work Distribution and Scheduling</h2><p><strong>性能优化-平衡负载</strong></p><p>优化目标：</p><ul><li>平衡负载</li><li>减少通信</li><li>减少额外的工作</li></ul><p>本节主要探讨的内容是负载的平衡，从任务分配开始考虑：</p><ul><li>静态分配：优点是没有运行时开销</li><li>动态分配：</li></ul><p><img src="/2023/10/13/CMU15-418notes(1-9)/image-20231017093150990.png" alt="image-20231017093150990" style="zoom:50%;"></p><p>如果task划分的太小，就会在切换task时浪费太多时间。而task划分的很大又会导致负载不平衡。因此task size要合理分配，并且size大的要先分配，保证其他线程都能同时工作，而不是放在最后，导致其他线程空闲。</p><p>上图中只用了一个队列来分配任务，由于需要使用锁，开销可能很大，改进方法是使用多个队列，这称为分布式工作队列。当队列中的任务全部完成后，线程需要从其他队列中获取任务继续工作，直到全部任务完成。这样做的另一个好处是每个队列中的任务可以是有依赖的。</p><p><img src="/2023/10/13/CMU15-418notes(1-9)/image-20231017095138853.png" alt="image-20231017095138853" style="zoom:50%;"></p><p><strong>fork-join程序的调度</strong></p><p>本节的后半讨论了分治问题的并行计算。通常的并行计算是不存在数据依赖的：</p><p>数据并行的方式：</p><p><img src="/2023/10/13/CMU15-418notes(1-9)/image-20231017103721407.png" alt="image-20231017103721407" style="zoom:50%;"></p><p>多线程(共享内存)：</p><p><img src="/2023/10/13/CMU15-418notes(1-9)/image-20231017103754114.png" alt="image-20231017103754114" style="zoom: 60%;"></p><p>但是有些问题是串行和并行交叉的，例如快排：</p><p><img src="/2023/10/13/CMU15-418notes(1-9)/image-20231017103901501.png" alt="image-20231017103901501" style="zoom:50%;"></p><p>C++的扩展标准Cilk plus可以处理这样的并行，主要通过两个声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cilk_spawn <span class="title">foo</span><span class="params">(args)</span></span>; <span class="comment">//逻辑上可以并行</span></span><br><span class="line">cilk_sync;</span><br><span class="line"></span><br><span class="line"><span class="comment">//foo()andbar()mayruninparallel</span></span><br><span class="line"><span class="function">cilk_spawn<span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">bar</span>();</span><br><span class="line">cilk_sync;</span><br></pre></td></tr></table></figure><p><img src="/2023/10/13/CMU15-418notes(1-9)/image-20231017104100714.png" alt="image-20231017104100714" style="zoom:50%;"></p><p>cilk_spawn并不是创建线程，而是提前创建线程，再给线程任务。</p><p>假设cilk_spawn的部分称为child，接下来是cilk实现的一些底层细节。</p><p>线程执行任务仍然使用work queue，以便其他线程可以去队列找到并执行可并行的待执行任务：</p><p><img src="/2023/10/13/CMU15-418notes(1-9)/image-20231017105320691.png" alt="image-20231017105320691" style="zoom:50%;"></p><p>线程可以先执行child，也可以先执行后续部分，这两种是不一样的。假设有一个循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">cilk_spawn <span class="title function_">foo</span><span class="params">(i)</span>;</span><br><span class="line">&#125;</span><br><span class="line">cilk_sync;</span><br></pre></td></tr></table></figure><p>先执行child，那么循环会搁置在队列中；先执行后续部分，那么会先进行循环，把所有foo(i)放到队列中。</p><p>线程总是从获取最早入队的任务，对于分治问题，早入队的任务更大，相当于选取了树的靠近根节点的分支处理，这样就能尽量平衡负载。(对于快排，相当于先执行排序，将分治的另一半入队，并递归下去直到最小规模)。</p><p><img src="/2023/10/13/CMU15-418notes(1-9)/image-20231017110858273.png" alt="image-20231017110858273" style="zoom: 67%;"></p><p>对于sync，有两种策略，clik采用的是第二种策略：</p><ul><li>stalling：调用spawn产生分支的线程继续执行sync后面的内容，需要等待其他线程完成。</li><li>greedy：最后一个完成任务的线程执行sync及之后的内容。</li></ul><h2 id="Lecture-6-Performance-Optimization-Part-II-Locality-Communication-and-Contention"><a href="#Lecture-6-Performance-Optimization-Part-II-Locality-Communication-and-Contention" class="headerlink" title="Lecture 6: Performance Optimization Part II: Locality, Communication, and Contention"></a>Lecture 6: Performance Optimization Part II: Locality, Communication, and Contention</h2><p>本节课的内容比较散，直接来到summary。</p><ul><li>Inherent vs. artifactual communication<ul><li>inherent communication：并行算法中分解和分配任务必要的通信</li><li>artifactual communication：所有其他的通信，依赖于系统实现细节的通信，例如缓存</li></ul></li><li>对涉及局部性、通信和冲突的内容进行优化：<ul><li>通过利用局部性来提高性能</li><li>减少通信(通过合并消息，发送大体积的消息)</li><li>通过复制和交错访问资源，以及使用细粒度的锁，来减少冲突</li><li>提高重叠的部分，例如流水线，多线程隐藏延迟等</li></ul></li></ul><h2 id="Lecture-7-GPU-Architecture-and-CUDA-Programming"><a href="#Lecture-7-GPU-Architecture-and-CUDA-Programming" class="headerlink" title="Lecture 7: GPU Architecture and CUDA Programming"></a>Lecture 7: GPU Architecture and CUDA Programming</h2><p>这一节听的很模糊，最后是选看了中山大学和清华大学的并行计算课以及一些文章做的笔记。</p><p>中山大学-超级计算机原理与操作：<a href="https://www.easyhpc.net/course/27?courseTab=lessonList&amp;activeLesson=345">https://www.easyhpc.net/course/27?courseTab=lessonList&amp;activeLesson=345</a></p><p>清华大学-并行计算基础：<a href="https://www.easyhpc.net/course/10?courseTab=lessonList&amp;activeLesson=110">https://www.easyhpc.net/course/10?courseTab=lessonList&amp;activeLesson=110</a></p><p>一些其他参考链接：</p><p><a href="https://hustcat.github.io/gpu-architecture/">https://hustcat.github.io/gpu-architecture/</a></p><p><a href="http://haifux.org/lectures/267/Introduction-to-GPUs.pdf">http://haifux.org/lectures/267/Introduction-to-GPUs.pdf</a></p><p><a href="https://zhuanlan.zhihu.com/p/123170285">https://zhuanlan.zhihu.com/p/123170285</a></p><h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><p>GPU和CPU一样，也是一种处理器，起初其功能是这样一条流水线：</p><p><img src="/2023/10/13/CMU15-418notes(1-9)/image-20231018163507487.png" alt="image-20231018163507487" style="zoom: 33%;"></p><p>GPU与CPU的不同：</p><ul><li>轻量级线程，可快速切换</li><li>cache容量小</li><li>较多电路用于计算，轻量级线程以SIMD方式运用</li><li>通过吞吐率提高效率，而不是单个线程的执行速度</li></ul><p>起初的GPU编程方法是通过<strong>DirectX和OpenGL</strong>等图形API进行程序映射，后来Nvidia发布了<strong>CUDA</strong>，提供了对GPU的底层控制，GPU的可编程性逐步提高，general-purposeGPU逐渐流行起来，也成为了HPC的潮流。CUDA只能运行在Nvidia的GPU上，而OpenCL是CUDA的一个开源标准版本，可以运行在各类CPU，GPU，DSP，FPGA上。</p><h3 id="GPU-体系结构"><a href="#GPU-体系结构" class="headerlink" title="GPU 体系结构"></a>GPU 体系结构</h3><p><strong>概念性结构</strong></p><p>一个假想的GPU中的单核结构如下图所示：</p><p><img src="/2023/10/13/CMU15-418notes(1-9)/image-20231018190054739.png" alt="image-20231018190054739" style="zoom: 50%;"></p><p>这个核中有18个Ctx(context)组，每个组中有8个Ctx，这样这个核可以并发处理(交错)18个指令流，这样组中就有18*8个并发程序片。分组的目的是为了减少访存的延迟(超线程的思想)，分组的数量也可以改变。每个组有多个线程，每个线程处理的元素是一个<strong>fragment</strong>。(一个组执行的都是相同的指令)</p><p>现在假设使用有4个Ctx组的核，一个GPU的例子如下：</p><p><img src="/2023/10/13/CMU15-418notes(1-9)/image-20231018190746045.png" alt="image-20231018190746045" style="zoom:50%;"></p><p><strong>NVIDIA GeForce GTX 580</strong></p><p>下面以GTX580为例，理解GPU的具体结构，首先对应上面的概念，一个GPU是由多个核构成的，一个GTX580包含16个核，和上面的概念性GPU是一样的。</p><p><img src="/2023/10/13/CMU15-418notes(1-9)/image-20231018192220074.png" alt="image-20231018192220074" style="zoom:50%;"></p><p>下面是每个单核的结构，在上面的概念性阐释中，可以看到一个核是由一个decoder+多个ALU+Ctx组成的，而在GTX580中，一个核由两个decoder+多个复杂ALU(CUDA core，(也叫做Stream Processor, SP))+Ctx和共享内存构成，称为<strong>Stream Multiprocessor(SM)</strong>。</p><p><img src="/2023/10/13/CMU15-418notes(1-9)/image-20231018193758358.png" alt="image-20231018193758358" style="zoom:67%;"></p><p>由于有两个decoder，这一个核可以<strong>并行</strong>执行两个指令。每个decoder对应16个CUDA core。所有CUDA core执行的线程被称为<strong>线程束(warp)</strong>，即SIMT(单指令流多线程)。</p><p>综上，一个GPU有多个SM，每个SM可以调度线程束warp，可以同时执行两个指令，每个warp都是执行相同指令的一组线程，这些线程通过CUDA core进行运算。此外，为了调度和运行，SM中还有warp调度器等部件。</p><p>目前CUDA的warp的大小为32，即一个线程束里面有32个线程。而每个SM中的warp数量是取决于具体的GPU的。</p><p>对于上图，标出的似乎是同时执行两个warp，但是这样每个warp就只有16个线程，单条指令。实际情况应该是和硬件架构有关的，可以同时执行多个warp，有的GPU似乎还可以在一个warp同时发射多条指令，总之，GPU core被分组为warp是由架构决定的，不是固定标准的</p><h3 id="CUDA编程模型"><a href="#CUDA编程模型" class="headerlink" title="CUDA编程模型"></a>CUDA编程模型</h3><p>CUDA程序分为CPU的HOST部分和GPU的DEVICE部分，两者有独立的存储器。GPU运行的函数被称为核函数，通过__global__声明，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kernel definition</span></span><br><span class="line">__global__ <span class="type">void</span> <span class="title function_">VecAdd</span><span class="params">(<span class="type">float</span>* A, <span class="type">float</span>* B, <span class="type">float</span>* C)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = threadIdx.x;</span><br><span class="line">    C[i] = A[i] + B[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// Kernel invocation with N threads</span></span><br><span class="line">    VecAdd&lt;&lt;&lt;<span class="number">1</span>, N&gt;&gt;&gt;(A, B, C);</span><br><span class="line">... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程组织</strong></p><p>CUDA中的线程组织为三个层次。最高的层次为grid，一个grid包含多个block，block可以是一维，二维或三维组织的，block中的thread也可以是一维，二维或三维组织的。</p><p><img src="/2023/10/13/CMU15-418notes(1-9)/image-20231018205225362.png" alt="image-20231018205225362" style="zoom:50%;"></p><p>由于组织形式的不同，threadID的计算方法也不同，例如：</p><p>grid一维，block一维：threadID = blockDim.x(block的线程数)*blockIdx.x(grid中的哪个block)+threadIdx.x(block中的位置)</p><p>grid一维，block二维：threadID = blockDim.x*blockDim.y*blockIdx.x+threadIdx.y*blockDim.x+threadIdx.x</p><p><strong>线程映射</strong></p><p>每个核函数会产生一个grid，并有相应的block和thread组织方式，每个block最终会映射到一个SM上，而thread映射到GPU core上。同一个block中的thread是可同步的。SM上的warp调度器会对block进行调度安排。由于warp的大小一般为32，所以block所含的thread的大小一般要设置为32的倍数。</p><h3 id="CUDA存储模型"><a href="#CUDA存储模型" class="headerlink" title="CUDA存储模型"></a>CUDA存储模型</h3><p>CUDA的存储模型如下，HOST是CPU的存储部分，DEVICE是GPU：</p><p><img src="/2023/10/13/CMU15-418notes(1-9)/image-20231018204432333.png" alt="image-20231018204432333" style="zoom:67%;"></p><p>每个线程都有自己的内存，每个block也有一个共享内存，block中的所有线程都可以访问，还有整个grid的global memory也是共享的。</p><p>通过cudaMalloc分配的内存是全局内存。核函数中用__shared__修饰的变量是共享内存。 核函数定义的变量使用的是本地内存。</p><h2 id="Lecture-8-Parallel-Programming-Case-Studies"><a href="#Lecture-8-Parallel-Programming-Case-Studies" class="headerlink" title="Lecture 8: Parallel Programming Case Studies"></a>Lecture 8: Parallel Programming Case Studies</h2><p>本节讲了一些并行计算的案例，包括海洋模拟，星体模拟等。</p><h2 id="Lecture-9-Workload-Driven-Performance-Evaluation"><a href="#Lecture-9-Workload-Driven-Performance-Evaluation" class="headerlink" title="Lecture 9: Workload-Driven Performance Evaluation"></a>Lecture 9: Workload-Driven Performance Evaluation</h2><p>本节的核心是探讨怎样根据处理器数量和问题规模来提高算法的性能和效率。</p><p>有两种scaling方式来提高算法的性能和效率：</p><ul><li>scaling up：处理器增加时，保持问题规模不变，提高并行算法的速度。但是这样做也会增加通信和同步的开销。</li><li>scaling down：处理器增加时，扩大问题规模，使并行算法的效率保持不变。随着问题规模增大，可能受内存或存储限制。</li></ul><p>而评估并行算法也有两个类似的度量：</p><ul><li>hard scaling：保持问题规模不变，增加处理器。(time-constrained)</li><li>soft scaling：增加处理器的同时扩大问题规模。(memory-constrained)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 高性能计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pthreads简记</title>
      <link href="/2023/10/13/Pthread/"/>
      <url>/2023/10/13/Pthread/</url>
      
        <content type="html"><![CDATA[<p>Pthreads是POSIX的线程标准，定义了创建和操作线程的一组API。</p><p>本篇源于<a href="https://www.cnblogs.com/mywolrd/archive/2009/02/05/1930707.html">Pthread：POSIX 多线程程序设计</a>。</p><span id="more"></span><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一.概述"></a>一.概述</h2><h3 id="1-使用多线程"><a href="#1-使用多线程" class="headerlink" title="1.使用多线程"></a>1.使用多线程</h3><p>为什么使用多线程：</p><ul><li>提高通信效率</li><li>异步事件处理</li><li>CPU在等待I/O时，可以被其他线程使用</li></ul><p>使用Pthreads的情况：</p><ul><li>数据可以被多个任务同时执行</li><li>阻塞与长时间的IO</li><li>对异步事件必须响应</li></ul><p>PthreadsAPI有三大类：</p><ul><li>线程管理</li><li>互斥量</li><li>条件变量</li></ul><h2 id="二-API"><a href="#二-API" class="headerlink" title="二.API"></a>二.API</h2><h3 id="1-线程管理"><a href="#1-线程管理" class="headerlink" title="1.线程管理"></a>1.线程管理</h3><p><strong>创建线程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_create(thread,attr,start_routine,arg);</span><br><span class="line">pthread_exit(status);</span><br><span class="line">pthread_attr_init(attr);</span><br><span class="line">pthread_attr_destroy(attr); </span><br></pre></td></tr></table></figure><p>pthread_create参数：</p><ul><li>thread：返回的唯一的新线程标识符</li><li>attr：线程属性，可缺省</li><li>start_routine：执行函数</li><li>arg：参数，必须转换为void*</li></ul><p>进程可创建的线程最大数量取决于操作系统，线程可以创建其他线程，没有依赖关系。</p><p>线程属性使用attr_init和attr_destroy来初始化和销毁。一些属性在下面讨论。</p><p><strong>终止线程</strong></p><p>终止线程有以下方法：</p><ul><li>线程返回</li><li>线程调用pthread_exit</li><li>其他线程调用pthread_cancel结束线程</li><li>调用exec或者exit函数</li></ul><p>当main结束时，所有线程都会结束，如果main中调用pthread_exit，那么其他线程还是会存活。</p><p><strong>创建与终止实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS     5 </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">PrintHello</span><span class="params">(<span class="type">void</span> *threadid)</span> &#123; </span><br><span class="line">   <span class="type">int</span> tid; </span><br><span class="line">   tid = (<span class="type">int</span>)threadid; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World! It&#x27;s me, thread #%d!\n&quot;</span>, tid); </span><br><span class="line">   pthread_exit(<span class="literal">NULL</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123; </span><br><span class="line">   <span class="type">pthread_t</span> threads[NUM_THREADS]; </span><br><span class="line">   <span class="type">int</span> rc, t; </span><br><span class="line">   <span class="keyword">for</span>(t=<span class="number">0</span>; t&lt;NUM_THREADS; t++)&#123; </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;In main: creating thread %d\n&quot;</span>, t); </span><br><span class="line">      rc = pthread_create(&amp;threads[t], <span class="literal">NULL</span>, PrintHello, (<span class="type">void</span> *)t); </span><br><span class="line">      <span class="keyword">if</span> (rc)&#123; </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;ERROR; return code from pthread_create() is %d\n&quot;</span>, rc); </span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">-1</span>); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125; </span><br><span class="line">   pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>向线程传递参数</strong></p><p>pthread_create函数只能传递一个参数，需要传递多个参数时，需要定义一个结构体包含所有参数，然后传递指向该结构体的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_data</span>&#123;</span></span><br><span class="line">   <span class="type">int</span>  thread_id; </span><br><span class="line">   <span class="type">int</span>  sum; </span><br><span class="line">   <span class="type">char</span> *message; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_data</span> <span class="title">thread_data_array</span>[<span class="title">NUM_THREADS</span>];</span> </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">PrintHello</span><span class="params">(<span class="type">void</span> *threadarg)</span> &#123; </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">thread_data</span> *<span class="title">my_data</span>;</span> </span><br><span class="line">   ... </span><br><span class="line">   my_data = (<span class="keyword">struct</span> thread_data *) threadarg; </span><br><span class="line">   taskid = my_data-&gt;thread_id; </span><br><span class="line">   sum = my_data-&gt;sum; </span><br><span class="line">   hello_msg = my_data-&gt;message; </span><br><span class="line">   ... </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123; </span><br><span class="line">   ... </span><br><span class="line">   thread_data_array[t].thread_id = t; </span><br><span class="line">   thread_data_array[t].sum = sum; </span><br><span class="line">   thread_data_array[t].message = messages[t]; </span><br><span class="line">   rc = pthread_create(&amp;threads[t], <span class="literal">NULL</span>, PrintHello,  </span><br><span class="line">        (<span class="type">void</span> *) &amp;thread_data_array[t]); </span><br><span class="line">   ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程同步：join</strong></p><p>相关API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_join (threadid,status)  </span><br><span class="line">pthread_detach (threadid,status)  </span><br><span class="line">pthread_attr_setdetachstate (attr,detachstate)  </span><br><span class="line">pthread_attr_getdetachstate (attr,detachstate) </span><br></pre></td></tr></table></figure><p>pthread_join会阻塞等待指定线程结束，如果目标线程调用pthread_exit()，可以在主线程获得终止状态。</p><p>当线程创建后，会默认处于joinable状态，是可以join等待结束的，可以用attr参数修改设置为detachable状态，就不可等待了。</p><p>线程结束后，如果没有join，则会处于僵尸态，有资源未回收，但是调用pthread_join会使调用者阻塞，如果不希望调用者阻塞，可以使用detach函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子线程加入</span></span><br><span class="line">pthread_detach(pthread_self());</span><br><span class="line"><span class="comment">//或者父线程调用</span></span><br><span class="line">pthread_detach(thread_id)</span><br></pre></td></tr></table></figure><p>调用后，子线程运行结束后会自动释放所有资源。</p><p><strong>栈管理</strong></p><p>POSIX标准没有指定线程栈的大小，可以分配和设定栈的位置和大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_attr_getstacksize(attr, stacksize)  </span><br><span class="line">pthread_attr_setstacksize(attr, stacksize)  </span><br><span class="line">pthread_attr_getstackaddr(attr, stackaddr)  </span><br><span class="line">pthread_attr_setstackaddr(attr, stackaddr)  </span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NTHREADS 4 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEGEXTRA 1000000 </span></span><br><span class="line"><span class="type">pthread_attr_t</span> attr; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dowork</span><span class="params">(<span class="type">void</span> *threadid)</span> &#123; </span><br><span class="line">   <span class="type">double</span> A[N][N]; </span><br><span class="line">   <span class="type">int</span> i,j,tid; </span><br><span class="line">   <span class="type">size_t</span> mystacksize; </span><br><span class="line">   tid = (<span class="type">int</span>)threadid; </span><br><span class="line">   pthread_attr_getstacksize (&amp;attr, &amp;mystacksize); </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Thread %d: stack size = %li bytes \n&quot;</span>, tid, mystacksize); </span><br><span class="line">   <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) </span><br><span class="line">     <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;N; j++) </span><br><span class="line">      A[i][j] = ((i*j)/<span class="number">3.452</span>) + (N-i); </span><br><span class="line">   pthread_exit(<span class="literal">NULL</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123; </span><br><span class="line">   <span class="type">pthread_t</span> threads[NTHREADS]; </span><br><span class="line">   <span class="type">size_t</span> stacksize; </span><br><span class="line">   <span class="type">int</span> rc, t; </span><br><span class="line">   pthread_attr_init(&amp;attr); </span><br><span class="line">   pthread_attr_getstacksize (&amp;attr, &amp;stacksize); </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Default stack size = %li\n&quot;</span>, stacksize); </span><br><span class="line">   stacksize = <span class="keyword">sizeof</span>(<span class="type">double</span>)*N*N+MEGEXTRA; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Amount of stack needed per thread = %li\n&quot;</span>,stacksize); </span><br><span class="line">   pthread_attr_setstacksize (&amp;attr, stacksize); </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Creating threads with stack size = %li bytes\n&quot;</span>,stacksize); </span><br><span class="line">   <span class="keyword">for</span>(t=<span class="number">0</span>; t&lt;NTHREADS; t++)&#123; </span><br><span class="line">      rc = pthread_create(&amp;threads[t], &amp;attr, dowork, (<span class="type">void</span> *)t); </span><br><span class="line">      <span class="keyword">if</span> (rc)&#123; </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;ERROR; return code from pthread_create() is %d\n&quot;</span>, rc); </span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">-1</span>); </span><br><span class="line">      &#125; </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Created %d threads.\n&quot;</span>, t); </span><br><span class="line">   pthread_exit(<span class="literal">NULL</span>); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>其他函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回线程id</span></span><br><span class="line">pthread_self();</span><br><span class="line"><span class="comment">//不同返回0，相同返回非0</span></span><br><span class="line">pthread_equal(thread1，thread2);</span><br><span class="line"><span class="comment">//pthread_once函数只会被调用一次，可能是任何一个调用该函数的线程</span></span><br><span class="line"><span class="type">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT; </span><br><span class="line">pthread_once (once_control, init_routine) </span><br></pre></td></tr></table></figure><h3 id="2-互斥量"><a href="#2-互斥量" class="headerlink" title="2.互斥量"></a>2.互斥量</h3><p>互斥量是保护共享数据的主要方法，用于防止竞争。</p><p>多个线程竞争同一个互斥量时会阻塞，用try_lock替换lock可以使失败时不会阻塞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_init (mutex,attr);</span><br><span class="line">pthread_mutex_destroy (mutex);  </span><br><span class="line">pthread_mutexattr_init (attr);  </span><br><span class="line">pthread_mutexattr_destroy (attr);  </span><br></pre></td></tr></table></figure><p>互斥量必须初始化，使用pthread_mutex_t类型声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mymutex = PTHREAD_MUTEX_INITIALIZER; </span><br><span class="line"><span class="type">pthread_mutextattr_t</span> attr;</span><br></pre></td></tr></table></figure><p>可选属性包括协议，优先级上限，进程共享。</p><p>互斥量的操作函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock (mutex);</span><br><span class="line">pthread_mutex_trylock (mutex);  </span><br><span class="line">pthread_mutex_unlock (mutex);</span><br></pre></td></tr></table></figure><p>互斥量的使用实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*    </span></span><br><span class="line"><span class="comment">The following structure contains the necessary information   </span></span><br><span class="line"><span class="comment">to allow the function &quot;dotprod&quot; to access its input data and  </span></span><br><span class="line"><span class="comment">place its output into the structure.   </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  &#123;</span> </span><br><span class="line">   <span class="type">double</span>*a; </span><br><span class="line">   <span class="type">double</span>   *b; </span><br><span class="line">   <span class="type">double</span>   sum;  </span><br><span class="line">   <span class="type">int</span>veclen;  </span><br><span class="line">&#125; DOTDATA;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* Define globally accessible variables and a mutex */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMTHRDS 4 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VECLEN 100 </span></span><br><span class="line"></span><br><span class="line">DOTDATA dotstr;  </span><br><span class="line"><span class="type">pthread_t</span> callThd[NUMTHRDS]; </span><br><span class="line"><span class="type">pthread_mutex_t</span> mutexsum; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">The function dotprod is activated when the thread is created. </span></span><br><span class="line"><span class="comment">All input to this routine is obtained from a structure  </span></span><br><span class="line"><span class="comment">of type DOTDATA and all output from this function is written into </span></span><br><span class="line"><span class="comment">this structure. The benefit of this approach is apparent for the  </span></span><br><span class="line"><span class="comment">multi-threaded program: when a thread is created we pass a single </span></span><br><span class="line"><span class="comment">argument to the activated function - typically this argument </span></span><br><span class="line"><span class="comment">is a thread number. All  the other information required by the  </span></span><br><span class="line"><span class="comment">function is accessed from the globally accessible structure.  </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dotprod</span><span class="params">(<span class="type">void</span> *arg)</span> &#123; </span><br><span class="line">   <span class="comment">/* Define and use local variables for convenience */</span> </span><br><span class="line">   <span class="type">int</span> i, start, end, offset, len ; </span><br><span class="line">   <span class="type">double</span> mysum, *x, *y; </span><br><span class="line">   offset = (<span class="type">int</span>)arg; </span><br><span class="line">   len = dotstr.veclen; </span><br><span class="line">   start = offset*len; </span><br><span class="line">   end   = start + len; </span><br><span class="line">   x = dotstr.a; </span><br><span class="line">   y = dotstr.b;</span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">   Perform the dot product and assign result </span></span><br><span class="line"><span class="comment">   to the appropriate variable in the structure.  </span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">   mysum = <span class="number">0</span>; </span><br><span class="line">   <span class="keyword">for</span> (i=start; i&lt;end ; i++)  &#123; </span><br><span class="line">      mysum += (x[i] * y[i]); </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">   Lock a mutex prior to updating the value in the shared </span></span><br><span class="line"><span class="comment">   structure, and unlock it upon updating. </span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">   pthread_mutex_lock (&amp;mutexsum); </span><br><span class="line">   dotstr.sum += mysum; </span><br><span class="line">   pthread_mutex_unlock (&amp;mutexsum); </span><br><span class="line">   pthread_exit((<span class="type">void</span>*) <span class="number">0</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">The main program creates threads which do all the work and then  </span></span><br><span class="line"><span class="comment">print out result upon completion. Before creating the threads, </span></span><br><span class="line"><span class="comment">the input data is created. Since all threads update a shared structure,  </span></span><br><span class="line"><span class="comment">we need a mutex for mutual exclusion. The main thread needs to wait for </span></span><br><span class="line"><span class="comment">all threads to complete, it waits for each one of the threads. We specify </span></span><br><span class="line"><span class="comment">a thread attribute value that allow the main thread to join with the </span></span><br><span class="line"><span class="comment">threads it creates. Note also that we free up handles when they are </span></span><br><span class="line"><span class="comment">no longer needed.</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123; </span><br><span class="line">   <span class="type">int</span> i; </span><br><span class="line">   <span class="type">double</span> *a, *b; </span><br><span class="line">   <span class="type">void</span> *status; </span><br><span class="line">   <span class="type">pthread_attr_t</span> attr; </span><br><span class="line">   <span class="comment">/* Assign storage and initialize values */</span> </span><br><span class="line">   a = (<span class="type">double</span>*) <span class="built_in">malloc</span> (NUMTHRDS*VECLEN*<span class="keyword">sizeof</span>(<span class="type">double</span>)); </span><br><span class="line">   b = (<span class="type">double</span>*) <span class="built_in">malloc</span> (NUMTHRDS*VECLEN*<span class="keyword">sizeof</span>(<span class="type">double</span>)); </span><br><span class="line">   <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;VECLEN*NUMTHRDS; i++) &#123; </span><br><span class="line">     a[i]=<span class="number">1.0</span>; </span><br><span class="line">     b[i]=a[i]; </span><br><span class="line">   &#125;</span><br><span class="line">   dotstr.veclen = VECLEN;  </span><br><span class="line">   dotstr.a = a;  </span><br><span class="line">   dotstr.b = b;  </span><br><span class="line">   dotstr.sum=<span class="number">0</span>; </span><br><span class="line">   pthread_mutex_init(&amp;mutexsum, <span class="literal">NULL</span>); </span><br><span class="line">   <span class="comment">/* Create threads to perform the dotproduct  */</span> </span><br><span class="line">   pthread_attr_init(&amp;attr); </span><br><span class="line">   pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); </span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NUMTHRDS; i++) &#123; </span><br><span class="line">        <span class="comment">/*  </span></span><br><span class="line"><span class="comment">        Each thread works on a different set of data. </span></span><br><span class="line"><span class="comment">        The offset is specified by &#x27;i&#x27;. The size of </span></span><br><span class="line"><span class="comment">        the data for each thread is indicated by VECLEN. </span></span><br><span class="line"><span class="comment">        */</span> </span><br><span class="line">        pthread_create( &amp;callThd[i], &amp;attr, dotprod, (<span class="type">void</span> *)i); </span><br><span class="line">   &#125; </span><br><span class="line">   pthread_attr_destroy(&amp;attr); </span><br><span class="line">   <span class="comment">/* Wait on the other threads */</span> </span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NUMTHRDS; i++)&#123; </span><br><span class="line">      pthread_join( callThd[i], &amp;status); </span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">/* After joining, print out the results and cleanup */</span> </span><br><span class="line">   <span class="built_in">printf</span> (<span class="string">&quot;Sum =  %f \n&quot;</span>, dotstr.sum); </span><br><span class="line">   <span class="built_in">free</span> (a); </span><br><span class="line">   <span class="built_in">free</span> (b); </span><br><span class="line">   pthread_mutex_destroy(&amp;mutexsum); </span><br><span class="line">   pthread_exit(<span class="literal">NULL</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-条件变量"><a href="#3-条件变量" class="headerlink" title="3.条件变量"></a>3.条件变量</h3><p>条件变量使用实际的数据值来实现同步，通常和互斥一起使用。条件变量本身是一个队列，可以让等待条件达成的线程休眠，并释放掉互斥量，等待条件完成后被其他线程唤起。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> myconvar = PTHREAD_COND_INITIALIZER;<span class="comment">//静态初始化</span></span><br><span class="line">pthread_cond_init(condition,attr);  </span><br><span class="line">pthread_cond_destroy(condition);  </span><br><span class="line">pthread_condattr_init(attr);  </span><br><span class="line">pthread_condattr_destroy(attr);  </span><br></pre></td></tr></table></figure><p>在条件变量上等待和发送信号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_wait(condition,mutex);  </span><br><span class="line">pthread_cond_signal(condition);</span><br><span class="line">pthread_cond_broadcast(condition);</span><br></pre></td></tr></table></figure><p>在学习OS时已经详细的学习过条件变量的内容了，所以这里直接放示例程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS  3 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCOUNT 10 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT_LIMIT 12 </span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> thread_ids[<span class="number">3</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;; </span><br><span class="line"><span class="type">pthread_mutex_t</span> count_mutex; </span><br><span class="line"><span class="type">pthread_cond_t</span> count_threshold_cv; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">inc_count</span><span class="params">(<span class="type">void</span> *idp)</span>  &#123; </span><br><span class="line">  <span class="type">int</span> j,i; </span><br><span class="line">  <span class="type">double</span> result=<span class="number">0.0</span>; </span><br><span class="line">  <span class="type">int</span> *my_id = idp; </span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;TCOUNT; i++) &#123; </span><br><span class="line">    pthread_mutex_lock(&amp;count_mutex); </span><br><span class="line">    count++; </span><br><span class="line">    <span class="keyword">if</span> (count == COUNT_LIMIT) &#123; </span><br><span class="line">pthread_cond_signal(&amp;count_threshold_cv); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;inc_count(): thread %d, count = %d  Threshold reached.\n&quot;</span>,  *my_id, count); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;inc_count(): thread %d, count = %d, unlocking mutex\n&quot;</span>,  *my_id, count); </span><br><span class="line">    pthread_mutex_unlock(&amp;count_mutex); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do some work so threads can alternate on mutex lock */</span> </span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">1000</span>; j++) </span><br><span class="line">      result = result + (<span class="type">double</span>)random(); </span><br><span class="line">    &#125; </span><br><span class="line">  pthread_exit(<span class="literal">NULL</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">watch_count</span><span class="params">(<span class="type">void</span> *idp)</span>  &#123; </span><br><span class="line">  <span class="type">int</span> *my_id = idp; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Starting watch_count(): thread %d\n&quot;</span>, *my_id); </span><br><span class="line">  pthread_mutex_lock(&amp;count_mutex); </span><br><span class="line">  <span class="keyword">if</span> (count&lt;COUNT_LIMIT) &#123; </span><br><span class="line">    pthread_cond_wait(&amp;count_threshold_cv, &amp;count_mutex); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;watch_count(): thread %d Condition signal  received.\n&quot;</span>, *my_id); </span><br><span class="line">  &#125; </span><br><span class="line">  pthread_mutex_unlock(&amp;count_mutex); </span><br><span class="line">  pthread_exit(<span class="literal">NULL</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123; </span><br><span class="line">  <span class="type">int</span> i, rc; </span><br><span class="line">  <span class="type">pthread_t</span> threads[<span class="number">3</span>]; </span><br><span class="line">  <span class="type">pthread_attr_t</span> attr; </span><br><span class="line">  <span class="comment">/* Initialize mutex and condition variable objects */</span> </span><br><span class="line">  pthread_mutex_init(&amp;count_mutex, <span class="literal">NULL</span>); </span><br><span class="line">  pthread_cond_init (&amp;count_threshold_cv, <span class="literal">NULL</span>); </span><br><span class="line">  <span class="comment">/* For portability, explicitly create threads in a joinable state */</span> </span><br><span class="line">  pthread_attr_init(&amp;attr); </span><br><span class="line">  pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); </span><br><span class="line">  pthread_create(&amp;threads[<span class="number">0</span>], &amp;attr, inc_count, (<span class="type">void</span> *)&amp;thread_ids[<span class="number">0</span>]); </span><br><span class="line">  pthread_create(&amp;threads[<span class="number">1</span>], &amp;attr, inc_count, (<span class="type">void</span> *)&amp;thread_ids[<span class="number">1</span>]); </span><br><span class="line">  pthread_create(&amp;threads[<span class="number">2</span>], &amp;attr, watch_count, (<span class="type">void</span> *)&amp;thread_ids[<span class="number">2</span>]); </span><br><span class="line">  <span class="comment">/* Wait for all threads to complete */</span> </span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;NUM_THREADS; i++) &#123; </span><br><span class="line">    pthread_join(threads[i], <span class="literal">NULL</span>); </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;Main(): Waited on %d  threads. Done.\n&quot;</span>, NUM_THREADS); </span><br><span class="line">  <span class="comment">/* Clean up and exit */</span> </span><br><span class="line">  pthread_attr_destroy(&amp;attr); </span><br><span class="line">  pthread_mutex_destroy(&amp;count_mutex); </span><br><span class="line">  pthread_cond_destroy(&amp;count_threshold_cv); </span><br><span class="line">  pthread_exit(<span class="literal">NULL</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-未涉及的内容"><a href="#三-未涉及的内容" class="headerlink" title="三.未涉及的内容"></a>三.未涉及的内容</h2><p>Pthreads还有一些API没有提到：</p><ul><li>线程调度：Pthreads提供了显式设定线程调度策略和优先级的函数</li><li>线程数据</li><li>互斥量的属性</li><li>跨进程的条件变量共享</li><li>取消线程</li><li>多线程和信号</li></ul><h2 id="四-练习"><a href="#四-练习" class="headerlink" title="四.练习"></a>四.练习</h2><p>因为同时在熟悉makefile，所以写了makefile。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">all = main array_sum comsumer</span><br><span class="line">obj_main = func.o main.o</span><br><span class="line">main : <span class="variable">$(obj)</span></span><br><span class="line">gcc -o obj_main <span class="variable">$(obj)</span> -lpthread</span><br><span class="line">main.o : main.c </span><br><span class="line">func.o : func.c </span><br><span class="line"><span class="section">array_sum: array_sum.c</span></span><br><span class="line">gcc -o array_sum array_sum.c -lpthread</span><br><span class="line"><span class="section">consumer: consumer.c</span></span><br><span class="line">gcc -o consumer consumer.c -lpthread</span><br><span class="line"><span class="section">rarraysum:</span></span><br><span class="line">./array_sum</span><br><span class="line"><span class="section">rconsumer:</span></span><br><span class="line">./consumer</span><br><span class="line">clean : </span><br><span class="line">-rm *.o <span class="variable">$(all)</span></span><br></pre></td></tr></table></figure><h3 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> NUM_THREADS;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> VEC_SIZE;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span>&#123;</span></span><br><span class="line"><span class="type">int</span> *a, *b, *sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dot_product_ser</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> *result)</span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;VEC_SIZE;i++)&#123;</span><br><span class="line">tmp += a[i]*b[i];</span><br><span class="line">&#125;</span><br><span class="line">*result = tmp;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dot_product_par</span><span class="params">(<span class="type">void</span> *thread_args)</span>&#123;</span><br><span class="line"><span class="type">int</span> my_size = VEC_SIZE/NUM_THREADS;</span><br><span class="line"><span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *a, *b, *result;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span> *<span class="title">my_arg</span> =</span> (<span class="keyword">struct</span> args*)thread_args;</span><br><span class="line">a = my_arg-&gt;a;</span><br><span class="line">b = my_arg-&gt;b;</span><br><span class="line">result = my_arg-&gt;sum;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;my_size;i++)&#123;</span><br><span class="line">tmp += a[i]*b[i];</span><br><span class="line">&#125;</span><br><span class="line">*result = tmp;</span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initialize</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;VEC_SIZE;i++)&#123;</span><br><span class="line">a[i] = <span class="number">1</span>;</span><br><span class="line">b[i] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> NUM_THREADS = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> VEC_SIZE = <span class="number">1e4</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">dot_product_ser</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> *result)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">dot_product_par</span><span class="params">(<span class="type">void</span> *thread_arg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">initialize</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span>&#123;</span></span><br><span class="line"><span class="type">int</span> *a, *b, *sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> *a = <span class="built_in">malloc</span>(VEC_SIZE*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span> *b = <span class="built_in">malloc</span>(VEC_SIZE*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span> *my_sum = <span class="built_in">malloc</span>(NUM_THREADS*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span> result_par = <span class="number">0</span>, step = NUM_THREADS/VEC_SIZE, result_ser = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">initialize(a, b);</span><br><span class="line">dot_product_ser(a,b,&amp;result_ser);</span><br><span class="line"></span><br><span class="line"><span class="comment">//parallel computing </span></span><br><span class="line"><span class="type">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">args</span> <span class="title">thread_arg</span>[<span class="title">NUM_THREADS</span>];</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NUM_THREADS;i++)&#123;</span><br><span class="line">thread_arg[i].a = a+i*step;</span><br><span class="line">thread_arg[i].b = b+i*step;</span><br><span class="line">thread_arg[i].sum = &amp;my_sum[i];</span><br><span class="line"><span class="type">int</span> rt = pthread_create(&amp;threads[i], <span class="literal">NULL</span>, dot_product_par,(<span class="type">void</span>*)&amp;thread_arg[i]); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NUM_THREADS;i++)&#123;</span><br><span class="line">pthread_join(threads[i],<span class="literal">NULL</span>);</span><br><span class="line">result_par += my_sum[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//check</span></span><br><span class="line"><span class="keyword">if</span>(result_par==result_ser)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;coorect and result is %d\n&quot;</span>, result_par);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;wrong!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">free</span>(my_sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组求和"><a href="#数组求和" class="headerlink" title="数组求和"></a>数组求和</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_THREADS = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mtx = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">array_sum</span><span class="params">(<span class="type">void</span> *a)</span>&#123;</span><br><span class="line"><span class="type">int</span> *t = (<span class="type">int</span>*)a;</span><br><span class="line"><span class="type">int</span> n = N/NUM_THREADS, tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">tmp += t[i];</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_lock(&amp;mtx);</span><br><span class="line">res += tmp;</span><br><span class="line">pthread_mutex_unlock(&amp;mtx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> *a = <span class="built_in">malloc</span>(N*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span> step = N/NUM_THREADS;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">pthread_t</span> threads[N];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;array_sum runnning...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">a[i] = i<span class="number">-1e3</span>;</span><br><span class="line">ans += a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NUM_THREADS;i++)&#123;</span><br><span class="line"><span class="type">int</span> rt = pthread_create(&amp;threads[i], <span class="literal">NULL</span>, array_sum, (<span class="type">void</span>*)(a+i*step));</span><br><span class="line"><span class="keyword">if</span>(rt) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ERROR! Create thread%d failed and error code is%d.\n&quot;</span>,i,rt);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NUM_THREADS;i++)&#123;</span><br><span class="line">pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;res = %d and ans = %d\n&quot;</span>, res, ans);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line">pthread_mutex_destroy(&amp;mtx);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费者与生产者"><a href="#消费者与生产者" class="headerlink" title="消费者与生产者"></a>消费者与生产者</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_THREADS = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUFFER_SIZE = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *buffer;</span><br><span class="line"><span class="type">int</span> done = <span class="number">0</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mtx = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> filled = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> empty = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">()</span>&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(cnt&lt;NUM_THREADS<span class="number">-1</span>)&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mtx);</span><br><span class="line"><span class="keyword">while</span>(done==<span class="number">0</span>)&#123;</span><br><span class="line">pthread_cond_wait(&amp;filled,&amp;mtx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">done = <span class="number">0</span>;</span><br><span class="line">pthread_cond_signal(&amp;empty);</span><br><span class="line">pthread_mutex_unlock(&amp;mtx);</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;All of the data have been received.\n&quot;</span>);</span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *tid)</span>&#123;</span><br><span class="line">sleep(<span class="number">2</span>);</span><br><span class="line">pthread_mutex_lock(&amp;mtx);</span><br><span class="line"><span class="keyword">while</span>(done==<span class="number">1</span>)&#123;</span><br><span class="line">pthread_cond_wait(&amp;empty,&amp;mtx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sprintf</span>(buffer,<span class="string">&quot;data written by thread%d&quot;</span>,(<span class="type">int</span>)tid);</span><br><span class="line">done = <span class="number">1</span>;</span><br><span class="line">pthread_cond_signal(&amp;filled);</span><br><span class="line">pthread_mutex_unlock(&amp;mtx);</span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">buffer = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NUM_THREADS<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="type">int</span> rc = pthread_create(&amp;threads[i],<span class="literal">NULL</span>,producer, (<span class="type">void</span> *)i);</span><br><span class="line"><span class="keyword">if</span>(rc)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Create thread failed and error code is %d\n&quot;</span>,rc);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rc = pthread_create(&amp;threads[NUM_THREADS<span class="number">-1</span>],<span class="literal">NULL</span>,consumer,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(rc)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Create thread failed and error code is %d\n&quot;</span>,rc);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NUM_THREADS;i++)&#123;</span><br><span class="line">pthread_join(threads[i],<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_destroy(&amp;mtx);</span><br><span class="line">pthread_cond_destroy(&amp;filled);</span><br><span class="line">pthread_cond_destroy(&amp;empty);</span><br><span class="line"><span class="built_in">free</span>(buffer);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 高性能计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPPNOTES</title>
      <link href="/2023/09/11/CPPNOTES/"/>
      <url>/2023/09/11/CPPNOTES/</url>
      
        <content type="html"><![CDATA[<p>update 2025.03.01，对实际情况中遇到的内容使用📌标记。</p><h2 id="一-关键字-基础知识"><a href="#一-关键字-基础知识" class="headerlink" title="一.关键字/基础知识"></a>一.关键字/基础知识</h2><h3 id="CONST"><a href="#CONST" class="headerlink" title="CONST"></a>CONST</h3><p><strong>1.作用</strong></p><ul><li>定义常量，防止修改，起保护作用。</li><li>类型检查：#define不会进行类型检查，const则是具有类型的。</li><li>节省空间：常量只有一份数据，可以避免多份拷贝。</li></ul><p><strong>2.默认为文件局部变量</strong></p><p>const 对象默认为文件局部变量，如果需要在其他文件中访问，则需要extern定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> ext = <span class="number">2</span>;<span class="comment">//无const修饰的变量不需要extern指定</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"><span class="comment">//file2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> ext;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p><strong>3.常量在定义时必须被初始化</strong></p><p><strong>4.常指针和指向常量的指针</strong></p><ul><li>const int <em> 为指向常量的指针， int </em> const为常指针。</li><li>指向常量的指针可以指向非常量，但不能修改。</li><li>常指针必须初始化且不能修改，常指针不能指向常量，如果需要则必须为const int * const形式。</li></ul><p><strong>5.函数中使用const</strong></p><ul><li>const指向参数或常指针参数无意义，因为本来就是临时变量拷贝的。</li><li>可以为指向常量的指针。</li><li>可以为引用。</li></ul><p><strong>6.类中使用const</strong></p><ul><li>const成员函数不能修改成员或调用非const成员函数。</li><li>const对象只能访问const成员函数。</li><li>const成员变量必须初始化列表初始化，C++11支持定义处初始化，或者可以结合static进行定义处初始化。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> people[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Apple</span>(<span class="type">int</span> i); </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> apple_number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Apple::<span class="built_in">Apple</span>(<span class="type">int</span> i):<span class="built_in">apple_number</span>(i)&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="STATIC"><a href="#STATIC" class="headerlink" title="STATIC"></a>STATIC</h3><p><strong>1.C语言中的STATIC</strong></p><ul><li>STATIC修饰的全局变量/函数只能在本文件使用，其他文件无法直接调用。即无外部链接性。</li><li>STATIC修饰的局部变量必须初始化且仅初始化一次，在程序编译时确定初始值，程序运行结束后才销毁。</li></ul><p><strong>2.C++中的STATIC</strong></p><p>类中的静态变量由对象共享。不能使用构造函数初始化，也不能在类中初始化，📌只能在外部进行初始化。</p><p>类中的静态函数只能访问静态变量。</p><p>📌工厂单例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> base&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPUDeviceAllocatorFactory</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;CPUDeviceAllocator&gt; <span class="title">get_instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        instance = std::<span class="built_in">make_shared</span>&lt;CPUDeviceAllocator&gt;();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;CPUDeviceAllocator&gt; instance;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//alloc_cpu.cpp</span></span><br><span class="line"><span class="keyword">namespace</span> base&#123;</span><br><span class="line">std::shared_ptr&lt;CPUDeviceAllocator&gt; CPUDeviceAllocatorFactory::instance = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="THIS"><a href="#THIS" class="headerlink" title="THIS"></a>THIS</h3><p>this指针指向类对象本身，通常用于返回对象本身，或在参数和成员变量名相同时使用。</p><h3 id="INLINE"><a href="#INLINE" class="headerlink" title="INLINE"></a>INLINE</h3><p>inline可以避免函数调用的开销，但会导致代码膨胀，因此只在函数非常短时使用。</p><p>虚函数可以是内联函数，但只有在已知对象是哪个类时可以内联。使用指针访问时表现多态性，不能调用内联的虚函数。</p><h3 id="SIZEOF"><a href="#SIZEOF" class="headerlink" title="SIZEOF"></a>SIZEOF</h3><ul><li>空类的大小为1字节。</li><li>类中的函数和静态数据成员不占用对象存储空间。</li><li>继承时，派生类继承基类成员，按照字节对齐计算大小。</li><li>继承多个有虚函数的基类时，继承多个虚指针。</li></ul><h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><ul><li>📌纯虚函数通过赋值0来声明。包含纯虚函数的类为抽象类。</li><li>所有纯虚函数被覆盖，类才不会变为抽象类。</li><li>纯虚函数没有实现，虚函数必须实现。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><ul><li>友元不是成员函数，不能是虚函数，但是可以让友元函数调用虚函数，实现友元的虚拟。</li><li>虚函数是通过vptr实现多态的。每个使用虚函数的类都有一个vptr，指向虚函数表，表中为函数指针。当使用基类指针调用虚函数时，通过vptr找到子类的虚函数表调用子类的函数实现。子类的虚函数表中没有重写的虚函数都仍然为基类指针，重写的为指向重写函数的指针。</li><li>📌构造函数不能是虚函数，析构函数可以是，<strong>并且析构函数应该是虚函数</strong>，调用相应类型的对象的析构函数，然后调用基类的虚构函数。如果不是虚函数，使用基类指针进行delete时，就会导致派生类析构未调用，释放不正确。例如以下代码，基类析构就必须是virtual的。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; <span class="comment">// 将析构函数声明为 virtual</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>]; <span class="comment">// 动态分配内存</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data; <span class="comment">// 释放内存</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>(); <span class="comment">// 基类指针指向派生类对象</span></span><br><span class="line">    <span class="keyword">delete</span> ptr; <span class="comment">// 通过基类指针删除对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数的默认参数是静态绑定的，因此默认参数是根据指针或引用使用的，而不是对象类型。例如base指针调用函数，使用的是基类的默认参数。调用的是指向对象的虚函数实现，取决于实际的指向对象。</li><li>静态函数不能是虚函数，因为他不属于任何类对象。</li><li>虚函数私有：要把基类声明为public，继承类为private，就可以用指针正常访问。</li></ul><h3 id="VOLATILE"><a href="#VOLATILE" class="headerlink" title="VOLATILE"></a>VOLATILE</h3><ul><li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</li><li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）。</li><li>const 可以是 volatile （如只读的状态寄存器），指针可以是 volatile。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span>  <span class="type">bool</span> bStop=<span class="literal">false</span>;  <span class="comment">//bStop 为共享全局变量 </span></span><br><span class="line"><span class="comment">//如果bstop不用volatile声明，这个值可能会读取到寄存器当中，从而导致thread中的死循环。</span></span><br><span class="line"><span class="comment">//第一个线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunc1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span>(!bStop)&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二个线程终止上面的线程循环</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunc2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    bStop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ASSERT"><a href="#ASSERT" class="headerlink" title="ASSERT"></a>ASSERT</h3><p>断言主要用于检查逻辑上不可能的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="type">int</span> x = <span class="number">7</span>; </span><br><span class="line">    <span class="comment">/*  Some big code in between and let&#x27;s say x  </span></span><br><span class="line"><span class="comment">    is accidentally changed to 9  */</span></span><br><span class="line">    x = <span class="number">9</span></span><br><span class="line">    <span class="comment">// Programmer assumes x to be 7 in rest of the code </span></span><br><span class="line">    <span class="built_in">assert</span>(x==<span class="number">7</span>); </span><br><span class="line">    <span class="comment">/* Rest of the code */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在代码开头加上#define NDEBUG可以忽略断言。</p><h3 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h3><p>位域必须是整型或枚举，通常使用结构体声明，为每个成员设置名称，并决定其宽度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_PRCODE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> code1: <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cdde2: <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> code3: <span class="number">8</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>C语言用 unsigned int 作为位域的基本单位，即使一个结构的唯一成员为 1 Bit 的位域，该结构大小也和一个 unsigned int 大小相同。 有些系统中，unsigned int 为 16 Bits，在 x86 系统中为 32 Bits。</p><p>一个位域成员不允许跨越两个 unsigned int 的边界，如果成员声明的总位数超过了一个 unsigned int 的大小， 那么编辑器会自动移位位域成员，使其按照 unsigned int 的边界对齐。</p><h3 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h3><p>C++和C中对函数编译生成的符号不同，C编译的函数名类似_add，没有参数，因为C语言中没有重载。所以如果链接C和CPP文件，则需要在引用C的头文件时，加extern “C”：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ADD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_H</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//add.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//add.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要将.c文件编译为.o文件(gcc -c)后进行链接。</p><h3 id="STRUCT"><a href="#STRUCT" class="headerlink" title="STRUCT"></a>STRUCT</h3><p>struct名字和函数名可以相同，但是不能是typedef定义别名，而且必须在声明前加struct：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不定义别名</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;&#125;;</span><br><span class="line"><span class="built_in">Student</span>()&#123;&#125;</span><br><span class="line">Struct Student s; <span class="comment">//ok</span></span><br><span class="line">Student s;  <span class="comment">//error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Base1</span> &#123;&#125;B;</span><br><span class="line"><span class="comment">//void B() &#123;&#125;  //error! 符号 &quot;B&quot; 已经被定义为一个 &quot;struct Base1&quot; 的别名</span></span><br></pre></td></tr></table></figure><p>和类的区别为struct成员默认为public，更适合看成数据结构实现体。</p><h3 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h3><p>联合可以有多个数据成员，任意时刻只有一个数据成员有值。默认为public，可以有构造和析构函数，不能含有引用类型成员，不能继承或作基类或含虚函数。</p><h3 id="EXPLICIT"><a href="#EXPLICIT" class="headerlink" title="EXPLICIT"></a>EXPLICIT</h3><p>📌explicit修饰构造函数，防止隐式转换和拷贝初始化；修饰转换函数时可以防止隐式转换，按语境转换除外。实际上，大部分拷贝初始化都会被自动优化为直接初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="type">int</span> b)</span>: num(b)&#123;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(B b)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">B <span class="title">b1</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//OK</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>);<span class="comment">//error</span></span><br><span class="line">    B b2 = <span class="number">1</span>;<span class="comment">//error</span></span><br><span class="line">    B b3 = (B)<span class="number">1</span>;<span class="comment">//OK static_cast</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FRIEND"><a href="#FRIEND" class="headerlink" title="FRIEND"></a>FRIEND</h3><p>友元共有两种形式，友元函数和友元类。友元没有继承和传递。</p><p>友元函数声明在类中，定义在外部：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> _a):<span class="built_in">a</span>(_a)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">geta</span><span class="params">(A &amp;ca)</span></span>;  <span class="comment">///&lt; 友元函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">geta</span><span class="params">(A &amp;ca)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ca.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>友元类声明在类声明中，实现在类外：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> _a):<span class="built_in">a</span>(_a)&#123;&#125;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getb</span><span class="params">(A ca)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  ca.a; </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>📌对于流重载这样的操作，不一定要使用友元，类应该有对外接口访问其成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::ostream&amp; operator&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="type">const</span> Status&amp; x) &#123;</span><br><span class="line">  os &lt;&lt; x.get_err_msg();</span><br><span class="line">  <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="USING"><a href="#USING" class="headerlink" title="USING"></a>USING</h3><p>作用域：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> isNs1 1</span></span><br><span class="line"><span class="comment">//#define isGlobal 2</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;::func&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ns1 &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ns1::func&quot;</span>&lt;&lt;endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ns2 &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> isNs1 </span></span><br><span class="line">    <span class="keyword">using</span> ns1::func;    <span class="comment">/// ns1中的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> isGlobal</span></span><br><span class="line">    <span class="keyword">using</span> ::func; <span class="comment">/// 全局中的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;other::func&quot;</span>&lt;&lt;endl; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这就是为什么在c++中使用了cmath而不是math.h头文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ns2::<span class="built_in">func</span>(); <span class="comment">// 会根据当前环境定义宏的不同来调用不同命名空间下的func()函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改变访问性：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> n;  &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> std::<span class="type">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">using</span> Base::size;<span class="comment">//改变私有继承的size()为public</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> <span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>重载：在继承过程中，派生类可以覆盖重载函数的0个或多个实例，<font color="red">一旦定义了一个重载版本，那么其他的重载版本都会变为不可见。</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; cout&lt;&lt;<span class="string">&quot;f()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Base::f(int)&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> Base::f;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Derived::f(int)&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">f</span>();</span><br><span class="line">    d.<span class="built_in">f</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取代typedef：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; V1; </span><br><span class="line"><span class="keyword">using</span> V2 = vector&lt;<span class="type">int</span>&gt;;</span><br></pre></td></tr></table></figure><h3 id="ENUM"><a href="#ENUM" class="headerlink" title="ENUM"></a>ENUM</h3><p>枚举有一个问题是作用域不受限，会引起命名冲突：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;RED,BLUE&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Feeling</span> &#123;EXCITED,BLUE&#125;;</span><br></pre></td></tr></table></figure><p>经典做法是加上前缀：COLOR_BLUE，但是这样会很累赘，有个代替的方法是使用结构体来限定作用域：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color1</span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Type</span>&#123;</span><br><span class="line">        RED=<span class="number">102</span>,</span><br><span class="line">        YELLOW,</span><br><span class="line">        BLUE</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另外两个问题是enum会转换为int，以及表示枚举变量的实际类型不能明确指定，C++11中引入了枚举类来解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color2</span>&#123;</span><br><span class="line">    RED=<span class="number">2</span>,</span><br><span class="line">    YELLOW,</span><br><span class="line">    BLUE</span><br><span class="line">&#125;;</span><br><span class="line">Color2 c2 = Color2::RED;</span><br><span class="line">cout &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(c2) &lt;&lt; endl; <span class="comment">//必须转！</span></span><br></pre></td></tr></table></figure><p>枚举类可以用特定类型来存储enum：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color3</span>:<span class="type">char</span>;  <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color3</span>:<span class="type">char</span> &#123;</span><br><span class="line">    RED=<span class="string">&#x27;r&#x27;</span>,</span><br><span class="line">    BLUE</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> c3 = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(Color3::RED);</span><br></pre></td></tr></table></figure><p>类中可以使用枚举来表示常量，枚举常量不会占用对象的存储空间，它们在编译时被全部求值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">        BOY = <span class="number">0</span>,</span><br><span class="line">        GIRL</span><br><span class="line">    &#125;SexType;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//访问的时候通过，Person::BOY或者Person::GIRL来进行访问。</span></span><br></pre></td></tr></table></figure><h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>decltype(expression)用于查询表达式的类型(不会对表达式求值)。常见用法：</p><ul><li>推导表达式类型：decltype(i) a;</li><li>定义类型</li><li>重用匿名类型</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> d ;</span><br><span class="line">    doubel b;</span><br><span class="line">&#125;anon_s;</span><br><span class="line"><span class="keyword">decltype</span>(anon_s) as ;<span class="comment">//定义了一个上面匿名的结构体</span></span><br></pre></td></tr></table></figure><ul><li>泛型编程中结合auto，追踪函数的返回类型(最大用途)：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">multiply</span><span class="params">(T x, T y)</span>-&gt;<span class="title">decltype</span><span class="params">(x*y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h3><p><strong>引用与指针</strong></p><ul><li><p>引用必须初始化，指针不必要。</p></li><li><p>引用不能为空，指针可以，所以指针需要检查是否为空。</p></li><li><p>指针可以随时改变指向，但是引用无法改变，只能指向初始化时指向的对象。</p></li></ul><p><strong>引用</strong></p><p>左值是存储在内存中、有明确存储地址（可寻址）的数据，右值是可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。</p><ul><li>左值引用是常规引用，一般表示对象的身份。左值引用要求右边的值必须能够取地址，如果不能取址，可以使用指向常量的引用，不过这样数据就无法修改了。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;var = <span class="number">10</span>;<span class="comment">//常量有地址，可以取址</span></span><br></pre></td></tr></table></figure><ul><li>右值引用是必须绑定到一个临时对象、将要销毁的对象的引用，一般表示对象的值。右值引用主要目的是消除不必要的对象拷贝，更简洁明确地定义泛型函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int &amp;&amp; a = num;   //右值引用不能初始化为左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp; a = <span class="number">10</span>;<span class="comment">//右值引用可以修改</span></span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><strong>引用型返回值</strong></p><p>使用引用型返回值常常是在运算符重载时，例如重载[]：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">v[<span class="number">5</span>] = <span class="number">10</span>;    <span class="comment">//[]操作符返回引用，然后vector对应元素才能被修改</span></span><br></pre></td></tr></table></figure><p><font color="orange">★</font><strong>常量左值引用</strong></p><p>常量左值引用既可以绑定左值又可以绑定右值，常见：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不考虑编译器优化</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Copyable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Copyable</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Copyable</span>(<span class="type">const</span> Copyable &amp;o) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copied&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Copyable <span class="title">ReturnRvalue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Copyable</span>(); <span class="comment">//返回一个临时对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AcceptVal</span><span class="params">(Copyable a)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AcceptRef</span><span class="params">(<span class="type">const</span> Copyable&amp; a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pass by value: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">AcceptVal</span>(<span class="built_in">ReturnRvalue</span>()); <span class="comment">// 应该调用两次拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pass by reference: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">AcceptRef</span>(<span class="built_in">ReturnRvalue</span>()); <span class="comment">//应该只调用一次拷贝构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="orange">★</font><strong>移动语义</strong></p><p>移动语义是为了解决不必要的构造次数过多的问题产生的方法，例如以下的一段MyString类实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> CCtor; <span class="comment">//统计调用拷贝构造函数的次数</span></span><br><span class="line"><span class="comment">//    static size_t CCtor; //统计调用拷贝构造函数的次数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">   <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* cstr=<span class="number">0</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span> (cstr) &#123;</span><br><span class="line">          m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(cstr)+<span class="number">1</span>];</span><br><span class="line">          <span class="built_in">strcpy</span>(m_data, cstr);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">          m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">          *m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 拷贝构造函数</span></span><br><span class="line">   <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; str) &#123;</span><br><span class="line">       CCtor ++;</span><br><span class="line">       m_data = <span class="keyword">new</span> <span class="type">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">       <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 拷贝赋值函数 =号重载</span></span><br><span class="line">   MyString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyString&amp; str)&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 避免自我赋值!!</span></span><br><span class="line">          <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">delete</span>[] m_data;</span><br><span class="line">       m_data = <span class="keyword">new</span> <span class="type">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">       <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">       <span class="keyword">delete</span>[] m_data;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">char</span>* m_data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">size_t</span> MyString::CCtor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;MyString&gt; vecStr;</span><br><span class="line">    vecStr.<span class="built_in">reserve</span>(<span class="number">1000</span>); <span class="comment">//先分配好1000个空间，不这么做，调用的次数可能远大于1000</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        vecStr.<span class="built_in">push_back</span>(<span class="built_in">MyString</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; MyString::CCtor &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在push_back的时候进行了1000次拷贝构造，构造出来的临时字符串都没有什么用，导致了没用的资源申请和释放。如果使用移动语义，就可以直接进行移动：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> CCtor; <span class="comment">//统计调用拷贝构造函数的次数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> MCtor; <span class="comment">//统计调用移动构造函数的次数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> CAsgn; <span class="comment">//统计调用拷贝赋值函数的次数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> MAsgn; <span class="comment">//统计调用移动赋值函数的次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">   <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* cstr=<span class="number">0</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span> (cstr) &#123;</span><br><span class="line">          m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(cstr)+<span class="number">1</span>];</span><br><span class="line">          <span class="built_in">strcpy</span>(m_data, cstr);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">          m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">          *m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 拷贝构造函数</span></span><br><span class="line">   <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; str) &#123;</span><br><span class="line">       CCtor ++;</span><br><span class="line">       m_data = <span class="keyword">new</span> <span class="type">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">       <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 移动构造函数</span></span><br><span class="line">   <span class="built_in">MyString</span>(MyString&amp;&amp; str) <span class="keyword">noexcept</span></span><br><span class="line">       :<span class="built_in">m_data</span>(str.m_data) &#123;</span><br><span class="line">       MCtor ++;</span><br><span class="line">       str.m_data = <span class="literal">nullptr</span>; <span class="comment">//不再指向之前的资源了</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 拷贝赋值函数 =号重载</span></span><br><span class="line">   MyString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyString&amp; str)&#123;</span><br><span class="line">       CAsgn ++;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 避免自我赋值!!</span></span><br><span class="line">          <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">delete</span>[] m_data;</span><br><span class="line">       m_data = <span class="keyword">new</span> <span class="type">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">       <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 移动赋值函数 =号重载</span></span><br><span class="line">   MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) <span class="keyword">noexcept</span>&#123;</span><br><span class="line">       MAsgn ++;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) <span class="comment">// 避免自我赋值!!</span></span><br><span class="line">          <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">delete</span>[] m_data;</span><br><span class="line">       m_data = str.m_data;</span><br><span class="line">       str.m_data = <span class="literal">nullptr</span>; <span class="comment">//不再指向之前的资源了</span></span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">       <span class="keyword">delete</span>[] m_data;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">char</span>* m_data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">size_t</span> MyString::CCtor = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> MyString::MCtor = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> MyString::CAsgn = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> MyString::MAsgn = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;MyString&gt; vecStr;</span><br><span class="line">    vecStr.<span class="built_in">reserve</span>(<span class="number">1000</span>); <span class="comment">//先分配好1000个空间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        vecStr.<span class="built_in">push_back</span>(<span class="built_in">MyString</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;CCtor = &quot;</span> &lt;&lt; MyString::CCtor &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MCtor = &quot;</span> &lt;&lt; MyString::MCtor &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;CAsgn = &quot;</span> &lt;&lt; MyString::CAsgn &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MAsgn = &quot;</span> &lt;&lt; MyString::MAsgn &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码直接把右值引用的指针修改了，相当于直接让自己的指针指向右值引向的临时变量的值，这样就避免了一次没有意义的拷贝，而临时变量也马上会被销毁，因此将其指针改为nullpter就可以了。(必须要改，不然数据被释放了)</p><blockquote><p>delete空指针是合法的。并且为了安全，delete非空指针后最好要把指针置空，因为delete只是释放指向的空间，指针还会指向那部分空间。</p></blockquote><p>右值引用可以移动，如果左值引用的局部变量生命周期很短，也是可以移动的，C++11提供了std::move()来将左值转换为右值，告诉编译器使用移动构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;MyString&gt; vecStr;</span><br><span class="line">    vecStr.<span class="built_in">reserve</span>(<span class="number">1000</span>); <span class="comment">//先分配好1000个空间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        <span class="function">MyString <span class="title">tmp</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">        vecStr.<span class="built_in">push_back</span>(tmp); <span class="comment">//调用的是拷贝构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;CCtor = &quot;</span> &lt;&lt; MyString::CCtor &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MCtor = &quot;</span> &lt;&lt; MyString::MCtor &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;CAsgn = &quot;</span> &lt;&lt; MyString::CAsgn &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MAsgn = &quot;</span> &lt;&lt; MyString::MAsgn &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    MyString::CCtor = <span class="number">0</span>;</span><br><span class="line">    MyString::MCtor = <span class="number">0</span>;</span><br><span class="line">    MyString::CAsgn = <span class="number">0</span>;</span><br><span class="line">    MyString::MAsgn = <span class="number">0</span>;</span><br><span class="line">    vector&lt;MyString&gt; vecStr2;</span><br><span class="line">    vecStr2.<span class="built_in">reserve</span>(<span class="number">1000</span>); <span class="comment">//先分配好1000个空间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        <span class="function">MyString <span class="title">tmp</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">        vecStr2.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(tmp)); <span class="comment">//调用的是移动构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;CCtor = &quot;</span> &lt;&lt; MyString::CCtor &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MCtor = &quot;</span> &lt;&lt; MyString::MCtor &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;CAsgn = &quot;</span> &lt;&lt; MyString::CAsgn &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MAsgn = &quot;</span> &lt;&lt; MyString::MAsgn &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是需要注意变量作用域，tmp在移动构造以后失去了内容，但是还没有被销毁，这之后使用是可能产生错误的。</p><p><strong>通用引用</strong></p><p>当遇到模版中的自动类型推导或auto时，&amp;&amp;会变成通用引用，到底是左值还是右值，取决于他的初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">( T&amp;&amp; param)</span></span>&#123;&#125;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>);  <span class="comment">//10是右值</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">f</span>(x); <span class="comment">//x是左值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">( T&amp;&amp; param)</span></span>; <span class="comment">//这里T的类型需要推导，所以&amp;&amp;是一个 universal references</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="built_in">Test</span>(Test&amp;&amp; rhs); <span class="comment">//Test是一个特定的类型，不需要类型推导，所以&amp;&amp;表示右值引用  </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Test&amp;&amp; param)</span></span>; <span class="comment">//右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//复杂一点</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; param)</span></span>; <span class="comment">//在调用这个函数之前，这个vector&lt;T&gt;中的推断类型</span></span><br><span class="line"><span class="comment">//已经确定了，所以调用f函数的时候没有类型推断了，所以是 右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>; <span class="comment">//右值引用</span></span><br><span class="line"><span class="comment">// universal references仅仅发生在 T&amp;&amp; 下面，任何一点附加条件都会使之失效</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>完美转发</strong></p><p>完美转发是指函数将参数进行转交时，不会改变参数的左/右值特征，就是完美的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; i)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;process(int&amp;):&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; i)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;process(int&amp;&amp;):&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myforward</span><span class="params">(<span class="type">int</span>&amp;&amp; i)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myforward(int&amp;&amp;):&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">process</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">process</span>(a); <span class="comment">//a被视为左值 process(int&amp;):0</span></span><br><span class="line">    <span class="built_in">process</span>(<span class="number">1</span>); <span class="comment">//1被视为右值 process(int&amp;&amp;):1</span></span><br><span class="line">    <span class="built_in">process</span>(<span class="built_in">move</span>(a)); <span class="comment">//强制将a由左值改为右值 process(int&amp;&amp;):0</span></span><br><span class="line">    <span class="built_in">myforward</span>(<span class="number">2</span>);  <span class="comment">//右值经过forward函数转交给process函数，却称为了一个左值，</span></span><br><span class="line">    <span class="comment">//原因是该右值有了名字  所以是 process(int&amp;):2</span></span><br><span class="line">    <span class="built_in">myforward</span>(<span class="built_in">move</span>(a));  <span class="comment">// 同上，在转发的时候右值变成了左值  process(int&amp;):0</span></span><br><span class="line">    <span class="comment">// forward(a) // 错误用法，右值引用不接受左值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的例子是不完美转发，C++11提供了std::forward()函数解决这个问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myforward</span><span class="params">(<span class="type">int</span>&amp;&amp; i)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myforward(int&amp;&amp;):&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;<span class="type">int</span>&gt;(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">myforward</span>(<span class="number">2</span>); <span class="comment">// process(int&amp;&amp;):2</span></span><br></pre></td></tr></table></figure><p>上面修改后，右值可以完美转发了，但是左值还是不行，这时就需要借助上述提到的通用引用来解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">perfectForward</span><span class="params">(T &amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RunCode</span>(forward&lt;T&gt; (t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样无论是左值还是右值，都可以完美转发了。</p><h2 id="二-常见方法"><a href="#二-常见方法" class="headerlink" title="二.常见方法"></a>二.常见方法</h2><h3 id="1-RAII"><a href="#1-RAII" class="headerlink" title="1.RAII"></a>1.RAII</h3><p>RAII的意思是资源获取即初始化，是一种编程技术。RAII保证资源的声明周期与一个对象的生存期相绑定。保证资源能够用于任何访问该对象的函数，避免内存泄露。</p><p>RAII可以总结如下：</p><ul><li>每个资源封装在一个类中，构造函数请求资源，在无法完成时抛出异常，析构函数释放资源且决不会抛出异常。</li><li>在使用资源时始终通过RAII类的具有自动存储器或临时生存期的实例。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">std::mutex m;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bad</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m.<span class="built_in">lock</span>();                    <span class="comment">// 请求互斥体</span></span><br><span class="line">    <span class="built_in">f</span>();                         <span class="comment">// 如果 f() 抛出异常，那么互斥体永远不会被释放</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">everything_ok</span>()) <span class="keyword">return</span>; <span class="comment">// 提早返回，互斥体永远不会被释放</span></span><br><span class="line">    m.<span class="built_in">unlock</span>();                  <span class="comment">// 只有 bad() 抵达此语句，互斥体才会被释放</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">good</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>; <span class="comment">// RAII类：互斥体的请求即是初始化</span></span><br><span class="line">    <span class="built_in">f</span>();                               <span class="comment">// 如果 f() 抛出异常，那么就会释放互斥体</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">everything_ok</span>()) <span class="keyword">return</span>;       <span class="comment">// 提早返回也会释放互斥体</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="2-智能指针"><a href="#2-智能指针" class="headerlink" title="2.智能指针"></a>2.智能指针</h3><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>1.<a href="https://light-city.github.io">https://light-city.github.io</a></p><p>2.<a href="https://www.jianshu.com/p/d19fc8447eaa">https://www.jianshu.com/p/d19fc8447eaa</a></p><p>3.<a href="https://zh.cppreference.com/w/cpp/language/raii">https://zh.cppreference.com/w/cpp/language/raii</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能计算学习记录</title>
      <link href="/2023/09/11/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/09/11/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>记录自己的高性能计算(入门)学习路线。</p><span id="more"></span><h2 id="一-基础知识"><a href="#一-基础知识" class="headerlink" title="一.基础知识"></a>一.基础知识</h2><h3 id="1-编程语言"><a href="#1-编程语言" class="headerlink" title="1.编程语言"></a>1.编程语言</h3><p><strong>C++</strong></p><p>这部分主要是了解了一小部分C++11/14/17的新特性，不过只略看了一些常见的内容。</p><p>发现了有意思的网站，待完成：<a href="https://roadmap.sh/cpp">https://roadmap.sh/cpp</a></p><p><strong>Python</strong></p><p>CS61A，待完成</p><h3 id="2-性能分析"><a href="#2-性能分析" class="headerlink" title="2.性能分析"></a>2.性能分析</h3><p>主要是perf和Intel VTune(VTune自己的机器暂时用不了，等之后在qemu上试)</p><h3 id="3-并行编程基础"><a href="#3-并行编程基础" class="headerlink" title="3.并行编程基础"></a>3.并行编程基础</h3><p><strong>课程</strong></p><ul><li><p>15-418✅</p></li><li><p>6.172</p></li><li><p>cec508/408</p></li></ul><p><strong>Lab</strong></p><ul><li>cs149</li><li>HPC101</li></ul><h3 id="4-Linux"><a href="#4-Linux" class="headerlink" title="4.Linux"></a>4.Linux</h3><ul><li><a href="https://gist.github.com/ryerh/14b7c24dfd623ef8edc7">Tmux</a></li><li><a href="https://101.lug.ustc.edu.cn/">Linux 101</a></li></ul><h2 id="二-并行编程"><a href="#二-并行编程" class="headerlink" title="二.并行编程"></a>二.并行编程</h2><ul><li><p>SIMD</p><ul><li>AVX</li><li>Neon</li></ul></li><li><p>MPI</p></li><li>CUDA</li><li>C++并行编程<ul><li>std::thread</li><li>pthread✅</li><li>OpenMP✅</li></ul></li></ul><h2 id="三-知识总结"><a href="#三-知识总结" class="headerlink" title="三.知识总结"></a>三.知识总结</h2>]]></content>
      
      
      <categories>
          
          <category> 高性能计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高性能计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机体系结构：体系结构基础与流水线原理</title>
      <link href="/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/"/>
      <url>/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机体系结构：体系结构基础与流水线原理"><a href="#计算机体系结构：体系结构基础与流水线原理" class="headerlink" title="计算机体系结构：体系结构基础与流水线原理"></a>计算机体系结构：体系结构基础与流水线原理</h1><p>​        计算机体系结构：量化设计与分析一书以RISC-V为例介绍计算机体系结构。本文为第一部分，介绍体系结构的基本知识和流水线原理。笔记内容为原书的第一章，附录A、B、C。</p><h2 id="第一章-量化设计与分析基础"><a href="#第一章-量化设计与分析基础" class="headerlink" title="第一章 量化设计与分析基础"></a>第一章 量化设计与分析基础</h2><p>​        第一章主要介绍关于体系结构的基础知识，最为重要的是关于体系结构的相关定义(指令集体系结构)的内容(1.3节)，主要位于附录A；其他内容(1.1-1.2&amp;1..4-1.8节)包括计算机的分类，技术趋势，成本趋势，功耗等，只需要有大概的认知和了解；最后的1.9节介绍了计算机设计的量化原理，给出了三个设计计算机时的指导原则。其中相对不重要的部分省略了。</p><span id="more"></span><h3 id="1-3-体系结构的定义"><a href="#1-3-体系结构的定义" class="headerlink" title="1.3 体系结构的定义"></a>1.3 体系结构的定义</h3><p>​        狭义的计算机体系结构仅包括指令集设计，但体系结构要解决的问题已经远超出指令集设计的范围了，因此，本书介绍的体系结构包括：<strong>指令集体系结构，微体系结构(存储器，内部处理器等组成)，硬件实现</strong>。</p><p>​        其中的指令集体系结构，在附录A中详细介绍。</p><h3 id="1-4技术趋势"><a href="#1-4技术趋势" class="headerlink" title="1.4技术趋势"></a>1.4技术趋势</h3><p>​        过去的计算机设计技术随着集成电路逻辑技术，半导体技术，磁盘技术等的快速发展而迅猛提高。然而现在随着摩尔定律的失效，技术提升的速度已经放缓了。仅关注性能方面的趋势，最大的特点是：<strong>带宽的改进远大于延迟的改进</strong>，经验表明带宽的增长速度至少是延迟改进速度的平方。</p><p><img src="/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/image-20230411212047842-16817400241941.png" alt="image-20230411212047842" style="zoom:50%;"></p><h3 id="1-9计算机设计的量化原理"><a href="#1-9计算机设计的量化原理" class="headerlink" title="1.9计算机设计的量化原理"></a>1.9计算机设计的量化原理</h3><ul><li>充分利用并行：指令并行，线程并行，数据并行，电路并行，任务并行等。</li><li>局部性原理：时间局部性/空间局部性原理</li><li>重点关注常见情形：从常见情形提高计算机的工作效率</li></ul><p>​        1.9还介绍了一个重要的定律，用于计算改进计算机的一部分而获得的性能增益，即Amdahl定律。Amdahl定义了加速比：</p><script type="math/tex; mode=display">加速比 = \frac{原执行时间}{采用改进后的执行时间}</script><p>​        假设改进的比例称为升级比例，改进的部分的升级加速比已知，则整体的执行时间为：</p><script type="math/tex; mode=display">新执行时间 = 原执行时间 \times [(1-升级比例)+\frac{升级比例}{升级加速比}]</script><p>​        从而可计算总加速比为：</p><script type="math/tex; mode=display">总加速比 = \frac{原执行时间}{新执行时间}=\frac{1}{(1-升级比例)+\frac{升级比例}{升级加速比}}</script><p>​        除此外还介绍了一些衡量性能的指标，例如CPI(每条指令时钟周期数)，时钟频率，响应时间，带宽/延迟等：</p><ul><li>响应时间 = 任务开始到任务完成的时间 = CPU TIME + WAITING TIME，用CPU性能衡量CPU执行时间</li><li>CPU时间  = 程序的CPU时钟周期数<script type="math/tex">\times</script>时钟周期时间 = CPI<script type="math/tex">\times</script>指令数<script type="math/tex">\times</script>时钟周期时间</li></ul><h2 id="附录A-指令集基本原理"><a href="#附录A-指令集基本原理" class="headerlink" title="附录A 指令集基本原理"></a>附录A 指令集基本原理</h2><h3 id="1-指令集体系结构的分类"><a href="#1-指令集体系结构的分类" class="headerlink" title="1.指令集体系结构的分类"></a>1.指令集体系结构的分类</h3><p>​        <strong>指令集体系结构的区别在于处理器中内部存储类型的不同</strong>。共有三种体系结构：<strong>栈体系结构，累加器体系结构，通用寄存器体系结构</strong>。其中，栈和累加器式的体系结构都使用隐式的操作数，而通用寄存器使用显式的操作数，或者为寄存器，或者为存储器位置。</p><p><img src="/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/image-20230307211206107.png" alt="image-20230307211206107" style="zoom: 67%;"></p><p>​        通用寄存器体系结构又可以分为两类，一类可使用任意指令来访问存储器，称为<strong>寄存器-存储器体系结构</strong>，另一类只能用载入和存储指令来访问存储器，称为<strong>载入-存储体系结构</strong>。第三类将所有操作数保存在存储器中，还没有出现在今天的计算机中，称为存储器-存储器体系结构。寄存器-存储器体系结构可以使用较少的指令，但指令的实现较为复杂；而载入-存储体系结构需要使用更多的指令，实现较为简单。</p><p>​        现有的计算机都使用通用寄存器体系结构，因为寄存器比存储器更快，且对于编译器来说，使用寄存器效率更高，这是因为寄存器可用于保存变量，可以降低存储器通信流量，加快程序速度。</p><h3 id="2-存储器寻址"><a href="#2-存储器寻址" class="headerlink" title="*2.存储器寻址"></a>*2.存储器寻址</h3><p><strong>解释存储器地址</strong></p><p>​        通常在指令集中都是字节寻址的，存储器地址访问到的是一个字节，指令集提供对字节，半字，和字的访问方式，大多数计算机还提供对双字的访问。</p><p>​        一个大于一个字节的数据在存储器中的存放方式有两种，分别为：</p><ul><li>小端法：低位在低地址</li><li>大端法：高位在低地址</li></ul><p>​        现代计算机通常支持双端，可以配置为任意一种顺序。</p><p>​        在许多计算机中，对于大于一个字节的存储器寻址都必须是对齐的。因为存储器通常与一个字或双字的倍数对齐，读写更快，如果使用非对齐寻址则会增加硬件的复杂性，并且非对齐寻址可能需要多个对齐的存储器引用。</p><p><strong>寻址方式</strong></p><p>​        常用的寻址方式包括寄存器间接寻址，立即数寻址，偏移量寻址等。</p><p>​        一种体系结构至少支持以上提到的三种寻址方式，并且根据统计数据，偏移量寻址方式中的地址大小至少为12-16位，立即数寻址中立即数字段的大小至少为8-16位，就能满足大多数情况下的使用需求。</p><p><img src="/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/image-20230401195836002.png" alt="image-20230401195836002" style="zoom: 50%;"></p><h3 id="3-操作数的类型与大小"><a href="#3-操作数的类型与大小" class="headerlink" title="*3.操作数的类型与大小"></a>*3.操作数的类型与大小</h3><p>​        操作数的常见类型包括字符，半字，字，单精度浮点和双精度浮点。整数通常用二进制补码表示，字符通常使用ASCII码表示，浮点数都采用IEEE标准。</p><h3 id="4-指令集操作"><a href="#4-指令集操作" class="headerlink" title="*4.指令集操作"></a>*4.指令集操作</h3><p>​        基本所有的指令集体系结构都至少支持以下几种操作：</p><ul><li>算数与逻辑：数的运算与逻辑运算</li><li>数据传送：载入-存储(move指令)</li><li>控制：分支，跳转，过程调用与返回，陷阱</li><li>系统：操作系统调用</li></ul><h3 id="5-控制流指令"><a href="#5-控制流指令" class="headerlink" title="5.控制流指令"></a>5.控制流指令</h3><p>​        关于改变控制流的指令，可以分为四类：</p><ul><li>条件分支(有条件的跳转)</li><li>跳转</li><li>过程调用</li><li>过程返回</li></ul><p>​        根据统计，在计算机中条件分支出现的频率是最高的。</p><p><strong>控制流寻址</strong></p><p>​        控制流寻址常见的一种方式是采用PC相对寻址，还有寄存器间接跳转动态寻址。分支常用PC相对寻址来指定目标，从下图可以看出，分支位移量至少为8位就可以满足大多数情况。</p><p><img src="/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/image-20230308085437140.png" alt="image-20230308085437140" style="zoom:50%;"></p><p>​        寄存器间接跳转寻址通常出现于以下四种情况：</p><ul><li>case/switch</li><li>虚拟函数或虚拟方法</li><li>高级函数或函数指针</li><li>动态共享库</li></ul><p><strong>条件分支选项</strong></p><p>​        条件分支的实现技术主要有以下三种：</p><ul><li>条件代码(80x86)：测试ALU运算设定的特殊位</li><li>条件寄存器(MIPS)：使用寄存器保存比较结果，实现简单</li><li>比较与分支</li></ul><p><strong>过程调用选项</strong></p><p>​        在过程调用和返回时，需要进行一些状态保存，至少包括返回地址和ebp，esp等指针的保存，而保存寄存器则分为两种：由调用者进行保存；由被调用者保存。大多数实际系统都采用这两种机制的组合方式，根据一些确定的基本规则，将一些寄存器由调用者保存，而另一些则由被调用者保存。</p><h3 id="6-指令集编码"><a href="#6-指令集编码" class="headerlink" title="6.指令集编码"></a>6.指令集编码</h3><p>​        指令的编码要说明指令的操作和操作数，此外，还必须能够得到操作数的寻址方式。<strong>对于简单的载入-存储计算机，寻址方式可以编码到操作码之中，而对于有多种寻址方式的计算机，通常为每个操作数添加一个地址标识符说明寻址方式</strong>。对指令集进行编码时，架构师必须平衡以下几个方面：</p><ul><li>允许尽可能多的寄存器和寻址方式</li><li>寄存器字段和寻址方式字段的大小对平均指令大小存在影响</li><li>编码后的指令长度应易于以流水线方式处理</li></ul><p>​        以下是三种常见的指令集编码方式：</p><p><img src="/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/image-20230308110725591.png" alt="image-20230308110725591" style="zoom: 67%;"></p><p>​        变长编码适用于寻址方式和操作较多时，定长编码适用于寻址方式与操作数较少的情况，但牺牲了平均代码规模。两种编码方式之间的权衡是<strong>代码规模与处理器译码的难易程度(性能)</strong>。第三种选择就是提供多种指令长度，缩小代码尺寸，这对于嵌入式应用程序来说很重要。一些RISC指令集版本同时提供16位和32位的指令，从而压缩代码规模。</p><h3 id="7-编译器"><a href="#7-编译器" class="headerlink" title="7.编译器(-)"></a>7.编译器(-)</h3><p>​        机器执行的指令都是由编译器生成的，因此在设计和实现指令集时，需要考虑编译器技术，尽可能降低编译器生成良好代码的难度。目前编译器的结构大致如下：</p><p><img src="/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/image-20230310111513499.png" alt="image-20230310111513499" style="zoom: 67%;"></p><p>​        编译器的首要目标是正确性，其次是编译后的代码速度，这取决于对代码的优化程度。现代编译器的优化可以分类为：</p><ul><li>高级优化：直接对源代码进行</li><li>本地优化：对基本块内的代码进行优化</li><li>全局优化：将本地优化扩展到分支范围之外，并引入对循环的优化</li><li>寄存器分配：图着色算法</li><li>处理器相关的优化</li></ul><p>​        不同优化的相对使用频率：</p><p><img src="/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/image-20230310112014116.png" alt="image-20230310112014116" style="zoom:50%;"></p><p>​        在设计指令集架构时，通过以下特性为编译器编写人员提供帮助：</p><ul><li>提供正交性：操作，数据类型和寻址方式应当是正交的。(两个方面应该互不影响)</li><li>提供原型而非解决方案</li><li>简化候选项之间的平衡</li><li>提供一些指令，将编译时的已知量绑定为常量</li></ul><p>​        综上，设计一个新的指令集体系结构总是希望满足以下三点：</p><ul><li>至少有16个通用寄存器，以简化寄存器分配</li><li>保证正交性，全部寻址方式适用于所有传送数据的指令</li><li>注重简单性</li></ul><h3 id="8-RISC-V"><a href="#8-RISC-V" class="headerlink" title="8.RISC V"></a>8.RISC V</h3><p>​        RISC V的设计如下：</p><ul><li>寄存器组：32个通用寄存器(GPR)，一组浮点寄存器</li><li>数据类型：字节，半字，字，双字，浮点</li><li>寻址方式：立即数寻址，偏移寻址，寄存器间接寻址</li><li>指令格式：32位指令，7位主操作码</li><li>操作：载入与存储，ALU运算，分支与跳转，浮点数运算</li><li>控制流指令：通过跳转指令和分支指令处理控制流转移，分支条件由指令指定</li></ul><p>​        指令格式分为以下几种：</p><img src="/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/image-20230415231042887.png" class title="image-20230415231042887"><p>​        R型是寄存器-寄存器指令，主要是运算类的指令；I型是立即数指令，包括涉及立即数的运算和Load指令；S型指令(以及SB型)通常为存储指令和分支指令，而U型指令(以及UJ型)用于实现跳转。指令中包含了源寄存器(rs)，目的寄存器(rd)，这些字段在译码和写回时使用，读取或写入指定的寄存器。</p><h2 id="附录B-存储器层次结构"><a href="#附录B-存储器层次结构" class="headerlink" title="附录B 存储器层次结构"></a>附录B 存储器层次结构</h2><p>术语表：</p><p><img src="/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/image-20230318094610807.png" alt="image-20230318094610807" style="zoom:80%;"></p><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p><strong>评价缓存性能</strong></p><p>​        评价缓存性能的一种方法是扩展第一章给出的处理器执行公式：</p><center>CPU执行时间 = (CPU时钟周期数+存储器停顿周期数) x 时钟周期时间</center><p>​        其中CPU周期数为IC(指令数) x CPI</p><p>​        存储器停顿周期取决于缺失数和每次缺失的代价：</p><center>存储器停顿周期 = 缺失数 x 缺失代价 = IC(指令数) x 存储器访问 / 指令 x 缺失率 x 缺失代价</center><p>​        其中的存储器访问/指令表示单条指令的存储器访问次数，对于操作不访问存储器的指令，只有取指令本身访问一次存储器。如果直接使用缺失数测量缺失率，通常使用每千条指令缺失数。</p><p>​        缺失率与硬件速度无关，易于测量，但可能产生误导，更好的度量存储器层次结构性能的标准是<strong>存储器平均访问时间</strong>：</p><center>存储器平均访问时间 = 命中时间 + 缺失率 x 缺失代价</center><p><strong>缓存</strong></p><p>​        对于存储器层次结构的第一级：缓存，考虑以下四个问题：</p><ul><li>缓存组织方式：共有以下三种，但其他两种也可以算作组相联<ul><li>直接映射：一个块只能放在一个确定的位置(相当于m个组相联)</li><li>全相联：一个块可放在缓存的任意位置(若可放m个块，相当于m路组相联)</li><li>组相联：一个块可放在缓存中划分出的组里的任意位置</li></ul></li><li>找到块中的缓存：<strong>物理地址</strong>可以划分为以下形式，标志位用于匹配判断是否为要找的块，索引字段指出了组，块偏移从块中选择数据</li></ul><img src="/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/image-20230318095933490.png" class title="image-20230318095933490"><ul><li>缓存缺失读入块时的替换策略：通常有三种策略<ul><li>随机</li><li>LRU</li><li>FIFO</li></ul></li><li>读写策略</li></ul><p>​        重点考虑读写策略。所有指令访问都是读取，大多数指令不会写入数据，针对读取操作的优化是：一旦得到了块地址，就开始读取块，如果命中，就立即交给处理器，否则只需忽略读取值，按照读取缺失处理。而对于写则不能这样优化，必须核对标志位是否相同，因此写入通常比读取慢。写入的策略有两种选项：</p><ul><li>直写：信息被写入缓存和低一级存储器</li><li>写回：信息仅被写入缓存，块被替换时才写入主存储器</li></ul><p>​        为了减少写回块的频率，通常采用一个脏位记录块是否被修改，如果块没有被修改，则不需要写回存储器。</p><p>​        对于写入缺失，也有两种策略：</p><ul><li>写入分派：发生写入缺失时将块写入缓存，随后执行写入命中</li><li>无写入分派：仅修改低一级存储器中的块</li></ul><p><strong>Opteran微处理器中数据缓存的组织方式</strong></p><p><img src="/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/image-20230318102521622.png" alt="image-20230318102521622" style="zoom:67%;"></p><p>​        Opteran采用两路组相联策略，LRU替换策略，写回策略，有一个牺牲块缓冲区，被替换且修改过的块会发送给该缓冲区，写入低一级的存储器。</p><h3 id="2-6种基本的缓存优化"><a href="#2-6种基本的缓存优化" class="headerlink" title="2.6种基本的缓存优化"></a>2.6种基本的缓存优化</h3><p>​        根据存储器平均访问时间的公式，可以将缓存优化的方式分为3类：</p><ul><li>降低缺失率：采用较大的块，大的缓存，较高的相联度</li><li>降低缺失代价：多级缓存</li><li>缩短在缓存中命中的时间：索引缓存时避免地址转换</li></ul><p>​        所有的缺失可以分为三类：</p><ul><li>冷不命中：第一次访问一个块时一定是缺失的</li><li>容量不命中：缓存无法容纳当前需要用到的所有块</li><li>冒险不命中：如果采用组相联或直接映射，则会发生冒险缺失，冒险缺失会随相联度的增大而减小</li></ul><p>​        其中的冒险不命中是最容易避免的，只需要采用全相联布置，但硬件实现成本高，可能会降低处理器时间频率；针对容量不命中，可采用的方法只有增大缓存；冷不命中可以通过增大块的大小来减少，但可能增加其他的缺失。许多降低缺失率的技术也会增加命中时间或缺失代价，因此必须综合考虑提高整体系统的速度的目标，优化缓存。下面介绍6种基本的缓存优化方法。</p><ul><li>增大块大小以降低缺失率：较大的块会降低冷不命中，并且充分利用了空间局部性，但是太大的块会增加缺失代价，增加其他两种缺失。块大小的选择有赖于低级存储器的带宽和延迟，对于高带宽的高延迟存储器，采用大块很少增加缺失代价，鼓励采用大块，若低级处理器是低延迟低带宽的，则鼓励采用小块</li><li>增大缓存以降低缺失率：可降低容量缺失，缺点是可能延长命中时间，增加成本和功耗</li><li>提高相联度以降低缺失率：经验规律是采用八路组相联和全相联是一样有效的。但是提高相联度会提高缺失代价</li><li>采用多级缓存降低缺失代价：使用多级缓存可以加快缓存的速度，同时扩大缓存的容量。为了有效衡量多级缓存的缺失情况，使用局部缺失率(当前缓存级别的缺失率)和全局缺失率(整体缓存的缺失率)。第一级缓存的速度影响处理器的时钟频率，第二级缓存的速度仅影响一级缓存的缺失代价。二级缓存的缺失率更高，，因此重心偏向减少缺失，采用更高相联度和更大的块</li><li>读取缺失的优先级高于写入缺失：对写后读问题，如果写入尚未完成，还在写入缓冲区，可以让读取缺失先检查写入缓冲区的内容</li><li>索引缓存时避免地址转换：多数系统在缓存中使用物理地址，缩短命中时间，避免使用虚拟地址时的地址保护检查和进程标识等问题</li></ul><h3 id="3-虚拟存储器"><a href="#3-虚拟存储器" class="headerlink" title="3.虚拟存储器"></a>3.虚拟存储器</h3><p>​        每个进程都有自己的地址空间，为了让同时运行的进程共享物理地址空间，计算机系统都采用虚拟存储器机制，让程序本身不需要考虑空间的具体分配，由操作系统及硬件负责具体空间的分配和虚拟地址到物理地址的转换。</p><p>​        虚拟存储器的划分由两种机制：段机制和页机制，常见这两种方式的混合使用，或是多页面大小的分页机制的使用。</p><p><strong>存储器层次结构的四个问题</strong></p><ul><li>块在主存的位置：由于存储器缺失会导致访问磁盘，因此需要尽可能降低缺失率，块可以放在主存中的任何位置，即组织方式为全相联</li><li>找到块的位置：分页方式通过页表找到虚拟地址对应的物理地址，地址被分为页号和偏移量，从页表查找映射；分段方式类似，使用段号和偏移获得物理地址。为了加快地址转换，计算机使用一个专门的地址转换缓存(TLB)</li><li>存储器缺失时替换哪个块：操作系统常采用LRU算法，替换最近最少使用的块</li><li>写入策略：由于写入磁盘代价很高，因此总是采用写回策略</li></ul><p><strong>快速地址转换</strong></p><p>​        分页表本身很大，有时候还会采用多级页表，这导致存储器访问甚至需要两次访存才能进行地址转换，因此计算机系统采用硬件缓存TLB(旁路地址转换缓冲)缓存地址转换。操作系统改变页表，必须使相应的TLB失效。</p><p><strong>选择页大小</strong></p><p>​        页大小是常见的体系结构参数，页表的大小和页大小成反比，增大页可以节省存储器，并且分页较大时，可以允许缓存命中较大缓存，并且大的分页还可以使TLB高效映射更多存储器。采用较小的页则可以减少空间碎片，加快进程启动时间。</p><h2 id="附录C-流水线基本原理"><a href="#附录C-流水线基本原理" class="headerlink" title="附录C 流水线基本原理"></a>附录C 流水线基本原理</h2><h3 id="1-RISC-V流水线"><a href="#1-RISC-V流水线" class="headerlink" title="1.RISC V流水线"></a>1.RISC V流水线</h3><p>​        流水线是一种将多条指令重叠执行的实现技术。一条指令需要多个操作，流水线技术利用了操作之间的并行性。流水线可以缩短每条指令的执行时间，可以记作CPI的下降或时钟周期的下降。如果开始时一条指令需要多个时钟周期，则看作是CPI的下降，否则可以看作是时钟周期的下降。</p><p>​        附录介绍RISC-V体系结构下的流水线实现原理。RISC体系结构已在附录A中有所介绍。</p><p><strong>RISC-V指令集的简单实现</strong></p><p>​        RISC指令集中的每条指令都可以在最多五个时钟周期内实现，这五个周期如下：</p><ul><li>取址周期IF：提取当前指令，更新程序计数器</li><li>指令译码/寄存器提取周期ID：对指令进行译码，并读取指定的寄存器值，并进行相等测试，判断是否为分支</li><li>执行周期EX：ALU对上一周期准备的操作数进行操作，根据指令类型执行：<ul><li>存储器引用：基址寄存器+偏移量形成有效地址</li><li>寄存器-寄存器ALU指令</li><li>寄存器-立即数ALU指令</li></ul></li><li>存储器访问MEM：使用上一周期计算的有效地址，载入指令则从存储器中读取数据，存储指令则向存储器写入寄存器组第二个寄存器读取的数据</li><li>写回周期WB：将结果写入寄存器组</li></ul><p>​        下图是MIPS的CPU结构，较RISC-V简单，可对照以上五个阶段，理解数据的流动过程。</p><p><img src="/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/image-20230316093834443.png" alt="image-20230316093834443" style="zoom:50%;"></p><p><strong>RISC-V的流水线</strong></p><p>​        在每个时钟周期开始执行一条新的指令，就可以实现流水线化，为了保证每个周期都能正确执行，需要解决流水线化带来的一些问题。本节首先<strong>确保在一个周期，不会同时对相同数据源执行两个不同操作</strong>。</p><p>​        下图是一个RISC数据路径的流水线表示：</p><p><img src="/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/image-20230314095500546.png" alt="image-20230314095500546" style="zoom:50%;"></p><p>​        主要的功能单元在不同周期使用，因此不会引入太多冒险，以下三点避免了可能的冒险：</p><ul><li>使用<strong>分离的指令缓存和数据缓存</strong>。在取址和存储器访问之间可能发生冒险，为了消除这种冒险，采用分离的缓存；访存可能是读也可能是写，无法确定，并且访存时间较长，不能像寄存器那样按照读写在半个周期分别处理</li><li>在ID和WB两个阶段都使用了寄存器组，ID是读取，WB是写入，因此每个时钟周期要完成多个读取和一次写入。为了处理这个问题，在<strong>时钟周期的前半部分写寄存器，在后半部分读寄存器</strong>（利用上升沿-下降沿将指令周期划分前后）</li><li>为了确保指令在流水线中不会相互干扰，在流水级之间引入流水线寄存器。在时钟周期的末尾，将一个流水级得到的结果存储到寄存器当中，用作下一级的输入</li></ul><p><strong>流水化的基本性能问题</strong></p><p>​        流水化提高了指令吞吐量，但不会缩短单条指令的执行时间，由于流水线控制会产生开销，通常还会稍微延长每条指令的执行时间。流水线开销包括流水线寄存器延迟(建立时间)和时钟偏差(两个寄存器之间的延迟)，时钟的速度不可能快于最慢的流水级，因此时钟周期被限定了下限。</p><h3 id="2-流水线冒险"><a href="#2-流水线冒险" class="headerlink" title="2.流水线冒险"></a>2.流水线冒险</h3><p>​        冒险阻止了指令流在下一个周期的执行，共有以下三类冒险：</p><ul><li>结构冒险：资源冲突</li><li>数据冒险：相邻指令之间存在相关性</li><li>控制冒险：分支指令及其他改变程序计数器的指令实现流水化时可能导致控制冲突</li></ul><p>​        冒险会使流水线停顿，为了避免冒险，经常要求一些指令延迟时，其他一些指令可以继续执行。附录中讨论的流水线，一条指令被停顿后，所有之后发射的指令也被停顿。</p><p><strong>结构冒险</strong></p><p>​        结构冒险是由于资源冲突，不允许某些指令重叠。例如写入存储器的同时从存储器取址。当遇到这种指令序列时，流水线会使其中一个指令停顿一个周期，这个周期被称为<strong>流水线气泡</strong>。结构冒险是可以避免的，例如访存的数据冒险，可以将缓存分为独立的指令缓存和数据缓存，也可以用一组缓冲区来保存指令。是否要避免结构冒险，要考虑单元的成本，对于罕见的结构冒险，不值得花代价避免其出现。</p><p><strong>数据冒险</strong></p><p>​        数据冒险是由数据的读写访问顺序产生的，重叠指令的执行改变了原有的读写顺序。下图的指令就是一个数据冒险，第五个周期ADD指令才写回，但SUB指令在第三个周期就要访问寄存器了。</p><p><img src="/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/image-20230327130454001.png" alt="image-20230327130454001" style="zoom:67%;"></p><p>​        or指令及之后的指令就不会导致冒险了，因为or读寄存器在第五周期的后半部分，而写入是在第五周期的前半部分。</p><p>​        典型的数据冒险是由以下三种相关产生的：</p><ul><li>读后写WAR</li><li>写后读RAW</li><li>写后写WAW</li></ul><p>​        可以利用转发技术减少上述的数据冒险，这一技术也称为数据前推(Forwardig)。转发技术的关键是要把数据转移到需要的地方，对于上例，如果add计算后的结果转移到sub指令计算的位置，就可以避免出现停顿。工作方式如下：</p><ul><li>来自EX/MEM和MEM/WB的流水线寄存器的ALU结果总是被反馈给ALU的输入</li><li>如果转发硬件检测到了前一个ALU操作已经对当前ALU操作的源寄存器进行了写入，则控制逻辑选择转发结果作为ALU输入，而不是从寄存器堆中读取值</li></ul><p><img src="/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/image-20230327145826318.png" alt="image-20230327145826318" style="zoom: 50%;"></p><p>​        上述方式可以减少数据冒险停顿，但有些数据冒险是无法通过转发处理的。考虑以下指令：</p><p><img src="/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/image-20230327150050792.png" alt="image-20230327150050792" style="zoom: 67%;"></p><p>​        对于这段程序，ld指令第四周期才读出sub指令需要的值，而sub指令第二周期就要读取这个值了，这个冒险是无法避免的。这个时候就需要增加一种称为<strong>流水线互锁</strong>的执行方式，检测冒险，并在冒险结束之前使流水线停顿。</p><p><strong>控制冒险</strong></p><p>​        处理分支的最简单办法是，如果译码检测到了分支指令，就在下一个周期重新对下一条指令进行取址，这会产生一个周期的停顿。假设分支指令在ID计算分支地址并判断分支条件。如果分支没有被选中，这一个停顿周期就是不必要的，因此，下面讨论一些应对这一问题的技术。</p><p><img src="/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/image-20230327152656624.png" alt="image-20230327152656624" style="zoom:67%;"></p><p>​        降低分支代价有四种编译时机制，由软件利用硬件机制和分支特点降低分支代价。</p><ul><li>冻结或冲刷流水线：保留或删除分支之后的指令，直到知道分支目标，这是上表选择的方式，代价是固定的</li><li>预测未选中机制：将所有分支看作未选中分支，如果分支被选中，就将提取的指令转为空操作</li><li>预测选中分支：将所有分支看作选中分支，对于五级流水线来说没有好处，因为计算分支地址最快也要ID完成，但对于具有隐形设定条件代码或其他分支机制的处理器，可能是有效的</li><li>延迟分支：无论分支是否被选中，都执行分支指令的下一条指令</li></ul><p>​        延迟分支在早期RISC中应用广泛，在分支和分支目标之间的<strong>分支延迟时隙</strong>执行一条指令，这条指令由编译器进行调度。显然如果没有冒险，把一条分支指令之前的一定会执行的指令移动到分支指令之后是最合适的，不过这可能无法实现。这个技术也被称为<strong>延迟槽</strong>。现在的RISC-V使用动态分支预测，已经不再使用延迟分支了。</p><p>​        当流水线越来越深，分支的代价增加时，上述简单机制就不够了，需要更好的分支预测机制。这些机制分为两类：依赖编译时信息的静态分支预测机制，根据程序特性对分支动态预测的机制。</p><ul><li>静态分支预测：利用先前运行过程收集的数据，预测选中或未选中。整数程序的错误预测率较高，此类分支频率很高，是静态分支预测的主要限制</li><li>动态分支预测：最简单的方式是使用分支预测缓冲区，根据分支指令的低位进行索引，这个缓冲区包含一个位，表明该分支是否被选中，如果预测不正确，则将该位翻转。如果一个分支连续两次的结果不相同且与之前的分支情况不同，则两次都会预测错误，第一次因为预测位为0，第二次因为预测位为1，为了弥补这一弱点，经常使用2位预测机制，经测量，每项两位的分支预测缓冲区预测准确度超过82%，算是相当准确了。</li></ul><p><img src="/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/image-20230411210343207-16817400241952.png" alt="image-20230411210343207" style="zoom: 50%;"></p><center>2位的动态分支预测</center><h3 id="3-流水化的实现"><a href="#3-流水化的实现" class="headerlink" title="3.流水化的实现"></a>3.流水化的实现</h3><h4 id="3-1-流水线的基本实现"><a href="#3-1-流水线的基本实现" class="headerlink" title="3.1 流水线的基本实现"></a>3.1 流水线的基本实现</h4><p>​        流水线化的方式已经在C.1中介绍过了。这里细致的说明每个周期指令完成的实际操作。</p><p><strong>取址周期</strong></p><p>​        IR &lt;- Mem[PC]</p><p>​        NPC &lt;- PC+4</p><p>​        其中IR存储取出的指令，NPC是下一条指令的地址。PC并不止这一种取值，还可能是分支值。</p><p><strong>指令译码/寄存器提取周期</strong></p><p>​        A &lt;- Regs[rt]</p><p>​        B &lt;- Regs[rt]</p><p>​        Imm &lt;- 扩展后的立即数</p><p><strong>执行周期</strong></p><p>​        这一周期有几种可能的操作：</p><ul><li>存储器引用：计算引用的地址值</li><li>ALU运算：进行寄存器与寄存器值或立即数值的计算</li><li>分支目标计算及条件判断(分支实际上不需要等到执行周期完成，后面会说明)</li></ul><p><strong>访存周期</strong></p><p>​        这一周期完成了存储器引用：</p><p>​        LMD(载入存储器数据) &lt;- MEM[ALUoutput] / MEM[ALUoutput] &lt;- B</p><p>​        同时在这个周期把上个周期计算出的分支目标地址写入PC。(和上面的分支计算一样，这一操作没有必要等到这个周期)</p><p><strong>写回周期</strong> </p><p>​        写回周期根据指令类型，写入寄存器组：</p><ul><li>R型指令：Regs[rd] &lt;- ALUoutput</li><li>I型运算指令：Regs[rt] &lt;- ALUoutput</li><li>I型访存指令：Regs[rt] &lt;- LMD</li></ul><p>​        通过将执行划分为五个周期，最终的流水线如下图：</p><p><img src="/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/image-20230412103338598-16817400241954.png" alt="image-20230412103338598" style="zoom:67%;"></p><h4 id="3-2实现流水线的控制"><a href="#3-2实现流水线的控制" class="headerlink" title="3.2实现流水线的控制"></a>3.2实现流水线的控制</h4><p>​        将一条指令从译码ID移入执行EX的过程通常为<strong>指令发射</strong>，已经执行这一步骤的指令称为已发射。对于整数的情况，所有的数据冒险都可以在ID阶段进行检查，如果存在数据冒险，就停顿当前指令。停顿的方式是IF/ID保持值而不更新，ID/EX输出空操作，这样流水线的IF和ID阶段停顿，后面的阶段继续运行，从而处理了数据冒险问题。以下是可能的数据冒险：        </p><p><img src="/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/image-20230412104822402-16817400241953.png" alt="image-20230412104822402" style="zoom: 80%;"></p><h4 id="3-3处理流水线分支"><a href="#3-3处理流水线分支" class="headerlink" title="3.3处理流水线分支"></a>3.3处理流水线分支</h4><p>​        对于零检测分支，分支条件判断和目标地址计算工作在译码ID阶段就可以完成了，不需要等到执行，因此<strong>ID阶段可以判断分支条件</strong>，这样如果有分支，只<strong>浪费了分支之后IF的一条指令，相当于停顿一个周期</strong>，这条IF的指令还可以作为延迟槽，使用指令重排序将一条无论是否跳转都要执行的指令到这里，避免浪费。对于更深的流水线设计，分支延迟可能更大。MIPS采用了这样的设计。然而，如果在ID阶段就完成分支计算，会导致一些数据冒险产生更多停顿，因此RISC-V设计<strong>在EX阶段完成分支判断</strong>，这样<strong>如果没有分支预测，会浪费两条指令，相当于产生两个停顿</strong>。</p><p>​        RISC-V使用动态分支预测，不使用延迟槽，因为分支延迟并不总是可行，并且分支判断在EX阶段完成，在ID阶段根据预测的结果进行跳转，EX阶段进行验证。</p><p><img src="/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/image-20230412110207710-16817400241955.png" alt="image-20230412110207710" style="zoom:50%;"></p><p>​        对于RISC-V来说，假设采用<strong>动态分支预测</strong>，流水线是这样的(对于jal这样的指令，分支地址可以在ID计算)，假设总是<strong>预测正确</strong>：</p><p><strong>预测选中</strong></p><div class="table-container"><table><thead><tr><th></th><th>CLK1</th><th>CLK2</th><th>CLK3</th><th>CLK4</th><th>CLK5</th><th>CLK6</th><th>CLK7</th></tr></thead><tbody><tr><td>pipline i1</td><td>IF(PC+4)</td><td>ID(分支预测，分支地址计算)</td><td>EX(计算分支条件)</td><td>MEM</td><td>WB</td><td></td><td></td></tr><tr><td>pipline i2</td><td></td><td>IF(根据预测结果更新PC=PC+8/branch target)</td><td>ID</td><td>flush</td><td>flush</td><td>flush</td><td></td></tr><tr><td>pipline i3</td><td></td><td></td><td>IF(PC=PC+4)</td><td>ID(branch target)</td><td>EX</td><td>MEM</td><td>WB</td></tr></tbody></table></div><p><strong>预测不选中</strong></p><div class="table-container"><table><thead><tr><th></th><th>CLK1</th><th>CLK2</th><th>CLK3</th><th>CLK4</th><th>CLK5</th><th>CLK6</th><th>CLK7</th></tr></thead><tbody><tr><td>pipline i1</td><td>IF(PC+4)</td><td>ID(分支预测，分支地址计算)</td><td>EX(计算分支条件)</td><td>MEM</td><td>WB</td><td></td><td></td></tr><tr><td>pipline i2</td><td></td><td>IF(根据预测结果更新PC=PC+8/branch target)</td><td>ID</td><td>EX</td><td>MEM</td><td>WB</td><td></td></tr><tr><td>pipline i3</td><td></td><td></td><td>IF(PC=PC+4)</td><td>ID(PC)</td><td>EX</td><td>MEM</td><td>WB</td></tr></tbody></table></div><blockquote id="fn_注"><sup>注</sup>. IF阶段有一个pc_reg周期上升沿更新为pc_reg+4，同时也接入了branch target，给指令存储器的PC是这二者之一，指令存储器读出指令，读指令是组合逻辑电路，更新pc_reg和ID/EX则是时序逻辑电路，在时钟上升沿将指令交给ID/EX，ID/EX将上个周期的取指交给ID。<a href="#reffn_注" title="Jump back to footnote [注] in the text."> &#8617;</a></blockquote><p>​        如果没有分支预测，或者说默认未选中，那么流水线将是这样的：</p><div class="table-container"><table><thead><tr><th></th><th>CLK1</th><th>CLK2</th><th>CLK3</th><th>CLK4</th><th>CLK5</th><th>CLK6</th><th>CLK7</th><th>CLK8</th></tr></thead><tbody><tr><td>pipline i1</td><td>IF(PC+4)</td><td>ID(分支地址计算)</td><td>EX(计算分支条件)</td><td>MEM</td><td>WB</td><td></td><td></td><td></td></tr><tr><td>pipline i2</td><td></td><td>IF(PC = PC+4)</td><td>ID(PC)</td><td>flush</td><td>flush</td><td>flush</td><td></td><td></td></tr><tr><td>pipline i3</td><td></td><td></td><td>IF(根据分支条件，PC=PC+4/branch target )</td><td>flush</td><td>flush</td><td>flush</td><td>flush</td><td></td></tr><tr><td>pipline i4</td><td></td><td></td><td></td><td>IF(PC=PC+4)</td><td>ID(branch target)</td><td>EX</td><td>MEM</td><td>WB</td></tr></tbody></table></div><p>​        分支预测正确时减少了指令的浪费和停顿。</p><h4 id="3-4流水线加速比"><a href="#3-4流水线加速比" class="headerlink" title="3.4流水线加速比"></a>3.4流水线加速比</h4><p>​        在理想情况下，流水线中没有停顿，一个流水线的时钟周期完成一条指令，假设流水线深度为d，没有流水线化的d个时钟周期可以完成一条指令，建立流水线后，可以完成d条指令，因此理想流水线加速比为d。考虑停顿，流水线加速比为：</p><script type="math/tex; mode=display">Speedup = \frac{d}{1+stalls}</script><p>​        其中的停顿时间来自各种冒险，如果知道每个冒险发生的频率和代价，就可以计算出流水线加速比。</p><h3 id="4-流水线中的异常"><a href="#4-流水线中的异常" class="headerlink" title="4.流水线中的异常"></a>4.流水线中的异常</h3><p>​        不同CPU会用不同的词描述改变指令正常执行顺序的情景，包括<strong>中断、错误、异常</strong>等词。在本书中，用异常来包含所有这些情况。异常的情况非常多，仅从流水线的角度来说，有以下这几种异常：</p><div class="table-container"><table><thead><tr><th>流水级</th><th>异常</th></tr></thead><tbody><tr><td>IF</td><td>指令提取发生页错误、非对齐存储器访问、违反存储器保护规则</td></tr><tr><td>ID</td><td>未定义或非法操作码</td></tr><tr><td>EX</td><td>算数异常</td></tr><tr><td>MEM</td><td>数据提取时发生页错误、非对齐存储器访问、违反存储器保护规则</td></tr><tr><td>WB</td><td>无</td></tr></tbody></table></div><p>​        在实际的流水线当中，错误很可能不按指令执行顺序发生。如果发生异常时，流水线可以停止，使紧急错误指令之前的指令可以完成，使其之后的指令可是从头重新启动，就说该流水线拥有精确异常。处理异常较为复杂，书中介绍了停止和恢复执行的方式，此处略过。</p><h3 id="7-交叉问题"><a href="#7-交叉问题" class="headerlink" title="7.交叉问题"></a>7.交叉问题</h3><h4 id="7-1RISC指令集和流水线"><a href="#7-1RISC指令集和流水线" class="headerlink" title="7.1RISC指令集和流水线"></a>7.1RISC指令集和流水线</h4><p>​        RISC这样的简单指令集有一个好处，对代码的调度是简单的。因为RISC完成一个完整的操作需要更多指令，增加了调度的灵活性。因此几乎所有复杂指令集的流水线都将复杂指令转换为类似RISC的简单操作，然后进行调度和流水化。</p><h4 id="7-2动态调度流水线"><a href="#7-2动态调度流水线" class="headerlink" title="7.2动态调度流水线"></a>7.2动态调度流水线</h4><p>​        之前介绍的数据前推解决流水线中的一些冒险，但是总是存在一些不可避免的冒险，使流水线停顿。停顿时，不会提取或发射新指令，为了弥补这些性能损失，编译器可以采用调度指令来避免冒险，这种方法为<strong>静态调度</strong>。几种早期处理器使用了另外一种动态调度技术，为了更好的理解后续采用的更加复杂的机制，有必要介绍<strong>动态调度机制</strong>。</p><p>​        之前介绍的流水线，指令时按序执行的，如果两条指令之间存在冒险，即使后面的指令是不相关的，也会停顿下来。</p><p>将一条指令从译码ID移入执行EX的过程通常为<strong>指令发射</strong>，已经执行这一步骤的指令称为已发射。为使一条指令在操作数可用时就可以开始执行，而不受先前停顿的指令的影响，发射过程必须分为两部分：检查冒险，等待数据冒险结束。按序对指令进行译码和发射，但乱序执行。ID流水线将被划分为两级：</p><ul><li>发射：指令译码，检查结构冲突</li><li>读取操作数：等到没有数据冒险，随后读取操作数</li></ul><p>​        为了能让多条指令处于执行状态中，要改变功能单元设计，改变单元数，操作延迟和功能单元流水化。</p><p><strong>采用记分牌的动态调度机制</strong></p><p>​        动态调度流水线中，指令按序发射，乱序执行，实现方式是使用<strong>记分牌</strong>。记分牌全面负责指令发射与执行，包括所有冒险检测任务。乱序执行会导致原来顺序执行流水线中不存在的WAR和WAW冒险出现，这些冒险都由记分牌来检测和处理。为了保证多个指令同时执行，处理器拥有多个功能单元(存储器引用单元，整数运算单元，浮点运算单元等)。每条指令都会进入记分牌，有一条记录，记分牌会判断什么时候能读取操作数并执行，还会控制指令什么时候能写回目标寄存器。</p><p>​        现在先不考虑存储器访问，只考虑运算指令，指令在流水线中完成有四个步骤：</p><ul><li>发射：如果指令的一个功能单元空闲，没有其他活动指令以同一寄存器为目标寄存器，则向功能单元发射指令。如果存在WAW冒险或结构冒险，则指令发射停顿。</li><li>读取操作数：记分牌监视源操作数的可用性，如果先前发射的指令都不写入源操作数，则该源操作数可用，这一步解决了RAW冒险。</li><li>执行：功能单元收到操作数后开始执行，结果就绪后，通知记分牌已经完成了执行。</li><li>写结果：记分牌知道了功能单元完成执行，则检查WAR冒险，并在必要时停止正在完成的指令。</li></ul><p>​        接下来以一个指令序列为例，给出记分牌中所有记录的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LD F6,34R2</span><br><span class="line">LD F2,45(R3)</span><br><span class="line">MULD F0,F2,F4</span><br><span class="line">SUBD F8,F6,F2</span><br><span class="line">DIVD F10,F0,F6</span><br><span class="line">ADDD F6,F8,F2</span><br></pre></td></tr></table></figure><p><img src="/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/image-20230417214050185.png" alt="image-20230417214050185" style="zoom: 80%;"></p><p>​        记分牌有三个部分：</p><ul><li>指令状态：指出该指令处于四个步骤中的哪一步</li><li>功能单元状态：指出功能单元的状态，Fj和Fk为源寄存器编号，Fi为目标寄存器，Qj，Qk为生成源寄存器的功能单元，Rj和Rk表示操作数是否已准备就绪</li><li>寄存器结果状态：指出哪个功能单元将写入哪个寄存器，写入完成后字段为空</li></ul><p>​        有了上述信息，记分牌就可以控制指令的执行过程，一个指令的执行，要先检查需要使用的结构单元是否处于空闲，如果空闲，则可以发射，并准备读取操作数。读取操作数之前要检查RAW冒险，确保操作数就绪，得到操作数后可以开始执行。执行结束后，根据寄存器结果状态以及其他信息，检查WAR冒险和WAW冒险，无冒险时完成写入。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统导论-并发</title>
      <link href="/2023/01/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/"/>
      <url>/2023/01/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统导论-并发"><a href="#操作系统导论-并发" class="headerlink" title="操作系统导论-并发"></a>操作系统导论-并发</h1><h2 id="一-并发"><a href="#一-并发" class="headerlink" title="一.并发"></a>一.并发</h2><p>操作系统为了进程能有多个执行点，为进程提供了一种抽象：线程。线程与进程类似，一个进程中的所有线程共享地址空间，但有自己独立的栈。</p><p><img src="/2023/01/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/image-20230106183045452.png" alt="image-20230106183045452" style="zoom:50%;"></p><h3 id="1-并发问题"><a href="#1-并发问题" class="headerlink" title="1.并发问题"></a>1.并发问题</h3><p>线程的执行顺序也需要操作系统来进行调度。由于线程共享相同的地址空间，不可控的调度可能产生一些问题，这些问题就是并发问题。</p><p>并发问题产生的根本原因在于，对于共享数据的操作，可能需要多条指令才能完成，在完成操作的过程中，如果发生了线程的切换，对共享数据进行修改，就会产生问题。</p><span id="more"></span><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*一个将指定位置的值+1的指令*/</span><br><span class="line">mov 0x8049a1c, %eax </span><br><span class="line">add $0x1, %eax </span><br><span class="line">mov %eax, 0x8049a1c</span><br><span class="line">/*一个可能的并发问题，两个线程都将同一变量+1*/</span><br><span class="line">//进程A运行</span><br><span class="line">mov 0x8049a1c, %eax //A取出值，假设为0</span><br><span class="line">add $0x1, %eax //A计算得到1</span><br><span class="line">//进程切换到B</span><br><span class="line">mov %eax, 0x8049a1c//B取出值，还是0</span><br><span class="line">add $0x1, %eax </span><br><span class="line">mov %eax, 0x8049a1c//B计算并将1写入内存</span><br><span class="line">//切换为A</span><br><span class="line">mov %eax, 0x8049a1c//A将1写入内存</span><br></pre></td></tr></table></figure><p>以上的例子假设变量为0，A和B都对变量+1，但结果是1，只加了1次，这是因为+1的操作不是<strong>原子</strong>进行的，不能保证正确完成。因此，操作系统和硬件必须提供一些方法，使调度可控，保证这些对共享数据的操作能够正确完成。</p><p>除了以上的并发问题，还有一些其他类型的并发问题，例如线程等待，父线程需要等待子线程完成才能继续运行，操作系统和硬件也需要提供方法，确保调度的正确。</p><h3 id="2-并发术语"><a href="#2-并发术语" class="headerlink" title="2.并发术语"></a>2.并发术语</h3><ul><li>临界区（critical section）是访问共享资源的一段代码，资源通常是一个变量或数据结构。 </li><li>竞态条件（race condition）出现在多个执行线程大致同时进入临界区时，它们都试图更新共享 的数据结构，导致了令人惊讶的（也许是不希望的）结果。 </li><li>不确定性（indeterminate）程序由一个或多个竞态条件组成，程序的输出因运行而异，具体取 决于哪些线程在何时运行。这导致结果不是确定的（deterministic），而我们通常期望计算机系统给出确 定的结果。 </li><li>为了避免这些问题，线程应该使用某种互斥（mutual exclusion）原语。这样做可以保证只有一 个线程进入临界区，从而避免出现竞态，并产生确定的程序输出。</li></ul><h2 id="二-锁"><a href="#二-锁" class="headerlink" title="二.锁"></a>二.锁</h2><p>操作系统为线程提供了锁，来处理并发问题。</p><h3 id="1-锁的基本思想"><a href="#1-锁的基本思想" class="headerlink" title="1.锁的基本思想"></a>1.锁的基本思想</h3><p>锁是一个变量，主要的操作是获取锁和释放锁，如果一个线程获取了锁，其他线程就无法获取锁。在临界区周围使用锁，就保证了临界区只有一个线程可以进入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lock_t mutex; //全局锁</span><br><span class="line">lock(&amp;mutex); </span><br><span class="line">balance = balance + 1; </span><br><span class="line">unlock(&amp;mutex); </span><br></pre></td></tr></table></figure><p>要实现一个锁，必须借助硬件原语来完成(原语指硬件原子性完成的指令)，如果获取锁和释放锁不借助硬件，还是会有调度问题。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct lock_t &#123; int flag; &#125; lock_t; </span><br><span class="line">//初始化锁为0，表示无线程持有</span><br><span class="line">void init(lock_t *mutex) &#123; </span><br><span class="line">mutex-&gt;flag = 0; </span><br><span class="line">&#125;</span><br><span class="line">//上锁，将值改为1</span><br><span class="line">void lock(lock_t *mutex) &#123; </span><br><span class="line">while (mutex-&gt;flag == 1) // TEST the flag </span><br><span class="line">; // spin-wait (do nothing) </span><br><span class="line">mutex-&gt;flag = 1; // now SET it! </span><br><span class="line">&#125; </span><br><span class="line">//释放锁</span><br><span class="line">void unlock(lock_t *mutex) &#123; </span><br><span class="line">mutex-&gt;flag = 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果锁也是一个共享变量，上锁只是从将值改为1，那么一个线程获取锁，还没将值改为1，另一个线程运行，读到的值仍为0，这个线程就也可以获取锁了。因此，必须要有硬件指令保证锁能原子性的获取。</p><h3 id="2-锁的评价指标"><a href="#2-锁的评价指标" class="headerlink" title="2.锁的评价指标"></a>2.锁的评价指标</h3><ul><li>互斥：锁必须有效，阻止多个线程进入临界区</li><li>公平性：线程有同等机会获取锁</li><li>性能：使用锁的性能开销</li></ul><h3 id="3-锁的实现"><a href="#3-锁的实现" class="headerlink" title="3.锁的实现"></a>3.锁的实现</h3><p>锁的实现有以下几种方式：</p><p><strong>控制中断</strong></p><p>锁不设置值，直接关闭中断，这样上锁后，就不会发生调度。控制中断可以直接用关中断指令来完成。</p><p>关中断的优点是简单，但缺点很多：</p><ul><li>关中断是特权指令，不能信任用户程序，允许用户程序使用特权指令</li><li>中断丢失：关中断时，一些IO中断等可能会丢失。如果一个进程在等待IO，而IO中断丢失了，进程就无法被唤醒</li><li>不支持多处理器：关闭一个处理器的中断，但另一个线程可能在其他处理器运行</li></ul><p>因为以上缺点，只有操作系统在一些特殊情况才使用关中断来实现锁。</p><p><strong>测试并设置</strong></p><p>锁可以使用测试并设置指令来实现，该指令原子的完成返回旧值，设定新值的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TestAndSet</span><span class="params">(<span class="type">int</span> *old_ptr, <span class="type">int</span> <span class="keyword">new</span>)</span></span>;<span class="comment">//C描述</span></span><br><span class="line"><span class="comment">//获取锁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> </span>&#123; </span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">TestAndSet</span>(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>) </span><br><span class="line">; <span class="comment">// spin-wait (do nothing) </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于无法获取锁时，线程会在while循环等待，这种锁也被称为自旋锁。自旋锁的效率很低，如果有多个线程要获取锁，每个线程都会自旋一个时间片后才切换到其他线程，自旋的时间被浪费了。</p><p><strong>比较并交换</strong></p><p>另一个实现可以实现锁的硬件原语是比较并交换，如果值和期望的值相等，就修改该值，原子性的完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int CompareAndSwap(int *ptr, int expected, int new);</span><br><span class="line">//获取锁</span><br><span class="line">void lock(lock_t *lock) &#123; </span><br><span class="line">while (CompareAndSwap(&amp;lock-&gt;flag, 0, 1) == 1) </span><br><span class="line">; // spin </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取并增加</strong></p><p>最后一个硬件原语是获取并增加指令，它能原子地返回特定地址的旧值，并且让该值自增一。</p><p>该原语实现的锁使用两个值，一个值ticket是当前线程排队获取锁的号，另一个值turn是当前持有锁的线程的号，获取锁时将ticket+1，释放锁时将turn+1，当一个线程的ticket与turn相等时，就可以获取锁，进入临界区。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int FetchAndAdd(int *ptr);</span><br><span class="line">typedef struct lock_t &#123; </span><br><span class="line">int ticket; </span><br><span class="line">int turn; </span><br><span class="line">&#125; lock_t; </span><br><span class="line"> </span><br><span class="line">void lock_init(lock_t *lock) &#123; </span><br><span class="line">lock-&gt;ticket = 0; </span><br><span class="line">lock-&gt;turn = 0; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">void lock(lock_t *lock) &#123; </span><br><span class="line">int myturn = FetchAndAdd(&amp;lock-&gt;ticket); </span><br><span class="line">while (lock-&gt;turn != myturn) </span><br><span class="line">; // spin </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>休眠队列</strong></p><p>为了解决自旋锁浪费资源的问题，可以采取一些方法避免自旋。一种方式是让线程主动让出cpu，另一种方式是一旦线程不能获取锁，就先进入休眠队列休眠，当一个线程释放锁，就从队列中唤醒一个线程运行。</p><p>第一种方式，每个线程还是可能会被调度到，然后再放弃cpu，接下来又可能被调度到，再放弃cpu，这也是浪费时间的，无意义的上下文切换开销很大。</p><p>第二种方式，一个可能的实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">typedef struct lock_t &#123; </span><br><span class="line">int flag; </span><br><span class="line">int guard; </span><br><span class="line">queue_t *q; </span><br><span class="line">&#125; lock_t; </span><br><span class="line"> </span><br><span class="line">void lock_init(lock_t *m) &#123; </span><br><span class="line">m-&gt;flag = 0; </span><br><span class="line">m-&gt;guard = 0; </span><br><span class="line">queue_init(m-&gt;q); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">void lock(lock_t *m) &#123; </span><br><span class="line">while (TestAndSet(&amp;m-&gt;guard, 1) == 1) </span><br><span class="line">; //acquire guard lock by spinning  </span><br><span class="line">if (m-&gt;flag == 0) &#123; </span><br><span class="line">m-&gt;flag = 1; // lock is acquired </span><br><span class="line">m-&gt;guard = 0; </span><br><span class="line">&#125; else &#123; </span><br><span class="line">queue_add(m-&gt;q, gettid()); </span><br><span class="line">m-&gt;guard = 0; </span><br><span class="line">park(); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">void unlock(lock_t *m) &#123; </span><br><span class="line">while (TestAndSet(&amp;m-&gt;guard, 1) == 1) </span><br><span class="line">; //acquire guard lock by spinning </span><br><span class="line">if (queue_empty(m-&gt;q)) </span><br><span class="line">m-&gt;flag = 0; // let go of lock; no one wants it </span><br><span class="line">else </span><br><span class="line">unpark(queue_remove(m-&gt;q)); // hold lock (for next thread!) </span><br><span class="line">m-&gt;guard = 0; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>flag表示锁是否被占用，而guard锁保证了对flag和队列的操作是互斥的。guard锁虽然自旋，但guard锁保护的获取锁和释放锁的临界区很小，因此不会浪费太多资源。</p><p>以上这个实现有一点小问题，如果有一个线程将要park休眠但还没休眠，另一个线程就释放了锁，这个线程就会在休眠后无人唤醒，解决方法是提前表明自己马上要 park。如果刚好另一个线程被调度，并且调用了 unpark，那么后续的 park 调用就会直接返回，而不是一直睡眠。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">queue_add(m-&gt;q, gettid()); </span><br><span class="line">setpark(); // new code </span><br><span class="line">m-&gt;guard = 0; </span><br></pre></td></tr></table></figure><p>不同的硬件提供了不同的硬件原语，不同的操作系统也有不同的对锁的实现，细节和策略都有所不同。</p><h2 id="三-条件变量"><a href="#三-条件变量" class="headerlink" title="三.条件变量"></a>三.条件变量</h2><p>有些情况下，线程需要检查某一条件满足之后，才会继续运行。例如，父线程可能需要检查子线程是否执行完毕，子线程完毕后继续执行。条件变量的设计就是为了解决这种等待/唤醒的线程等待问题。</p><p>条件变量是一个显式队列，当某些执行状态（即条件，condition）不满足时，线程可以把自己加入队列，等待（waiting）该条件。另外某个线程，当它改变了上述状态时，就可以唤醒一个或者多个等待线程（通过在该条件上发信号），让它们继续执行。</p><h4 id="1-条件变量的使用"><a href="#1-条件变量的使用" class="headerlink" title="1.条件变量的使用"></a>1.条件变量的使用</h4><p>条件变量有两种相关操作：wait()和 signal()。线程要睡 眠的时候，调用 wait()。当线程想唤醒等待在某个条件变量上的睡眠线程时，调用 signal()。以下是使用条件变量实现父线程等待子线程结束后继续执行的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> done = <span class="number">0</span>; </span><br><span class="line"><span class="type">pthread_mutex_t</span> m = PTHREAD_MUTEX_INITIALIZER; </span><br><span class="line"><span class="type">pthread_cond_t</span> c = PTHREAD_COND_INITIALIZER; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thr_exit</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="built_in">Pthread_mutex_lock</span>(&amp;m); </span><br><span class="line">done = <span class="number">1</span>; </span><br><span class="line"><span class="built_in">Pthread_cond_signal</span>(&amp;c); </span><br><span class="line"><span class="built_in">Pthread_mutex_unlock</span>(&amp;m); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">child</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>); </span><br><span class="line"><span class="built_in">thr_exit</span>(); </span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thr_join</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="built_in">Pthread_mutex_lock</span>(&amp;m); </span><br><span class="line"><span class="keyword">while</span> (done == <span class="number">0</span>) </span><br><span class="line"><span class="built_in">Pthread_cond_wait</span>(&amp;c, &amp;m); </span><br><span class="line"><span class="built_in">Pthread_mutex_unlock</span>(&amp;m); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>); </span><br><span class="line"><span class="type">pthread_t</span> p; </span><br><span class="line"><span class="built_in">Pthread_create</span>(&amp;p, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>); </span><br><span class="line"><span class="built_in">thr_join</span>(); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对以上的例子中的一些细节作一些说明：</p><ul><li>尽管使用了条件变量，还是需要一个变量done来进行同步，该变量是有必要的，如果父线程创建子线程后，子线程立即运行并执行完毕，父线程就根据done判断不应该休眠，否则将无法被唤醒。</li><li><p>使用while判断done是否为1，在此不是必要的，但最好使用while，接下来介绍的生产者消费者问题中会说明为什么最好使用while。</p></li><li><p><a id="mark1">在线程休眠和唤醒的操作前后都进行了上锁</a>，因为休眠队列也是共享数据，如果不上锁可能会产生竞态条件，例如父线程将要睡眠，子线程调度运行并执行完毕，唤醒父线程，然而父线程还没有休眠，再调度回父线程，父线程休眠就无法被唤醒了。</p></li><li><p>wait()调用时传入了锁，当线程休眠时，需要释放掉锁，让其他线程可以获取锁，当被信号唤醒时，该线程将重新获取锁，然后从wait()调用返回。如果不释放锁，会导致死锁，当前线程休眠，另一个线程被唤醒却获取不到锁，导致无法继续运行。</p></li></ul><h3 id="2-生产者消费者问题"><a href="#2-生产者消费者问题" class="headerlink" title="2.生产者消费者问题"></a>2.生产者消费者问题</h3><p>生产者/消费者（producer/consumer）问题，也叫作有界缓冲区（bounded buffer）问题。 假设有一个或多个生产者线程和一个或多个消费者线程。生产者把生成的数据项放入缓冲区；消费者从缓冲区取走数据项，以某种方式消费。生产者消费者需要同步，如果缓冲区为空，消费者就应该睡眠，唤醒生产者；如果缓冲区已满，生产者就应该睡眠，唤醒消费者。</p><p>以下是使用条件变量解决的生产者消费者问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">cond_t</span> empty, fill; </span><br><span class="line"><span class="type">mutex_t</span> mutex; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">producer</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123; </span><br><span class="line">    <span class="type">int</span> i; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123; </span><br><span class="line"><span class="built_in">Pthread_mutex_lock</span>(&amp;mutex); <span class="comment">// p1 </span></span><br><span class="line"><span class="keyword">while</span> (count == MAX) <span class="comment">// p2 </span></span><br><span class="line">            <span class="built_in">Pthread_cond_wait</span>(&amp;empty, &amp;mutex); <span class="comment">// p3 </span></span><br><span class="line"><span class="built_in">put</span>(i); <span class="comment">// p4 </span></span><br><span class="line"><span class="built_in">Pthread_cond_signal</span>(&amp;fill); <span class="comment">// p5 </span></span><br><span class="line"><span class="built_in">Pthread_mutex_unlock</span>(&amp;mutex); <span class="comment">// p6 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123; </span><br><span class="line"><span class="type">int</span> i; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123; </span><br><span class="line"><span class="built_in">Pthread_mutex_lock</span>(&amp;mutex); <span class="comment">// c1 </span></span><br><span class="line"><span class="keyword">while</span> (count == <span class="number">0</span>) <span class="comment">// c2 </span></span><br><span class="line"><span class="built_in">Pthread_cond_wait</span>(&amp;fill, &amp;mutex); <span class="comment">// c3 </span></span><br><span class="line"><span class="type">int</span> tmp = <span class="built_in">get</span>(); <span class="comment">// c4 </span></span><br><span class="line"><span class="built_in">Pthread_cond_signal</span>(&amp;empty); <span class="comment">// c5 </span></span><br><span class="line"><span class="built_in">Pthread_mutex_unlock</span>(&amp;mutex); <span class="comment">// c6 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>对实现中的细节进行说明：</p><ul><li>使用两个条件变量，即两个队列，因为需要明确唤醒的对象类型，例如缓冲区空时，消费者必须唤醒生产者，而不是另一个消费者，因此需要两个条件变量让消费者和生产者在不同的队列休眠。</li><li>使用while语句和count变量判断是否休眠，这是因为需要有一个变量进行同步，而且可能存在不止一个修改该变量的线程。例如，一个线程被唤醒但还未运行，另一个新线程插入并消费了缓冲区数据，然后刚被唤醒的线程才开始运行，就必须通过判断count确认缓冲区不为空，否则就产生了错误。这也是为什么使用while总是更好的原因，如果使用if，被唤醒的变量就不会再判断count是否为0了。</li></ul><h3 id="3-覆盖条件"><a href="#3-覆盖条件" class="headerlink" title="3.覆盖条件"></a>3.覆盖条件</h3><p>条件变量是通过休眠/唤醒来进行线程等待和同步的，然而有一些情况，在等待的线程并不是完全相同的，而是有差别的，这时唤醒哪个线程就会对程序的运行存在影响。</p><p>考虑一个内存分配程序，假设有三个线程，一个线程正在使用50的内存空间，另两个线程分别要求分配10和100的内存空间，并因空间不足而休眠等待。这时运行的线程执行完毕，释放了50的空间，并唤醒一个线程，如果唤醒100的线程，内存空间还是不够，该线程继续休眠，需要10内存空间的线程可以运行却没有被唤醒。</p><p>解决以上问题的方案是唤醒所有等待的线程，确保所有应该唤醒的线程都被唤醒。这种方式下的条件变量被称为覆盖条件。显然因为唤醒了不必要的线程，产生了额外的开销，但在有些情况下，使用覆盖条件是必须的。</p><h2 id="四-信号量"><a href="#四-信号量" class="headerlink" title="四.信号量"></a>四.信号量</h2><p>信号量是另一个解决并发问题的原语，是由Dijkstra 及其同事发明的。信号量可以用作锁和条件变量。</p><h3 id="1-信号量"><a href="#1-信号量" class="headerlink" title="1.信号量"></a>1.信号量</h3><p>信号量是有一个整数值的对象，可以用两个函数来操作它。在 POSIX 标准中，是 sem_wait()和 sem_post()①。因为信号量的初始值能够决定其行为，所以首先要初始化信号量， 才能调用其他函数与之交互。</p><p>如果信号量的值大于等于1，sem_wait会立即返回，否则将让线程挂起，直到被唤醒。无论是否挂起，sem_wait最后都会将信号量的值-1。sem_post则直接增加信号量的值，如果有等待线程，唤醒其中一个。</p><h3 id="2-二值信号量-锁"><a href="#2-二值信号量-锁" class="headerlink" title="2.二值信号量(锁)"></a>2.二值信号量(锁)</h3><p>信号量可以用作锁，使用 sem_wait()/sem_post()环绕临界区就可以了。第一个线程进入临界区应该可以获取锁，但另一个就不能了，因此显然信号量应该初始化为1，第一个线程进入临界区并将信号量-1变为0，第二个线程进入时因为信号量为0而进入休眠，并将信号量-1为-1,，第一个线程结束时，信号量被加到0，然后第二个线程被唤醒，此时直接从sem_wait返回，不再判断信号量是否大于1，最后执行结束，将信号量+1，信号量就又回到了1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sem_t</span> m; </span><br><span class="line"><span class="built_in">sem_init</span>(&amp;m, <span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"><span class="built_in">sem_wait</span>(&amp;m); </span><br><span class="line"><span class="comment">// critical section here </span></span><br><span class="line"><span class="built_in">sem_post</span>(&amp;m);</span><br></pre></td></tr></table></figure><h3 id="3-信号量用作条件变量"><a href="#3-信号量用作条件变量" class="headerlink" title="3.信号量用作条件变量"></a>3.信号量用作条件变量</h3><p>信号量也可以用作条件变量，只需要将值初始化为0。这样父线程将会休眠，等待子线程运行结束后将其唤醒，如果子线程在父线程休眠前先运行了，可以根据done的值直接运行而不调用sem_wait，在结束后调用sem_post，将信号量加为1，然后父线程就可以运行了。</p><p>但是回到<a href="#mark1">条件变量的使用</a>，条件变量在让线程休眠时，是需要释放锁的，如果不释放锁，就会导致死锁，而信号量没有这个功能，但是锁又是必须使用的，否则一个刚被唤醒的线程，和一个新插入的线程可能同时进入临界区。解决该问题的方法是调整锁的作用域：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sem_wait</span>(&amp;full); </span><br><span class="line"><span class="built_in">sem_wait</span>(&amp;mutex); </span><br><span class="line"><span class="type">int</span> tmp = <span class="built_in">get</span>(); </span><br><span class="line"><span class="built_in">sem_post</span>(&amp;mutex); </span><br><span class="line"><span class="built_in">sem_post</span>(&amp;empty); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br></pre></td></tr></table></figure><p>这样就可以避免以上问题了，但是在条件变量的使用时，这个锁是为了保护休眠队列的：</p><blockquote><p>休眠队列也是共享数据，如果不上锁可能会产生竞态条件，例如父线程将要睡眠，子线程调度运行并执行完毕，唤醒父线程，然而父线程还没有休眠，再调度回父线程，父线程休眠就无法被唤醒了。</p></blockquote><p>把锁移动到休眠的内部，只保护了缓冲区，不再保护队列了。但是不会有使用条件变量发生的上面这个问题，因为子线程执行完毕会将信号量+1，父线程就不会休眠了。</p><h4 id="4-生产者-消费者（有界缓冲区）问题"><a href="#4-生产者-消费者（有界缓冲区）问题" class="headerlink" title="4.生产者/消费者（有界缓冲区）问题"></a>4.生产者/消费者（有界缓冲区）问题</h4><p>以下是信号量实现的生产者/消费者（有界缓冲区）问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sem_t</span> empty; </span><br><span class="line"><span class="type">sem_t</span> full; </span><br><span class="line"><span class="type">sem_t</span> mutex; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">producer</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123; </span><br><span class="line"><span class="type">int</span> i; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123; </span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;empty); <span class="comment">// line p1 </span></span><br><span class="line"><span class="built_in">sem_wait</span>(&amp;mutex); <span class="comment">// line p1.5 (MOVED MUTEX HERE...) </span></span><br><span class="line"> <span class="built_in">put</span>(i); <span class="comment">// line p2 </span></span><br><span class="line"><span class="built_in">sem_post</span>(&amp;mutex); <span class="comment">// line p2.5 (... AND HERE) </span></span><br><span class="line"><span class="built_in">sem_post</span>(&amp;full); <span class="comment">// line p3 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123; </span><br><span class="line"><span class="type">int</span> i; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123; </span><br><span class="line"><span class="built_in">sem_wait</span>(&amp;full); <span class="comment">// line c1 </span></span><br><span class="line"><span class="built_in">sem_wait</span>(&amp;mutex); <span class="comment">// line c1.5 (MOVED MUTEX HERE...) </span></span><br><span class="line"><span class="type">int</span> tmp = <span class="built_in">get</span>(); <span class="comment">// line c2 </span></span><br><span class="line"><span class="built_in">sem_post</span>(&amp;mutex); <span class="comment">// line c2.5 (... AND HERE) </span></span><br><span class="line"><span class="built_in">sem_post</span>(&amp;empty); <span class="comment">// line c3 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123; </span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="built_in">sem_init</span>(&amp;empty, <span class="number">0</span>, MAX); <span class="comment">// MAX buffers are empty to begin with... </span></span><br><span class="line"><span class="built_in">sem_init</span>(&amp;full, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// ... and 0 are full </span></span><br><span class="line"><span class="built_in">sem_init</span>(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// mutex=1 because it is a lock </span></span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>所有细节的问题都已经在以上的说明中提到了。</p><h2 id="五-常见并发问题"><a href="#五-常见并发问题" class="headerlink" title="五.常见并发问题"></a>五.常见并发问题</h2><p>常见的并发问题可以划分为死锁缺陷和非死锁缺陷。</p><h3 id="1-非死锁缺陷"><a href="#1-非死锁缺陷" class="headerlink" title="1.非死锁缺陷"></a>1.非死锁缺陷</h3><p>非死锁缺陷占并发问题的大多数，非死锁缺陷这里主要讨论两种：违反原子性（atomicity violation）缺陷和错误顺序（order  violation）缺陷。</p><p>违反原子性缺陷就是对共享数据没有保护导致并发访问错误的缺陷，解决方法就是对临界区上锁。这是最简单的一种缺陷。</p><p>违反顺序缺陷是另一种问题下发生的，就是介绍条件变量时提到的等待问题，如果一个线程需要等待另一个线程执行完毕才能正确执行，却没有保证这种顺序，就可能产生问题。解决方式也很简单，使用条件变量或者信号量，保证线程执行的顺序。</p><h3 id="2-死锁缺陷"><a href="#2-死锁缺陷" class="headerlink" title="2.死锁缺陷"></a>2.死锁缺陷</h3><p>死锁缺陷是多个线程互相等待的缺陷。</p><p><img src="/2023/01/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/image-20230111180716598.png" alt="image-20230111180716598" style="zoom:50%;"></p><p>产生死锁的条件  死锁的产生需要如下 4 个条件：</p><ul><li>互斥：线程对于需要的资源进行互斥的访问（例如一个线程抢到锁）。 </li><li>持有并等待：线程持有了资源（例如已将持有的锁），同时又在等待其他资源（例如，需要获得的锁）。</li><li>非抢占：线程获得的资源（例如锁），不能被抢占。 </li><li>循环等待：线程之间存在一个环路，环路上每个线程都额外持有一个资源，而这 个资源又是下一个线程要申请的。</li></ul><p>下面说明如何预防死锁：</p><ul><li><p>考虑从循环等待解决问题，可以通过保证加锁的顺序，避免循环等待。严格限定加锁顺序称为<strong>全序</strong>，但是有时锁的依赖很复杂，涉及多个锁，全序很难做到，这时可以使用偏序进行加锁。</p></li><li><p>从持有并等待的角度解决问题，可以通过保证原子性获取所有锁，来避免持有并等待。使用这个方式必须提前知道所有要获取的锁，一方面其不适用于封装，另一方面提前获取所有锁可能降低了效率。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lock</span>(prevention); </span><br><span class="line"><span class="built_in">lock</span>(L1); </span><br><span class="line"><span class="built_in">lock</span>(L2); </span><br><span class="line">... </span><br><span class="line"><span class="built_in">unlock</span>(prevention); </span><br></pre></td></tr></table></figure><ul><li>从非抢占的角度考虑也可以预防死锁，如果另一个线程不能抢占自己的锁，导致了死锁，可以在不能获取锁时，把自己已经获取的锁释放掉，从而打破死锁的情况。然而如果另一线程采用不同的加锁顺序，持续的重复这一过程，又抢锁失败，会导致活锁。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">top: </span><br><span class="line"><span class="built_in">lock</span>(L1); </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">trylock</span>(L2) == <span class="number">-1</span>) &#123; </span><br><span class="line"><span class="built_in">unlock</span>(L1); </span><br><span class="line">        <span class="keyword">goto</span> top; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>从互斥考虑预防死锁的方法就是完全避免互斥，使用无等待（wait-free）数据结构，通过直接使用硬件原语避免死锁。</li></ul><p>除了以上的预防方法，另一种方式是用调度避免死锁（然而锁的存在就是为了避免不确定的调度）。如果了解全局的信息，包 括不同线程在运行中对锁的需求情况，就可以让后续的调度能够避免产生死锁。</p><p>最后一种常用的策略就是允许死锁偶尔发生，检查到死锁时再采取行动。如果死锁很少见，这种不是办法的办法也是很实用的。</p>]]></content>
      
      
      <categories>
          
          <category> cs基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法设计与分析-线性dp</title>
      <link href="/2023/01/05/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E7%BA%BF%E6%80%A7dp/"/>
      <url>/2023/01/05/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E7%BA%BF%E6%80%A7dp/</url>
      
        <content type="html"><![CDATA[<p style="text-indent:2em">算法设计与分析-线性dp题目记录。</p><span id="more"></span><h3 id="P1020-导弹拦截"><a href="#P1020-导弹拦截" class="headerlink" title="P1020 导弹拦截"></a>P1020 导弹拦截</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。</p><p>输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。</p><h4 id="输入格式与输出格式"><a href="#输入格式与输出格式" class="headerlink" title="输入格式与输出格式"></a>输入格式与输出格式</h4><p>输入：</p><p>一行，若干个整数，中间由空格隔开。</p><p>输出：</p><p>两行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。</p><h4 id="样例输入与输出"><a href="#样例输入与输出" class="headerlink" title="样例输入与输出"></a>样例输入与输出</h4><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">389 207 155 300 299 170 158 65</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>对于前 $50\%$ 数据（NOIP 原题数据），满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用$\mathcal O(n^2)$ 做法通过。<br>对于后 $50\%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\mathcal O(n\log n)$ 做法通过。</p><p>对于全部数据，满足导弹的高度为正整数，且不超过 $5\times 10^4$。</p><p>此外本题开启 spj，每点两问，按问给分。</p><h4 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h4><p>问题的本质是求最长不上升子序列的长度。</p><p>可以使用tail[i]表示长度为i的不上升子序列的尾元素，要求最长的不上升子序列，应该让尾元素尽量更大，子序列才可能更长。如果遇到一个大于最大长度的尾元素的元素，就用这个元素更新某个特定长度i的尾元素，这样长度i的单调递减序列就可能添加新的元素。如果遇到一个小于等于最大长度的尾元素的元素，那么可以将最大长度+1，将这个元素作为尾元素。</p><p>对于特定长度i的序列的尾元素的更新，可以使用二分搜索的方法，因为tail数组一定是一个递减的数组。</p><p>第二问使用贪心算法，使用已有系统中最后一枚导弹最低的系统进行拦截，如果不存在，使用一个新的系统。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> bf.readLine();</span><br><span class="line">String[] temp = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> temp.length;</span><br><span class="line"><span class="type">int</span>[] h = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">h[i] = Integer.parseInt(temp[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.gc();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] tail = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//从0开始，最后的结果是MaxLen+1</span></span><br><span class="line"><span class="type">int</span>[] sys = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">used</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="comment">//求最长不上升子序列的长度</span></span><br><span class="line"><span class="keyword">if</span>(h[i] &gt; tail[maxLen]) &#123;</span><br><span class="line">tail[binarySearch(tail, <span class="number">0</span>, maxLen, h[i])] = h[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tail[++maxLen] = h[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求拦截需要的系统数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sys_used</span> <span class="operator">=</span> -<span class="number">1</span>, sys_h = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;used;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(sys[j]&gt;=h[i]) &#123;<span class="comment">//可以使用该系统</span></span><br><span class="line"><span class="keyword">if</span>(sys[j]&lt;sys_h) &#123;  <span class="comment">//选可以使用的系统中最后一枚导弹高度最低的用</span></span><br><span class="line">sys_used = j;</span><br><span class="line">sys_h = sys[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sys_used==-<span class="number">1</span>) sys[used++] = h[i];</span><br><span class="line"><span class="keyword">else</span> sys[sys_used] = h[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(maxLen+<span class="number">1</span>);</span><br><span class="line">System.out.println(used);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分搜索</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a ,<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> e)</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right-left)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mid]&lt;e) &#123;</span><br><span class="line">right = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">left = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的结果只能200分，增加的sub-task数据TLE。对于第二问，根据Dilworth定理，需要的系统数是最长上升子序列的长度，修改为求最长上升子序列，就能优化通过最后的sub-task。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> bf.readLine();</span><br><span class="line">String[] temp = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> temp.length;</span><br><span class="line"><span class="type">int</span>[] h = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">h[i] = Integer.parseInt(temp[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.gc();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] tail = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span>[] tail2 = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> maxLen2, maxLen;</span><br><span class="line">maxLen = maxLen2 =  <span class="number">1</span>;</span><br><span class="line">tail2[<span class="number">1</span>] = tail[<span class="number">1</span>] = h[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="comment">//求最长不上升子序列的长度</span></span><br><span class="line"><span class="keyword">if</span>(h[i] &gt; tail[maxLen]) &#123;</span><br><span class="line">tail[binarySearch(tail, <span class="number">1</span>, maxLen, h[i])] = h[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tail[++maxLen] = h[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求最长上升子序列</span></span><br><span class="line"><span class="keyword">if</span>(h[i] &lt;= tail2[maxLen2]) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> binarySearch2(tail2, <span class="number">1</span>, maxLen2, h[i]);</span><br><span class="line">                <span class="comment">//如果tail[]里已经有了元素h[i]，不可以用h[i]更新数组，因为对于上升序列，不可以有相等的元素，例如tail：1 2 3 5 8 9， 如果又有个长度为8的元素，是不可以更新9的，因为他不能加到以8结尾的序列的后面</span></span><br><span class="line"><span class="keyword">if</span>(x!=-<span class="number">1</span>)</span><br><span class="line">tail2[x] = h[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tail2[++maxLen2] = h[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(maxLen);</span><br><span class="line">System.out.println(maxLen2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分搜索-递减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a ,<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> e)</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right-left)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mid]&lt;e) &#123;</span><br><span class="line">right = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">left = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分搜索-递增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch2</span><span class="params">(<span class="type">int</span>[] a ,<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> e)</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right-left)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mid]&gt;e) &#123;</span><br><span class="line">right = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[mid]==e) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">left = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1439-最长公共子序列"><a href="#P1439-最长公共子序列" class="headerlink" title="P1439 最长公共子序列"></a>P1439 最长公共子序列</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给出 $1,2,\ldots,n$ 的两个排列 $P_1$ 和 $P_2$ ，求它们的最长公共子序列。</p><h4 id="输入与输出格式"><a href="#输入与输出格式" class="headerlink" title="输入与输出格式"></a>输入与输出格式</h4><p>输入：</p><p>第一行是一个数 $n$。</p><p>接下来两行，每行为 $n$ 个数，为自然数 $1,2,\ldots,n$ 的一个排列。</p><p>输出：</p><p>一个数，即最长公共子序列的长度。</p><h4 id="样例输入与输出-1"><a href="#样例输入与输出-1" class="headerlink" title="样例输入与输出"></a>样例输入与输出</h4><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 </span><br><span class="line">3 2 1 4 5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h4><ul><li>对于 $50\%$ 的数据， $n \le 10^3$；</li><li>对于 $100\%$ 的数据， $n \le 10^5$。</li></ul><h4 id="算法设计-1"><a href="#算法设计-1" class="headerlink" title="算法设计"></a>算法设计</h4><p><strong>直接dp</strong></p><p>用一般的动态规划方法，如果A[i]和B[I]相同，A和B的前i个元素的最长公共子序列长度为A和B前i-1元素的最长公共子序列的长度+1，如果不同，有两种可能：</p><ul><li>长度为A前i-1元素和B的前i元素的最长公共子序列长度</li><li>长度为B前i-1元素和A的前i元素的最长公共子序列长度</li></ul><p>最长子序列长度为这两种可能中的最大值。</p><p>用dp[i][j]表示A的前i项和B的前j项的最长公共子序列长度，按照以上的最优子结构填表就可以得到答案，但是时间复杂度是n^2，无法通过全部测试。</p><p><strong>转化为最长上升子序列</strong></p><p>该问题可以转化为一个最长上升子序列问题。可以将B中元素在A中的位置找出来，由于A和B都是1-n的一种排列，所以B中元素一定有在A中对应的位置，所有的位置形成一个新的序列，如果新序列存在子序列是上升的，则表示在B中子序列对应下标的元素在A中也是按顺序出现的，是公共子序列。这样最长公共子序列问题就转化为了最长上升子序列问题。</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">Reader</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reader</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> r.nextInt();</span><br><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = r.nextInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[i] = r.nextInt();</span><br><span class="line"><span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">map[a[i]] = i; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[] tail = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">tail[<span class="number">1</span>] = map[b[<span class="number">1</span>]]; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> map[b[i]];</span><br><span class="line"><span class="keyword">if</span>(temp&gt;tail[maxLen]) &#123;</span><br><span class="line">tail[++maxLen] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> binarySearch(tail, <span class="number">1</span>, maxLen, temp);</span><br><span class="line"><span class="keyword">if</span>(pos!=-<span class="number">1</span>) tail[pos] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(maxLen);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> e)</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right-left)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(arr[mid]==e) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(arr[mid]&gt;e) &#123;</span><br><span class="line">right = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> left = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span>&#123;</span><br><span class="line"><span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)));</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">st.nextToken();</span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>)st.nval;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P2758-编辑距离"><a href="#P2758-编辑距离" class="headerlink" title="P2758 编辑距离"></a>P2758 编辑距离</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>设 $A$ 和 $B$ 是两个字符串。我们要用最少的字符操作次数，将字符串 $A$ 转换为字符串 $B$。这里所说的字符操作共有三种：</p><ol><li>删除一个字符；</li><li>插入一个字符；</li><li>将一个字符改为另一个字符。</li></ol><p>$A, B$ 均只包含小写字母。</p><h4 id="输入与输出格式-1"><a href="#输入与输出格式-1" class="headerlink" title="输入与输出格式"></a>输入与输出格式</h4><p>输入：</p><p>第一行为字符串 $A$；第二行为字符串 $B$；字符串 $A, B$ 的长度均小于 $2000$。</p><p>输出：</p><p>只有一个正整数，为最少字符操作次数。</p><h4 id="样例输入与输出-2"><a href="#样例输入与输出-2" class="headerlink" title="样例输入与输出"></a>样例输入与输出</h4><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sfdqxbw</span><br><span class="line">gfdgw</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h4 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h4><p>对于 $100 \%$ 的数据，$1 \le |A|, |B| \le 2000$。</p><h4 id="算法设计-2"><a href="#算法设计-2" class="headerlink" title="算法设计"></a>算法设计</h4><p>用dp[i][j]表示A的前i项和B的前j项的匹配情况如果A[i-1]==B[i-1]，则dp[i][j]=dp[i-1][j-1]，不需要修改，如果A[i-1]!=B[j-1]，则有三种修改方式，对应的修改次数为：</p><ul><li>删除A[i]：dp[i-1][j]+1</li><li>向A中插入B[j]：dp[i][j-1]+1</li><li>将A[i]修改为B[j]：dp[i-1][j-1]+1</li></ul><p>取以上三种的最小值。</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> bf.readLine();</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> bf.readLine();</span><br><span class="line"><span class="type">int</span> <span class="variable">lenA</span> <span class="operator">=</span> a.length(), lenB = b.length();</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[lenA+<span class="number">1</span>][lenB+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=lenA;i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=lenB;j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lenA;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=lenB;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(a.charAt(i-<span class="number">1</span>)==(b.charAt(j-<span class="number">1</span>))) dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j], Math.min(dp[i][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j-<span class="number">1</span>]))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(dp[lenA][lenB]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1040-加分二叉树"><a href="#P1040-加分二叉树" class="headerlink" title="P1040 加分二叉树"></a>P1040 加分二叉树</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>设一个 $n$ 个节点的二叉树 $\text{tree}$ 的中序遍历为$(1,2,3,\ldots,n)$，其中数字 $1,2,3,\ldots,n$ 为节点编号。每个节点都有一个分数（均为正整数），记第 $i$ 个节点的分数为 $d_i$，$\text{tree}$ 及它的每个子树都有一个加分，任一棵子树 $\text{subtree}$（也包含 $\text{tree}$ 本身）的加分计算方法如下：</p><p>$\text{subtree}$ 的左子树的加分 $\times$ $\text{subtree}$ 的右子树的加分 $+$ $\text{subtree}$ 的根的分数。</p><p>若某个子树为空，规定其加分为 $1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。</p><p>试求一棵符合中序遍历为 $(1,2,3,\ldots,n)$ 且加分最高的二叉树 $\text{tree}$。要求输出</p><ol><li><p>$\text{tree}$ 的最高加分。</p></li><li><p>$\text{tree}$ 的前序遍历。</p></li></ol><h4 id="输入与输出格式-2"><a href="#输入与输出格式-2" class="headerlink" title="输入与输出格式"></a>输入与输出格式</h4><p>输入：</p><p>第 $1$ 行 $1$ 个整数 $n$，为节点个数。</p><p>第 $2$ 行 $n$ 个用空格隔开的整数，为每个节点的分数</p><p>输出：</p><p>第 $1$ 行 $1$ 个整数，为最高加分（$ Ans \le 4,000,000,000$）。</p><p>第 $2$ 行 $n$ 个用空格隔开的整数，为该树的前序遍历。</p><h4 id="样例输入与输出-3"><a href="#样例输入与输出-3" class="headerlink" title="样例输入与输出"></a>样例输入与输出</h4><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">5 7 1 2 10</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">145</span><br><span class="line">3 1 2 4 5</span><br></pre></td></tr></table></figure><h4 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h4><p>对于全部的测试点，保证 $1 \leq n&lt; 30$，节点的分数是小于 $100$ 的正整数，答案不超过 $4 \times 10^9$。</p><h4 id="算法设计-3"><a href="#算法设计-3" class="headerlink" title="算法设计"></a>算法设计</h4><p>想不到加分是和区间子树取根决定，直接看题解了。</p><p><a href="https://bubbleioa.blog.luogu.org/solution-p1040">https://bubbleioa.blog.luogu.org/solution-p1040</a></p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] root;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span>[][] dp;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] score;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">Reader</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reader</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> r.nextInt();</span><br><span class="line"><span class="comment">//读入分数</span></span><br><span class="line">score = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) score[i] = r.nextInt(); </span><br><span class="line">dp = <span class="keyword">new</span> <span class="title class_">long</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">root = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//记忆化搜索</span></span><br><span class="line"><span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> _dp(<span class="number">1</span>, n);</span><br><span class="line">System.out.println(result);</span><br><span class="line">pre_traverse(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">_dp</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(dp[i][j]!=<span class="number">0</span>) <span class="keyword">return</span> dp[i][j];</span><br><span class="line"><span class="keyword">if</span>(i==j) &#123;</span><br><span class="line">dp[i][i] = score[i];</span><br><span class="line">root[i][i] = i;</span><br><span class="line"><span class="keyword">return</span> score[i];</span><br><span class="line">&#125;</span><br><span class="line">dp[i][j] = _dp(i+<span class="number">1</span>,j) + score[i];</span><br><span class="line">root[i][j] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=i+<span class="number">1</span>;k&lt;j;k++) &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> _dp(i,k-<span class="number">1</span>)*_dp(k+<span class="number">1</span>,j)+score[k];</span><br><span class="line"><span class="keyword">if</span>(temp&gt;dp[i][j]) &#123;</span><br><span class="line">dp[i][j] = temp;</span><br><span class="line">root[i][j] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">pre_traverse</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;j) <span class="keyword">return</span>;</span><br><span class="line">System.out.print(root[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(i&lt;j) &#123;</span><br><span class="line">pre_traverse(i, root[i][j]-<span class="number">1</span>);</span><br><span class="line">pre_traverse(root[i][j]+<span class="number">1</span>, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span>&#123;</span><br><span class="line"><span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)));</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">st.nextToken();</span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>)st.nval;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P4933大师"><a href="#P4933大师" class="headerlink" title="P4933大师"></a>P4933大师</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>ljt12138 首先建了 $n$ 个特斯拉电磁塔，这些电塔排成一排，从左到右依次标号为 $1$ 到 $n$，第 $i$ 个电塔的高度为 $h[i]$。</p><p>建筑大师需要从中选出一些电塔，然后这些电塔就会缩到地下去。这时候，如果留在地上的电塔的高度，从左向右构成了一个等差数列，那么这个选择方案就会被认为是美观的。</p><p>建筑大师需要求出，一共有多少种美观的选择方案，答案模 $998244353$。</p><p>注意，如果地上只留了一个或者两个电塔，那么这种方案也是美观的。地上没有电塔的方案被认为是不美观的。</p><p>同时也要注意，等差数列的公差也可以为负数。</p><h4 id="输入与输出格式-3"><a href="#输入与输出格式-3" class="headerlink" title="输入与输出格式"></a>输入与输出格式</h4><p>输入：</p><p>第一行一个正整数 $n$。</p><p>第二行 $n$ 个非负整数，第 $i$ 个整数是第 $i$ 个电塔的高度 $h[i]$。</p><p>输出：</p><p>输出一个整数，表示美观的方案数模 $998244353$ 的值。</p><h4 id="样例输入与输出-4"><a href="#样例输入与输出-4" class="headerlink" title="样例输入与输出"></a>样例输入与输出</h4><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">13 14 6 20 27 34 34 41</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">50</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">90 1004 171 99 1835 108 81 117 141 126 135 144 81 153 193 81 962 162 1493 171 1780 864 297 180 532 1781 189 1059 198 333 1593 824 207 1877 216 270 225 1131 336 1875 362 234 81 288 1550 243 463 1755 252 406 261 270 279 288 1393 261 1263 297 135 333 872 234 881 180 198 81 225 306 180 90 315 81 81 198 252 81 297 1336 1140 1238 81 198 297 661 81 1372 469 1132 81 126 324 333 342 81 351 481 279 1770 1225 549</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11153</span><br></pre></td></tr></table></figure><h4 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h4><p>设 $v$ 为最高的电塔高度。</p><p>对于前 $30\%$ 的数据，$n \le 20 $。</p><p>对于前 $60\%$ 的数据，$n \le 100$，$v \le 2 \times 10^3$。</p><p>对于另外 $20\%$ 的数据，所有电塔的高度构成一个等差数列。</p><p>对于 $100\%$ 的数据，$n \le 10^3$，$v \leq2 \times 10^4$。</p><h4 id="算法设计-4"><a href="#算法设计-4" class="headerlink" title="算法设计"></a>算法设计</h4><p>考虑线性dp，如果前面的元素的等差数列数已知，此后的元素应该可以借助前面的元素的等差数列数求解。如果前i-1项里面的元素可以形成一些公差为k的等差数列，那么只要第i项比这个等差数列中的任意一项大k，就可以接在该项后形成新的等差数列。例如前i-1项可以形成等差数列1；1 3；1 3 5；，新的元素只要是减去1 3 5等于公差2的元素，都可以形成一个公差为2的新序列(由于题目背景是建塔，两个相同的序列可以表示不同建塔情况)。因此，对于公差k，只要新的元素比之前所有公差k的数列的最后一项大k，就可以产生新序列。而k可以通过枚举找到所有可能的取值。</p><p>根据以上的分析，可以使用两维来表示状态，用dp[i][j]表示<strong>以第i项为最后一项，公差为j的长度大于1的</strong>数列数，递推式为：</p><script type="math/tex; mode=display">dp[i][k]=\sum_{j=1}^{i-1}{dp[j][k]}+1 \ \  \ \ \ \ \ \ \  h[i]-h[j]=k</script><p>其中，k枚举时只需要用h[i]-h[j]表示就可以了。公差存在负数情况，因此还要加一个偏置值(最大高度)。</p><p>最后考虑一下边界条件，只有一个塔或只有两个塔也是符合要求的，以上的递推式中，已经包含了只有两个塔的情况，没有一个塔的情况，最后只需要将结果加上n就可以了。</p><p>总数应该是dp[i][k]的矩阵和+n，可以直接在填表的过程中计算，每轮计算都加上dp[j][k]+1。</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> v;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] h;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] dp;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">Reader</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reader</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> r.nextInt();</span><br><span class="line">h = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">h[i] = r.nextInt();</span><br><span class="line">v = Math.max(h[i], v);</span><br><span class="line">&#125;</span><br><span class="line">dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][<span class="number">2</span>*v+<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> h[i] - h[j] + v;</span><br><span class="line">dp[i][k] = (dp[i][k] + dp[j][k] + <span class="number">1</span>) % mod;</span><br><span class="line">result = (result + dp[j][k] + <span class="number">1</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">result = (result + n) % mod;</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span>&#123;</span><br><span class="line"><span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)));</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">st.nextToken();</span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>)st.nval;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1077-摆花"><a href="#P1077-摆花" class="headerlink" title="P1077 摆花"></a>P1077 摆花</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>小明的花店新开张，为了吸引顾客，他想在花店的门口摆上一排花，共 $m$ 盆。通过调查顾客的喜好，小明列出了顾客最喜欢的 $n$ 种花，从 $1$ 到 $n$ 标号。为了在门口展出更多种花，规定第 $i$ 种花不能超过 $a_i$ 盆，摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。</p><p>试编程计算，一共有多少种不同的摆花方案。</p><h4 id="输入与输出格式-4"><a href="#输入与输出格式-4" class="headerlink" title="输入与输出格式"></a>输入与输出格式</h4><p>输入：</p><p>第一行包含两个正整数 $n$ 和 $m$，中间用一个空格隔开。</p><p>第二行有 $n$ 个整数，每两个整数之间用一个空格隔开，依次表示 $a_1,a_2, \cdots ,a_n$。</p><p>输出：</p><p>一个整数，表示有多少种方案。注意：因为方案数可能很多，请输出方案数对 $10^6+7$ 取模的结果。</p><h4 id="样例输入与输出-5"><a href="#样例输入与输出-5" class="headerlink" title="样例输入与输出"></a>样例输入与输出</h4><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 4</span><br><span class="line">3 2</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h4><p>对于 $20\%$ 数据，有 $0&lt;n \le 8,0&lt;m \le 8,0 \le a_i \le 8$。</p><p>对于 $50\%$ 数据，有 $0&lt;n \le 20,0&lt;m \le 20,0 \le a_i \le 20$。</p><p>对于 $100\%$ 数据，有 $0&lt;n \le 100,0&lt;m \le 100,0 \le a_i \le 100$。</p><p>NOIP 2012 普及组 第三题</p><h4 id="算法设计-5"><a href="#算法设计-5" class="headerlink" title="算法设计"></a>算法设计</h4><p>摆花的顺序存在要求，标号大的必须排在后面，因此先摆标号小的，然后依据标号小的摆放方法数求标号大的摆放方法数。</p><p>设dp[i][j]表示前i-1种花，共摆j盆花的方法数，递推方程如下：</p><script type="math/tex; mode=display">dp[i][j] = \sum_{k=0}^{a_i} dp[i-1][j-k]</script><p>将前面i-1种花的摆放方式，用k盆花i替换掉最后的k盆花，就是新的摆放方式，dp[i][j]就是所有替换方式数的和。</p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] a;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[][] dp;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">Reader</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reader</span>();</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">n = r.nextInt(); m = r.nextInt();</span><br><span class="line">a = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">a[i] = r.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=a[i]&amp;&amp;k&lt;=j;k++) &#123;</span><br><span class="line">dp[i][j] = (dp[i][j] + dp[i-<span class="number">1</span>][j-k]) % <span class="number">1000007</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(dp[n][m]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span>&#123;</span><br><span class="line"><span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)));</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">st.nextToken();</span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>)st.nval;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1233-木棍加工"><a href="#P1233-木棍加工" class="headerlink" title="P1233 木棍加工"></a>P1233 木棍加工</h3><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>一堆木头棍子共有n根，每根棍子的长度和宽度都是已知的。棍子可以被一台机器一个接一个地加工。机器处理一根棍子之前需要准备时间。准备时间是这样定义的：</p><p>第一根棍子的准备时间为1分钟；</p><p>如果刚处理完长度为L，宽度为W的棍子，那么如果下一个棍子长度为Li，宽度为Wi，并且满足L&gt;＝Li，W&gt;＝Wi，这个棍子就不需要准备时间，否则需要1分钟的准备时间；</p><p>计算处理完n根棍子所需要的最短准备时间。比如，你有5根棍子，长度和宽度分别为(4, 9)，(5, 2)，(2, 1)，(3, 5)，(1, 4)，最短准备时间为2（按(4, 9)、(3, 5)、(1, 4)、(5, 2)、(2, 1)的次序进行加工）。</p><h4 id="输入与输出格式-5"><a href="#输入与输出格式-5" class="headerlink" title="输入与输出格式"></a>输入与输出格式</h4><p>输入：</p><p>第一行是一个整数n(n&lt;＝5000)，第2行是2n个整数，分别是L1，W1，L2，w2，…，Ln，Wn。L和W的值均不超过10000，相邻两数之间用空格分开。</p><p>输出：</p><p>仅一行，一个整数，所需要的最短准备时间。</p><h4 id="样例输入与输出-6"><a href="#样例输入与输出-6" class="headerlink" title="样例输入与输出"></a>样例输入与输出</h4><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">4 9 5 2 2 1 3 5 1 4</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="算法设计-6"><a href="#算法设计-6" class="headerlink" title="算法设计"></a>算法设计</h4><p>长度和宽度是两维，不好进行计算，可以先对长度(或宽度)进行排序，这样就不用考虑长度，只需要按宽度来求最短准备时间。根据dilworth定理，最长不上升子序列的个数=最长上升子序列的长度，求宽度序列的最长上升子序列长度就是答案。</p><h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line"><span class="keyword">static</span> stick[] sticks;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] tail;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">int</span> n,l,w;</span><br><span class="line"><span class="type">Reader</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reader</span>();</span><br><span class="line">n = r.nextInt();</span><br><span class="line">sticks = <span class="keyword">new</span> <span class="title class_">stick</span>[n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">l = r.nextInt();</span><br><span class="line">w = r.nextInt();</span><br><span class="line">sticks[i] = <span class="keyword">new</span> <span class="title class_">stick</span>(l,w);</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(sticks, <span class="number">1</span>, n+<span class="number">1</span> ,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;stick&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(stick a, stick b)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="literal">null</span>||b==<span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a.l&lt;b.l) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a.l==b.l) &#123;</span><br><span class="line"><span class="keyword">if</span>(a.w&gt;b.w) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//求最长上升子序列</span></span><br><span class="line">tail = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">tail[<span class="number">1</span>] = sticks[<span class="number">1</span>].w;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(sticks[i].w&gt;tail[maxLen]) &#123;</span><br><span class="line">tail[++maxLen] = sticks[i].w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> Arrays.binarySearch(tail, <span class="number">1</span>, maxLen+<span class="number">1</span>, sticks[i].w);</span><br><span class="line"><span class="keyword">if</span>(pos&gt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> tail[-pos-<span class="number">1</span>] = sticks[i].w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(+maxLen);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">stick</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> l,w;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">stick</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> w)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.l = l;</span><br><span class="line"><span class="built_in">this</span>.w = w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span>&#123;</span><br><span class="line"><span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)));</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">st.nextToken();</span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>)st.nval;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题最大的收获是用了Arrays的排序和二分查找，尤其是排序，先对长度降序，相等时则按宽度降序，排序时发现一组数据无法通过：</p><p>3<br>1 1 1 2 1 3</p><p>原因是排序时按宽度降序没有排序成功，输出Comparator的参数a和b的地址，和原来stick数组的元素地址对应，发现<strong>a排在b的后面</strong>，又经过修改返回值发现，<strong>返回-1才是交换a和b</strong>，这和许多网上的解释是不一样的。</p><p><img src="/2023/01/05/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E7%BA%BF%E6%80%A7dp/image-20230107171101302.png" alt="image-20230107171101302" style="zoom:50%;"></p><p>另外binarySearch如果没找到元素，假设插入位置下标为idx，返回值是<strong>-idx-1</strong>，这是为了修正0，避免返回0分不清是否找到元素。</p><h3 id="P1091-合唱队形"><a href="#P1091-合唱队形" class="headerlink" title="P1091 合唱队形"></a>P1091 合唱队形</h3><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><p>$n$ 位同学站成一排，音乐老师要请其中的 $n-k$ 位同学出列，使得剩下的 $k$ 位同学排成合唱队形。</p><p>合唱队形是指这样的一种队形：设 $k$ 位同学从左到右依次编号为 $1,2,$ … $,k$，他们的身高分别为 $t_1,t_2,$ … $,t_k$，则他们的身高满足 $t_1&lt; \cdots <t_i>t_{i+1}&gt;$ … $&gt;t_k(1\le i\le k)$。</t_i></p><p>你的任务是，已知所有 $n$ 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。</p><h4 id="输入与输出格式-6"><a href="#输入与输出格式-6" class="headerlink" title="输入与输出格式"></a>输入与输出格式</h4><p>输入：</p><p>共二行。</p><p>第一行是一个整数 $n$（$2\le n\le100$），表示同学的总数。</p><p>第二行有 $n$ 个整数，用空格分隔，第 $i$ 个整数 $t_i$（$130\le t_i\le230$）是第 $i$ 位同学的身高（厘米）。</p><p>输出：</p><p>一个整数，最少需要几位同学出列。</p><h4 id="样例输入与输出-7"><a href="#样例输入与输出-7" class="headerlink" title="样例输入与输出"></a>样例输入与输出</h4><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">186 186 150 200 160 130 197 220</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h4 id="提示-6"><a href="#提示-6" class="headerlink" title="提示"></a>提示</h4><p>对于 $50\%$ 的数据，保证有 $n \le 20$。</p><p>对于全部的数据，保证有 $n \le 100$。</p><h4 id="算法设计-7"><a href="#算法设计-7" class="headerlink" title="算法设计"></a>算法设计</h4><p>合唱队形的人数取决于C位同学，队形中C位左侧的同学是C左侧所有同学身高形成的序列的最长上升子序列长度，同理，右侧最多的人数是最长下降子序列长度。所以只要求出以每个位置结束的序列的最长上升子序列长度，以每个位置开始的序列的最长下降子序列长度，然后枚举所有C位的最大人数就可以了。由于n&lt;=100，计算最长上升子序列可以只用O(n^2)的方法，不用优化。</p><h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] h;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] dp1;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] dp2;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">Reader</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reader</span>();</span><br><span class="line">n = r.nextInt();</span><br><span class="line">h = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">dp1 = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">dp2 = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">h[i] = r.nextInt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算最长上升子序列</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">dp1[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(h[i]&gt;h[j]) &#123;</span><br><span class="line">dp1[i] = Math.max(dp1[i], dp1[j]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算最长下降子序列</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">dp2[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(h[i]&gt;h[j]) &#123;</span><br><span class="line">dp2[i] = Math.max(dp2[i], dp2[j]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历C位</span></span><br><span class="line"><span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">maxNum = Math.max(maxNum, dp1[i]+dp2[i]-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(n-maxNum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span>&#123;</span><br><span class="line"><span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)));</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">st.nextToken();</span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>)st.nval;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P5858-「SWTR-03」Golden-Sword"><a href="#P5858-「SWTR-03」Golden-Sword" class="headerlink" title="P5858 「SWTR-03」Golden Sword"></a>P5858 「SWTR-03」Golden Sword</h3><h4 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h4><p>小 E 不幸在一场战斗中失去了他的金宝剑。</p><h4 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h4><p>制造一把金宝剑需要 $n$ 种原料，编号为 $1$ 到 $n$，编号为 $i$ 的原料的坚固值为 $a_i$。</p><p>炼金是很讲究放入原料的顺序的，因此小 E 必须<strong>按照 $1$ 到 $n$ 的顺序</strong>依次将这些原料放入炼金锅。</p><p>但是，炼金锅的容量非常有限，它<strong>最多只能容纳 $w$ 个原料</strong>。</p><p>所幸的是，<strong>每放入一个原料之前</strong>，小 E 可以从中取出一些原料，数量不能超过 $s$ 个。</p><ul><li>我们定义第 $i$ 种原料的耐久度为：放入第 $i$ 种原料时锅内的原料总数（包括正在放入的原料） $\times\ a_i$，则宝剑的耐久度为<strong>所有原料</strong>的耐久度之和。</li></ul><p>小 E 当然想让他的宝剑的耐久度尽可能得大，这样他就可以带着它进行更多的战斗，请求出耐久度的最大值。</p><p>注：这里的“放入第 $i$ 种原料时锅内的原料总数<strong>包括正在放入锅中的原料</strong>，详细信息请见样例。</p><h4 id="输入与输出格式-7"><a href="#输入与输出格式-7" class="headerlink" title="输入与输出格式"></a>输入与输出格式</h4><p>输入：</p><p>第一行，三个整数 $n,w,s$。</p><p>第二行，$n$ 个整数 $a_1,a_2,\dots,a_n$。</p><p>输出：</p><p>一行一个整数，表示耐久度的最大值。</p><h4 id="样例输入与输出-8"><a href="#样例输入与输出-8" class="headerlink" title="样例输入与输出"></a>样例输入与输出</h4><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 3 3</span><br><span class="line">1 3 2 4 5</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">40</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 3 3</span><br><span class="line">1 -3 -2 4 5</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7 4 2</span><br><span class="line">-5 3 -1 -4 7 -6 5</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 3 1</span><br><span class="line">-1 -3 -2 -4 -5</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-15</span><br></pre></td></tr></table></figure><h4 id="提示-7"><a href="#提示-7" class="headerlink" title="提示"></a>提示</h4><p><strong>「样例说明」</strong></p><ul><li><strong>对于样例 1</strong>，一种可行的<strong>最优</strong>方案为：<br>首先放进原料 1，此时锅内有 $1$ 种原料，耐久度为 $1\times a_1=1\times 1=1$。<br>再放进原料 2，此时锅内有 $2$ 种原料，耐久度为 $2\times a_2=2\times 3=6$。<br>再放进原料 3，此时锅内有 $3$ 种原料，耐久度为 $3\times a_3=3\times 2=6$。<br>取出原料 1，再放进原料 4，此时锅内有 $3$ 种原料，耐久度为 $3\times a_4=3\times 4=12$。<br>取出原料 4，再放进原料 5，此时锅内有 $3$ 种原料，耐久度为 $3\times a_5=3\times 5=15$。<br>最终答案为 $1+6+6+12+15=40$。  </li><li><strong>对于样例 2</strong>，一种可行的<strong>最优</strong>方案为：<br>放进原料 1，耐久度为 $1\times 1=1$。<br>取出原料 1，放进原料 2，耐久度为 $1\times (-3)=-3$。<br>放进原料 3，耐久度为 $2\times (-2)=-4$。<br>放进原料 4，耐久度为 $3\times 4=12$。<br>取出原料 2，放进原料 5，耐久度为 $3\times 5=15$。<br>最终答案为 $1+(-3)+(-4)+12+15=21$。  </li><li><strong>对于样例 3</strong>，一种可行的<strong>最优</strong>方案为：<br>$a_1+2a_2+2a_3+3a_4+4a_5+3a_6+4a_7=17$。 </li><li><strong>对于样例 4</strong>，一种可行的<strong>最优</strong>方案为：<br>$a_1+a_2+a_3+a_4+a_5=-15$。</li></ul><p><strong>「数据范围与约定」</strong></p><ul><li>Subtask #1（15 points）：$n\leq 10$。</li><li>Subtask #2（5 points）：$n\leq 100$，$a_i\geq0$。</li><li>Subtask #3（15 points）：$n\leq 300$。</li><li>Subtask #4（15 points）：$s=w=n$。</li><li>Subtask #5（5 points）：$a_i\geq 0$。</li><li>Subtask #6（10 points）：$n\leq 2\times 10^3$。</li><li>Subtask #7（10 points）：$s=1$。</li><li>Subtask #8（25 points）：无特殊限制。</li></ul><p>对于 $100\%$ 的数据，$1 \leq s \leq w \leq n \leq 5\times 10^3$，$|a_i| \leq 10^9$。对于 Subtask $i$ 有 $|a_i|\leq 10^{i+1}$。</p><h4 id="算法设计-8"><a href="#算法设计-8" class="headerlink" title="算法设计"></a>算法设计</h4><p>放入一个原料和之前放入的原料有关，因此状态需要保存原料标号，放入原料时的原料耐久度与已放入的原料数有关，因此还需要保存原料数信息，因此可以用二维数组表示状态。设dp[i][j]表示前i种原料，共放入j种原料的耐久度，可写出递推方程：</p><script type="math/tex; mode=display">dp[i][j] = max_{j-1\leq k \leq j+s-1}\{dp[i-1][k]\}+a[i]*j</script><p>其中k的取值范围是j-1到j+s-1，前i种原料有j-1种加入，可直接放入i；有j种加入，可以取出1种再放入i；有更多种加入，可以先取出到只剩j-1种，然后加入原料i，最多可以取出s种，因此k最大取j+s-1。</p><p>计算dp[i][j]时，对于不同的j值，可以发现k的区间每次都+1，然后从这个区间找最大值，这个过程中有重复的比较，可以使用单调队列进行优化。只要在求j值的时候建一个单调队列就可以了，第一维没有影响。并且dp[i][j]只需要用上一层的值，最后的结果也只需要dp[n][j]的最大值，因此可以使用滚动数组。</p><h4 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span>[] a;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span>[][] dp;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] queue;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> head, tail;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">int</span> n, w, s;</span><br><span class="line"><span class="type">Reader</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reader</span>();</span><br><span class="line">n = r.nextInt(); w = r.nextInt(); s = r.nextInt();</span><br><span class="line">a = <span class="keyword">new</span> <span class="title class_">long</span>[n+<span class="number">1</span>];</span><br><span class="line">dp = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">2</span>][w+<span class="number">1</span>];</span><br><span class="line">queue = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>*w+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = r.nextInt();</span><br><span class="line">Arrays.fill(dp[<span class="number">0</span>], Long.MIN_VALUE/<span class="number">2</span>);</span><br><span class="line">Arrays.fill(dp[<span class="number">1</span>], Long.MIN_VALUE/<span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">l = l^<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> head, tail;</span><br><span class="line">head = tail = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=Math.min(w,i); j&gt;=<span class="number">1</span>; j--) &#123;</span><br><span class="line"><span class="keyword">while</span>(queue[head+<span class="number">1</span>]&gt;s+j-<span class="number">1</span>&amp;&amp;head!=tail) head++;</span><br><span class="line"><span class="keyword">while</span>(dp[l^<span class="number">1</span>][queue[tail]]&lt;dp[l^<span class="number">1</span>][j]&amp;&amp;head!=tail) tail--;</span><br><span class="line">queue[++tail]=j;</span><br><span class="line">dp[l][j]=Math.max(dp[l^<span class="number">1</span>][queue[head+<span class="number">1</span>]],dp[l^<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">dp[l][j]+=j*a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=w;i++) &#123;</span><br><span class="line">result = Math.max(result, dp[l][i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span>&#123;</span><br><span class="line"><span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)));</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">st.nextToken();</span><br><span class="line"><span class="keyword">return</span> (<span class="type">int</span>)st.nval;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法设计与分析-树形dp</title>
      <link href="/2023/01/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E6%A0%91%E5%BD%A2dp/"/>
      <url>/2023/01/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E6%A0%91%E5%BD%A2dp/</url>
      
        <content type="html"><![CDATA[<p style="text-indent:2em">算法设计与分析-动态规划树形DP题目记录。</p><span id="more"></span><h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h2><h3 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h3><p>树形DP的思路是用树形结构存储数据，使用DFS更新状态数组。</p><p>树形DP一般自底向上，按子树从小到大求解，将将节点编号作为状态的第一维，表示以该节点为根的子树的解。</p><p>树形DP一般采用深度优先遍历，先求解叶子节点，向上进行状态转移，求解完当前节点的所有子树，才求解当前节点。</p><p>能够使用树形DP解决的问题的特征是<strong>每个子树的问题独立</strong>。</p><h3 id="链式前向星图"><a href="#链式前向星图" class="headerlink" title="链式前向星图"></a>链式前向星图</h3><p>有向树上的问题可以将树作为有向图来存储，有向图常用邻接表或静态邻接表存储。静态邻接表又称为链式前向星，使用两个数组保存所有边，head[i]表示以i为起点的最后一条边，edges[]中存储了所有的边，每个边的结构体保存了一个值last(或者常写为next)，指向相同起点的另一条边。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">int</span> last;</span><br><span class="line">    <span class="type">int</span> d;<span class="comment">//边权</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;<span class="comment">//边数</span></span><br><span class="line"><span class="type">int</span> head[maxn];</span><br><span class="line">edge edges[maxk];</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line"><span class="comment">//添加边</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    edges[cnt].to = j;</span><br><span class="line">    edges[cnt].last = head[x];</span><br><span class="line">    head[x] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历所有边</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;<span class="comment">//遍历每个点为起点的边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=head[i];j!=<span class="number">-1</span>;j=edges[j].last)&#123;</span><br><span class="line">            <span class="comment">//edges[j]为i为起点的一条边</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>使用链式前向星图比邻接表，vector实现的邻接表更省空间，vector扩大时会将空间扩大2倍，数据规模大时可能被卡空间或时间。</p><h3 id="P1352-没有上司的舞会"><a href="#P1352-没有上司的舞会" class="headerlink" title="P1352 没有上司的舞会"></a>P1352 没有上司的舞会</h3><p>传送门：<a href="https://www.luogu.com.cn/problem/P1352">https://www.luogu.com.cn/problem/P1352</a></p><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>某大学有 n个职员，编号为 1…n1…n。</p><p>他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。</p><p>现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 r，但是如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。</p><p>请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入的第一行是一个整数 n。</p><p>第 22 到第 (n+1) 行，每行一个整数，第 (i+1) 行的整数表示 i 号职员的快乐指数 r。</p><p>第 (n+2) 到第 2n 行，每行输入一对整数 l,k，代表 k 是 l 的直接上司。</p><h4 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h4><p>用树形结构表示所有职员，节点为每个职员，直接相连的父节点为直接上司。</p><p>用dp[i][0/1]表示以节点i为根节点的子树的最优解，第二维的0/1表示当前节点的职员是否参加舞会。考虑当前节点是否选择参加：</p><ul><li>不选择当前节点u，则u的所有子节点可选可不选，因此<script type="math/tex">dp[u][0] +=max\{dp[v][0]，dp[v][1]\}</script>，v为u的子节点。</li><li>选择当前节点，则u的所有子节点都不可选择参加，<script type="math/tex">dp[u][1]+=dp[v][0]</script>。</li></ul><p>对于节点u，可以初始化其子树解的下界：<script type="math/tex">dp[u][0]=0,\ dp[u][1]=val[u]</script>。</p><p>最终的结果为<script type="math/tex">max\{dp[root][0],dp[root][1]\}</script></p><p>使用链式前向星图(静态邻接表)存储树，有向边为父节点指向子节点的边。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>c++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">6e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">int</span> last;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n, cnt = <span class="number">0</span>;         <span class="comment">//节点数与边数</span></span><br><span class="line"><span class="type">int</span> head[maxn];         <span class="comment">//从i出发的最后一条边</span></span><br><span class="line"><span class="type">int</span> dp[maxn][<span class="number">2</span>];        <span class="comment">//状态数组</span></span><br><span class="line"><span class="type">int</span> r[maxn];            <span class="comment">//快乐指数</span></span><br><span class="line">edge edges[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];         <span class="comment">//记录是否有向上层的边, 用于找根节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    edges[cnt].to = y;          <span class="comment">//连接的点</span></span><br><span class="line">    edges[cnt].last = head[x];  <span class="comment">//上一条边</span></span><br><span class="line">    head[x] = cnt++;            <span class="comment">//当前边为从x出发的最后一条边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur)</span></span>&#123;</span><br><span class="line">    dp[cur][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[cur][<span class="number">1</span>] = r[cur];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[cur];~i;i=edges[i].last)&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(edges[i].to);</span><br><span class="line">        dp[cur][<span class="number">1</span>] += dp[edges[i].to][<span class="number">0</span>];</span><br><span class="line">        dp[cur][<span class="number">0</span>] += <span class="built_in">max</span>(dp[edges[i].to][<span class="number">0</span>], dp[edges[i].to][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y, root;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输入边</span></span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="built_in">add</span>(y, x);</span><br><span class="line">        vis[x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到根节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            root = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(dp[root][<span class="number">0</span>], dp[root][<span class="number">1</span>]) &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> to, last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">graph</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">maxn</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">6e3</span>+<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> root;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] head;</span><br><span class="line">    <span class="keyword">private</span> edge[] edges;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dp;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] r;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">graph</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">edge</span>[maxn];</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        r = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(head, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;maxn;i++) edges[i] = <span class="keyword">new</span> <span class="title class_">edge</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(<span class="type">int</span> r)</span> &#123; root = r;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setR</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> r)</span> &#123;<span class="built_in">this</span>.r[i] = r;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        edges[cnt].to = y;</span><br><span class="line">        edges[cnt].last = head[x];</span><br><span class="line">        head[x] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cur)</span>&#123;</span><br><span class="line">        dp[cur][<span class="number">1</span>] = r[cur];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[cur];i!=-<span class="number">1</span>;i=edges[i].last)&#123;</span><br><span class="line">            dfs(edges[i].to);</span><br><span class="line">            dp[cur][<span class="number">0</span>] += Math.max(dp[edges[i].to][<span class="number">0</span>], dp[edges[i].to][<span class="number">1</span>]);</span><br><span class="line">            dp[cur][<span class="number">1</span>] += dp[edges[i].to][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solution</span><span class="params">()</span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        System.out.println(Math.max(dp[root][<span class="number">0</span>], dp[root][<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">P1352</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> n, x, y;</span><br><span class="line">        <span class="type">int</span>[] vis;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        <span class="type">graph</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">graph</span>(n);</span><br><span class="line">        vis = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//读入指数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            g.setR(i, sc.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读入边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            x = sc.nextInt();</span><br><span class="line">            y = sc.nextInt();</span><br><span class="line">            g.add(y, x);</span><br><span class="line">            vis[x] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到根节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                g.setRoot(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        g.solution();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试输入与输出"><a href="#测试输入与输出" class="headerlink" title="测试输入与输出"></a>测试输入与输出</h4><p>输入：</p><p>7<br>1<br>1<br>1<br>1<br>1<br>1<br>1<br>1 3<br>2 3<br>6 4<br>7 4<br>4 5<br>3 5</p><p>输出：</p><p>5</p><h3 id="318-有向树k中值问题"><a href="#318-有向树k中值问题" class="headerlink" title="318 有向树k中值问题"></a>318 有向树k中值问题</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一颗有向树T，T中每个顶点u都有一个权w(u)，树的每条边(u，v)也有一个非负边长d。有向树T的每个顶点u可以看作客户，服务需求量为w(u)。每条边的边长可以看作运输费用。如果在顶点u处为设置服务机构，则将顶点u处的服务需求沿有向树的边(u，v)转移到v处服务机构所付出的服务转移费用为w(u)*d(u，v)。树根处已设置了服务机构，现在要在树T中增设k处服务机构，使整棵树的服务转移费用最小。</p><p>对于给定的有向树T，计算在树T中增设k处服务机构的最小服务转移费用。</p><p><img src="/2023/01/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E6%A0%91%E5%BD%A2dp/image-20230102103543549.png" alt="image-20230102103543549" style="zoom:50%;"></p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入的第一行为两个数字n和k，n为边数，k为增设服务机构数。树有编号为0,1,…,n的节点，0为根节点。此后的n行输入每行有三个数，分别为wi，vi，di，表示顶点权，有向边(i，vi)，边长(i取1-n)。</p><h4 id="算法设计-1"><a href="#算法设计-1" class="headerlink" title="算法设计"></a>算法设计</h4><p>参考传送门：<a href="https://blog.csdn.net/RinRinko/article/details/127436260">https://blog.csdn.net/RinRinko/article/details/127436260</a></p><p>每个子树的问题都独立，因此可以考虑树形dp。</p><p>对于每个以当前节点为根的子树，要考虑的问题如下：</p><ul><li>当前节点是否增设服务机构</li><li>如果一共增设k个服务机构，子节点应该怎么分配这k个服务机构</li></ul><p>对于第一个问题，只需要分两种情况讨论。但是第二个问题，如果使用原来的有向树处理，每个节点可能有多个子节点，遍历所有的分配情况是困难的，因此可以考虑<strong>将原来的有向树转化为一颗二叉树</strong>。</p><p>原来的树可以转化为二叉树处理的原因是，将一棵树转化为二叉树，<strong>一个节点的子节点仍然是他的子节点</strong>，因此将k个服务机构分配下去，每个节点都再进行分配，就考虑到了每个子节点分配0-k个服务机构的情况。但是转化为二叉树是为了分配服务机构，不能将原树的节点距离改变，因此要<strong>在初始的树上，把每个节点到其上层节点的距离算出来</strong>，这样计算转移费用时，仍然使用的是原来的树上的距离。</p><p>具体设计如下：</p><ul><li>dp[v][u][k]：表示以v为根节点的子树，离v最近的服务节点为u且子树可增设k个服务机构的最小转移费用。第二维的设置是考虑当前节点设置不设置服务机构，如果设置，子节点距离最近的服务机构就在点v，否则不是点v，在点v的上层。</li><li>d[v][u]：原始有向树上任意两点的距离</li><li>如果当前节点i不增设服务机构，v子树的服务需要转移到u，子节点距离最近的服务机构也是u，枚举子节点分配k个服务机构数量的所有情况，最小费用为：</li></ul><script type="math/tex; mode=display">minCost1 = min_{0\leq i\leq k}\{dp[v.left\_child][u][i]+dp[v.right\_child][u][k-i]\} +d[v][u]*w[v]</script><ul><li>如果当前节点i增设服务机构，v子树的服务可以在v处理，子节点距离最近的服务机构是v，最小费用为：</li></ul><script type="math/tex; mode=display">minCost2 = min_{0\leq i\leq k-1}\{dp[v.left\_child][v][i]+dp[v.right\_child][v][k-i-1]\}</script><ul><li>最终dp[v][u][k] = min{minCost1，minCost2}</li><li>状态转移方向不确定，采用记忆化搜索</li><li>如果子节点数量小于分配到的服务机构数量，dp[v][u][k] =0，可以不计算子树</li><li>每个节点的有向边是指向父节点的，只有一条，且问题在新的二叉树解决，因此原树只需要记录每个点的父节点及距离，用于计算任意两点之间的距离</li><li>如果d(v，u)不存在，即u是v的同层节点，那在u设置服务机构，v是不可以用的，因此需要将u修正为距离v最近的服务机构，且u可达。用if_serve[i]记录节点是否是服务机构，然后从v的父节点开始向上寻找最近的服务机构。</li></ul><p><img src="/2023/01/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E6%A0%91%E5%BD%A2dp/image-20230102171620549.png" alt="image-20230102171620549" style="zoom: 67%;"></p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>c++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据题意，每个点都只有一个有向边，因此边不需要存储为链式前向星图中边的格式</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//树的相关变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, k;    </span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> maxn = <span class="number">100</span>;                  </span><br><span class="line">    edge original_edge[maxn];     <span class="comment">//原始树的n条边</span></span><br><span class="line">    <span class="type">int</span> nodes[maxn];             <span class="comment">//二叉树子树的节点数</span></span><br><span class="line">    <span class="type">int</span> w[maxn];                 <span class="comment">//每个点的权重</span></span><br><span class="line">    <span class="type">int</span> binary_tree[maxn][<span class="number">2</span>];    <span class="comment">//二叉树</span></span><br><span class="line">    <span class="type">int</span> d[maxn][maxn];           <span class="comment">//两节点的距离</span></span><br><span class="line">    <span class="type">int</span> if_serve[maxn];          <span class="comment">//是否是服务机构</span></span><br><span class="line">    <span class="type">int</span> ***dp;                   <span class="comment">//dp数组，有三维，需要开在堆内存</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造开好dp数组</span></span><br><span class="line">    <span class="built_in">solution</span>(<span class="type">int</span> n, <span class="type">int</span> k)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="type">int</span>**[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i] = <span class="keyword">new</span> <span class="type">int</span>*[n+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">new</span> <span class="type">int</span>[k+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;=k;l++)&#123;</span><br><span class="line">                    dp[i][j][l] = INT_MAX;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fill</span>(if_serve, if_serve+maxn, <span class="number">0</span>);</span><br><span class="line">        if_serve[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">fill</span>(binary_tree[<span class="number">0</span>], binary_tree[<span class="number">0</span>]+<span class="number">2</span>*maxn, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fill</span>(d[<span class="number">0</span>], d[<span class="number">0</span>]+maxn*maxn, INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">solution</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k;j++)&#123;</span><br><span class="line">                <span class="keyword">delete</span>[] dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) <span class="keyword">delete</span>[] dp[i];</span><br><span class="line">        <span class="keyword">delete</span>[] dp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读入树并存入二叉树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input_tree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> vi,wi,di;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cin &gt;&gt; wi &gt;&gt; vi &gt;&gt; di;</span><br><span class="line">            w[i] = wi;</span><br><span class="line">            original_edge[i].to = vi;</span><br><span class="line">            original_edge[i].d = di;</span><br><span class="line">            <span class="comment">//存入二叉树, vi是上层父节点，i是子节点，对于转化的二叉树，左子树是子节点，右子树是同层节点</span></span><br><span class="line">            <span class="keyword">if</span> (binary_tree[vi][<span class="number">0</span>]==<span class="number">-1</span>)&#123;                   <span class="comment">//vi没有左节点，左节点就是i</span></span><br><span class="line">                binary_tree[vi][<span class="number">0</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                binary_tree[i][<span class="number">1</span>] = binary_tree[vi][<span class="number">0</span>];    <span class="comment">//vi的左节点接到i的右节点，i作为vi的左节点</span></span><br><span class="line">                binary_tree[vi][<span class="number">0</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化原树所有节点之间的距离</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cal_dis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">0</span>;i--)&#123;              <span class="comment">//从原树的叶子节点向上算距离</span></span><br><span class="line">            <span class="type">int</span> dest = i, dis = <span class="number">0</span>;          </span><br><span class="line">            <span class="keyword">while</span>(dest)&#123;                    <span class="comment">//向上到根节点</span></span><br><span class="line">                dis += original_edge[dest].d;</span><br><span class="line">                dest = original_edge[dest].to;</span><br><span class="line">                d[i][dest] = d[dest][i] = dis;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算二叉树的子树的节点数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count_child</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">        nodes[node] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(binary_tree[node][<span class="number">0</span>]!=<span class="number">-1</span>)&#123;</span><br><span class="line">            nodes[node] += <span class="built_in">count_child</span>(binary_tree[node][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(binary_tree[node][<span class="number">1</span>]!=<span class="number">-1</span>)&#123;</span><br><span class="line">            nodes[node] += <span class="built_in">count_child</span>(binary_tree[node][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes[node];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记忆化搜索</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> u, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(dp[v][u][k]!=INT_MAX) <span class="keyword">return</span> dp[v][u][k];</span><br><span class="line">        <span class="keyword">if</span>(k&gt;nodes[v]) &#123;</span><br><span class="line">            dp[v][u][k] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果u在原来的树上不可达，那dp[v][u][k]中u是v在原树上的上层服务机构点</span></span><br><span class="line">        <span class="keyword">if</span>(d[v][u]==INT_MAX) u = original_edge[v].to; </span><br><span class="line">        <span class="keyword">while</span>(if_serve[u]==<span class="number">0</span>)&#123;</span><br><span class="line">            u = original_edge[u].to;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分别计算节点v设置和不设置服务机构的情况</span></span><br><span class="line">        <span class="comment">//不设置服务机构</span></span><br><span class="line">        <span class="type">int</span> cost;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            cost = w[v]*d[v][u];</span><br><span class="line">            <span class="keyword">if</span>(binary_tree[v][<span class="number">0</span>]!=<span class="number">-1</span>)&#123;</span><br><span class="line">                cost += <span class="built_in">cal</span>(binary_tree[v][<span class="number">0</span>], u, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cost &gt; dp[v][u][k]) <span class="keyword">continue</span>;       <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(binary_tree[v][<span class="number">1</span>]!=<span class="number">-1</span>)&#123;</span><br><span class="line">                cost += <span class="built_in">cal</span>(binary_tree[v][<span class="number">1</span>], u, k-i);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[v][u][k] = <span class="built_in">min</span>(dp[v][u][k], cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置服务机构, 根节点不可以设置</span></span><br><span class="line">        <span class="keyword">if</span>(v==<span class="number">0</span>) <span class="keyword">return</span> dp[v][u][k];</span><br><span class="line">        if_serve[v] = <span class="number">1</span>;                           <span class="comment">//当前节点设置为服务机构</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            cost = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(binary_tree[v][<span class="number">0</span>]!=<span class="number">-1</span>)&#123;</span><br><span class="line">                cost += <span class="built_in">cal</span>(binary_tree[v][<span class="number">0</span>], v, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cost &gt; dp[v][u][k]) <span class="keyword">continue</span>;       <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(binary_tree[v][<span class="number">1</span>]!=<span class="number">-1</span>)&#123;</span><br><span class="line">                cost += <span class="built_in">cal</span>(binary_tree[v][<span class="number">1</span>], v, k-i<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[v][u][k] = <span class="built_in">min</span>(dp[v][u][k], cost);</span><br><span class="line">        &#125;</span><br><span class="line">        if_serve[v] = <span class="number">0</span>;                           <span class="comment">//取消当前节点为服务机构</span></span><br><span class="line">        <span class="keyword">return</span> dp[v][u][k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">input_tree</span>();</span><br><span class="line">        <span class="built_in">cal_dis</span>();</span><br><span class="line">        <span class="built_in">count_child</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">cal</span>(<span class="number">0</span>, <span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k, result;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">solution <span class="title">s</span><span class="params">(n, k)</span></span>;</span><br><span class="line">    result = s.<span class="built_in">solve</span>();</span><br><span class="line">    cout &lt;&lt; result &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> to, d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n,k;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] w;</span><br><span class="line">    <span class="keyword">private</span> edge[] original_edge;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] d;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] binary_tree;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] nodes;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][][] dp;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] is_server;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        original_edge = <span class="keyword">new</span> <span class="title class_">edge</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) original_edge[i] = <span class="keyword">new</span> <span class="title class_">edge</span>();</span><br><span class="line">        d = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        binary_tree = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        nodes = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        is_server = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>][k+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;=k;l++)&#123;</span><br><span class="line">                    dp[i][j][l] = Integer.MAX_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) binary_tree[i][<span class="number">0</span>] = binary_tree[i][<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) Arrays.fill(d[i], Integer.MAX_VALUE);</span><br><span class="line">        is_server[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读入树并转为二叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">input_tree</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> wi, vi, di;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        n = sc.nextInt(); k = sc.nextInt();</span><br><span class="line">        initialize(n, k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            wi = sc.nextInt(); vi = sc.nextInt(); di = sc.nextInt();</span><br><span class="line">            w[i] = wi;</span><br><span class="line">            original_edge[i].to = vi;</span><br><span class="line">            original_edge[i].d = di;</span><br><span class="line">            <span class="comment">//存入二叉树, 左子节点是原树子节点，右子节点是原树同层节点</span></span><br><span class="line">            <span class="keyword">if</span>(binary_tree[vi][<span class="number">0</span>]==-<span class="number">1</span>)&#123;</span><br><span class="line">                binary_tree[vi][<span class="number">0</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                binary_tree[i][<span class="number">1</span>] = binary_tree[vi][<span class="number">0</span>];</span><br><span class="line">                binary_tree[vi][<span class="number">0</span>] = i; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算原树中各点之间的距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cal_dis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">dest</span> <span class="operator">=</span> i, dis = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(dest!=<span class="number">0</span>)&#123;</span><br><span class="line">                dis += original_edge[dest].d;</span><br><span class="line">                dest = original_edge[dest].to;</span><br><span class="line">                d[i][dest] = dis;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算二叉树的子树的节点数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count_child</span><span class="params">(<span class="type">int</span> node)</span>&#123;</span><br><span class="line">        nodes[node] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(binary_tree[node][<span class="number">0</span>]!=-<span class="number">1</span>)&#123;</span><br><span class="line">            nodes[node] += count_child(binary_tree[node][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(binary_tree[node][<span class="number">1</span>]!=-<span class="number">1</span>)&#123;</span><br><span class="line">            nodes[node] += count_child(binary_tree[node][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes[node];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记忆化搜索</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> u, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(dp[v][u][k]!=Integer.MAX_VALUE) <span class="keyword">return</span> dp[v][u][k];</span><br><span class="line">        <span class="keyword">if</span>(k&gt;nodes[v]) &#123;</span><br><span class="line">            dp[v][u][k] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果u在原来的树上不可达，那dp[v][u][k]中u是v在原树上的上层服务机构点</span></span><br><span class="line">        <span class="keyword">if</span>(d[v][u]==Integer.MAX_VALUE) u = original_edge[v].to; </span><br><span class="line">        <span class="keyword">while</span>(is_server[u]==<span class="number">0</span>)&#123;</span><br><span class="line">            u = original_edge[u].to;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分别计算节点v设置和不设置服务机构的情况</span></span><br><span class="line">        <span class="comment">//不设置服务机构</span></span><br><span class="line">        <span class="type">int</span> cost;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            cost = w[v]*d[v][u];</span><br><span class="line">            <span class="keyword">if</span>(binary_tree[v][<span class="number">0</span>]!=-<span class="number">1</span>)&#123;</span><br><span class="line">                cost += cal(binary_tree[v][<span class="number">0</span>], u, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cost &gt; dp[v][u][k]) <span class="keyword">continue</span>;       <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(binary_tree[v][<span class="number">1</span>]!=-<span class="number">1</span>)&#123;</span><br><span class="line">                cost += cal(binary_tree[v][<span class="number">1</span>], u, k-i);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[v][u][k] = Math.min(dp[v][u][k], cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置服务机构, 根节点不可以设置</span></span><br><span class="line">        <span class="keyword">if</span>(v==<span class="number">0</span>) <span class="keyword">return</span> dp[v][u][k];</span><br><span class="line">        is_server[v] = <span class="number">1</span>;                          <span class="comment">//当前节点设置为服务机构</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            cost = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(binary_tree[v][<span class="number">0</span>]!=-<span class="number">1</span>)&#123;</span><br><span class="line">                cost += cal(binary_tree[v][<span class="number">0</span>], v, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cost &gt; dp[v][u][k]) <span class="keyword">continue</span>;       <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(binary_tree[v][<span class="number">1</span>]!=-<span class="number">1</span>)&#123;</span><br><span class="line">                cost += cal(binary_tree[v][<span class="number">1</span>], v, k-i-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[v][u][k] = Math.min(dp[v][u][k], cost);</span><br><span class="line">        &#125;</span><br><span class="line">        is_server[v] = <span class="number">0</span>;                           <span class="comment">//取消当前节点为服务机构</span></span><br><span class="line">        <span class="keyword">return</span> dp[v][u][k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">solve</span><span class="params">()</span>&#123;</span><br><span class="line">        input_tree();</span><br><span class="line">        cal_dis();</span><br><span class="line">        count_child(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> cal(<span class="number">0</span>, <span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DP318</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        <span class="type">solution</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">solution</span>();</span><br><span class="line">        res = s.solve();</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试输入与输出-1"><a href="#测试输入与输出-1" class="headerlink" title="测试输入与输出"></a>测试输入与输出</h4><p>输入：</p><p>4 2 </p><p>1 0 1</p><p>1 1 10</p><p>10 2 5</p><p>1 2 3</p><p>输出：</p><p>4</p><h3 id="322-树的最大连通分支问题"><a href="#322-树的最大连通分支问题" class="headerlink" title="322 树的最大连通分支问题"></a>322 树的最大连通分支问题</h3><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一棵树T，树中每个顶点u都有权值w(u)，可以是负数。现在要找到树T的一个连通子图使该子图的权之和最大。</p><p>设计一个算法，对于给定的树T，计算树T的最大连通分支。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行有一个整数n，表示树T有n个节点，编号为1-n。第二行有n个整数，表示n个节点的权值，接下来的n-1行中，每一行有两个整数u和v，表示顶点u和顶点v相连。</p><h4 id="算法设计-2"><a href="#算法设计-2" class="headerlink" title="算法设计"></a>算法设计</h4><p>每个子树的问题都独立，可以使用树形DP。</p><p>设dp[i][0/1]表示以i为根节点的子树的最大连通分支，dp[i][0]表示不选择当前节点时，最大连通分支权值，dp[i][1]表示选择当前节点时，最大连通分支权值。</p><p>如果选择当前节点，要连接上一个子节点u，子节点u也必须选择，才能保证连通，包含当前节点的最大连通分支为：</p><script type="math/tex; mode=display">dp[i][1] = \sum{dp[u][1]} \ \ \  dp[u][1]>0</script><p>如果不选择当前节点，包含当前节点的最大连通分支就是所有子树的最大连通分支权值：</p><script type="math/tex; mode=display">dp[i][0] = max\{dp[u][0], dp[u][1]\}</script><p>用链式前向星图存树，将编号为1的节点作为根节点。最终的答案为max{dp[1][0]，dp[1][1]}</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>c++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">int</span> last;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line">    <span class="type">int</span> n, cnt;</span><br><span class="line">    <span class="type">int</span> w[maxn];</span><br><span class="line">    edge edges[maxn];</span><br><span class="line">    <span class="type">int</span> head[maxn];</span><br><span class="line">    <span class="type">int</span> dp[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">solution</span>(<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n; </span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fill</span>(dp[<span class="number">0</span>], dp[<span class="number">0</span>] + maxn*<span class="number">2</span>, INT_MIN);</span><br><span class="line">        <span class="built_in">fill</span>(head, head + maxn, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//权值输入</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setW</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> wi)</span></span>&#123; w[i] = wi; &#125;</span><br><span class="line">    <span class="comment">//添加边</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        edges[cnt].to = y;</span><br><span class="line">        edges[cnt].last = head[x];</span><br><span class="line">        head[x] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求最大连通分支值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = w[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=head[i];j!=<span class="number">-1</span>;j=edges[j].last)&#123;</span><br><span class="line">            <span class="type">int</span> child = edges[j].to;</span><br><span class="line">            <span class="built_in">dfs</span>(child);</span><br><span class="line">            <span class="keyword">if</span>(dp[child][<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][<span class="number">1</span>] += dp[child][<span class="number">1</span>];</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i][<span class="number">0</span>], <span class="built_in">max</span>(dp[child][<span class="number">0</span>], dp[child][<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">0</span>], dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, x, y, res;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">solution <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        s.<span class="built_in">setW</span>(i, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y)&#123;</span><br><span class="line">            s.<span class="built_in">addEdge</span>(y, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            s.<span class="built_in">addEdge</span>(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res = s.<span class="built_in">solve</span>();</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to, last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n, cnt;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] w;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] head;</span><br><span class="line">    <span class="keyword">private</span> edge[] edges;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">edge</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) edges[i] = <span class="keyword">new</span> <span class="title class_">edge</span>();</span><br><span class="line">        Arrays.fill(head, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) dp[i][<span class="number">0</span>] = dp[i][<span class="number">1</span>] = Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设定权重</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setW</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> wi)</span>&#123; w[x] = wi; &#125;</span><br><span class="line">    <span class="comment">//添加边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        edges[cnt].to = y;</span><br><span class="line">        edges[cnt].last = head[x];</span><br><span class="line">        head[x] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dfs填表求最大连通分支</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = w[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=head[i];j!=-<span class="number">1</span>;j=edges[j].last)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> edges[j].to;</span><br><span class="line">            dfs(child);</span><br><span class="line">            <span class="keyword">if</span>(dp[child][<span class="number">1</span>]&gt;<span class="number">0</span>) dp[i][<span class="number">1</span>] += dp[child][<span class="number">1</span>];</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i][<span class="number">0</span>], Math.max(dp[child][<span class="number">0</span>], dp[child][<span class="number">1</span>])); </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solve</span><span class="params">()</span>&#123;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[<span class="number">1</span>][<span class="number">0</span>], dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DP322</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> n, x, y, res;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        <span class="type">solution</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">solution</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            x = sc.nextInt();</span><br><span class="line">            s.setW(i, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            x = sc.nextInt(); y = sc.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(x&gt;y)&#123;</span><br><span class="line">                s.addEdge(y, x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s.addEdge(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = s.solve();</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试输入与输出-2"><a href="#测试输入与输出-2" class="headerlink" title="测试输入与输出"></a>测试输入与输出</h4><p>输入：</p><p>5</p><p>-1 1 3 1 -1</p><p>4 1</p><p>1 3</p><p>1 2</p><p>4 5</p><p>输出：</p><p>4</p><h3 id="P2015-二叉苹果树"><a href="#P2015-二叉苹果树" class="headerlink" title="P2015 二叉苹果树"></a>P2015 二叉苹果树</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>有一棵苹果树，如果树枝有分叉，一定是分二叉（就是说没有只有一个儿子的结点）</p><p>这棵树共有 $N$ 个结点（叶子点或者树枝分叉点），编号为 $1 \sim N$，树根编号一定是 $1$。</p><p>我们用一根树枝两端连接的结点的编号来描述一根树枝的位置。下面是一颗有 $4$ 个树枝的树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2   5</span><br><span class="line"> \ / </span><br><span class="line">  3   4</span><br><span class="line">   \ /</span><br><span class="line">    1</span><br></pre></td></tr></table></figure><p>现在这颗树枝条太多了，需要剪枝。但是一些树枝上长有苹果。</p><p>给定需要保留的树枝数量，求出最多能留住多少苹果。</p><h4 id="输入与输出格式"><a href="#输入与输出格式" class="headerlink" title="输入与输出格式"></a>输入与输出格式</h4><p>输入</p><p>第一行 $2$ 个整数 $N$ 和 $Q$，分别表示表示树的结点数，和要保留的树枝数量。</p><p>接下来 $N-1$ 行，每行 $3$ 个整数，描述一根树枝的信息：前 $2$ 个数是它连接的结点的编号，第 $3$ 个数是这根树枝上苹果的数量。</p><p>输出</p><p>一个数，最多能留住的苹果的数量。</p><h4 id="样例输入与输出"><a href="#样例输入与输出" class="headerlink" title="样例输入与输出"></a>样例输入与输出</h4><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5 2</span><br><span class="line">1 3 1</span><br><span class="line">1 4 10</span><br><span class="line">3 2 20</span><br><span class="line">3 5 20</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>$1 \leqslant Q &lt; N \leqslant 100$，每根树枝上的苹果 $\leqslant 3 \times 10^4$。</p><h4 id="算法设计-3"><a href="#算法设计-3" class="headerlink" title="算法设计"></a>算法设计</h4><p>将树枝的苹果数记入树形结构节点。</p><p>用dp[i][j]表示到编号i为根节点的子树保留j个树枝的最大苹果数，采用dfs的方式进行记忆化搜索。如果i为叶子节点，则其保留树枝为1时最大苹果数就是自身苹果数，对于非叶子节点，递推方程为：</p><script type="math/tex; mode=display">dp[i][j] = max_{0\leq k < j }\{dp[left\_child][k]+dp[right\_child][j-k]\}</script><p>j取不到，因为节点本身占了一个树枝，如果是根节点则不占用。</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> n, q;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] apples;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] tree;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] dp;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Reader</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reader</span>();</span><br><span class="line">        n = r.nextInt(); q = r.nextInt();</span><br><span class="line">        apples = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][q+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) tree[i][<span class="number">0</span>] = tree[i][<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> parent, child, num_apples;</span><br><span class="line">            parent = r.nextInt(); child = r.nextInt(); num_apples = r.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(tree[parent][<span class="number">0</span>]==-<span class="number">1</span>) tree[parent][<span class="number">0</span>] = child;</span><br><span class="line">            <span class="keyword">else</span> tree[parent][<span class="number">1</span>] = child;</span><br><span class="line">            apples[child] = num_apples;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> _dp(<span class="number">1</span>, q);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">_dp</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j]!=<span class="number">0</span>) <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        <span class="keyword">if</span>(tree[i][<span class="number">0</span>]==-<span class="number">1</span>||tree[i][<span class="number">1</span>]==-<span class="number">1</span>)&#123;</span><br><span class="line">            dp[i][j] = (j&gt;=<span class="number">1</span>)?apples[i]:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> dp[i][j]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (i==<span class="number">1</span>)?j:j-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=num;k++)&#123;</span><br><span class="line">            dp[i][j] = Math.max(dp[i][j], _dp(tree[i][<span class="number">0</span>], k)+_dp(tree[i][<span class="number">1</span>], num-k)+apples[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span>&#123;</span><br><span class="line">    <span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)));</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)st.nval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P2014-选课"><a href="#P2014-选课" class="headerlink" title="P2014 选课"></a>P2014 选课</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有 $N$ 门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程 a 是课程 b 的先修课即只有学完了课程 a，才能学习课程 b）。一个学生要从这些课程里选择 $M$ 门课程学习，问他能获得的最大学分是多少？</p><h4 id="输入与输出格式-1"><a href="#输入与输出格式-1" class="headerlink" title="输入与输出格式"></a>输入与输出格式</h4><p>输入</p><p>第一行有两个整数 $N$ , $M$ 用空格隔开。( $1 \leq N \leq 300$ , $1 \leq M \leq 300$ )</p><p>接下来的 $N$ 行,第 $I+1$ 行包含两个整数 $k_i $和 $s_i$, $k_i$ 表示第I门课的直接先修课，$s_i$ 表示第I门课的学分。若 $k_i=0$ 表示没有直接先修课（$1 \leq {k_i} \leq N$ , $1 \leq {s_i} \leq 20$）。</p><p>输出</p><p>只有一行，选 $M$ 门课程的最大得分。</p><h4 id="样例输入与输出-1"><a href="#样例输入与输出-1" class="headerlink" title="样例输入与输出"></a>样例输入与输出</h4><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7  4</span><br><span class="line">2  2</span><br><span class="line">0  1</span><br><span class="line">0  4</span><br><span class="line">2  1</span><br><span class="line">7  1</span><br><span class="line">7  6</span><br><span class="line">2  2</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure><h4 id="算法设计-4"><a href="#算法设计-4" class="headerlink" title="算法设计"></a>算法设计</h4><p>该问题类似于背包问题。</p><p>设dp[i][j]表示第i个节点为根的子树可以选j种课的最大学分，对于每个子节点的子树，都可以选择放入或不放入，递推方程为：</p><script type="math/tex; mode=display">dp[i][j] = max_{0\leq k< j}\{dp[i][j-k]+dp[v][k]+s[i]\}</script><p>i为当前节点，v为子节点，当前节点只要j&gt;1必选，才能考虑选子节点。</p><p>使用链式前向星存储树，因为有多棵树，以0为虚拟根节点，形成一颗大树。</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> to,last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, m, cnt;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] score;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] head;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> edge[] edges;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] dp;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Reader</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reader</span>();</span><br><span class="line">        n = r.nextInt(); m = r.nextInt();</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        score = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">edge</span>[<span class="number">305</span>];</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">2</span>];</span><br><span class="line">        Arrays.fill(head, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> pre, s;</span><br><span class="line">            pre = r.nextInt(); s = r.nextInt();</span><br><span class="line">            add(pre, i);</span><br><span class="line">            score[i] = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i][<span class="number">1</span>] = score[i];</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        System.out.println(dp[<span class="number">0</span>][m+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        edges[cnt] = <span class="keyword">new</span> <span class="title class_">edge</span>();</span><br><span class="line">        edges[cnt].to = y;</span><br><span class="line">        edges[cnt].last = head[x];</span><br><span class="line">        head[x] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=head[i];x!=-<span class="number">1</span>;x=edges[x].last)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> edges[x].to;</span><br><span class="line">            dfs(child);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=m+<span class="number">1</span>;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;j;k++)&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i][j-k]+dp[child][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span>&#123;</span><br><span class="line">    <span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)));</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)st.nval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P2585-三色二叉树"><a href="#P2585-三色二叉树" class="headerlink" title="P2585 三色二叉树"></a>P2585 三色二叉树</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>一棵二叉树可以按照如下规则表示成一个由 $0$、$1$、$2$ 组成的字符序列，我们称之为“二叉树序列 $S$”：</p><script type="math/tex; mode=display">S=\begin{cases}0& \text表示该树没有子节点\\1S_1& 表示该树有一个节点，S_1 为其子树的二叉树序列\\2S_1S_2& 表示该树由两个子节点，S_1 和 S_2 分别表示其两个子树的二叉树序列\end{cases}</script><p>例如，下图所表示的二叉树可以用二叉树序列 $S=\texttt{21200110}$ 来表示。</p><p><img src="https://i.loli.net/2020/04/27/Ijw8ZEWCKH2rtJG.png" alt="haha.png"></p><p>你的任务是要对一棵二叉树的节点进行染色。每个节点可以被染成红色、绿色或蓝色。并且，一个节点与其子节点的颜色必须不同，如果该节点有两个子节点，那么这两个子节点的颜色也必须不同。给定一颗二叉树的二叉树序列，请求出这棵树中<strong>最多和最少</strong>有多少个点能够被染成绿色。</p><h4 id="输入与输出格式-2"><a href="#输入与输出格式-2" class="headerlink" title="输入与输出格式"></a>输入与输出格式</h4><p>输入</p><p>输入只有一行一个字符串 $s$，表示二叉树序列。</p><p>输出</p><p>输出只有一行，包含两个数，依次表示最多和最少有多少个点能够被染成绿色。</p><h4 id="样例输入与输出-2"><a href="#样例输入与输出-2" class="headerlink" title="样例输入与输出"></a>样例输入与输出</h4><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1122002010</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 2</span><br></pre></td></tr></table></figure><h4 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h4><p>对于全部的测试点，保证 $1 \leq |s| \leq 5 \times 10^5$，$s$ 中只含字符 <code>0</code> <code>1</code> <code>2</code>。</p><h4 id="算法设计-5"><a href="#算法设计-5" class="headerlink" title="算法设计"></a>算法设计</h4><p>可以使用dp[i][j]表示点i为根节点的子树最多有多少个点可以被染成绿色，j为1表示节点i为绿色。</p><p>如果i为绿色，则其子节点都不可以为绿色；如果i不为绿色，则要选择两个子节点其中一个染为绿色，故递推方程为：</p><script type="math/tex; mode=display">dp[i][j] = \begin{cases}dp[lchild][0]+dp[rchild]+1 & j=1 \\max\{dp[lchild][1]+dp[rchild][0], dp[lchild][0]+dp[rchild][1]\} & j =0\end{cases}</script><p>将二叉树序列处理为数组存储的二叉树，然后以记忆化搜索的方式完成计算，最终的结果为dp[1]。</p><p>最少数量类似。</p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">maxn</span> <span class="operator">=</span> <span class="number">500005</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String orignal_tree;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, cnt, cur;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] tree;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] dp;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] dpMin;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        orignal_tree= bf.readLine();</span><br><span class="line">        cnt = <span class="number">0</span>; cur = <span class="number">1</span>; n = <span class="number">1</span>;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="title class_">int</span>[maxn][<span class="number">2</span>];</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="title class_">int</span>[maxn][<span class="number">2</span>];</span><br><span class="line">        dpMin = <span class="keyword">new</span> <span class="title class_">int</span>[maxn][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;maxn;i++) tree[i][<span class="number">0</span>] = tree[i][<span class="number">1</span>] = dp[i][<span class="number">0</span>] = dp[i][<span class="number">1</span>] = dpMin[i][<span class="number">0</span>] = dpMin[i][<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        load_tree(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//搜索</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">resultMax</span> <span class="operator">=</span> Math.max(dfs(<span class="number">1</span>, <span class="number">0</span>), dfs(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">resultMin</span> <span class="operator">=</span> Math.min(dfsMin(<span class="number">1</span>, <span class="number">0</span>), dfsMin(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">        System.out.println(resultMax+<span class="string">&quot; &quot;</span>+resultMin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//序列化二叉树转储到数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">load_tree</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">childs</span> <span class="operator">=</span> orignal_tree.charAt(cnt++);</span><br><span class="line">        <span class="keyword">if</span>(childs&gt;=<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            tree[i][<span class="number">0</span>] = ++cur;</span><br><span class="line">            load_tree(cur);</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(childs==<span class="string">&#x27;2&#x27;</span>)&#123;</span><br><span class="line">            tree[i][<span class="number">1</span>] = ++cur;</span><br><span class="line">            load_tree(cur);</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记忆化搜索</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==-<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j]!=-<span class="number">1</span>) <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;   <span class="comment">//节点i不是绿色</span></span><br><span class="line">            dp[i][j] = Math.max(dfs(tree[i][<span class="number">0</span>],<span class="number">1</span>)+dfs(tree[i][<span class="number">1</span>], <span class="number">0</span>), dfs(tree[i][<span class="number">0</span>],<span class="number">0</span>)+dfs(tree[i][<span class="number">1</span>], <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;       <span class="comment">//节点i是绿色</span></span><br><span class="line">            dp[i][j] = <span class="number">1</span> + dfs(tree[i][<span class="number">0</span>], <span class="number">0</span>) + dfs(tree[i][<span class="number">1</span>], <span class="number">0</span>);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dfsMin</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==-<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dpMin[i][j]!=-<span class="number">1</span>) <span class="keyword">return</span> dpMin[i][j];</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;   <span class="comment">//节点i不是绿色</span></span><br><span class="line">            dpMin[i][j] = Math.min(dfsMin(tree[i][<span class="number">0</span>],<span class="number">1</span>)+dfsMin(tree[i][<span class="number">1</span>], <span class="number">0</span>), dfsMin(tree[i][<span class="number">0</span>],<span class="number">0</span>)+dfsMin(tree[i][<span class="number">1</span>], <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;       <span class="comment">//节点i是绿色</span></span><br><span class="line">            dpMin[i][j] = <span class="number">1</span> + dfsMin(tree[i][<span class="number">0</span>], <span class="number">0</span>) + dfsMin(tree[i][<span class="number">1</span>], <span class="number">0</span>);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dpMin[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span>&#123;</span><br><span class="line">    <span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)));</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        st.nextToken();</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)st.nval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P2656-采蘑菇"><a href="#P2656-采蘑菇" class="headerlink" title="P2656 采蘑菇"></a>P2656 采蘑菇</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>小胖和 ZYR 要去 ESQMS 森林采蘑菇。</p><p>ESQMS 森林间有 $N$ 个小树丛，$M$ 条小径，每条小径都是单向的，连接两个小树丛，上面都有一定数量的蘑菇。小胖和 ZYR 经过某条小径一次，可以采走这条路上所有的蘑菇。由于 ESQMS 森林是一片神奇的沃土，所以一条路上的蘑菇被采过后，又会长出一些新的蘑菇，数量为原来蘑菇的数量乘上这条路的“恢复系数”，再下取整。</p><p>比如，一条路上有 $4$ 个蘑菇，这条路的“恢复系数”为 $0.7$，则第一~四次经过这条路径所能采到的蘑菇数量分别为 $4,2,1,0$。</p><p>现在，小胖和 ZYR 从 $S$ 号小树丛出发，求他们最多能采到多少蘑菇。</p><h4 id="输入与输出格式-3"><a href="#输入与输出格式-3" class="headerlink" title="输入与输出格式"></a>输入与输出格式</h4><p>输入</p><p>第一行两个整数，$N$ 和 $M$。</p><p>第二行到第 $M+1$ 行，每行四个数，分别表示一条小路的起点，终点，初始蘑菇数，恢复系数。</p><p>第 $M+2$ 行，一个整数 $S$。</p><p>输出</p><p>一行一个整数，表示最多能采到多少蘑菇，保证答案不超过 $(2^{31}-1)$。</p><h4 id="样例输入与输出-3"><a href="#样例输入与输出-3" class="headerlink" title="样例输入与输出"></a>样例输入与输出</h4><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 4 0.5</span><br><span class="line">1 3 7 0.1</span><br><span class="line">2 3 4 0.6</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h4 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h4><p>对于 $30\%$ 的数据，$N\le 7$，$M\le15$</p><p>另有 $30\%$ 的数据，满足所有“恢复系数”为 $0$。</p><p>对于 $100\%$ 的数据，$1<br>\le N\le 8\times 10^4$，$1\le M\le 2\times 10^5$，$0\le\text{恢复系数}\le 0.8$ 且最多有一位小数， $1\le S\le N$。</p><h4 id="算法设计-6"><a href="#算法设计-6" class="headerlink" title="算法设计"></a>算法设计</h4><p>设dp[i]表示以当前节点为根的子树能采集的最大蘑菇数。假设节点u有子节点v，递推方程为：</p><script type="math/tex; mode=display">dp[u] = max\{dp[v]\}+nums[u]</script><p>即在每个根节点选择一个能得到蘑菇数最大的子节点为根的子树走下去。</p><p>处理环路的方式是每经过一次就修正蘑菇数，一个蘑菇数为0的节点走过两次，说明产生了环路，此时开始记录环路上的蘑菇数</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法设计与分析-动态规划-区间DP&amp;其他</title>
      <link href="/2022/12/25/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2022/12/25/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p style="text-indent:2em">算法设计与分析-动态规划区间DP题目记录。</p><span id="more"></span><h2 id="区间DP-amp-其他"><a href="#区间DP-amp-其他" class="headerlink" title="区间DP&amp;其他"></a>区间DP&amp;其他</h2><h3 id="301-独立任务最优调度问题"><a href="#301-独立任务最优调度问题" class="headerlink" title="301 独立任务最优调度问题"></a>301 独立任务最优调度问题</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>用两台处理机A和B处理n个作业，每个机器处理第i个作业所需的时间分别为<script type="math/tex">a_i</script>和<script type="math/tex">b_i</script>，某些作业在机器A上作业更快，有些作业在机器B上工作更快，每台机器都不能同时处理两个作业。对于给定的2台处理机A和B处理n个作业，找出一个最优调度方案，使两台机器处理完n个作业的时间最短。</p><h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><p>第一行是一个正整数n，表示处理n个作业。接下来的2行中，每行n个正整数，表示A和B处理第i个作业的时间。</p><h4 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h4><p>子问题分解：定义t[i][j]为：表示完成i个作业且机器A花费j时间的情况下，机器B所花费时间的最小值。第i件作业如果由机器A处理，则t[i][j]  =  t[i - 1][j - a[i]]，如果由机器B处理，则t[i][j] = t[i - 1][j] + b[i]，因此t[i][j] = min{t[i - 1][j] + b[i], t[i - 1][j - a[i]]}。</p><p>递推方程：</p><script type="math/tex; mode=display">t[i][j] = \begin{cases}0 & i=0 \\t[i-1][j]+b[i] & j<a[i],i>0 \\min\{t[i - 1][j] + b[i], t[i - 1][j - a[i]]\} & j>=a[i],i>0\end{cases}</script><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXT = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solution</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *a, <span class="type">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t[n+<span class="number">1</span>][MAXT], <span class="type">max_t</span>, <span class="type">min_t</span>;</span><br><span class="line">    <span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="built_in">sizeof</span>(t));</span><br><span class="line">    <span class="type">max_t</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//a的最大工作时长</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">max_t</span> += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自底向上求解</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="type">max_t</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;a[i])&#123;</span><br><span class="line">                t[i][j] = t[i<span class="number">-1</span>][j] + b[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                t[i][j] = <span class="built_in">min</span>(t[i<span class="number">-1</span>][j-a[i]], t[i<span class="number">-1</span>][j] + b[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求最优解</span></span><br><span class="line">    <span class="type">min_t</span> = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="type">max_t</span>;i++)&#123;</span><br><span class="line">        <span class="type">min_t</span> = <span class="built_in">min</span>(<span class="built_in">max</span>(t[n][i], i), <span class="type">min_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">min_t</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, *a, *b, result;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    a = <span class="keyword">new</span> <span class="type">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    b = <span class="keyword">new</span> <span class="type">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">solution</span>(n, a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;result = &quot;</span> &lt;&lt; result;</span><br><span class="line">    <span class="keyword">delete</span>[] a;</span><br><span class="line">    <span class="keyword">delete</span>[] b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner; </span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DP301</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> n, result;</span><br><span class="line">        <span class="type">int</span>[] a,b;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        n = s.nextInt();</span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        b = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i=i+<span class="number">1</span>)&#123;</span><br><span class="line">            a[i] = (<span class="type">int</span>) s.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i=i+<span class="number">1</span>)&#123;</span><br><span class="line">            b[i] = (<span class="type">int</span>) s.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        result = solution(n, a, b);</span><br><span class="line">        System.out.println(<span class="string">&quot;result=&quot;</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] a, <span class="type">int</span>[] b)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[][] t = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][<span class="number">10000</span>];</span><br><span class="line">        <span class="type">int</span> max_t, min_t;</span><br><span class="line">        max_t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//a的最大工作时长</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            max_t += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//自底向上求解</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=max_t;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;a[i])&#123;</span><br><span class="line">                    t[i][j] = t[i-<span class="number">1</span>][j] + b[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    t[i][j] = Math.min(t[i-<span class="number">1</span>][j-a[i]], t[i-<span class="number">1</span>][j] + b[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//求最优解</span></span><br><span class="line">        min_t = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=max_t;i++)&#123;</span><br><span class="line">            min_t = Math.min(Math.max(t[n][i], i), min_t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min_t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试输入与输出"><a href="#测试输入与输出" class="headerlink" title="测试输入与输出"></a>测试输入与输出</h4><p>输入：</p><p>6</p><p>2 5 7 10 5 2</p><p>3 8 4 11 3 4</p><p>输出：</p><p>15</p><h3 id="303-石子合并问题"><a href="#303-石子合并问题" class="headerlink" title="303 石子合并问题"></a>303 石子合并问题</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>在一个圆形操场的四周摆放着n堆石子。现要将石子有次序的合并成一堆。规定每次只能选相邻的石子合并成一堆，并将新的一堆石子数即为该次合并的得分。试设计一个算法，计算出将n堆石子合并成一堆的最小得分和最大得分。输入为n和每堆石子的数量。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行是正整数n，表示n堆石子。第2行有n个数，表示每堆石子的个数。</p><h4 id="算法设计-1"><a href="#算法设计-1" class="headerlink" title="算法设计"></a>算法设计</h4><p>先考虑石子直线摆放的情况。假设将石子合并<script type="math/tex">S_iS_{i+1}...S_{j}</script>记为S[i:j]。考虑计算S[1:n]的合并方法，假设S[1:n]的最优合并方法在k堆石子处断开，则合并方式为<script type="math/tex">(S_1...S_k)(S_{k+1}...S_n)</script>，合并得分为S[1:k]的得分加上S[k+1:n]的合并得分，再加上这两堆石子的得分。这个问题的最优子结构在于，如果S[1:n]合并方法是最优的，那么S[1:k]和S[k+1:n]的合并也是最优的。</p><p>用a[i]表示前i堆石子的数量，m[i][j]表示合并第i到j堆的最小合并得分。递推方程可写为：</p><script type="math/tex; mode=display">m[i][j] = \begin{cases}0 & i=j \\min_{i\le k<j}\{m[i][k]+m[k+1][j]+a[j]-a[i-1]\} & i\neq j\end{cases}</script><p>对于环形摆放，只要将石子按顺序放到原来石子堆顺序的尾部就可以实现首尾相连了，例如石子堆4 4 5 9，扩展为石子堆4 4 5 9 4 4 5 9，就能将首尾相连的环形情况包括进去，最后的结果是m[1][4]，m[2][5]，m[3][6]，m[4][7]中的最值。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>c++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solution</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *stones)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>*n+<span class="number">1</span>], stones_line[<span class="number">2</span>*n+<span class="number">1</span>], m_min[<span class="number">2</span>*n+<span class="number">1</span>][<span class="number">2</span>*n+<span class="number">1</span>], m_max[<span class="number">2</span>*n+<span class="number">1</span>][<span class="number">2</span>*n+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(m_min, <span class="number">0</span>, <span class="built_in">sizeof</span>(m_min));</span><br><span class="line">    <span class="built_in">memset</span>(m_max, <span class="number">0</span>, <span class="built_in">sizeof</span>(m_max));</span><br><span class="line">    <span class="comment">//展开成直线型</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n+<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">        stones_line[i-n] = stones_line[i] = stones[i-n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">        a[i] = a[i<span class="number">-1</span>] + stones_line[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算最小和最大合并</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">2</span>;r&lt;=n;r++)&#123;          <span class="comment">//从两堆石子的合并开始计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n-r+<span class="number">1</span>;i++)&#123;  <span class="comment">//起始位置</span></span><br><span class="line">            <span class="type">int</span> j = i + r - <span class="number">1</span>;</span><br><span class="line">            m_min[i][j] = INT_MAX;</span><br><span class="line">            m_max[i][j] = INT_MIN;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;k++)&#123;</span><br><span class="line">                m_min[i][j] = <span class="built_in">min</span>(m_min[i][j], m_min[i][k]+m_min[k+<span class="number">1</span>][j]+a[j]-a[i<span class="number">-1</span>]);</span><br><span class="line">                m_max[i][j] = <span class="built_in">max</span>(m_max[i][j], m_max[i][k]+m_max[k+<span class="number">1</span>][j]+a[j]-a[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到最值</span></span><br><span class="line">    <span class="type">int</span> min_score, max_score;</span><br><span class="line">    min_score = INT_MAX;</span><br><span class="line">    max_score = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        min_score = <span class="built_in">min</span>(min_score, m_min[i][i+n<span class="number">-1</span>]);</span><br><span class="line">        max_score = <span class="built_in">max</span>(max_score, m_max[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;min_score = &quot;</span> &lt;&lt; min_score &lt;&lt; endl &lt;&lt; <span class="string">&quot;max_score = &quot;</span> &lt;&lt; max_score &lt;&lt; endl ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> stones[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; stones[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solution</span>(n, stones);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DP303</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="type">int</span>[] stones;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        stones = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            stones[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        solution(n, stones);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] stones)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] a, stones_line;</span><br><span class="line">        <span class="type">int</span>[][] m_min, m_max;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>*n+<span class="number">1</span>];</span><br><span class="line">        stones_line = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>*n+<span class="number">1</span>];</span><br><span class="line">        m_min = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>*n+<span class="number">1</span>][<span class="number">2</span>*n+<span class="number">1</span>];</span><br><span class="line">        m_max = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>*n+<span class="number">1</span>][<span class="number">2</span>*n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//展开为线性</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n+<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">            stones_line[i] = stones_line[i-n] = stones[i-n]; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//前缀和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">            a[i] = a[i-<span class="number">1</span>] + stones_line[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算最小和最大合并</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">2</span>;r&lt;=n;r++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n-r+<span class="number">1</span>;i++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + r - <span class="number">1</span>;</span><br><span class="line">                m_min[i][j] =  Integer.MAX_VALUE;</span><br><span class="line">                m_max[i][j] = Integer.MIN_VALUE;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;k++)&#123;</span><br><span class="line">                    m_min[i][j] = Math.min(m_min[i][j], m_min[i][k]+m_min[k+<span class="number">1</span>][j]+a[j]-a[i-<span class="number">1</span>]);</span><br><span class="line">                    m_max[i][j] = Math.max(m_max[i][j], m_max[i][k]+m_max[k+<span class="number">1</span>][j]+a[j]-a[i-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//求最大值和最小值</span></span><br><span class="line">        <span class="type">int</span> min_score, max_score;</span><br><span class="line">        min_score = Integer.MAX_VALUE;</span><br><span class="line">        max_score = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            min_score = Math.min(min_score, m_min[i][i+n-<span class="number">1</span>]);</span><br><span class="line">            max_score = Math.max(max_score, m_max[i][i+n-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;min_score = %d\n&quot;</span>, min_score);</span><br><span class="line">        System.out.printf(<span class="string">&quot;max_score = %d&quot;</span>, max_score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试输入与输出-1"><a href="#测试输入与输出-1" class="headerlink" title="测试输入与输出"></a>测试输入与输出</h4><p>输入：</p><p>4</p><p>4 4 5 9</p><p>输出：</p><p>43</p><p>54</p><h3 id="304-数字三角形问题"><a href="#304-数字三角形问题" class="headerlink" title="304 数字三角形问题"></a>304 数字三角形问题</h3><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一个由n行数字组成的数字三角形，试设计一个算法，计算出从三角形的顶至底的一条路径，使该路径经过的数字总和最大。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行为n，后n行为三角形的元素。</p><h4 id="算法设计-2"><a href="#算法设计-2" class="headerlink" title="算法设计"></a>算法设计</h4><p>设dp[i][j]表示从顶层开始第i层的第j个元素为最后一个元素的路径的数字和最大值，t[i][j]表示第i层i个数字，可得递推方程如下：</p><script type="math/tex; mode=display">dp[i][j] = \begin{cases}t[1][1] & i=1     \\t[1][1]+t[i][j] & i=2 \\dp[i-1][j]+t[i][j] & i>2,j=1 \\max(dp[i-1][j-1],\ dp[i-1][j])+t[i][j] & i>2,i>j>1 \\dp[i-1][j-1]+t[i][j] &i>2,j=i\end{cases}</script><p>最大的路径上数字和为<script type="math/tex">max_{1 \leq j \leq n }(dp[n][j])</script></p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>c++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solution</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> **t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> dp[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">2</span>][<span class="number">1</span>] = t[<span class="number">1</span>][<span class="number">1</span>] + t[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">2</span>][<span class="number">2</span>] = t[<span class="number">1</span>][<span class="number">1</span>] + t[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>] + t[i][<span class="number">1</span>];</span><br><span class="line">        dp[i][i] = dp[i<span class="number">-1</span>][i<span class="number">-1</span>] + t[i][i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;i;j++)&#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j]) + t[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        res = <span class="built_in">max</span>(dp[n][i], res);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> **t;</span><br><span class="line">    t = <span class="keyword">new</span> <span class="type">int</span>*[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        t[i] = <span class="keyword">new</span> <span class="type">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            cin&gt;&gt;t[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solution</span>(n, t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] t;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DP304</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[][] t = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                t[i][j] = sc.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        solution(n, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] t)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>][<span class="number">1</span>] = t[<span class="number">1</span>][<span class="number">1</span>] + t[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>][<span class="number">2</span>] = t[<span class="number">1</span>][<span class="number">1</span>] + t[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i-<span class="number">1</span>][<span class="number">1</span>] + t[i][<span class="number">1</span>];</span><br><span class="line">            dp[i][i] = dp[i-<span class="number">1</span>][i-<span class="number">1</span>] + t[i][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;i;j++)&#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j]) + t[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            res = Math.max(dp[n][i], res);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] t)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>][<span class="number">1</span>] = t[<span class="number">1</span>][<span class="number">1</span>] + t[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>][<span class="number">2</span>] = t[<span class="number">1</span>][<span class="number">1</span>] + t[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i-<span class="number">1</span>][<span class="number">1</span>] + t[i][<span class="number">1</span>];</span><br><span class="line">            dp[i][i] = dp[i-<span class="number">1</span>][i-<span class="number">1</span>] + t[i][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;i;j++)&#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j]) + t[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            res = Math.max(dp[n][i], res);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="测试输入与输出-2"><a href="#测试输入与输出-2" class="headerlink" title="测试输入与输出"></a>测试输入与输出</h4><p>输入：</p><p>5</p><p>7</p><p>3 8</p><p>8 1 0</p><p>2 7 4 4</p><p>4 5 2 6 5</p><p>输出：</p><p>30</p><h3 id="305乘法表问题"><a href="#305乘法表问题" class="headerlink" title="305乘法表问题"></a>305乘法表问题</h3><h4 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h4><p>定义字母表{a，b，c}上的乘法表如下：</p><div class="table-container"><table><thead><tr><th></th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td>a</td><td>b</td><td>b</td><td>a</td></tr><tr><td>b</td><td>c</td><td>b</td><td>a</td></tr><tr><td>c</td><td>a</td><td>c</td><td>c</td></tr></tbody></table></div><p>依次乘法表，对于任一定义于该字母表上的字符串，适当加括号后，得到一个表达式。例如x=bbbba。一个加括号方式为(b(bb))(ba)，结果为a。设计一个动态规划算法，计算有多少种不同的方式，使由字符串x导出的加括号表达式结果为a。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入为给定字符串。</p><h4 id="算法设计-3"><a href="#算法设计-3" class="headerlink" title="算法设计"></a>算法设计</h4><p>可以将每种加括号方式下得到一个字符的方式都记录下来，最后计算出结果为a的方式。假设用dp[i][j][c]表示从i乘到j，得到字符c的方法数，计算dp[i][j][c]时，需要考虑每一种断开，假设从k处断开，则方法数为∑ dp[i][k][c1]*dp[k+1][j][c2]，c1*c2 = c。最终得到dp[1][n][a]即为所求结果。</p><p>递推方程如下：</p><script type="math/tex; mode=display">dp[i][j][c] = \begin{cases}1 & i=j,c=str[i-1] \\\sum_{k=i}^{j} dp[i][k][c1]*dp[k+1][j][c2] & j>i,c1*c2=c\end{cases}</script><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>c++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solution</span><span class="params">(<span class="type">char</span> c[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(c);</span><br><span class="line">    <span class="type">int</span> dp[n+<span class="number">1</span>][n+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i<span class="number">-1</span>]==<span class="string">&#x27;a&#x27;</span>) dp[i][i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c[i<span class="number">-1</span>]==<span class="string">&#x27;b&#x27;</span>) dp[i][i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c[i<span class="number">-1</span>]==<span class="string">&#x27;c&#x27;</span>) dp[i][i][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">2</span>;r&lt;=n;r++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-r+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> j = i + r - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;k++)&#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>] += dp[i][k][<span class="number">0</span>]*dp[k+<span class="number">1</span>][j][<span class="number">2</span>] + dp[i][k][<span class="number">1</span>]*dp[k+<span class="number">1</span>][j][<span class="number">2</span>] + dp[i][k][<span class="number">2</span>]*dp[k+<span class="number">1</span>][j][<span class="number">0</span>];</span><br><span class="line">                dp[i][j][<span class="number">1</span>] += dp[i][k][<span class="number">0</span>]*dp[k+<span class="number">1</span>][j][<span class="number">0</span>] + dp[i][k][<span class="number">0</span>]*dp[k+<span class="number">1</span>][j][<span class="number">1</span>] + dp[i][k][<span class="number">1</span>]*dp[k+<span class="number">1</span>][j][<span class="number">1</span>];</span><br><span class="line">                dp[i][j][<span class="number">2</span>] += dp[i][k][<span class="number">1</span>]*dp[k+<span class="number">1</span>][j][<span class="number">0</span>] + dp[i][k][<span class="number">2</span>]*dp[k+<span class="number">1</span>][j][<span class="number">1</span>] + dp[i][k][<span class="number">2</span>]*dp[k+<span class="number">1</span>][j][<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[<span class="number">1</span>][n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">1024</span>];</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    <span class="built_in">solution</span>(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DP305</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        solution(args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solution</span><span class="params">(String c)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> c.length();</span><br><span class="line">        <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c.charAt(i-<span class="number">1</span>)==<span class="string">&#x27;a&#x27;</span>) dp[i][i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c.charAt(i-<span class="number">1</span>)==<span class="string">&#x27;b&#x27;</span>) dp[i][i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c.charAt(i-<span class="number">1</span>)==<span class="string">&#x27;c&#x27;</span>) dp[i][i][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">2</span>;r&lt;=n;r++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-r+<span class="number">1</span>;i++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + r - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;k++)&#123;</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] += dp[i][k][<span class="number">0</span>]*dp[k+<span class="number">1</span>][j][<span class="number">2</span>] + dp[i][k][<span class="number">1</span>]*dp[k+<span class="number">1</span>][j][<span class="number">2</span>] + dp[i][k][<span class="number">2</span>]*dp[k+<span class="number">1</span>][j][<span class="number">0</span>];</span><br><span class="line">                    dp[i][j][<span class="number">1</span>] += dp[i][k][<span class="number">0</span>]*dp[k+<span class="number">1</span>][j][<span class="number">0</span>] + dp[i][k][<span class="number">0</span>]*dp[k+<span class="number">1</span>][j][<span class="number">1</span>] + dp[i][k][<span class="number">1</span>]*dp[k+<span class="number">1</span>][j][<span class="number">1</span>];</span><br><span class="line">                    dp[i][j][<span class="number">2</span>] += dp[i][k][<span class="number">1</span>]*dp[k+<span class="number">1</span>][j][<span class="number">0</span>] + dp[i][k][<span class="number">2</span>]*dp[k+<span class="number">1</span>][j][<span class="number">1</span>] + dp[i][k][<span class="number">2</span>]*dp[k+<span class="number">1</span>][j][<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[<span class="number">1</span>][n][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试输入与输出-3"><a href="#测试输入与输出-3" class="headerlink" title="测试输入与输出"></a>测试输入与输出</h4><p>输入：</p><p>bbbba</p><p>输出：</p><p>6</p><h3 id="306-租用游艇问题"><a href="#306-租用游艇问题" class="headerlink" title="306 租用游艇问题"></a>306 租用游艇问题</h3><h4 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h4><p>在长江上有n个游艇出租站1，2，…，n。游客可在任何出租站租用游艇，并在下游的任何一个出租站归还游艇。出租站i到出租站j之间的租金为r(i，j)。使设计一个算法，计算从出租站1到出租站n所需的最少租金。</p><h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行的正整数n表示有n个出租站，此后的n-1行为r(i，j)，i和j取1-n，i&lt;j。</p><h4 id="算法设计-4"><a href="#算法设计-4" class="headerlink" title="算法设计"></a>算法设计</h4><p>假设dp[i][j]表示从出租站i到出租站j的租金，从i到j可以在中间的第k个站归还并重新租借游艇，则dp[i][j]= dp[i][k]+dp[k][j]，递推方程为：</p><script type="math/tex; mode=display">dp[i][j] = \begin{cases}0 & i=j \\min\{min_{i \leq k <j}\{dp[i][k]+dp[k][j]\},r[i][j]\} &  i \neq j\end{cases}</script><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p>c++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solution</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> **r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> dp[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> rr=<span class="number">2</span>;rr&lt;=n;rr++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-rr+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> j = i + rr - <span class="number">1</span>;</span><br><span class="line">            dp[i][j] = r[i][j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;k++)&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k]+dp[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[<span class="number">1</span>][n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, **r;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    r = <span class="keyword">new</span> <span class="type">int</span> *[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        r[i] = <span class="keyword">new</span> <span class="type">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            cin &gt;&gt; r[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solution</span>(n, r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DP306</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[][] r = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                r[i][j] = sc.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        solution(n, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] r)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> rr=<span class="number">2</span>;rr&lt;=n;rr++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-rr+<span class="number">1</span>;i++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + rr - <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = r[i][j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;k++)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i][k]+dp[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[<span class="number">1</span>][n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试输入与输出-4"><a href="#测试输入与输出-4" class="headerlink" title="测试输入与输出"></a>测试输入与输出</h4><p>输入：</p><p>3</p><p>5 15</p><p>7</p><p>输出：</p><p>12</p><h3 id="308-最小m段和"><a href="#308-最小m段和" class="headerlink" title="308 最小m段和"></a>308 最小m段和</h3><p>有一个n个数形成的整数序列，将该序列划分为m段，每段求和，求子段和的最大值。设计一个动态规划算法，找出使子段和的最大值的最小值。</p><h4 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行有两个正整数n和m，n是序列长度，m是段数。第二行有n个整数，是序列的元素值。</p><h4 id="算法设计-5"><a href="#算法设计-5" class="headerlink" title="算法设计"></a>算法设计</h4><p>设dp[i][j]表示将前i项划分为j个子段后，子段和的最大值的最小值，所求最优值为dp[n][m]。考虑不同的划分方法，当j=1时，<script type="math/tex">dp[i][j]=\sum_{k=1}^{i}a[k]</script>，当j&gt;1时，假设在前k项中有j-1个子段，后i-k+1项为1个子段，则这种划分方式下的最大子段和为<script type="math/tex">max\{dp[k][j-1], \ dp[i,1]-dp[k][1]\}</script>，或者在前j-1段，或者在最后一段。要找到一个k，使这个最大值最小，因此递推方程如下：</p><script type="math/tex; mode=display">dp[i][j] = \begin{cases}\sum_{k=1}^{i}a[k] & j = 1 \\min_{j-1 \leq k \leq i}\{max\{dp[k][j-1], \ dp[i][1]-dp[k][1]\}\} & j>1\end{cases}</script><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><p>c++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solution</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> a[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> dp[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=<span class="number">3</span>;j++)&#123;</span><br><span class="line">            dp[i][j] = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=j<span class="number">-1</span>;k&lt;=i;k++)&#123;</span><br><span class="line">                <span class="type">int</span> t = <span class="built_in">max</span>(dp[k][j<span class="number">-1</span>], dp[i][<span class="number">1</span>] - dp[k][<span class="number">1</span>]);</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(t, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> a[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solution</span>(n, m , a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DP308</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> n,m;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        m = sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            a[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        solution(n, m , a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i-<span class="number">1</span>][<span class="number">1</span>] + a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=<span class="number">3</span>;j++)&#123;</span><br><span class="line">                dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=j-<span class="number">1</span>;k&lt;=i;k++)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> Math.max(dp[k][j-<span class="number">1</span>], dp[i][<span class="number">1</span>] - dp[k][<span class="number">1</span>]);</span><br><span class="line">                    dp[i][j] = Math.min(t, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[n][m]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试输入与输出-5"><a href="#测试输入与输出-5" class="headerlink" title="测试输入与输出"></a>测试输入与输出</h4><p>输入：</p><p>5 3 </p><p>5 4 3 2 1</p><p>输出：</p><p>6</p><h3 id="310-最大长方体问题"><a href="#310-最大长方体问题" class="headerlink" title="310 最大长方体问题"></a>310 最大长方体问题</h3><h4 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h4><p>一个长，宽，高分别为m，n，p的长方体被分隔为mxnxp个小立方体，每个小立方体内有一个整数，设计一个算法，计算所给长方体的最大子长方体，子长方体的大小定义为所含整数之和。</p><h4 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行的三个整数为m，n，p。接下来的mxn行每行p个整数，表示小立方体的数。</p><h4 id="算法设计-6"><a href="#算法设计-6" class="headerlink" title="算法设计"></a>算法设计</h4><p>假设原问题为对一个条形长方体进行切割，则该问题为一个最大子段和问题。假设原问题对一个高度为一的长方体切割，该问题就是最大子段和的二维形式，即最大子矩阵和问题。将原问题的三维形式降维为二维形式，就可以作为最大子矩阵和问题处理，将每个方块的数字保存在dp3[i][j][k]中，i表示长，j表示宽，k表示高，将其降维到二维，再二维降维到一维解决。</p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><p>c++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSum1</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *a)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxSum = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            sum += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        maxSum = <span class="built_in">max</span>(maxSum, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSum2</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> **a)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *sum = <span class="keyword">new</span> <span class="type">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;                  <span class="comment">//从i行开始</span></span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=m;j++)&#123;              <span class="comment">//逐行加上，求一维的最大子段和</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">                sum[k] += a[j][k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> max1 = <span class="built_in">maxSum1</span>(n, sum);</span><br><span class="line">            maxSum = <span class="built_in">max</span>(max1, maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] sum;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSum3</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> p, <span class="type">int</span> ***a)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> **sum = <span class="keyword">new</span> <span class="type">int</span>*[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        sum[i] = <span class="keyword">new</span> <span class="type">int</span>[p+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;                  <span class="comment">//从i行开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=p;k++)&#123;</span><br><span class="line">                sum[j][k] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=m;j++)&#123;             </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;          <span class="comment">//降维到n*p</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> h=<span class="number">1</span>;h&lt;=p;h++)&#123;</span><br><span class="line">                    sum[k][h] += a[j][k][h];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> max2 = <span class="built_in">maxSum2</span>(n, p, sum);</span><br><span class="line">            maxSum = <span class="built_in">max</span>(max2, maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] sum[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] sum;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n, p;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    <span class="type">int</span> ***a = <span class="keyword">new</span> <span class="type">int</span>**[m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        a[i] = <span class="keyword">new</span> <span class="type">int</span>*[n+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            a[i][j] = <span class="keyword">new</span> <span class="type">int</span>[p+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=p;k++)&#123;</span><br><span class="line">                cin &gt;&gt; a[i][j][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">maxSum3</span>(m, n, p, a) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DP310</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> m, n, p;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        m = sc.nextInt(); n = sc.nextInt(); p = sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[][][] a = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>][p+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=p;k++)&#123;</span><br><span class="line">                    a[i][j][k] = sc.nextInt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(maxSum3(m, n, p, a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSum1</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum += a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sum = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            maxSum = Math.max(maxSum, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSum2</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span>[][] a)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            Arrays.fill(sum, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">                    sum[k] += a[j][k];</span><br><span class="line">                &#125;</span><br><span class="line">                maxSum = Math.max(maxSum, maxSum1(n, sum));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSum3</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> p, <span class="type">int</span>[][][] a)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[][] sum = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][p+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                Arrays.fill(sum[j], <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> h=<span class="number">1</span>;h&lt;=p;h++)&#123;</span><br><span class="line">                        sum[k][h] += a[j][k][h];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                maxSum = Math.max(maxSum, maxSum2(n, p, sum));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试输入与输出-6"><a href="#测试输入与输出-6" class="headerlink" title="测试输入与输出"></a>测试输入与输出</h4><p>输入：</p><p>3 3 3</p><p>0 -1 2</p><p>1 2 2</p><p>1 1 -2</p><p>-2 -1 -1</p><p>-3 3 -2</p><p>-2 -3 1</p><p>-2 3 3</p><p>0 1 3</p><p>2 1 -3</p><p>输出：</p><p>14</p><h3 id="312-双调旅行售货员问题"><a href="#312-双调旅行售货员问题" class="headerlink" title="312 双调旅行售货员问题"></a>312 双调旅行售货员问题</h3><h4 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h4><p>最短双调TSP回路问题是欧式旅行售货员问题的特殊情况。平面上n个点的双调TSP回路是从最左点开始，严格地从左向右直到最右点，然后严格由右至左直到最左点，且连接每个点恰好一次的闭合回路。给定平面上n个点，计算这n个点的最短双调TSP回路。</p><h4 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行的整数n表示点数，接下来的n行，每行有两个值x和y，表示点的位置。</p><h4 id="算法设计-7"><a href="#算法设计-7" class="headerlink" title="算法设计"></a>算法设计</h4><p>下图是同一个图中，两条不同的双调TSP路径：</p><p><img src="/2022/12/25/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20221230154220865.png" alt="image-20221230154220865" style="zoom:50%;"></p><p>由于每个点都要经过一遍，实际上每个点不是在从左到右的路径上，就是在从右到左的路径上，而且如果将所有点按照横坐标进行排序，每次从一个点出发选择下一个点时，从左向右只能选择右侧的点，从右向左只能选择左侧的点。</p><p>用d(i,j)表示i点到j点的直线距离，定义dp[i][j]表示从i连接到最左边的点1，点1再连接到最右边的点j的最短距离，dp[i][j]就是原问题的子问题，通过逐步将点加入路径中，最终得到的就是双调TSP回路。</p><p>点i在i→1的路径中，点j在1→j的路径中，考虑j左侧的点j-1在哪条路径上：</p><ul><li>i&lt;j-1，则点j-1一定在1→j的路径上</li></ul><p><img src="/2022/12/25/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20221230155335222.png" alt="image-20221230155335222" style="zoom:50%;"></p><ul><li>i=j-1，则此时j左侧的第一个点是i，与j相连的路径1→j的点是1 - j-2中的一点k</li></ul><p><img src="/2022/12/25/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20221230155632387.png" alt="image-20221230155632387" style="zoom:50%;"></p><ul><li>i=j，形成一条回路，此时i=j=n，左侧的点可能是1→n上的，也可能是1←n上的</li></ul><p><img src="/2022/12/25/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20221230160308764.png" alt="image-20221230160308764" style="zoom:50%;"></p><p>根据以上三种情况，给出递推方程：</p><script type="math/tex; mode=display">b[i][j]=\begin{cases}b[i][j-1]+d(j-1,j) & i<j-1 \\min_{1\leq k \leq j-2}\{b[k][j-1]+d(k,j)\} & i=j-1 \\b[n-1][n]+d(n-1,n) & i=j=n\end{cases}</script><p>其中，第二种情况是b[k][j-1]而不是b[j-1][k]是因为k&lt;j-1，子问题都是i&lt;j的，因此是b[k][j-1]，从k→1→j-1和j-1→1→k的最短路径是一样的。这里用b[k][j-1]表示j-1→1→k的最短距离。</p><h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><p>c++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span>&#123;</span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> point &amp;p) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; p.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">d</span><span class="params">(point p1, point p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>( <span class="built_in">pow</span>((p1.x-p2.x),<span class="number">2</span>) + <span class="built_in">pow</span>((p1.y-p2.y),<span class="number">2</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solution</span><span class="params">(point p[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> dp[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">sort</span>(p+<span class="number">1</span>, p+n+<span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">2</span>] = <span class="built_in">d</span>(p[<span class="number">1</span>], p[<span class="number">2</span>]);   <span class="comment">//点1和2一定相连，无论2在哪条路径上</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">3</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        <span class="comment">// i &lt; j-1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=j<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            dp[i][j] = dp[i][j<span class="number">-1</span>] + <span class="built_in">d</span>(p[j<span class="number">-1</span>], p[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i = j-1</span></span><br><span class="line">        dp[j<span class="number">-1</span>][j] = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=j<span class="number">-2</span>;k++)&#123;</span><br><span class="line">            dp[j<span class="number">-1</span>][j] = <span class="built_in">min</span>(dp[j<span class="number">-1</span>][j], dp[k][j<span class="number">-1</span>]+<span class="built_in">d</span>(p[k],p[j]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i = j = n</span></span><br><span class="line">        dp[n][n] = dp[n<span class="number">-1</span>][n] + <span class="built_in">d</span>(p[n<span class="number">-1</span>], p[n]); </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    point p[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solution</span>(p, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">point</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> x,y;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">point</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">point</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>&#123; <span class="built_in">this</span>.x = x; <span class="built_in">this</span>.y = y;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DP312</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        point[] p = <span class="keyword">new</span> <span class="title class_">point</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            p[i] = <span class="keyword">new</span> <span class="title class_">point</span>(sc.nextDouble(), sc.nextDouble());</span><br><span class="line">        &#125;</span><br><span class="line">        solution(p, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">d</span><span class="params">(point p1, point p2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(Math.pow((p1.x-p2.x),<span class="number">2</span>) + Math.pow((p1.y-p2.y),<span class="number">2</span>) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solution</span><span class="params">(point[] p, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">double</span>[][] dp = <span class="keyword">new</span> <span class="title class_">double</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        Arrays.sort(p, <span class="keyword">new</span> <span class="title class_">cmp</span>());</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">2</span>] = d(p[<span class="number">1</span>], p[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">3</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="comment">// i &lt; j-1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=j-<span class="number">2</span>;i++)&#123;</span><br><span class="line">                dp[i][j] = dp[i][j-<span class="number">1</span>] + d(p[j-<span class="number">1</span>], p[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// i = j-1</span></span><br><span class="line">            dp[j-<span class="number">1</span>][j] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=j-<span class="number">2</span>;k++)&#123;</span><br><span class="line">                dp[j-<span class="number">1</span>][j] = Math.min(dp[j-<span class="number">1</span>][j], dp[k][j-<span class="number">1</span>]+d(p[k],p[j]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// i = j = n</span></span><br><span class="line">            dp[n][n] = dp[n-<span class="number">1</span>][n] + d(p[n-<span class="number">1</span>], p[n]); </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%.2f&quot;</span>, dp[n][n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试输入与输出-7"><a href="#测试输入与输出-7" class="headerlink" title="测试输入与输出"></a>测试输入与输出</h4><p>输入：</p><p>7<br>0 6<br>1 0<br>2 3<br>5 4<br>6 1<br>7 5<br>8 2</p><p>输出：</p><p>25.58</p><h3 id="313-最大k乘积问题"><a href="#313-最大k乘积问题" class="headerlink" title="313 最大k乘积问题"></a>313 最大k乘积问题</h3><h4 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h4><p>设I是一个n位十进制整数。如果将I划分为k段，则可得到k个整数。这k个整数的乘积称为I的一个k乘积。设计一个算法，对于给定的I和k，求出I的最大k乘积。</p><h4 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行的两个整数为n和k，接下来的一行是一个n位十进制整数l。</p><h4 id="算法设计-8"><a href="#算法设计-8" class="headerlink" title="算法设计"></a>算法设计</h4><p>设dp[i][j]表示将前i位划分为j段的最大k乘积，需要找到一个位置m，前m位中有j-1段，此后的位为1段。设a[i][j]表示第i到j位，则<script type="math/tex">dp[i][j] = max_{j-1 \leq m < i}\{dp[m][j-1]\times a[m+1][i]\}</script></p><p>递推方程为：</p><script type="math/tex; mode=display">dp[i][j] = \begin{cases}a[1][i] & j = 1,i>j \\max_{j-1 \leq m <i}\{dp[m][j-1]\times a[m+1][i] \} & j>1,i>j\end{cases}</script><h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><p>c++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solution</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[n+<span class="number">1</span>][n+<span class="number">1</span>], dp[n+<span class="number">1</span>][k+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">            a[i][j] = <span class="built_in">stoi</span>(<span class="built_in">to_string</span>(num).<span class="built_in">substr</span>(i<span class="number">-1</span>,j-i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = a[<span class="number">1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=k;j++)&#123;</span><br><span class="line">            dp[i][j] = INT_MIN;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> m=j<span class="number">-1</span>;m&lt;i;m++)&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[m][j<span class="number">-1</span>]*a[m+<span class="number">1</span>][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][k] &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k, num;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k &gt;&gt; num;</span><br><span class="line">    <span class="built_in">solution</span>(n, k, num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DP313</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> n, k, num;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        n = sc.nextInt(); k = sc.nextInt(); num = sc.nextInt();</span><br><span class="line">        solution(n, k, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>], dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">                a[i][j] = Integer.parseInt(Integer.toString(num).substring(i-<span class="number">1</span>, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = a[<span class="number">1</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=k;j++)&#123;</span><br><span class="line">                dp[i][j] = Integer.MIN_VALUE;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> m=j-<span class="number">1</span>;m&lt;i;m++)&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[m][j-<span class="number">1</span>]*a[m+<span class="number">1</span>][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[n][k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试输入与输出-8"><a href="#测试输入与输出-8" class="headerlink" title="测试输入与输出"></a>测试输入与输出</h4><p>输入：</p><p>3 2</p><p>312</p><p>输出：</p><p>62</p><h3 id="314-最少费用购物问题"><a href="#314-最少费用购物问题" class="headerlink" title="314 最少费用购物问题"></a>314 最少费用购物问题</h3><h4 id="问题描述-8"><a href="#问题描述-8" class="headerlink" title="问题描述"></a>问题描述</h4><p>商店中每种物品都有标价。例如，一朵花的价格是2元，一个花瓶的价格是5元，为了吸引顾客，商店提供了一组优惠商品价，优惠商品是把一种或多种商品分成一组，并降价销售，例如，3朵花的价格是5元，2个花瓶+1朵花的价格是10元，设计一个算法，计算出某顾客购买商品应付的最少费用。</p><h4 id="输入格式-8"><a href="#输入格式-8" class="headerlink" title="输入格式"></a>输入格式</h4><p>input.txt提供欲购物信息，第一行输入为B(0-5)，此后的B行每行有三个数C K P，分别表示商品编号(1-999)，购买总数(1-5)，商品单价，一次最多购买5*5件商品。</p><p>offer.txt提供优惠商品价数据，文件中的第一行有一个整数S，表示有S种优惠组合，接下来的S行，每行的第一个数表示组合中的商品种类j，接下来是j个数字对(C K)，C为商品编号，K为在优惠组合中的数量，最后一个数字P表示该组合的优惠价。输出最少费用。</p><h4 id="算法设计-9"><a href="#算法设计-9" class="headerlink" title="算法设计"></a>算法设计</h4><p>由于每次购买的商品最多五种，可以使用一个五维数组保存购买情况，用dp[i][j][k][l][p]表示购买的五种商品有i，j，k，l，p个时的最少费用。求最少费用时，遍历每种优惠组合，更新dp数组，设offer[m][c]表示第m个优惠组合中，商品c的数量，c取1-5，在读入时就只读入欲购买的商品。以下是考虑优惠组合时的递推方程，每种情况应该先初始化为用单价购买的价格，然后遍历组合找到最小值。</p><script type="math/tex; mode=display">dp[i][j][k][l][p]=min_{1\leq m \leq S}\{dp[i-offer[m][1]][j-offer[m][2]][k-offer[m][3]][l-offer[m][4][p-offer[m][5]]+offer[m][0]\}</script><p>其中offer[m][0]表示优惠组合m的价格。</p><p>如果i-offer[m][i]&lt;0，应该取0，这样就包含了凑单的情况。</p><h4 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h4><p>c++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">good</span>&#123;</span><br><span class="line">    <span class="type">int</span> id = <span class="number">-1</span>, n = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> B, C, K, S;</span><br><span class="line">    <span class="type">int</span> offer[<span class="number">101</span>][<span class="number">6</span>];</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">6</span>][<span class="number">6</span>][<span class="number">6</span>][<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line">    good goods[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    solution s;</span><br><span class="line">    s.<span class="built_in">input</span>();</span><br><span class="line">    s.<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solution::input</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fstream in;</span><br><span class="line">    in.<span class="built_in">open</span>(<span class="string">&quot;input314.txt&quot;</span>, ios::in);</span><br><span class="line">    in &gt;&gt; B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=B;i++)&#123;</span><br><span class="line">        in &gt;&gt; goods[i].id &gt;&gt; goods[i].n &gt;&gt; goods[i].p;</span><br><span class="line">    &#125;</span><br><span class="line">    in.<span class="built_in">close</span>();</span><br><span class="line">    <span class="comment">//读入组合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">101</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">6</span>;j++) offer[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    in.<span class="built_in">open</span>(<span class="string">&quot;offer.txt&quot;</span>, ios::in);</span><br><span class="line">    in &gt;&gt; S;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=S;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        in &gt;&gt; t;</span><br><span class="line">        <span class="comment">//t种商品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;t;j++)&#123;</span><br><span class="line">            in &gt;&gt; C &gt;&gt; K;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=B;k++)&#123;      <span class="comment">//找到优惠组合中欲购买的商品</span></span><br><span class="line">                <span class="keyword">if</span>(goods[k].id==C)&#123;</span><br><span class="line">                    offer[i][k] = K;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        in &gt;&gt; offer[i][<span class="number">0</span>];              <span class="comment">//总价    </span></span><br><span class="line">    &#125;</span><br><span class="line">    in.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solution::solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=goods[<span class="number">1</span>].n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=goods[<span class="number">2</span>].n;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=goods[<span class="number">3</span>].n;k++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;=goods[<span class="number">4</span>].n;l++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;=goods[<span class="number">5</span>].n;p++)&#123;</span><br><span class="line">                        <span class="type">int</span> minPrice = i*goods[<span class="number">1</span>].p + j*goods[<span class="number">2</span>].p + k*goods[<span class="number">3</span>].p + l*goods[<span class="number">4</span>].p + p*goods[<span class="number">5</span>].p;</span><br><span class="line">                        dp[i][j][k][l][p] = minPrice;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">1</span>;m&lt;=S;m++)&#123;</span><br><span class="line">                            minPrice = <span class="built_in">min</span>(minPrice, dp[<span class="built_in">max</span>(<span class="number">0</span>, i-offer[m][<span class="number">1</span>])][<span class="built_in">max</span>(<span class="number">0</span>, j-offer[m][<span class="number">2</span>])][<span class="built_in">max</span>(<span class="number">0</span>, k-offer[m][<span class="number">3</span>])][<span class="built_in">max</span>(<span class="number">0</span>, l-offer[m][<span class="number">4</span>])][<span class="built_in">max</span>(<span class="number">0</span>, p-offer[m][<span class="number">5</span>])]+offer[m][<span class="number">0</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; p &lt;&lt; &quot;的最小费用为&quot; &lt;&lt; minPrice &lt;&lt; endl;</span></span><br><span class="line">                        dp[i][j][k][l][p] = minPrice;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[goods[<span class="number">1</span>].n][goods[<span class="number">2</span>].n][goods[<span class="number">3</span>].n][goods[<span class="number">4</span>].n][goods[<span class="number">5</span>].n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DP314</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">solution</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">solution</span>();</span><br><span class="line">        s.initialize();</span><br><span class="line">        s.input();</span><br><span class="line">        s.solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">good</span>&#123;</span><br><span class="line">    <span class="type">int</span> id, n, p;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">good</span><span class="params">()</span>&#123;id=-<span class="number">1</span>;n=<span class="number">0</span>;p=<span class="number">0</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> B, C, K, S;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] offer;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][][][][] dp;</span><br><span class="line">    <span class="keyword">private</span> good[] goods;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span>&#123;</span><br><span class="line">        offer = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">101</span>][<span class="number">6</span>];</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>][<span class="number">6</span>][<span class="number">6</span>][<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line">        goods = <span class="keyword">new</span> <span class="title class_">good</span>[<span class="number">6</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) goods[i] = <span class="keyword">new</span> <span class="title class_">good</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">input</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//读入欲购买的商品</span></span><br><span class="line">        <span class="keyword">try</span>(<span class="type">Scanner</span> <span class="variable">sc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;input314.txt&quot;</span>)))&#123;</span><br><span class="line">            B = sc1.nextInt();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=B;i++)&#123;</span><br><span class="line">                goods[i].id = sc1.nextInt();</span><br><span class="line">                goods[i].n = sc1.nextInt();</span><br><span class="line">                goods[i].p = sc1.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读入组合</span></span><br><span class="line">        <span class="keyword">try</span>(<span class="type">Scanner</span> <span class="variable">sc2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;offer.txt&quot;</span>)))&#123;</span><br><span class="line">            S = sc2.nextInt();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=S;i++)&#123;</span><br><span class="line">                <span class="type">int</span> t;</span><br><span class="line">                t = sc2.nextInt();</span><br><span class="line">                <span class="comment">//t种商品</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;t;j++)&#123;</span><br><span class="line">                    C = sc2.nextInt();</span><br><span class="line">                    K = sc2.nextInt();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=B;k++)&#123;      <span class="comment">//找到优惠组合中欲购买的商品</span></span><br><span class="line">                        <span class="keyword">if</span>(goods[k].id==C)&#123;</span><br><span class="line">                            offer[i][k] = K;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;    </span><br><span class="line">                offer[i][<span class="number">0</span>] = sc2.nextInt();    <span class="comment">//总价    </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=goods[<span class="number">1</span>].n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=goods[<span class="number">2</span>].n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=goods[<span class="number">3</span>].n;k++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;=goods[<span class="number">4</span>].n;l++)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;=goods[<span class="number">5</span>].n;p++)&#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">minPrice</span> <span class="operator">=</span> i*goods[<span class="number">1</span>].p + j*goods[<span class="number">2</span>].p + k*goods[<span class="number">3</span>].p + l*goods[<span class="number">4</span>].p + p*goods[<span class="number">5</span>].p;</span><br><span class="line">                            dp[i][j][k][l][p] = minPrice;</span><br><span class="line">                            <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">1</span>;m&lt;=S;m++)&#123;</span><br><span class="line">                                minPrice = Math.min(minPrice, dp[Math.max(<span class="number">0</span>, i-offer[m][<span class="number">1</span>])][Math.max(<span class="number">0</span>, j-offer[m][<span class="number">2</span>])][Math.max(<span class="number">0</span>, k-offer[m][<span class="number">3</span>])][Math.max(<span class="number">0</span>, l-offer[m][<span class="number">4</span>])][Math.max(<span class="number">0</span>, p-offer[m][<span class="number">5</span>])]+offer[m][<span class="number">0</span>]);</span><br><span class="line">                            &#125;</span><br><span class="line">                            dp[i][j][k][l][p] = minPrice;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[goods[<span class="number">1</span>].n][goods[<span class="number">2</span>].n][goods[<span class="number">3</span>].n][goods[<span class="number">4</span>].n][goods[<span class="number">5</span>].n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试输入与输出-9"><a href="#测试输入与输出-9" class="headerlink" title="测试输入与输出"></a>测试输入与输出</h4><p>测试1</p><p>输入：</p><p>input.txt</p><p>2 </p><p>7 3 2</p><p>8 2 5</p><p>offer.txt</p><p>2</p><p>1 7 3 5</p><p>2 7 1 8 2 10</p><p>输出：</p><p>14</p><p>测试2</p><p>输入：</p><p>input.txt</p><p>5<br> 1 1 2<br> 2 1 3<br> 3 1 4<br> 4 1 5<br> 5 1 6</p><p>offer.txt</p><p> 6<br> 1 2 1 3<br> 2 1 1 2 1 5<br> 5 1 1 2 1 3 1 4 1 5 1 3<br> 3 1 1 3 1 4 1 1<br> 2 2 1 5 1 1<br> 1 1 1 3</p><p>输出：</p><p>2</p><h3 id="315-收集样本问题"><a href="#315-收集样本问题" class="headerlink" title="315 收集样本问题"></a>315 收集样本问题</h3><h4 id="问题描述-9"><a href="#问题描述-9" class="headerlink" title="问题描述"></a>问题描述</h4><p>机器人在一个nxn方格区域收集样本，(i，j)方格中的样本价值为v(i，j)，机器人从左上角的第一个点出发，向右或向下移动到达右下角的点，在走过的路上收集样本，共走两次，设计一个算法，计算两次行走能够收集的样本最大价值。</p><h4 id="输入格式-9"><a href="#输入格式-9" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行的正整数n表示区域为nxn，接下来每行有三个整数x，y，v，表示(x，y)有价值为v的样本，直到输入为0 0 0结束。</p><h4 id="算法设计-10"><a href="#算法设计-10" class="headerlink" title="算法设计"></a>算法设计</h4><p>设dp[i][j]表示走到(i，j)能够收集的样本最大价值，则递推方程为：</p><script type="math/tex; mode=display">dp[i][j] = \begin{cases}dp[i-1][j]+v[i][j] & j=0 \\dp[i][j-1]+v[i][j] & i = 0 \\max\{dp[i-1][j],dp[i][j-1]\}+v[i][j]    & j \neq 0 , i \neq 0\end{cases}</script><p>记录走过的路径，将最优路径的值回溯清空，然后再次计算，得到两次行走的最大价值。</p><h4 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h4><p>c++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Up = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Left = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> v[maxn][maxn];</span><br><span class="line"><span class="type">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="type">int</span> path[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span> || y&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    v[x][y] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(path[x][y]==Up)&#123;</span><br><span class="line">        <span class="built_in">clear</span>(x<span class="number">-1</span>, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">clear</span>(x, y<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">collect</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(dp[<span class="number">0</span>], dp[<span class="number">0</span>]+n*n, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + v[i][<span class="number">0</span>];</span><br><span class="line">        path[i][<span class="number">0</span>] = Up;</span><br><span class="line">        dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i<span class="number">-1</span>] + v[<span class="number">0</span>][i];</span><br><span class="line">        path[<span class="number">0</span>][i] = Left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + v[i][j];</span><br><span class="line">            path[i][j] = (dp[i<span class="number">-1</span>][j]&gt;dp[i][j<span class="number">-1</span>])?Up:Left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">clear</span>(n<span class="number">-1</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, x, y, val, res;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;x&gt;&gt;y&gt;&gt;val)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span> &amp;&amp; y==<span class="number">0</span> &amp;&amp; val==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        v[x<span class="number">-1</span>][y<span class="number">-1</span>] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">collect</span>(n);</span><br><span class="line">    res += <span class="built_in">collect</span>(n);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">maxn</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">Up</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">Left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] v;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dp;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] path;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        v = <span class="keyword">new</span> <span class="title class_">int</span>[maxn][maxn];</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="title class_">int</span>[maxn][maxn];</span><br><span class="line">        path = <span class="keyword">new</span> <span class="title class_">int</span>[maxn][maxn];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSample</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> val)</span> &#123;v[x][y] = val;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span> || y&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        v[x][y] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(path[x][y]==Up)</span><br><span class="line">            clear(x-<span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            clear(x, y-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">collect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) Arrays.fill(dp[i], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + v[i][<span class="number">0</span>];</span><br><span class="line">            path[i][<span class="number">0</span>] = Up;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">1</span>] + v[<span class="number">0</span>][i];</span><br><span class="line">            path[<span class="number">0</span>][i] = Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]) + v[i][j];</span><br><span class="line">                path[i][j] = (dp[i-<span class="number">1</span>][j]&gt;dp[i][j-<span class="number">1</span>])?Up:Left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        clear(n-<span class="number">1</span>, n-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DP315</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> n, x, y, val, res;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        <span class="type">solution</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">solution</span>(n);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            x = sc.nextInt(); y = sc.nextInt(); val = sc.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="number">0</span> &amp;&amp; y==<span class="number">0</span> &amp;&amp; val==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            s.addSample(x-<span class="number">1</span>, y-<span class="number">1</span>, val);</span><br><span class="line">        &#125;</span><br><span class="line">        res = s.collect();</span><br><span class="line">        res += s.collect();</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试输入与输出-10"><a href="#测试输入与输出-10" class="headerlink" title="测试输入与输出"></a>测试输入与输出</h4><p>输入：</p><p>8</p><p>2 3 13</p><p>2 6 6</p><p>3 5 7</p><p>4 4 14</p><p>5 2 21</p><p>5 6 4</p><p>6 3 15</p><p>7 2 14</p><p>0 0 0</p><p>输出：</p><p>67</p><h3 id="316-最优时间表问题-线性DP"><a href="#316-最优时间表问题-线性DP" class="headerlink" title="316 最优时间表问题(线性DP)"></a>316 最优时间表问题(线性DP)</h3><p>传送门：<a href="https://www.luogu.com.cn/problem/P1280">https://www.luogu.com.cn/problem/P1280</a></p><h4 id="问题描述-10"><a href="#问题描述-10" class="headerlink" title="问题描述"></a>问题描述</h4><p>一台精密仪器的工作时间为n个时间单位。与仪器工作时间同步进行若干仪器维修程序。一旦启动维修程序，仪器必须进入维修。如果只有一个维修程序，必须进入该程序，如果在同一时刻有多个维修程序，可任选进入其中任何一个维修程序。维修程序必须从头开始，不得从中间插入，一个维修程序从第s个时间单位开始，持续t个时间单位，则该维修程序在第s+t-1个时间单位结束。为了提高仪器使用率，尽可能减少仪器维修的时间。</p><p>设计一个算法，对于给定的维修程序时间表，计算最短维修时间。</p><h4 id="输入格式-10"><a href="#输入格式-10" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行有两个正整数n和k，表示工作时间和维修程序数，接下来的k行每行有两个数s和t，表示维修程序的开始时间和持续时间。</p><h4 id="算法设计-11"><a href="#算法设计-11" class="headerlink" title="算法设计"></a>算法设计</h4><p>如果正向计算最短维修时间或最大工作时间，当前作出的选择会影响后续的选择，选择短还是长的维修程序与后续的程序有关。可以反向计算最大工作时间，用dp[i]表示i到n的最小维修时间，如果时刻i没有维修开始，dp[i] = dp[i+1]，如果时刻i有维修开始，则dp[i] = min{dp[m[j].end_time]+m[j].t}，m[j]表示从i时刻开始的维修。</p><p>对于测试输入与输出，时间线和dp值如下：</p><img src="/2022/12/25/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230101111333964.png" class title="image-20230101111333964"><p>当考虑i时刻到n时刻的最短维修时间时，只要m[i].end_time大于此后某一维修x的开始时间，计算的值就是没有进行维修x的i到n时刻的维修时间。</p><h4 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h4><p>c++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">maintenance</span>&#123;</span><br><span class="line">    <span class="type">int</span> s, t, end_time;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> maintenance &amp;a)&#123;</span><br><span class="line">        <span class="keyword">return</span> s &gt; a.s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solution</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, maintenance m[], <span class="type">int</span> t[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> dp[n+<span class="number">1</span>], mi;</span><br><span class="line">    mi = <span class="number">0</span>;         <span class="comment">//维修程序的编号</span></span><br><span class="line">    <span class="built_in">sort</span>(m, m+k);</span><br><span class="line">    dp[n] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[i]==<span class="number">0</span>) dp[i] = dp[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i] = dp[m[mi].end_time] + m[mi++].t;     <span class="comment">//只要有维修就必须选择</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;t[i];j++)&#123;</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[m[mi].end_time]+m[mi++].t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[<span class="number">1</span>] &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k, s, t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> T[n+<span class="number">1</span>];    <span class="comment">//记录时刻i有几个开始的维修程序</span></span><br><span class="line">    maintenance m[k];</span><br><span class="line">    <span class="built_in">fill</span>(T, T+n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        T[s]++;</span><br><span class="line">        m[i].s = s;</span><br><span class="line">        m[i].t = t;</span><br><span class="line">        m[i].end_time = s + t - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solution</span>(n, k, m, T);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">maintenance</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> s, t, end_time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DP316</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> n, k;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        k = sc.nextInt();</span><br><span class="line">        maintenance[] m = <span class="keyword">new</span> <span class="title class_">maintenance</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++) m[i] = <span class="keyword">new</span> <span class="title class_">maintenance</span>();</span><br><span class="line">        <span class="type">int</span> s, t;</span><br><span class="line">        <span class="type">int</span>[] T = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            s = sc.nextInt();</span><br><span class="line">            t = sc.nextInt();</span><br><span class="line">            T[s]++;</span><br><span class="line">            m[i].s = s;</span><br><span class="line">            m[i].t = t;</span><br><span class="line">            m[i].end_time = s + t - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        solution(m, T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solution</span><span class="params">(maintenance[] m, <span class="type">int</span>[] t)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mi</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        Arrays.sort(m, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;maintenance&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(maintenance a, maintenance b)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (a.s &lt; b.s)?<span class="number">1</span>:(a.s == b.s)?<span class="number">0</span>:-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t[i]==<span class="number">0</span>) dp[i] = dp[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i] = dp[m[mi].end_time] + m[mi++].t;     <span class="comment">//只要有维修就必须选择</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;t[i];j++)&#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[m[mi].end_time]+m[mi].t);</span><br><span class="line">                    mi++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试输入与输出-11"><a href="#测试输入与输出-11" class="headerlink" title="测试输入与输出"></a>测试输入与输出</h4><p>输入：</p><p>15 6</p><p>1 2</p><p>1 6</p><p>4 11 </p><p>8 5</p><p>8 1</p><p>11 5</p><p>输出：</p><p>11</p><h3 id="317-字符串比较问题"><a href="#317-字符串比较问题" class="headerlink" title="317 字符串比较问题"></a>317 字符串比较问题</h3><h4 id="问题描述-11"><a href="#问题描述-11" class="headerlink" title="问题描述"></a>问题描述</h4><p>对于长度相同的两个字符串A和B，其距离定义为相应位置字符距离之和。两个非空格字符的距离是他们ASCII编码差的绝对值，空格与空格的距离为0，空格与其他字符的距离为一定值k。</p><p>一般情况下，A和B的长度不一定相同，A的扩展是在A中插入若干空格字符产生的字符串。在A和B所有长度相同的扩展中，有一对距离最小的扩展，该距离称为A和B的扩展距离。</p><p>设计一个算法，计算给定字符串A和B的扩展距离。</p><h4 id="输入格式-11"><a href="#输入格式-11" class="headerlink" title="输入格式"></a>输入格式</h4><p>前两行为字符串A和B，第三行为空格与其他字符的距离k。</p><h4 id="算法设计-12"><a href="#算法设计-12" class="headerlink" title="算法设计"></a>算法设计</h4><p>对于A的第i个字符Ai和B的第j个字符Bj，扩展情况下两个字符的匹配只有三种情况：</p><ul><li>Ai与B的前j-1个字符匹配，Bj与空格匹配</li><li>Ai与空格匹配，Bj与A的前i-1个字符匹配</li><li>Ai与Bj匹配</li></ul><p>用dp[i][j]来表示A的前i个字符和B的前j个字符的扩展距离，可根据以上三种情况写出递推方程：</p><script type="math/tex; mode=display">dp[i][j] = \begin{cases}jk & i=0 \\ik & j=0 \\min\{dp[i][j-1]+k,dp[j-1][i]+k,dp[i-1][j-1]+abs(Ai-Bj)\} & i>0,j>0\end{cases}</script><h4 id="代码实现-11"><a href="#代码实现-11" class="headerlink" title="代码实现"></a>代码实现</h4><p>c++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solution</span><span class="params">(string a, string b, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    m = a.<span class="built_in">length</span>(); n = b.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> dp[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">fill</span>(dp[<span class="number">0</span>], dp[<span class="number">0</span>]+(m+<span class="number">1</span>)*(n+<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++) dp[i][<span class="number">0</span>] = i*k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) dp[<span class="number">0</span>][i] = i*k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j]+k, <span class="built_in">min</span>(dp[i][j<span class="number">-1</span>]+k, dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="built_in">abs</span>(a[i<span class="number">-1</span>]-b[j<span class="number">-1</span>])));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[m][n] &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; k;</span><br><span class="line">    <span class="built_in">solution</span>(a, b, k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DP317</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        String a, b;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        a = sc.next(); b = sc.next(); k = sc.nextInt();</span><br><span class="line">        solution(a, b, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solution</span><span class="params">(String a, String b, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> m, n;</span><br><span class="line">        m = a.length();</span><br><span class="line">        n = b.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++) dp[i][<span class="number">0</span>] = i*k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) dp[<span class="number">0</span>][i] = i*k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j]+k, Math.min(dp[i][j-<span class="number">1</span>]+k, dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+Math.abs(a.charAt(i-<span class="number">1</span>)-b.charAt(j-<span class="number">1</span>))));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[m][n]); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试输入与输出-12"><a href="#测试输入与输出-12" class="headerlink" title="测试输入与输出"></a>测试输入与输出</h4><p>输入：</p><p>cmc</p><p>snmn</p><p>2</p><p>输出：</p><p>10</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络自顶向下方法笔记04</title>
      <link href="/2022/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B004/"/>
      <url>/2022/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B004/</url>
      
        <content type="html"><![CDATA[<p style="text-indent:2em">《计算机网络自顶向下方法》学习笔记04:链路层。</p><p style="text-indent:2em">网络层实现的是主机到主机之间的通信。链路层则是解决分组在各段链路上传输的问题。</p><h1 id="第五章-链路层"><a href="#第五章-链路层" class="headerlink" title="第五章 链路层"></a>第五章 链路层</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p style="text-indent:2em">在网络中，每一个设备都可以称作是一个<b>节点</b>，包括主机，交换机，WiFi接入点。沿着相邻节点的通信信道称为<b>链路(link)</b>。为了将数据报传输到目的主机，数据报必须经过各段链路传输。链路层主要讨论的就是数据报在链路上传输的问题。在链路层，数据报被添加上首部和尾部(校验位)，被称为<b>帧</b>。链路层主要提供以下的服务，本章也主要介绍以下内容的相关问题：</p><ul><li>封装成帧：网络层数据报经链路传输之前，需要封装成帧。</li><li>链路接入：规定帧在链路上传输的规则(媒体访问控制协议MAC)。</li><li>可靠交付：在易于产生高差错率的链路中，可能提供可靠交付服务。由于在运输层也提供了可靠交付的服务，在链路层提供该服务不是必要的，许多链路层协议不提供可靠交付服务。</li><li>差错检测和纠正：检测在链路层传输过程中的差错，并可能进行纠错。</li></ul><p style="text-indent:2em">以上链路层的服务主要在路由器的线路卡或主机的网络适配器中实现的。原来的网络适配器通常是一张卡，可以插入PC的PCI卡槽，现在的网络适配器基本上都综合到了主机的主板。大部分链路层在硬件中实现，但还有一部分在主机CPU的软件实现，因此链路层是整个网络层次中硬件与软件交接的位置。</p><span id="more"></span><h2 id="2-差错检测和纠正技术"><a href="#2-差错检测和纠正技术" class="headerlink" title="2.差错检测和纠正技术"></a>2.差错检测和纠正技术</h2><p style="text-indent:2em">链路层提供了比特级的差错检测和纠正，对于节点之间传输可能发生的错误进行检测与纠正。为了检错与纠正，要在数据的尾部添加一些比特。差错检测和纠正只能尽可能的检测错误并纠正，并不能处理所有的错误。接下来主要介绍三种差错检测技术：奇偶校验(检错与纠错的基本思想)，检验和(主要用于运输层)，循环冗余检测(通常应用在链路层)。</p><h3 id="2-1-奇偶校验"><a href="#2-1-奇偶校验" class="headerlink" title="2.1 奇偶校验"></a>2.1 奇偶校验</h3><p style="text-indent:2em">奇偶校验是最为简单的差错检测和纠正技术。给数据添加一个附加的bit，使数据以及这一位的值中有偶数个1，这就是偶校验，奇校验同理。显然，奇偶校验码只有发生了奇数个错误的时候才可以检出，偶数个错误无法检出。而且这样也无法进行差错纠正。如果需要进行差错纠正，需要使用二维的奇偶校验码，把数据表示为行和列，对每行和每列都添加一个奇偶校验码，就可以定位到错误的位置，纠正错误。</p><h3 id="2-2-检验和"><a href="#2-2-检验和" class="headerlink" title="2.2 检验和"></a>2.2 检验和</h3><p style="text-indent:2em">检验和方法就是将所有数据的bit加起来，用得到的和作为检错码。在运输层的TCP和UDP就是使用检验和进行差错检测，将所有数据的bit求和，然后取反作为检验和，接收方将数据和检验和求和，得到的是全1则说明没有产生差错。</p><p style="text-indent:2em">检验和的差错检测能力较弱，显然多个错误还是可能检测不出，因此在链路层中采用了循环冗余检测(CRC)方法进行差错检测和纠正，循环冗余检测更为复杂，但是由于链路层主要在硬件上，可以使用硬件实现检测，因此可以快速得到循环冗余检测的结果。</p><h3 id="2-3-循环冗余校验"><a href="#2-3-循环冗余校验" class="headerlink" title="2.3 循环冗余校验"></a>2.3 循环冗余校验</h3><p style="text-indent:2em">在链路层上广泛应用的差错检测技术是<b>循环冗余检测编码CRC，也称为多项式编码</b>。</p><p style="text-indent:2em">CRC编码中，发送方与接收方首先约定一个<b>生成多项式</b>，一个多项式对应了一个01串。例如多项式:</p><script type="math/tex; mode=display">1*X^4+1*X^3+0*X^2+1*X^1+1</script><p style="text-indent:2em">对应的01串是11011。假设数据为D，CRC冗余位为R，则DR应该可以整除该多项式对应的01串。由此，可以先假设R=0000，位数是多项式的最高次项(即多项式01串有5位，余数最多只有4位)，然后用DR除多项式对应的01串，得到的余数就是CRC冗余位。在书中有这种计算方法的详细证明。需要注意，每一步算余数进行的是<font color="red">异或运算</font>，例如下图中第一位结果取1，1010与1101异或得到111，再继续运算。</p><p><img src="/2022/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B004/image-20221201231249088.png" alt="image-20221201231249088" style="zoom:80%;"></p><p style="text-indent:2em">每个CRC都可以检测小于r+1位的突发差错。在国际标准中，已经定义了各个位数的生成多项式。</p><h2 id="3-多路访问链路和协议"><a href="#3-多路访问链路和协议" class="headerlink" title="3.多路访问链路和协议"></a>3.多路访问链路和协议</h2><p style="text-indent:2em">网络中的链路有两种类型：<b>点对点链路</b>和<b>广播链路</b>。点对点链路中，一个链路上只有一个发送方和接收方，只需要正常发送和接收数据。而广播链路中，许多节点都连接在相同的，共享的，单一的广播信道上，在这样的信道上传输数据。以太网和无线局域网都是使用广播链路，这里也先介绍并重点介绍广播链路的协议和技术。</p><p style="text-indent:2em">在广播链路上，许多节点都需要发送和接收数据，必须协调各个节点对信道的访问，这就是<b>多路访问问题</b>。有许多不同的<b>多路访问协议</b>用于解决该问题，这些协议可以被划分为三类：</p><ul><li>信道划分协议：信道资源被预先划分。</li><li>随机接入协议：传输节点总是以信道全部速率进行发送，如果发生了碰撞，就反复重发该帧，直到成功发送。每次重发之前要等待一个随机的时延，每个节点的时延都是独立的，因此节点可能交错发送数据，这样就可以在共享信道上完成数据传输。</li><li>轮流协议：节点轮流发送。</li></ul><p style="text-indent:2em">在理想情况下，总是希望多路访问协议具有以下特性：</p><ul><li>仅有一个节点时，节点具有信道最大速率R bps的吞吐量。</li><li>有M个节点时，每个节点有R/M bps的吞吐量。</li><li>协议是分散的，不会因某个主节点的故障而使整个系统崩溃。</li><li>协议是简单的。</li></ul><p style="text-indent:2em">下面分别介绍这三类协议：</p><h3 id="3-1-信道划分协议"><a href="#3-1-信道划分协议" class="headerlink" title="3.1 信道划分协议"></a>3.1 信道划分协议</h3><p style="text-indent:2em">信道划分协议是在共享信道节点之间划分广播信道带宽的协议。按照划分的方法，主要分为三种：<b>时分多路复用TDM、频分多路复用FDM、码分多址CDMA</b>。</p><p style="text-indent:2em">时分多路复用TDM是将时间划分为时间帧，再将时间帧划分为时隙。每个节点在循环的时间帧中都占有一个时隙，在这个时隙内发送数据。时隙的长度保证至少能传输一个数据分组。TDM的缺点在于，无论一个节点是否需要发送数据，他都拥有一个时隙，当其不发送数据时，这个时隙就被浪费掉了。</p><p style="text-indent:2em">频分多路复用FDM将R bit/s的信道划分为不同的频段，假设有N个节点，则每个频段的带宽只有R/N，每个节点使用一个频段。FDM的缺点也是显然的，限制了一个节点只能使用R/N的带宽，无论其他节点是否有数据要发送。</p><p style="text-indent:2em">码分多址CDMA不对信道进行划分，而是为每个节点分配一个不同的编码，在信道中，节点使用唯一的编码来传递数据，这使得不同的节点可以同时传输，而数据接收方只要知道编码就可以正确接收，不在乎其他节点的干扰。CDMA与无线信道紧密相关，在无线网络章节中有重点讨论。</p><h3 id="3-2-随机接入协议"><a href="#3-2-随机接入协议" class="headerlink" title="3.2 随机接入协议"></a>3.2 随机接入协议</h3><p style="text-indent:2em">随机接入协议中，节点总是以全部速率发送数据，当有碰撞时，就重发发生碰撞的帧，直到该帧成功发送。但是重发不是在碰撞后立刻进行的，而是等待一个随机时延，而不同节点独立选择随机时延，因此碰撞发生后，可能交错发送数据，从而正确完成传输。随机接入协议有许多种，接下来重点介绍其中的三种。</p><p><strong>时隙ALOHA</strong></p><p style="text-indent:2em">时隙ALOHA协议时最简单的随机接入协议之一。在该协议中，有如下假设：</p><ul><li>所有帧由L比特组成</li><li>时间被划分为长度为L/R秒的时隙</li><li>节点只在时隙起点开始传播帧</li><li>每个节点都知道时隙何时开始</li><li>如果一个时隙中发生了碰撞，所有节点在该时隙结束前检测到碰撞</li></ul><p style="text-indent:2em">对于节点而言，在该协议的处理如下：</p><ul><li>有新帧要发送时，等到下一个时隙开始并在该时隙传输整个帧</li><li>如果没有碰撞，节点成功传输该帧</li><li>如果有碰撞，该节点在时隙结束之前检测到碰撞，以概率p在后续时隙中重传该帧</li></ul><p style="text-indent:2em">ALOHA协议中，节点传输的过程大致如下：</p><p><img src="/2022/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B004/image-20221204165049326.png" alt="image-20221204165049326" style="zoom:80%;"></p><p style="text-indent:2em">现在考虑时隙ALOHA的传输效率。假设有N个节点，对于一个节点，成功发送数据的概率为p(1-p)^(N-1)，因为有N个节点，任一节点成功传输的概率为Np(1-p)^(N-1)。求其极限，可以得到最大效率为0.37(0.364)。因此当有大量节点要传输数据时，有效传输速率最多仅有0.37R bps。</p><p><strong>ALOHA</strong></p><p style="text-indent:2em">上述的ALOHA已经是改进的版本了。最早的纯ALOHA更加简单，不限制节点发送数据的时间，即不进行同步。在这种情况下，假设时间单位为时隙，一个节点要在t0 ~ t0+1发送一个帧，那么t0-1 ~ t0不可以有帧发送，t0 ~ t0+1也不可以有其他帧发送，否则都会产生碰撞，因此一个节点发送的时间落在两个时隙时间，两个时隙都不能有其他节点发送，这个概率为p(1-p)^(2(N-1))，求极限后，最大效率为0.184，刚好是时隙ALOHA的一半。</p><p><img src="/2022/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B004/image-20221204170057042.png" alt="image-20221204170057042" style="zoom:67%;"></p><p><strong>载波侦听多路访问CSMA</strong></p><p style="text-indent:2em">载波侦听多路访问协议(CSMA)是一类通过侦听来尽量避免碰撞并减少碰撞后无效传输的协议。</p><ul><li>载波侦听(CS)：一个节点在传输前先听信道，等待到信道上有一小段时间都没有数据传输，就开始传输。</li><li>多路访问(MA)：多个节点共享信道。</li></ul><p style="text-indent:2em">根据监听方式和监听到信道忙后的处理方式不同，CSMA协议可以分为三种：</p><ul><li>1-坚持CSMA：监听到信道忙后，继续坚持监听信道；监听到信道空闲，立即发送数据(即发送概率为1)。</li><li>非坚持CSMA：监听到信道忙后，放弃监听，等待一个随机时间后再进行监听。</li><li>p-坚持CSMA：p-坚持CSMA用于时分信道，基本思想是，监听信道直到信道空闲，如果空闲，以概率p发送数据，以概率1-p推迟到下一个时隙再发送，如果下一个时隙还是空闲，继续以概率p发送数据，以1-p推迟到再下一个时隙发送数据，重复这个过程至发送成功或监听到信道忙。</li></ul><p style="text-indent:2em">一般提到CSMA，都是指CSMA/CD或CSMA/CA，即具有碰撞检测(CD)的载波侦听多路访问和碰撞避免(CA)的载波侦听多路访问。下面先介绍CSMA/CD，这个协议其实在现在的网络中已经没有必要使用了，因为以太网交换机一般是全双工的，一条线路发数据，一条线路接收数据，不会产生冲突。CSMA/CA一般用于无线网络，因为无线网络中碰撞检测困难，在无线网络章节中介绍。</p><p><strong>具有碰撞检测的载波侦听多路访问CSMA/CD</strong></p><p style="text-indent:2em">如果能检测到信道中的碰撞，就可以在碰撞后立刻放弃传输损坏的帧，避免传输一个无用的帧，改善性能。检测方式就是适配器在传输时检测是否有来自其他适配器的信号能量，如果有，就中止当前帧的传输。不过这也对帧长和传输时间有了要求，如果一个正在传输的帧发生了碰撞，那么碰撞信号传回来到适配器的时间，应该小于帧传输的时间，这样才能提前停止无效帧的传输，提高性能。因此在CSMA/CD中，做以下约定：</p><ul><li>使用CSMA/CD协议的以太网争用期(碰撞窗口)<ul><li>发送帧的主机最多经过以太网端到端往返传播时延2t时间，就可检测到碰撞，这个时间称为争用期</li><li>争用期内没有检测到碰撞则确定不会发生碰撞</li><li>以太网规定2t取值为512比特时间</li></ul></li><li>使用CSMA/CD协议的以太网的最小帧长和最大帧长<ul><li>最小帧长 = 争用期*信道带宽(10Mbps的以太网，最小帧长为64字节)</li><li>最小帧长保证了主机可在帧发送完成前检测到该帧是否发生了碰撞</li><li>为了防止主机长时间占用总线，以太网的帧长有限制(V2的MAC帧最大长度为1518字节)</li></ul></li></ul><p style="text-indent:2em">概括而言，<b>信号从起始节点到下一个节点的往返时间，必须小于传输最小帧的时间。</b>这样碰撞才能在该帧发送完之前才能检测到。</p><p style="text-indent:2em">当发生碰撞时，重发的间隔时间称为随机退避时间，<font color="red">以太网</font>的CSMA/CD协议使用的截断二进制指数退避算法如下：</p><ul><li>随机退避时间 = 争用期2t * 随机数r，r从离散整数集合{0,1…,(2^k-1)}中随机取一个，k = Min[重传次数，10]</li><li>重传16次仍不成功时，表示同时有太多主机打算发送数据，此时丢弃该帧并向高层报告</li></ul><h3 id="3-3-轮询协议"><a href="#3-3-轮询协议" class="headerlink" title="3.3 轮询协议"></a>3.3 轮询协议</h3><p style="text-indent:2em">最后一类协议是轮流协议，节点轮流占用信道进行数据传输。轮流协议也有许多种，简单介绍其中的两种：轮询协议和令牌传递协议。轮询协议中，有一个主节点，主节点每次告知每个节点最多能传输的帧，然后让节点轮流进行传输。令牌传递协议中，没有主节点，有一个称为令牌的特殊帧在节点之间以固定次序交换，只有持有令牌且有数据需要传输的节点才可以传输数据。如果节点没有数据要传输，就将令牌传递。以上两种协议都有缺点，最主要的是如果主节点有故障，或者令牌崩溃或停留在一个节点，整个信道的传输就会有问题。</p><h2 id="4-交换局域网"><a href="#4-交换局域网" class="headerlink" title="4.交换局域网"></a>4.交换局域网</h2><p style="text-indent:2em">互联网是由一个个小的网络连接而成，在网络层中，已经学习了这些网络是通过路由器连接起来，并通过RIP或OSPF这样的路由选择算法确定路径。接下来介绍交换局域网，即最小的网络，介绍在这样的网络中，数据是怎样传输的。在交换局域网中，网络层的数据报通过交换机在链路上转发，数据报被封装为链路层帧，使用链路层地址来转发。</p><h3 id="4-1-链路层寻址与ARP"><a href="#4-1-链路层寻址与ARP" class="headerlink" title="4.1 链路层寻址与ARP"></a>4.1 链路层寻址与ARP</h3><p><strong>MAC地址</strong></p><p style="text-indent:2em">每一个主机或路由器的适配器(网络接口)都有一个链路层地址，被称为MAC地址。每个MAC地址都是独一无二的，由厂商生产时指定，通常情况下，适配器的MAC地址是固定的，无论在哪里使用，都不会变化。MAC地址有6个字节，48位，用十六进制表示为XX-XX-XX-XX-XX-XX。当适配器要向目的适配器发送一个帧时，要在帧首部加入目的适配器的MAC地址。适配器接收到帧，检查帧中的目的MAC地址是否与自己的MAC地址匹配，如果匹配，则接收该帧。有时适配器需要广播帧，只需要将目的MAC地址设置为FF-FF-FF-FF-FF-FF，就可以让所有适配器接收该帧。</p><p style="text-indent:2em">在主机和路由器接口有网络层地址，也有MAC地址，主要的原因有以下几个：</p><ul><li>局域网是为任意网络层协议设计的，不止用于IP和因特网，因此需要一个链路层地址。</li><li>如果适配器使用网络地址，网络地址必须存储在适配器的RAM中，并且每次适配器移动都要重新配置。</li><li>如果适配器不使用任何地址，把数据报上交到网络层，让网络层核对IP地址是否匹配，会导致主机被局域网上发送的每个帧中断。</li></ul><p style="text-indent:2em">由于以上几点和一些其他的原因，链路层需要有自己的寻址方案，因此使用MAC地址。</p><p><strong>地址解析协议</strong></p><p style="text-indent:2em">因为存在IP地址和MAC地址，所以需要在这两个地址间进行转换。这个转换由<b>地址解析协议(ARP)</b>来完成。</p><p style="text-indent:2em">链路层帧是网络层数据报的封装，需要根据IP地址确认目的MAC地址。ARP协议就是根据IP地址，确认目的MAC地址的协议。每台主机或路由器都在内存中有一个ARP表，记录了IP地址和MAC地址的映射关系。当主机需要知道一个IP地址对应的MAC地址时，构造一个ARP分组，包含源IP与MAC地址，目的IP地址，广播该ARP分组，网络中的每个适配器都收到该帧，并将其交付给网络层，网络层会检查ARP请求的目的IP地址是否与自己的IP地址匹配，如果匹配，就构造一个包含自己MAC地址的ARP响应帧，发给发出ARP请求的主机。源主机收到后，将映射存入ARP表，并相应的有一个TTL值，在TTL时间内保存该映射。需要注意的是，<b>ARP只为在同一个子网的主机和路由器接口解析IP地址</b>，路由器不会转发ARP请求到其他网络。</p><div class="table-container"><table><thead><tr><th style="text-align:center">IP地址</th><th style="text-align:center">MAC地址</th><th style="text-align:center">TTL</th></tr></thead><tbody><tr><td style="text-align:center">222.222.222.221</td><td style="text-align:center">88-B2-2F-54-1A-0F</td><td style="text-align:center">13:45:00</td></tr><tr><td style="text-align:center">222.222.222.223</td><td style="text-align:center">5C-66-AB-90-75-B1</td><td style="text-align:center">13:52:00</td></tr></tbody></table></div><p><strong>发送数据到子网外</strong></p><p style="text-indent:2em">考虑主机向子网外的目的主机发送数据，通过IP地址，可以得知目的主机与源主机不在同一子网，那么就不能使用ARP找到目的IP的MAC地址，必须先通过路由器将帧转发到目的IP所在的子网中，因此主机应该先发送ARP请求，ARP请求的目的IP为第一跳路由器地址，获得MAC地址后，将该地址封装进帧，发送给路由器，然后由路由器进行处理。注意主机发送出去的帧，封装的IP数据报的目的IP为目的主机的IP，而目的MAC地址则是该报文下一站的MAC地址，目的MAC地址是由所经过的路由器，在路由表确认下一站的IP地址经ARP请求解析得到的。</p><p><img src="/2022/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B004/image-20221213211801595.png" alt="image-20221213211801595" style="zoom:67%;"></p><p style="text-indent:2em">上图中的帧首部是简化了的，只是为了说明发送数据到子网外时，帧的形成情况。下面介绍以太网时，会看到帧首部的完整内容。</p><h3 id="4-2-以太网"><a href="#4-2-以太网" class="headerlink" title="4.2 以太网"></a>4.2 以太网</h3><p style="text-indent:2em">以太网是有线局域网技术的一种，但经历了与ATM，令牌环等技术的竞争后，现在已经占领了几乎现在所有的优先局域网市场。这是由于以太网部署的较早，且速率总是能够比其他技术更快，并且硬件也随着其大规模应用价格极低。起初的以太网是用集线器将主机连接起来的，集线器是物理层设备，作用于比特，只把输入的比特重新生成，以更大的能量强度向其他所有接口传输出去，因此最早的采用集线器的星型拓扑的局域网其实是一个广播局域网。21世纪初，交换机替换了集线器，稍后会介绍交换机的工作内容和流程。接下来先介绍一下以太网帧和以太网技术。</p><p><strong>以太网帧</strong></p><p style="text-indent:2em">以太网帧的格式如下：</p><p><img src="/2022/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B004/image-20221213213746275.png" alt="image-20221213213746275" style="zoom:67%;"></p><ul><li>前同步码：以太网帧以8字节的前同步码开始，前7字节值为10101010，最后一个字节是10101011。前7个字节用于唤醒适配器，同步时钟，最后一个字节的最后两个1告诉适配器重要的数据就要到来。</li><li>数据字段：46-1500字节。以太网的最大传输单元(MTU)是1500字节，超过1500字节，主机必须将数据报分片。</li></ul><p style="text-indent:2em">以太网提供的是无连接的不可靠服务，因此首部非常简单，而其尾部的CRC也只用于检验，无论帧是否通过CRC检验，适配器都不发出确认或否定确认，只在不通过检验时丢弃帧。如果上层运输层协议使用了TCP，那么会通过TCP实现可靠传输，丢失的报文会重传，但在链路层这个层次，以太网并不知道传输的数据时新的还是重传的。</p><p><strong>以太网技术</strong></p><p style="text-indent:2em">以太网在多年的发展过程中，已经经历了一系列的演化，也有许多不同标准，从速率上看，已经经历了10Mbps，100Mbps，40Gbps的发展，但是以太网帧和MAC协议一直都没有改变。不过对于今天的以太网，连接链路的交换机已经是全双工的了，一台交换机和一个节点可以同时向对方发送帧而互不干扰，因此MAC协议已经是没有必要使用的了。</p><h3 id="4-3-链路层交换机"><a href="#4-3-链路层交换机" class="headerlink" title="4.3 链路层交换机"></a>4.3 链路层交换机</h3><p style="text-indent:2em">目前为止，已经介绍了以太网相关的内容和链路层寻址等问题，还没有仔细介绍过在局域网中，把一段一段链路连接起来的交换机，接下来就介绍交换机的工作内容和工作方式。</p><p style="text-indent:2em">交换机的任务是接收入链路层帧并将他们转发到出链路，对于主机和路由器来说，交换机是透明的，就向链路的一部分一样，并不知道交换机会接收并转发帧。交换机的转发是通过交换机表(CAM:ContextAddress Memory)完成的。以下是一个交换机表，其中的时间是接收到帧的时间。</p><div class="table-container"><table><thead><tr><th style="text-align:center">地址</th><th style="text-align:center">接口</th><th style="text-align:center">时间</th></tr></thead><tbody><tr><td style="text-align:center">62-DE-F7-11-89-A3</td><td style="text-align:center">1</td><td style="text-align:center">9:36</td></tr><tr><td style="text-align:center">7C-BA-B2-B4-91-10</td><td style="text-align:center">3</td><td style="text-align:center">9:32</td></tr></tbody></table></div><p style="text-indent:2em">交换机收到帧后，对帧的处理有三种：</p><ul><li>如果能在CAM表中查询到目的主机所在端口，且该端口不是接收帧的源端口，交换机把帧从这一端口转发出去。</li><li>如果目的主机端口和接收帧的源端口是同一端口，过滤掉该帧。</li><li>如果交换机不能查询到目的主机的端口，就将该帧从源端口以外的其他所有端口洪泛发送出去，如果该帧是广播帧，也进行洪泛发送。</li></ul><p style="text-indent:2em">交换机是<b>自学习的</b>，不需要对交换机表配置。交换机表初始为空，每接收到一个帧，就将其源MAC地址，到达接口，到达时间添加到交换机表中，在一段时间后如果没有收到该地址的帧，就删除表项。交换机的自学习也意味着他是一个即插即用设备，不需要进行任何配置，只需要连接接口。</p><p style="text-indent:2em">交换机有一些特性或可称为优点，不同于基于集线器或总线的广播链路：</p><ul><li>消除碰撞：交换机缓存帧并只在网段上同一时间传输不超过一个帧，没有因碰撞浪费的带宽。</li><li>异质链路：交换机将链路隔离，不同链路可以以不同的速率在不同的媒体上运行。</li><li>管理：交换机易于进行网络管理。例如，如果一个适配器工作异常并持续发送以太网帧，交换机能够检测到该问题，并在内部断开异常适配器。</li></ul><h3 id="4-4-交换机与路由器的比较"><a href="#4-4-交换机与路由器的比较" class="headerlink" title="4.4 交换机与路由器的比较"></a>4.4 交换机与路由器的比较</h3><p style="text-indent:2em">路由器和交换机都是存储转发分组交换机，但一个工作在网络层，一个工作在链路层，从根本上是不同的，但是安装互联设备时，也常常需要在这两个设备之间作出选择。下面分别讨论交换机和路由器的优点和缺点。</p><p style="text-indent:2em">交换机的优点是即插即用，并且具有较高的分组过滤和转发速率，因为只需要处理链路层的帧。缺点是为了防止广播帧的循环，必须限制网络拓扑结构为生成树；且交换机不对广播风暴有任何保护措施，如果主机故障不停广播，交换机将转发所有广播帧；此外，如果内部都使用交换机，使网络整体很大，主机和路由器中就必须有大的ARP表，这产生了可观的ARP流量和处理量。</p><p style="text-indent:2em">路由器的优点是网络寻址是分层次的，分组不会通过路由器循环，IP首部也有字段避免循环，因此网络拓扑不受限制；另一个优点是对广播风暴提供了防火墙保护。路由器的缺点在于不是即插即用的，需要人为配置IP地址；而且路由器处理分组时间较长，需要处理到网络层的字段。</p>]]></content>
      
      
      <categories>
          
          <category> cs基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理实验四</title>
      <link href="/2022/11/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E5%9B%9B/"/>
      <url>/2022/11/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p style="text-indent:2em">cminus-f的词法分析和语法分析部分已经完成，最终得到的是语法分析树。而为了产生目标代码，还需要将语法分析树转为抽象语法树，通过抽象语法分析树生成中间代码(即IR)，最后使用中间代码来进行优化并生成目标代码。在本实验中，只要完成中间表示IR的生成，语法分析树到抽象语法树的转换已经在框架中提供了，而IR代码到目标代码的生成由clang来完成。</p><p style="text-indent:2em">生成IR指令的过程为在访问者模式下访问抽象语法树。本次实验要完成的就是访问抽象语法树的相关visit函数，在这些visit函数中要完成IR指令的生成。</p><h2 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h2><h3 id="1-使用AST和visit函数生成IR指令"><a href="#1-使用AST和visit函数生成IR指令" class="headerlink" title="1.使用AST和visit函数生成IR指令"></a>1.使用AST和visit函数生成IR指令</h3><p style="text-indent:2em">由于cminus-f的语法还是比lab3中计算器要复杂的多，供参考的抽象语法树的打印代码也还是和生成IR指令由很大差别，在开始编写时存在困难。通过阅读AST的头文件和lab3的visitor.cpp，首先确定了visit函数生成IR指令的过程：</p><ul><li>visit函数调用当前节点的子节点accept函数，即调用子节点的visit函数</li><li>处理当前节点，生成指令</li></ul><p style="text-indent:2em">若子节点需要向父节点传值，则通过全局变量来实现。在visit节点时还要加入语义分析的部分，判断语义是否正确。</p><p style="text-indent:2em">为了进一步弄清楚遍历AST生成IR的过程，在各个visit函数中加入logging信息，也为后续排查错误做好准备。然后首先完成较为简单的表达式处理等部分，通过这个过程逐渐熟悉IR转换和层次关系以及传值的过程，最后完成困难的visit函数。并在实现过程中逐步用简单的cminus程序测试，用logging找到出错的位置，完成逐个函数的设计。</p><p style="text-indent:2em">以第一个产生式program->declaration-list为例，首先找到节点的定义，program节点包含一个保存了declaration的vector，因此在visit中要逐个调用这些declaration节点的accept函数。Program只需要产生声明，不需要产生IR，只需要进行语义分析，在语义说明中给出了以下规则：</p><ul><li>一个程序由一系列声明组成，声明包括了函数声明与变量声明，它们可以以任意顺序排列。</li><li>一个程序中至少要有一个声明且最后一个声明必须是 void main(void)形式的函数声明。</li></ul><p style="text-indent:2em">只需要对第二条进行检查，判断至少有一个声明，且最后一个声明是否是void main(void)形式的函数声明。在Declaration类型的节点中有id和type，进行检查即可，其中type是CminusType类型，在hpp开头枚举。因此Program节点的visit函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTProgram &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;Program\n&quot;</span>;</span><br><span class="line">    <span class="comment">//语义检查</span></span><br><span class="line">    <span class="keyword">if</span>(node.declarations.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR: 该程序中没有声明。\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(node.declarations.<span class="built_in">back</span>()-&gt;id==<span class="string">&quot;main&quot;</span>&amp;&amp; node.declarations.<span class="built_in">back</span>()-&gt;type==TYPE_VOID))&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR: 最后一个声明不是void main(void)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//访问declarations子节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> dec: node.declarations)</span><br><span class="line">        dec-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="2-函数参数的处理"><a href="#2-函数参数的处理" class="headerlink" title="2.函数参数的处理"></a>2.函数参数的处理</h3><p style="text-indent:2em">在编写FunDeclaration和Param的visit函数时，不明确参数具体的处理方法。找到lab3中由clang生成的.ll，对于参数的处理都是先分配空间，然后使用store指令将参数值存入分配好的空间。例如以下程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define i32 @<span class="built_in">callee</span>(i32 %<span class="number">0</span>) #<span class="number">0</span> &#123;</span><br><span class="line">    %<span class="number">2</span> = alloca i32</span><br><span class="line">    store i32 %<span class="number">0</span>, i32* %<span class="number">2</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">但是Param的参数只有id，表示的是源程序中的参数名，对于如何找到这个参数产生了疑惑。重新找到lab3中编写的cpp传参的部分，传参是在函数创建以后，通过Function中的iterator获取得到的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入callee的BasicBlock中的指令</span></span><br><span class="line">std::vector&lt;Value *&gt; args;                      <span class="comment">//获取函数的形参,通过Function中的iterator</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> arg = callee-&gt;<span class="built_in">arg_begin</span>(); arg != callee-&gt;<span class="built_in">arg_end</span>(); arg++) &#123;</span><br><span class="line">    args.<span class="built_in">push_back</span>(*arg);                       <span class="comment">//* 号运算符是从迭代器中取出迭代器当前指向的元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> mul = builder-&gt;<span class="built_in">create_imul</span>(args[<span class="number">0</span>], <span class="built_in">CONST_INT</span>(<span class="number">110</span>));             <span class="comment">//mul = a*2</span></span><br></pre></td></tr></table></figure><p style="text-indent:2em">此处获取参数的部分，是直接按lab3提供的gcd_array.cpp仿照编写的，因为理解不够深入，所以在本实验处理参数时又产生了疑惑。回顾lab3此部分代码后，FunDeclaration中的参数存储的部分就没有问题了。与lab3不同的是，FunDeclaration是逐个调用Param的accept函数，完成存储空间分配的，所以需要一个全局变量在FunDeclaration和Param的visit函数之间传递arg。</p><h3 id="3-ASTVar的处理"><a href="#3-ASTVar的处理" class="headerlink" title="3.ASTVar的处理"></a>3.ASTVar的处理</h3><p style="text-indent:2em">根据cminus的语义说明，Var可以是整型变量，浮点变量或数组变量。如果是数组变量，需要判断下标是否为负，如果为负则添加neg_idx_except指令退出程序，否则计算对应元素的地址(gep指令)。如果是数组，则下标可能是个表达式，需要确保表达式的返回结果为整型，然后才能进行取元素的操作。</p><p style="text-indent:2em">从上面的语义说明可以理解Var是一种变量。但是下面的赋值语义说明：先找到var代表的变量地址（如果是数组，需要先对下标表达式求值），然后对右侧的表达式进行求值，求值结果将在转换成变量类型后存储在先前找到的地址中。同时，存储在var中的值将作为赋值表达式的求值结果。一开始结合Var节点中含有一个表达式，把这句话错误的理解为了在Var的visit函数内要完成找到地址，求表达式的值并赋值的指令。后来为了进一步理解Var变量的visit函数内要产生什么指令，继续阅读了剩下的产生式，最终找到Var出现的两种情况：</p><ul><li>expression→var = expression | simple-expression</li><li>factor→(expression) | var | call | integer | float</li></ul><p style="text-indent:2em">这两种情况下对于var的处理是不同的。对于第一种情况，var是赋值表达式的一个组成部分，在访问赋值表达式时，应该访问Var，在全局变量ret中保存Var的地址，然后进行赋值，产生store指令；而第二种情况，应该将Var的值取出保存到ret中，作为因子参与计算表达式的计算。因此访问Var节点时，需要知道是从哪种情况访问的，为此添加一个全局变量ifAssign，如果访问赋值语句，就将该变量置为true，访问Var时返回地址。</p><p style="text-indent:2em">解决了以上问题后，就可以根据是否有指向expression的指针判断是否为数组，然后取出相应的值或者地址了。如果是数组，还要对下标进行处理。如果下标为负则终止程序，这可以通过跳转到一个仅含终止指令的exitBasicBlock实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ifNegative = builder-&gt;<span class="built_in">create_icmp_lt</span>(idx, <span class="built_in">CONST_INT</span>(<span class="number">0</span>));</span><br><span class="line"><span class="comment">//创建exitBasicBlock和正常继续的BasicBlock</span></span><br><span class="line"><span class="keyword">auto</span> exitBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), node.id + <span class="string">&quot;exit&quot;</span>, func);</span><br><span class="line"><span class="keyword">auto</span> nextBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), node.id + <span class="string">&quot;next&quot;</span>, func);</span><br><span class="line"><span class="comment">//条件跳转指令</span></span><br><span class="line">builder-&gt;<span class="built_in">create_cond_br</span>(ifNegative, exitBB, nextBB);</span><br></pre></td></tr></table></figure><p style="text-indent:2em">处理非数组变量比较简单，处理数组变量时又产生了问题，因为数组获取元素地址有两种方式，即lab3中的两种getelementptr，分别需要两个偏移和一个偏移。为了明确如何处理数组，得到数组元素的指针，重新比较两种数组的分配的IR形式：</p><ul><li>%1  = alloca [10 x i32]</li><li>%1 = alloca i32*</li></ul><p style="text-indent:2em">可以看出，第一种分配的是数组，得到的是指向数组的指针。第二种分配的是指针，这个指针是数组的首地址，返回的值是一个指向指针的指针。因此取元素地址时，使用第一种分配方式，直接对%1使用两个偏移的getelementptr，就得到了元素的地址；使用第二种分配方式，需要先使用load取出指针(数组首地址)，然后使用一个偏移获取元素地址。因此在Var的visit函数中，处理如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> var = scope.<span class="built_in">find</span>(node.id);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">处理非数组，数组下标，检查下标不为负....</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//如果var的值是指向数组的指针，需要两个偏移取地址</span></span><br><span class="line"><span class="keyword">if</span>(var-&gt;<span class="built_in">get_type</span>()-&gt;<span class="built_in">get_pointer_element_type</span>()-&gt;<span class="built_in">is_array_type</span>())</span><br><span class="line">    builder-&gt;<span class="built_in">create_gep</span>(var, &#123; <span class="built_in">CONST_INT</span>(<span class="number">0</span>), idx &#125;);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(var-&gt;<span class="built_in">get_type</span>()-&gt;<span class="built_in">get_pointer_element_type</span>()-&gt;<span class="built_in">is_pointer_type</span>())&#123;</span><br><span class="line">    <span class="comment">//从var中取出数组的起始地址</span></span><br><span class="line">    var = builder-&gt;<span class="built_in">create_load</span>(var);          <span class="comment">//a[]的地址</span></span><br><span class="line">    var = builder-&gt;<span class="built_in">create_gep</span>(var, &#123; idx &#125;);  <span class="comment">//a[idx]的地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ERROR: 变量&quot;</span> &lt;&lt; node.id &lt;&lt; <span class="string">&quot;不是一个数组\n&quot;</span>;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">处理好以上两个问题后，剩下的部分就比较简单了。最终完整的Var的visit函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTVar &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;Var\n&quot;</span>;</span><br><span class="line">    <span class="comment">//先在作用域找到变量</span></span><br><span class="line">    <span class="keyword">auto</span> var = scope.<span class="built_in">find</span>(node.id);</span><br><span class="line">    <span class="keyword">if</span>(var==<span class="literal">nullptr</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR: 未声明的变量&quot;</span> &lt;&lt; node.id &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">//处理不是数组的情况</span></span><br><span class="line">    <span class="keyword">if</span>(node.expression==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ifAssign)&#123;                             <span class="comment">//直接返回地址</span></span><br><span class="line">            ret = var;</span><br><span class="line">            ifAssign = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//数组的指针即a[]类型就返回数组的起始地址，否则load取值</span></span><br><span class="line">            <span class="keyword">if</span>(var-&gt;<span class="built_in">get_type</span>()-&gt;<span class="built_in">get_pointer_element_type</span>()-&gt;<span class="built_in">is_array_type</span>())</span><br><span class="line">                ret = builder-&gt;<span class="built_in">create_gep</span>(var, &#123;<span class="built_in">CONST_INT</span>(<span class="number">0</span>), <span class="built_in">CONST_INT</span>(<span class="number">0</span>)&#125;);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ret = builder-&gt;<span class="built_in">create_load</span>(var);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理数组的情况</span></span><br><span class="line">    node.expression-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    Value *idx = ret;                             <span class="comment">//下标</span></span><br><span class="line">    <span class="keyword">if</span>(idx-&gt;<span class="built_in">get_type</span>()-&gt;<span class="built_in">is_float_type</span>())          <span class="comment">//如果为浮点类型，转换为整型</span></span><br><span class="line">        idx = builder-&gt;<span class="built_in">create_fptosi</span>(idx, INT32_Type);</span><br><span class="line">    <span class="keyword">auto</span> func = builder-&gt;<span class="built_in">get_insert_block</span>()-&gt;<span class="built_in">get_parent</span>();</span><br><span class="line">    <span class="keyword">auto</span> ifNegative = builder-&gt;<span class="built_in">create_icmp_lt</span>(idx, <span class="built_in">CONST_INT</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//创建exitBasicBlock和正常继续的BasicBlock</span></span><br><span class="line">    <span class="keyword">auto</span> exitBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), node.id + <span class="string">&quot; exit&quot;</span>, func);</span><br><span class="line">    <span class="keyword">auto</span> nextBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), node.id + <span class="string">&quot; next&quot;</span>, func);</span><br><span class="line">    <span class="comment">//条件跳转指令</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_cond_br</span>(ifNegative, exitBB, nextBB);</span><br><span class="line">    <span class="comment">//向exitBB插入退出程序的指令</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(exitBB);</span><br><span class="line">    <span class="keyword">auto</span> fail = scope.<span class="built_in">find</span>(<span class="string">&quot;neg_idx_except&quot;</span>);               </span><br><span class="line">    builder-&gt;<span class="built_in">create_call</span>(<span class="built_in">static_cast</span>&lt;Function*&gt;(fail), &#123;&#125;); </span><br><span class="line">    builder-&gt;<span class="built_in">create_br</span>(nextBB);</span><br><span class="line">    <span class="comment">//向nextBB插入正常执行的指令</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(nextBB);</span><br><span class="line">    <span class="comment">//如果var的值是指向数组的指针，需要两个偏移取地址</span></span><br><span class="line">    <span class="keyword">if</span>(var-&gt;<span class="built_in">get_type</span>()-&gt;<span class="built_in">get_pointer_element_type</span>()-&gt;<span class="built_in">is_array_type</span>())</span><br><span class="line">        builder-&gt;<span class="built_in">create_gep</span>(var, &#123; <span class="built_in">CONST_INT</span>(<span class="number">0</span>), idx &#125;);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(var-&gt;<span class="built_in">get_type</span>()-&gt;<span class="built_in">get_pointer_element_type</span>()-&gt;<span class="built_in">is_pointer_type</span>())&#123;</span><br><span class="line">        <span class="comment">//从var中取出数组的起始地址</span></span><br><span class="line">        var = builder-&gt;<span class="built_in">create_load</span>(var);          <span class="comment">//a[]的地址</span></span><br><span class="line">        var = builder-&gt;<span class="built_in">create_gep</span>(var, &#123; idx &#125;);  <span class="comment">//a[idx]的地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR: 变量&quot;</span> &lt;&lt; node.id &lt;&lt; <span class="string">&quot;不是一个数组\n&quot;</span>;</span><br><span class="line">    <span class="comment">//判断是赋值还是变量引用</span></span><br><span class="line">    <span class="keyword">if</span>(ifAssign)&#123;                             <span class="comment">//直接返回地址</span></span><br><span class="line">        ret = var;</span><br><span class="line">        ifAssign = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = builder-&gt;<span class="built_in">create_load</span>(var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-表达式顺序错误"><a href="#4-表达式顺序错误" class="headerlink" title="4.表达式顺序错误"></a>4.表达式顺序错误</h3><p style="text-indent:2em">在完成了整个实验后，进行测试，发现无法通过最后一个testcase。打开12.minus查看代码，其中有函数调用和一些基本运算，一开始不确定错误在什么位置，因为此时编译已经没有问题了，只可能是语义处理的问题。经过一些尝试后，改写了lab4_test.py，将运行的结果与正确的结果输出，分别为-39和39，通过这个结果将错误定位到函数调用，然后检查生成的.ll代码，发现函数gcd中有一个减法，操作数的顺序错误。因此找到了加法表达式中创建指令时，传值传反了的错误。additive-expression的产生式为：additive-expression -→ additive-expression addop term | term。生成运算指令时，加法表达式的结果应该在左边，编写时没有注意到这个问题，所以导致了结果的错误。修改后，testcases全部通过。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">if</span>(node.op==OP_PLUS)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ifInt)</span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_iadd</span>(addRes, mulRes);     <span class="comment">//addRes在左!</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_fadd</span>(addRes, mulRes);  </span><br><span class="line">    &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h2><h3 id="1-全局变量与宏定义"><a href="#1-全局变量与宏定义" class="headerlink" title="1.全局变量与宏定义"></a>1.全局变量与宏定义</h3><p style="text-indent:2em">补充了一个CONST_INT()宏定义获取常量值。INT32_Type和FLOAT_TYPE获取int32和float类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONST_INT(num) \</span></span><br><span class="line"><span class="meta">    ConstantInt::get((int)num, module.get())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT32_Type \</span></span><br><span class="line"><span class="meta"> Type::get_int32_type(module.get())      </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLOAT_Type \</span></span><br><span class="line"><span class="meta"> Type::get_float_type(module.get())</span></span><br></pre></td></tr></table></figure><p style="text-indent:2em">全局变量ret用于节点返回值。arg用于传递参数。ifAssign表示访问Var节点时，应该返回值还是变量地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Value* ret;</span><br><span class="line">Value* arg;</span><br><span class="line"><span class="type">bool</span> ifAssign = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="2-visit函数"><a href="#2-visit函数" class="headerlink" title="2.visit函数"></a>2.visit函数</h3><h4 id="Program"><a href="#Program" class="headerlink" title="Program"></a><strong>Program</strong></h4><p style="text-indent:2em">检查语义后，逐个访问declarations。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTProgram &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;Program\n&quot;</span>;</span><br><span class="line">    <span class="comment">//语义检查</span></span><br><span class="line">    <span class="keyword">if</span>(node.declarations.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR: 该程序中没有声明。\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(node.declarations.<span class="built_in">back</span>()-&gt;id==<span class="string">&quot;main&quot;</span>&amp;&amp; node.declarations.<span class="built_in">back</span>()-&gt;type==TYPE_VOID))&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR: 最后一个声明不是void main(void)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//访问declarations子节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> dec: node.declarations)</span><br><span class="line">        dec-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Num"><a href="#Num" class="headerlink" title="Num"></a>Num</h4><p style="text-indent:2em">数值节点没有子节点，直接进行处理，根据type确认数值类型，然后将值保存到全局变量value中。根据语义规则，只能有整型和浮点数两个类型。但此处的检查是没有必要的，因为其他数据类型会在词法分析时被识别为标识符，在语法分析时就会产生错误。而VOID类型在变量声明时进行检查，保证变量声明只有整型和浮点型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTNum &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;Num\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(node.type == TYPE_INT)</span><br><span class="line">        ret = <span class="built_in">CONST_INT</span>(node.i_val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node.type == TYPE_FLOAT)</span><br><span class="line">        ret = <span class="built_in">CONST_FP</span>(node.f_val);</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">//没有子节点，直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="VarDeclaration"><a href="#VarDeclaration" class="headerlink" title="VarDeclaration"></a><strong>VarDeclaration</strong></h4><p style="text-indent:2em">根据节点的定义，节点中包含一个类型和一个指针，还有继承自ASTDeclaration的id。对于变量声明节点的处理，需要产生分配空间的IR，在处理时还要区分数组与一般变量(根据节点的指针是否为空区分)，局部变量与全局变量。并且要把声明的变量放入当前作用域中，保证后续使用可以找到。根据语义规则，全局变量需要初始化为0，数组变量声明时，大小应该大于0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTVarDeclaration &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;VarDeclaration\n&quot;</span>;</span><br><span class="line">    Type *varType;</span><br><span class="line">    <span class="keyword">if</span>(node.type==TYPE_INT)</span><br><span class="line">        varType = INT32_Type;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node.type==TYPE_FLOAT)</span><br><span class="line">        varType = FLOAT_Type;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        std::cout &lt;&lt;<span class="string">&quot;ERROR: 在变量声明中，只有整型和浮点型可以使用\n&quot;</span>;</span><br><span class="line">    <span class="comment">//对变量进行空间分配</span></span><br><span class="line">    <span class="keyword">if</span>(scope.<span class="built_in">in_global</span>())&#123;           <span class="comment">//全局变量</span></span><br><span class="line">        <span class="keyword">if</span>(node.num==<span class="literal">nullptr</span>)&#123;    <span class="comment">//非数组</span></span><br><span class="line">            <span class="keyword">auto</span> initializer = <span class="built_in">CONST_ZERO</span>(varType);</span><br><span class="line">            <span class="keyword">auto</span> globalVar = GlobalVariable::<span class="built_in">create</span>(node.id, <span class="keyword">module</span>.<span class="built_in">get</span>(), varType, <span class="literal">false</span>, initializer);</span><br><span class="line">            scope.<span class="built_in">push</span>(node.id, globalVar);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.num-&gt;i_val&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">auto</span> *array = ArrayType::<span class="built_in">get</span>(varType, node.num-&gt;i_val);</span><br><span class="line">                <span class="keyword">auto</span> initializer = <span class="built_in">CONST_ZERO</span>(array);</span><br><span class="line">                <span class="keyword">auto</span> globalVar = GlobalVariable::<span class="built_in">create</span>(node.id, <span class="keyword">module</span>.<span class="built_in">get</span>(), array, <span class="literal">false</span>, initializer);</span><br><span class="line">                scope.<span class="built_in">push</span>(node.id, globalVar);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;ERROR: 数组长度必须大于0\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;                          <span class="comment">//局部变量</span></span><br><span class="line">        <span class="keyword">if</span>(node.num==<span class="literal">nullptr</span>)&#123;     <span class="comment">//非数组</span></span><br><span class="line">             <span class="keyword">auto</span> localVar = builder-&gt;<span class="built_in">create_alloca</span>(varType);</span><br><span class="line">             scope.<span class="built_in">push</span>(node.id, localVar);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.num-&gt;i_val&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">auto</span> *array = ArrayType::<span class="built_in">get</span>(varType, node.num-&gt;i_val);</span><br><span class="line">                <span class="keyword">auto</span> localVar = builder-&gt;<span class="built_in">create_alloca</span>(array);</span><br><span class="line">                scope.<span class="built_in">push</span>(node.id, localVar);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;ERROR: 数组长度必须大于0\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FunDeclaration"><a href="#FunDeclaration" class="headerlink" title="FunDeclaration"></a><strong>FunDeclaration</strong></h4><p style="text-indent:2em">FunDeclaration节点包含一个形参列表param和复合语句compound-stmt。需要创建的IR是创建函数和创建函数的第一个BasicBlock的指令，然后处理复合语句。在进入函数时要进入函数作用域，创建函数时要处理参数与返回值。对于每个参数，用全局变量取出实参，调用accept函数进行处理，在Param的visit函数中完成存储空间的分配，并加入到函数作用域当中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTFunDeclaration &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;FunDeclaration\n&quot;</span>;</span><br><span class="line">    Type *retType;                 <span class="comment">//函数返回类型</span></span><br><span class="line">    std::vector&lt;Type *&gt; paramType; <span class="comment">//参数类型</span></span><br><span class="line">    FunctionType *funType;         <span class="comment">//函数类型</span></span><br><span class="line">    <span class="comment">//语义检查</span></span><br><span class="line">    <span class="keyword">if</span>(node.id==<span class="string">&quot;main&quot;</span> &amp;&amp; node.params.<span class="built_in">size</span>()&gt;<span class="number">0</span>)</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;ERROR: main函数必须为void main(void)形式\n&quot;</span>;</span><br><span class="line">    <span class="comment">//确定函数的返回类型</span></span><br><span class="line">    <span class="keyword">if</span>(node.type==TYPE_INT)</span><br><span class="line">        retType = INT32_Type;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node.type==TYPE_FLOAT)</span><br><span class="line">        retType = FLOAT_Type;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node.type==TYPE_VOID)</span><br><span class="line">        retType = Type::<span class="built_in">get_void_type</span>(<span class="keyword">module</span>.<span class="built_in">get</span>());</span><br><span class="line">    <span class="comment">//确定函数的参数类型</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> param : node.params)&#123;</span><br><span class="line">        <span class="keyword">if</span>(param-&gt;isarray)&#123;       <span class="comment">//参数为数组，则参数为数组的首地址指针</span></span><br><span class="line">            <span class="keyword">if</span>(param-&gt;type==TYPE_INT)</span><br><span class="line">                paramType.<span class="built_in">push_back</span>(Type::<span class="built_in">get_int32_ptr_type</span>(<span class="keyword">module</span>.<span class="built_in">get</span>()));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(param-&gt;type==TYPE_FLOAT)</span><br><span class="line">                paramType.<span class="built_in">push_back</span>(Type::<span class="built_in">get_int32_ptr_type</span>(<span class="keyword">module</span>.<span class="built_in">get</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;                    <span class="comment">//参数为整型或浮点型</span></span><br><span class="line">            <span class="keyword">if</span> (param-&gt;type==TYPE_INT)       </span><br><span class="line">                paramType.<span class="built_in">push_back</span>(INT32_Type);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(param-&gt;type==TYPE_FLOAT)</span><br><span class="line">                paramType.<span class="built_in">push_back</span>(FLOAT_Type);     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建函数</span></span><br><span class="line">    funType = FunctionType::<span class="built_in">get</span>(retType, paramType);</span><br><span class="line">    <span class="keyword">auto</span> func = Function::<span class="built_in">create</span>(funType, node.id, <span class="keyword">module</span>.<span class="built_in">get</span>());</span><br><span class="line">    scope.<span class="built_in">push</span>(node.id, func);   <span class="comment">//将函数加入全局作用域</span></span><br><span class="line">    scope.<span class="built_in">enter</span>();               <span class="comment">//进入函数作用域</span></span><br><span class="line">    <span class="keyword">auto</span> entryBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), node.id + <span class="string">&quot;entry&quot;</span>, func);</span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(entryBB);     <span class="comment">//插入指令</span></span><br><span class="line">    <span class="comment">//visit参数节点</span></span><br><span class="line">    std::vector&lt;Value*&gt; args;    <span class="comment">//存储参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> arg = func-&gt;<span class="built_in">arg_begin</span>();arg != func-&gt;<span class="built_in">arg_end</span>();arg++) &#123;</span><br><span class="line">        args.<span class="built_in">push_back</span>(*arg);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; node.params.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> param = node.params[i];</span><br><span class="line">        arg = args[i];           </span><br><span class="line">        param-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理函数体内的语句</span></span><br><span class="line">    node.compound_stmt-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//如果BasicBlock最后没有终止指令，创建返回指令</span></span><br><span class="line">    <span class="keyword">if</span> (builder-&gt;<span class="built_in">get_insert_block</span>()-&gt;<span class="built_in">get_terminator</span>() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (func-&gt;<span class="built_in">get_return_type</span>()-&gt;<span class="built_in">is_void_type</span>())</span><br><span class="line">            builder-&gt;<span class="built_in">create_void_ret</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (func-&gt;<span class="built_in">get_return_type</span>()-&gt;<span class="built_in">is_float_type</span>())</span><br><span class="line">            builder-&gt;<span class="built_in">create_ret</span>(<span class="built_in">CONST_FP</span>(<span class="number">0.0</span>));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            builder-&gt;<span class="built_in">create_ret</span>(<span class="built_in">CONST_INT</span>(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    scope.<span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Param"><a href="#Param" class="headerlink" title="Param"></a><strong>Param</strong></h4><p style="text-indent:2em">在处理参数时，要为参数分配空间，使参数能够保留在函数的作用域内。在lab3中自行编写.ll文件时直接使用参数，不进行存储，直接使用就可以实现相同的逻辑。但在将cminus转换为IR时，cminus的语义规定了每次函数调用都会产生一组独立内存的参数，因此为参数分配空间，并存入作用域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTParam &amp;node)</span> </span>&#123;     </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;Param\n&quot;</span>; </span><br><span class="line">    Value* paramP; </span><br><span class="line">    <span class="keyword">if</span> (node.isarray) &#123;          <span class="comment">//数组</span></span><br><span class="line">        <span class="keyword">if</span> (node.type==TYPE_INT)        </span><br><span class="line">            paramP = builder-&gt;<span class="built_in">create_alloca</span>(Type::<span class="built_in">get_int32_ptr_type</span>(<span class="keyword">module</span>.<span class="built_in">get</span>()));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node.type==TYPE_FLOAT) </span><br><span class="line">            paramP = builder-&gt;<span class="built_in">create_alloca</span>(Type::<span class="built_in">get_float_ptr_type</span>(<span class="keyword">module</span>.<span class="built_in">get</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                       <span class="comment">//非数组</span></span><br><span class="line">        <span class="keyword">if</span> (node.type==TYPE_INT)       </span><br><span class="line">            paramP = builder-&gt;<span class="built_in">create_alloca</span>(INT32_Type);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node.type==TYPE_FLOAT)</span><br><span class="line">            paramP = builder-&gt;<span class="built_in">create_alloca</span>(FLOAT_Type);</span><br><span class="line">    &#125;</span><br><span class="line">    builder-&gt;<span class="built_in">create_store</span>(arg, paramP);         <span class="comment">//存储参数</span></span><br><span class="line">    scope.<span class="built_in">push</span>(node.id, paramP);                <span class="comment">//加入作用域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CompoundStmt"><a href="#CompoundStmt" class="headerlink" title="CompoundStmt"></a><strong>CompoundStmt</strong></h4><p style="text-indent:2em">每个函数内部都有一个复合语句，根据ASTCompoundStmt的定义，复合语句由局部声明和一系列语句构成。只需要逐个调用相应的accept函数，不需要产生IR。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTCompoundStmt &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;CompoundStmt\n&quot;</span>;</span><br><span class="line">    <span class="comment">//访问局部声明的节点和语句节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> local_declaration: node.local_declarations)</span><br><span class="line">        local_declaration-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> statement: node.statement_list)</span><br><span class="line">        statement-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ExpressionStmt"><a href="#ExpressionStmt" class="headerlink" title="ExpressionStmt"></a><strong>ExpressionStmt</strong></h4><p style="text-indent:2em">ExpressionStmt对应一条表达式或空，只要表达式存在，就处理该表达式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CminusfBuilder::visit</span><span class="params">(ASTExpressionStmt &amp;node)</span> &#123; </span><br><span class="line">    LOG(DEBUG) &lt;&lt; <span class="string">&quot;ExpressionStmt\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (node.expression != nullptr)</span><br><span class="line">node.expression-&gt;accept(*this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SelectionStmt"><a href="#SelectionStmt" class="headerlink" title="SelectionStmt"></a><strong>SelectionStmt</strong></h4><p style="text-indent:2em">SelectionStmt包含一个条件表达式，一个if语句块，还有可能存在的else语句块。先处理表达式，产生条件跳转语句。如果指向else语句块的指针为空，就说明只有if语句。考虑只有if的情况，在执行到if时，应该通过br指令条件跳转到if语句块或if后的部分。如果还有else语句，则通过br指令条件跳转到if语句块或else语句块，然后从这两个语句块的结尾返回或者跳转到ifelse语句之后的部分。因此在SelectionStmt的visit函数中应该至少生成三个BasicBlock，并生成br指令。根据else指针是否为空判断是否需要生成条件判断为false的BasicBlock。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTSelectionStmt &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;SelectionStmt\n&quot;</span>;</span><br><span class="line">    <span class="comment">//处理条件表达式</span></span><br><span class="line">    <span class="keyword">auto</span> func = builder-&gt;<span class="built_in">get_insert_block</span>()-&gt;<span class="built_in">get_parent</span>();</span><br><span class="line">    node.expression-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">auto</span> retType = ret-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    Value* ifExpression;                         <span class="comment">//条件表达式的结果             </span></span><br><span class="line">    <span class="comment">//根据返回类型处理, 生成比较语句</span></span><br><span class="line">    <span class="keyword">if</span>(retType-&gt;<span class="built_in">is_integer_type</span>())</span><br><span class="line">        ifExpression = builder-&gt;<span class="built_in">create_icmp_gt</span>(ret, <span class="built_in">CONST_ZERO</span>(INT32_Type));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ifExpression = builder-&gt;<span class="built_in">create_fcmp_gt</span>(ret, <span class="built_in">CONST_ZERO</span>(FLOAT_Type));</span><br><span class="line">    <span class="comment">//生成BasicBlock</span></span><br><span class="line">    <span class="keyword">auto</span> ifBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), <span class="string">&quot;ifBasicBlock&quot;</span>, func);</span><br><span class="line">    <span class="keyword">auto</span> elseBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), <span class="string">&quot;elseBasicBlock&quot;</span>, func);</span><br><span class="line">    <span class="keyword">auto</span> afterIfBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), <span class="string">&quot;afterIfBasicBlock&quot;</span>, func);</span><br><span class="line">    <span class="comment">//创建br指令</span></span><br><span class="line">    <span class="keyword">if</span>(node.else_statement==<span class="literal">nullptr</span>)             <span class="comment">//没有else</span></span><br><span class="line">        builder-&gt;<span class="built_in">create_cond_br</span>(ifExpression, ifBB, afterIfBB);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        builder-&gt;<span class="built_in">create_cond_br</span>(ifExpression, ifBB, elseBB);</span><br><span class="line">    <span class="comment">//为ifBB添加IR</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(ifBB);</span><br><span class="line">    node.if_statement-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (builder-&gt;<span class="built_in">get_insert_block</span>()-&gt;<span class="built_in">get_terminator</span>() == <span class="literal">nullptr</span>)</span><br><span class="line">builder-&gt;<span class="built_in">create_br</span>(afterIfBB);</span><br><span class="line">    <span class="comment">//为elseBB添加IR</span></span><br><span class="line">    <span class="keyword">if</span>(node.else_statement!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        builder-&gt;<span class="built_in">set_insert_point</span>(elseBB);</span><br><span class="line">        node.else_statement-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (builder-&gt;<span class="built_in">get_insert_block</span>()-&gt;<span class="built_in">get_terminator</span>() == <span class="literal">nullptr</span>)</span><br><span class="line">builder-&gt;<span class="built_in">create_br</span>(afterIfBB);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        elseBB-&gt;<span class="built_in">erase_from_parent</span>();</span><br><span class="line">    <span class="comment">//后面的语句块的IR在新的BasicBlock中</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(afterIfBB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="IterationStmt"><a href="#IterationStmt" class="headerlink" title="IterationStmt"></a><strong>IterationStmt</strong></h4><p style="text-indent:2em">与if语句类似，while迭代语句也有一个条件表达式，进行条件跳转。可以创建一个用于判断的ifBasicBlock，一个循环的loopBasicBlock，一个while语句后的afterWhileBasicBlock，添加相应的指令。当条件表达式为True时，进行ifBB->loopBB->ifBB的循环跳转。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTIterationStmt &amp;node)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;IterationStmt\n&quot;</span>;</span><br><span class="line">    <span class="comment">//创建BasicBlock</span></span><br><span class="line">    <span class="keyword">auto</span> func = builder-&gt;<span class="built_in">get_insert_block</span>()-&gt;<span class="built_in">get_parent</span>();</span><br><span class="line">    <span class="keyword">auto</span> ifBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), <span class="string">&quot;ifBasicBlock&quot;</span>, func);</span><br><span class="line">    <span class="keyword">auto</span> loopBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), <span class="string">&quot;loopBasicBlock&quot;</span>, func);</span><br><span class="line">    <span class="keyword">auto</span> afterWhileBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), <span class="string">&quot;afterWhileBasicBlock&quot;</span>, func);</span><br><span class="line">    <span class="comment">//跳转到条件表达式判断的BasicBlock</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_br</span>(ifBB);</span><br><span class="line">    <span class="comment">//为ifBB添加IR, 判断条件表达式的结果</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(ifBB);</span><br><span class="line">    node.expression-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">auto</span> retType = ret-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    Value* ifExpression;                         <span class="comment">//条件表达式的结果             </span></span><br><span class="line">    <span class="comment">//根据返回类型处理, 生成比较语句</span></span><br><span class="line">    <span class="keyword">if</span>(retType-&gt;<span class="built_in">is_integer_type</span>())</span><br><span class="line">        ifExpression = builder-&gt;<span class="built_in">create_icmp_gt</span>(ret, <span class="built_in">CONST_ZERO</span>(INT32_Type));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ifExpression = builder-&gt;<span class="built_in">create_fcmp_gt</span>(ret, <span class="built_in">CONST_ZERO</span>(FLOAT_Type));</span><br><span class="line">    <span class="comment">//条件跳转</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_cond_br</span>(ifExpression, loopBB, afterWhileBB);</span><br><span class="line">    <span class="comment">//为loopBB添加IR</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(loopBB);</span><br><span class="line">    node.statement-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (builder-&gt;<span class="built_in">get_insert_block</span>()-&gt;<span class="built_in">get_terminator</span>() == <span class="literal">nullptr</span>)</span><br><span class="line">        builder-&gt;<span class="built_in">create_br</span>(ifBB);</span><br><span class="line">    <span class="comment">//后面的语句块的IR在新的BasicBlock中</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(afterWhileBB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReturnStmt"><a href="#ReturnStmt" class="headerlink" title="ReturnStmt"></a><strong>ReturnStmt</strong></h4><p style="text-indent:2em">返回语句中有一个表达式计算返回值，如果指向该返回语句的指针为空，说明没有返回值，创建一个void返回IR，否则需要调用该表达式的accept函数，并检查返回类型是否和函数的返回类型相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTReturnStmt &amp;node)</span> </span>&#123; </span><br><span class="line"><span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;ReturnStmt\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(node.expression==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        builder-&gt;<span class="built_in">create_void_ret</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node.expression-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//处理返回值，产生返回的IR</span></span><br><span class="line">    <span class="keyword">auto</span> func = builder-&gt;<span class="built_in">get_insert_block</span>()-&gt;<span class="built_in">get_parent</span>();</span><br><span class="line">    <span class="keyword">auto</span> retType = func-&gt;<span class="built_in">get_return_type</span>();</span><br><span class="line">    <span class="keyword">auto</span> resType = ret-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    <span class="keyword">if</span> (retType-&gt;<span class="built_in">is_integer_type</span>() &amp;&amp; resType-&gt;<span class="built_in">is_float_type</span>())</span><br><span class="line">        ret = builder-&gt;<span class="built_in">create_fptosi</span>(ret, INT32_Type);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(retType-&gt;<span class="built_in">is_float_type</span>() &amp;&amp; resType-&gt;<span class="built_in">is_integer_type</span>())</span><br><span class="line">        ret = builder-&gt;<span class="built_in">create_sitofp</span>(ret, FLOAT_Type);</span><br><span class="line">    builder-&gt;<span class="built_in">create_ret</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Var"><a href="#Var" class="headerlink" title="Var"></a><strong>Var</strong></h4><p style="text-indent:2em">在实验难点中已说明。</p><h4 id="AssignExpression"><a href="#AssignExpression" class="headerlink" title="AssignExpression"></a>AssignExpression</h4><p style="text-indent:2em">对于Assign语句，将全局变量ifAssign置为true，调用子节点var的accept函数得到变量的地址，然后计算表达式的值，创建store指令将值存入地址。需要确认表达式结果是否与变量类型相同，如果不同需要将表达式结果转换为和变量相同的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTAssignExpression &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;AssignExpression\n&quot;</span>;</span><br><span class="line">    ifAssign = <span class="literal">true</span>;</span><br><span class="line">    node.var-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">auto</span> varAdd = ret;</span><br><span class="line">    node.expression-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//确认表达式结果类型与变量类型相同，不同则进行转换</span></span><br><span class="line">    <span class="keyword">auto</span> varType = varAdd-&gt;<span class="built_in">get_type</span>()-&gt;<span class="built_in">get_pointer_element_type</span>();</span><br><span class="line">    <span class="keyword">auto</span> valueType = ret-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    Value* value = ret;</span><br><span class="line">    <span class="keyword">if</span>(varType!=valueType)&#123;</span><br><span class="line">        <span class="keyword">if</span>(varType==INT32_Type)</span><br><span class="line">            value = builder-&gt;<span class="built_in">create_fptosi</span>(ret, INT32_Type);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            value = builder-&gt;<span class="built_in">create_sitofp</span>(ret, FLOAT_Type);</span><br><span class="line">    &#125;</span><br><span class="line">    builder-&gt;<span class="built_in">create_store</span>(value, varAdd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SimpleExpression"><a href="#SimpleExpression" class="headerlink" title="SimpleExpression"></a>SimpleExpression</h4><p style="text-indent:2em">简单表达式SimpleExpression是一个加法表达式或两个加法表达式的关系运算。在节点中有两个加法表达式的指针和一个运算符类型为RelOp的运算符op，RelOp是一个枚举类型，包含了所有比较运算符。根据语义，对于该节点的处理，应该先处理加法表达式，将表达式的值保存下来，如果两个表达式指针都不为空，说明为关系运算，再比较两个运算结果，根据结果将表达式的值赋为0或1。进行比较时需要注意两个值的类型，整型和浮点型比较时要将整型转换为浮点型。</p><p style="text-indent:2em">具体实现中，应该调用加法表达式的accept函数(如果指针不为空)，暂存结果，对于比较运算，根据op生成icmp或fcmp的指令，最后返回的值就是指令结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTSimpleExpression &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;SimpleExpression\n&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> ifInt = <span class="literal">true</span>;                      <span class="comment">//表达式结果类型</span></span><br><span class="line">    Value *resL, *resR;</span><br><span class="line">    Type *resLType, *resRType;</span><br><span class="line">    <span class="comment">//计算两个加法表达式</span></span><br><span class="line">    <span class="keyword">if</span>(node.additive_expression_l!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        node.additive_expression_l-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">        resL = ret;</span><br><span class="line">        resLType = ret-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.additive_expression_r!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        node.additive_expression_r-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">        resR = ret;</span><br><span class="line">        resRType = ret-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果只有一个加法表达式, 直接返回表达式的值</span></span><br><span class="line">    <span class="keyword">if</span>(!(node.additive_expression_l!=<span class="literal">nullptr</span> &amp;&amp; node.additive_expression_r!=<span class="literal">nullptr</span>))&#123;</span><br><span class="line">        ret = (node.additive_expression_l!=<span class="literal">nullptr</span>) ? resL : resR;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果有两个加法表达式, 为关系运算</span></span><br><span class="line">    <span class="comment">//先统一类型</span></span><br><span class="line">    <span class="keyword">if</span>(resLType!=resRType)&#123;</span><br><span class="line">        ifInt = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(resLType-&gt;<span class="built_in">is_float_type</span>())        <span class="comment">//左表达式为浮点型，则右表达式从整型转换为浮点型</span></span><br><span class="line">            resL = builder-&gt;<span class="built_in">create_sitofp</span>(resL, FLOAT_Type);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//左表达式为整型，转换为浮点型</span></span><br><span class="line">            resR = builder-&gt;<span class="built_in">create_sitofp</span>(resR, FLOAT_Type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据关系运算类型，创建指令</span></span><br><span class="line">    <span class="keyword">switch</span> (node.op)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> OP_LE:</span><br><span class="line">        <span class="keyword">if</span>(ifInt)</span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_icmp_le</span>(resL, resR);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_fcmp_le</span>(resL, resR);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/*其他运算符......*/</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结果为整型</span></span><br><span class="line">    ret = builder-&gt;<span class="built_in">create_zext</span>(ret, INT32_Type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AdditiveExpression"><a href="#AdditiveExpression" class="headerlink" title="AdditiveExpression"></a>AdditiveExpression</h4><p style="text-indent:2em">加法表达式中包含了一个乘法表达式，一个加法表达式和一个运算符。如果加法表达式指针为空，则表达式的值就是乘法表达式的值，否则分别计算两个表达式，调用相应的accept函数，然后进行根据运算符生成加或减指令。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTAdditiveExpression &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;AdditiveExpression\n&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> ifInt = <span class="literal">true</span>;                        <span class="comment">//两个表达式类型</span></span><br><span class="line">    <span class="comment">//如果只有乘法表达式</span></span><br><span class="line">    <span class="keyword">if</span>(node.additive_expression==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        node.term-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有乘法表达式和加法表达式，创建加法或减法指令</span></span><br><span class="line">    node.additive_expression-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);  <span class="comment">//处理加法表达式</span></span><br><span class="line">    <span class="keyword">auto</span> addRes = ret;</span><br><span class="line">    <span class="keyword">auto</span> addType = addRes-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    node.term-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);                 <span class="comment">//处理乘法表达式</span></span><br><span class="line">    <span class="keyword">auto</span> mulRes = ret;</span><br><span class="line">    <span class="keyword">auto</span> mulType = mulRes-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    <span class="comment">//确认类型相同</span></span><br><span class="line">    <span class="keyword">if</span>(addType!=mulType)&#123;</span><br><span class="line">        ifInt = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(addType-&gt;<span class="built_in">is_float_type</span>())</span><br><span class="line">            mulRes = builder-&gt;<span class="built_in">create_sitofp</span>(mulRes, FLOAT_Type);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            addRes = builder-&gt;<span class="built_in">create_sitofp</span>(addRes, INT32_Type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指令</span></span><br><span class="line">    <span class="keyword">if</span>(node.op==OP_PLUS)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ifInt)</span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_iadd</span>(addRes, mulRes);     <span class="comment">//addRes在左!</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_fadd</span>(addRes, mulRes);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ifInt)</span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_isub</span>(addRes, mulRes);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_fsub</span>(addRes, mulRes);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Term"><a href="#Term" class="headerlink" title="Term"></a>Term</h4><p style="text-indent:2em">乘法表达式由乘法表达式和因子或单独一个因子构成。与加法表达式的处理相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTTerm &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;Term\n&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> ifInt = <span class="literal">true</span>;                        <span class="comment">//因子和乘法表达式结果类型</span></span><br><span class="line">    <span class="comment">//如果只有因子</span></span><br><span class="line">    <span class="keyword">if</span>(node.term==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        node.factor-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有乘法表达式和因子，创建乘法或除法指令</span></span><br><span class="line">    node.term-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);                 <span class="comment">//处理乘法表达式</span></span><br><span class="line">    <span class="keyword">auto</span> mulRes = ret;</span><br><span class="line">    <span class="keyword">auto</span> mulType = mulRes-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    node.factor-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);               <span class="comment">//处理因子</span></span><br><span class="line">    <span class="keyword">auto</span> factorRes = ret;</span><br><span class="line">    <span class="keyword">auto</span> factorType = factorRes-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    <span class="comment">//确认类型相同</span></span><br><span class="line">    <span class="keyword">if</span>(factorType!=mulType)&#123;</span><br><span class="line">        ifInt = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(factorType-&gt;<span class="built_in">is_float_type</span>())</span><br><span class="line">            mulRes = builder-&gt;<span class="built_in">create_sitofp</span>(mulRes, FLOAT_Type);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            factorRes = builder-&gt;<span class="built_in">create_sitofp</span>(factorRes, INT32_Type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指令</span></span><br><span class="line">    <span class="keyword">if</span>(node.op==OP_MUL)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ifInt)</span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_imul</span>(mulRes, factorRes);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_fmul</span>(mulRes, factorRes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ifInt)</span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_isdiv</span>(mulRes, factorRes);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_fdiv</span>(mulRes, factorRes);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h4><p style="text-indent:2em">call节点需要创建一条函数调用call指令，从作用域中取出函数，然后根据函数的参数将节点的实参传入，并检查类型是否与函数参数的类型一致，不一致则需要转换为函数的形参类型。创建一个参数列表，将转换好的参数存入列表来调用函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTCall &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;Call\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> func = <span class="built_in">static_cast</span>&lt;Function*&gt;(scope.<span class="built_in">find</span>(node.id));</span><br><span class="line">    <span class="keyword">auto</span> paramType = func-&gt;<span class="built_in">get_function_type</span>()-&gt;<span class="built_in">param_begin</span>();</span><br><span class="line">    <span class="keyword">if</span>(func==<span class="literal">nullptr</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR: 函数&quot;</span> &lt;&lt; node.id &lt;&lt; <span class="string">&quot;未定义\n&quot;</span>;</span><br><span class="line">    <span class="comment">//处理参数</span></span><br><span class="line">    Value *temp;</span><br><span class="line">    std::vector&lt;Value*&gt; args;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> arg: node.args)&#123;</span><br><span class="line">        arg-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);                   <span class="comment">//获取参数值</span></span><br><span class="line">        temp = ret;</span><br><span class="line">        <span class="keyword">auto</span> argType = ret-&gt;<span class="built_in">get_type</span>();       <span class="comment">//处理类型</span></span><br><span class="line">        <span class="keyword">if</span>(argType!=*paramType)</span><br><span class="line">            <span class="keyword">if</span>((*paramType)-&gt;<span class="built_in">is_integer_type</span>())</span><br><span class="line">                temp = builder-&gt;<span class="built_in">create_fptosi</span>(ret, INT32_Type);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp = builder-&gt;<span class="built_in">create_sitofp</span>(ret, FLOAT_Type);</span><br><span class="line">        args.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        paramType++;</span><br><span class="line">    &#125;</span><br><span class="line">    builder-&gt;<span class="built_in">create_call</span>(func, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><h3 id="1-结果验证"><a href="#1-结果验证" class="headerlink" title="1.结果验证"></a>1.结果验证</h3><p style="text-indent:2em">在进行测试，改正编写过程中的一些错误后，编译后运行测试程序，所有测试样例都通过。</p><p><img src="/2022/11/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E5%9B%9B/image-20221123173758944.png" alt="image-20221123173758944" style="zoom:50%;"></p><h3 id="2-总结"><a href="#2-总结" class="headerlink" title="2.总结"></a>2.总结</h3><p style="text-indent:2em">通过本次实验，理解了从抽象语法树产生中间IR的方法，并进行了实现。在实现过程中，对于IR的指令有了进一步的熟悉与理解，掌握了使用C++接口创建不同IR指令的方法，以及在访问者模式下遍历抽象语法树，完成IR生成的过程。在完成实现时阅读了相关的头文件，语义规则，通过整个实验的框架复习了C++中一些概念和方法。经过四次实验，结合课程所学的原理，理解了编译器的词法分析，语法分析，中间代码生成的过程，也学习了相关工具的使用并进行了实践，清楚了编译器工作的每一个部分的原理和相互之间的配合。</p>]]></content>
      
      
      <categories>
          
          <category> cs基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理实验三</title>
      <link href="/2022/11/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%89/"/>
      <url>/2022/11/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h2 id="问题1-cpp与-ll的对应"><a href="#问题1-cpp与-ll的对应" class="headerlink" title="问题1: cpp与.ll的对应"></a>问题1: cpp与.ll的对应</h2><p>请描述你的cpp代码片段和.ll的每个BasicBlock的对应关系。描述中请附上两者代码。</p><h3 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h3><p style="text-indent:2em">对应的.ll代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">define i32 @main() #0 &#123;</span><br><span class="line">    %1 = alloca [10 x i32]    ;int a[10]</span><br><span class="line">    %2 = getelementptr inbounds [10 x i32], [10 x i32]* %1, i32 0, i32 0        ;a[0] addr    </span><br><span class="line">    %3 = getelementptr inbounds [10 x i32], [10 x i32]* %1, i32 0, i32 1        ;a[1] addr</span><br><span class="line">    store i32 10, i32* %2     ;a[0] = 10</span><br><span class="line">    %4 = load i32, i32* %2    ;%4 = a[0]</span><br><span class="line">    %5 = mul i32 %4,2         ;%5 = a[0]*2</span><br><span class="line">    store i32 %5, i32* %3     ;a[1] = %5 = a[0]*2</span><br><span class="line">    %6 = load i32, i32* %3    ;%6 = a[1]</span><br><span class="line">    ret i32 %6                ;return a[1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">这一段程序仅有一个函数，一个BasicBlock。仿照gcd_array.cpp的写法，创建Module和BasicBlock，将.ll中的指令使用IRBuilder插入到BasicBlock的指令链表当中。与.ll中指令的对应关系在以下的cpp代码片段的注释中说明。cpp代码片段如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BasicBlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Constant.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IRBuilder.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Module.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Type.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG  <span class="comment">// 用于调试信息,大家可以在编译过程中通过&quot; -DDEBUG&quot;来开启这一选项</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_OUTPUT std::cout &lt;&lt; __LINE__ &lt;&lt; std::endl;  <span class="comment">// 输出行号的简单示例</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_OUTPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONST_INT(num) \</span></span><br><span class="line"><span class="meta">    ConstantInt::get(num, module)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONST_FP(num) \</span></span><br><span class="line"><span class="meta">    ConstantFP::get(num, module) <span class="comment">// 得到常数值的表示,方便后面多次用到</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">module</span> = <span class="keyword">new</span> <span class="built_in">Module</span>(<span class="string">&quot;Assign&quot;</span>);                 </span><br><span class="line">    <span class="keyword">auto</span> builder = <span class="keyword">new</span> <span class="built_in">IRBuilder</span>(<span class="literal">nullptr</span>, <span class="keyword">module</span>);                      <span class="comment">//使用IRBuilder创建指令</span></span><br><span class="line">    <span class="comment">//创建函数与BasicBlock</span></span><br><span class="line">    Type *Int32Type = Type::<span class="built_in">get_int32_type</span>(<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">auto</span> mainTy = FunctionType::<span class="built_in">get</span>(Int32Type, &#123;&#125;);                     <span class="comment">//返回值为i32，参数为空</span></span><br><span class="line">    <span class="keyword">auto</span> main = Function::<span class="built_in">create</span>(mainTy, <span class="string">&quot;main&quot;</span>, <span class="keyword">module</span>);            </span><br><span class="line">    <span class="keyword">auto</span> BB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>, <span class="string">&quot;BasicBlock1&quot;</span> , main);</span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(BB);                                      <span class="comment">//设置插入指令的BasicBlock</span></span><br><span class="line">    <span class="comment">//插入.ll中对应的指令</span></span><br><span class="line">    <span class="keyword">auto</span> *arrayType = ArrayType::<span class="built_in">get</span>(Int32Type, <span class="number">10</span>);                    <span class="comment">//数组的类型为[10 x i32]</span></span><br><span class="line">    <span class="keyword">auto</span> a = builder-&gt;<span class="built_in">create_alloca</span>(arrayType);                         <span class="comment">//分配数组</span></span><br><span class="line">    <span class="keyword">auto</span> a0P = builder-&gt;<span class="built_in">create_gep</span>(a, &#123;<span class="built_in">CONST_INT</span>(<span class="number">0</span>), <span class="built_in">CONST_INT</span>(<span class="number">0</span>)&#125;);    <span class="comment">//计算a[0]地址</span></span><br><span class="line">    <span class="keyword">auto</span> a1P = builder-&gt;<span class="built_in">create_gep</span>(a, &#123;<span class="built_in">CONST_INT</span>(<span class="number">0</span>), <span class="built_in">CONST_INT</span>(<span class="number">0</span>)&#125;);    <span class="comment">//计算a[1]地址</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_store</span>(&#123;<span class="built_in">CONST_INT</span>(<span class="number">10</span>)&#125;, a0P);                        <span class="comment">//a[0] = 10</span></span><br><span class="line">    <span class="keyword">auto</span> a0 = builder-&gt;<span class="built_in">create_load</span>(a0P);                                <span class="comment">//取出a[0]</span></span><br><span class="line">    <span class="keyword">auto</span> temp = builder-&gt;<span class="built_in">create_imul</span>(a0, &#123;<span class="built_in">CONST_INT</span>(<span class="number">2</span>)&#125;);               <span class="comment">//a[0]*2</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_store</span>(temp, a1P);                                   <span class="comment">//a1 = a[0]*2</span></span><br><span class="line">    <span class="keyword">auto</span> a1 = builder-&gt;<span class="built_in">create_load</span>(a1P);       </span><br><span class="line">    builder-&gt;<span class="built_in">create_ret</span>(a1);                                            <span class="comment">//return a1 = a[0]*2</span></span><br><span class="line">    <span class="comment">//指令创建结束</span></span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">module</span>-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">module</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">make之后运行程序进行验证，生成的指令和.ll中的指令相同。</p><p><img src="/2022/11/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%89/image-20221121113522342.png" alt="image-20221121113522342" style="zoom: 67%;"></p><span id="more"></span><h3 id="fun"><a href="#fun" class="headerlink" title="fun"></a>fun</h3><p style="text-indent:2em">对应的.ll代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define i32 @callee(i32 %0) #0 &#123;</span><br><span class="line">    %2 = mul i32 %0, 2               ;%2 = a*2</span><br><span class="line">    ret i32 %2</span><br><span class="line">&#125;</span><br><span class="line">define i32 @main() #0 &#123;</span><br><span class="line">    %1 = call i32 @callee(i32 110)   ;%1 = callee(110)</span><br><span class="line">    ret i32 %1                       ;return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">共有两个函数，相应有两个BasicBlock，分别插入指令。与.ll中指令的对应关系在注释中说明，相应的cpp代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件和宏定义省略</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">module</span> = <span class="keyword">new</span> <span class="built_in">Module</span>(<span class="string">&quot;fun&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> builder = <span class="keyword">new</span> <span class="built_in">IRBuilder</span>(<span class="literal">nullptr</span>, <span class="keyword">module</span>);</span><br><span class="line">    <span class="comment">//创建callee函数</span></span><br><span class="line">    Type *Int32Type = Type::<span class="built_in">get_int32_type</span>(<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">auto</span> calleeTy = FunctionType::<span class="built_in">get</span>(Int32Type, &#123;Int32Type&#125;);            <span class="comment">//返回值为i32，一个i32类型的参数</span></span><br><span class="line">    <span class="keyword">auto</span> callee = Function::<span class="built_in">create</span>(calleeTy, <span class="string">&quot;callee&quot;</span>, <span class="keyword">module</span>); </span><br><span class="line">    <span class="keyword">auto</span> BB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>, <span class="string">&quot;callee_BasicBlock&quot;</span> , callee);</span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(BB);</span><br><span class="line">    <span class="comment">//插入callee的BasicBlock中的指令</span></span><br><span class="line">    std::vector&lt;Value *&gt; args;                                            <span class="comment">//获取函数的形参,通过Function中的iterator</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> arg = callee-&gt;<span class="built_in">arg_begin</span>(); arg != callee-&gt;<span class="built_in">arg_end</span>(); arg++) &#123;</span><br><span class="line">        args.<span class="built_in">push_back</span>(*arg);                                             <span class="comment">//* 号运算符是从迭代器中取出迭代器当前指向的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> mul = builder-&gt;<span class="built_in">create_imul</span>(args[<span class="number">0</span>], <span class="built_in">CONST_INT</span>(<span class="number">2</span>));             <span class="comment">//mul = a*2</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_ret</span>(mul);</span><br><span class="line">    <span class="comment">//创建main函数</span></span><br><span class="line">    <span class="keyword">auto</span> mainTy = FunctionType::<span class="built_in">get</span>(Int32Type, &#123;&#125;);</span><br><span class="line">    <span class="keyword">auto</span> main = Function::<span class="built_in">create</span>(mainTy, <span class="string">&quot;main&quot;</span>, <span class="keyword">module</span>); </span><br><span class="line">    <span class="keyword">auto</span> BB1 = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>, <span class="string">&quot;main_BasicBlock&quot;</span> , main);</span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(BB1);</span><br><span class="line">    <span class="comment">//插入main的BasicBlock中的指令</span></span><br><span class="line">    <span class="keyword">auto</span> callret = builder-&gt;<span class="built_in">create_call</span>(callee, &#123;<span class="built_in">CONST_INT</span>(<span class="number">110</span>)&#125;);       <span class="comment">//callret = callee(110)</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_ret</span>(callret);                                        <span class="comment">//return callret</span></span><br><span class="line">    <span class="comment">//指令创建结束</span></span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">module</span>-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">module</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">运行程序，生成的指令和.ll中的指令相同。</p><p><img src="/2022/11/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%89/image-20221121161232658.png" alt="image-20221121161232658" style="zoom: 67%;"></p><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p style="text-indent:2em">对应的.ll代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">define i32 @main() #0 &#123;</span><br><span class="line">    %1 = alloca float                    ;%1 = float a addr</span><br><span class="line">    store float 0x40163851E0000000, float* %1</span><br><span class="line">    %2 = load float, float* %1           ;%2 = a</span><br><span class="line">    %3 = fcmp ugt float %2, 1.0          ;a&gt;1   </span><br><span class="line">    br i1 %3, label %4, label %5         ;if(a&gt;1) goto 4 else goto 5</span><br><span class="line">4:</span><br><span class="line">    ret i32 233</span><br><span class="line">5:</span><br><span class="line">    ret i32 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">本段指令有3个BasicBlock，相比与前两个多了fcmp和br跳转指令。相应的.cpp文件如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件和宏定义省略</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">module</span> = <span class="keyword">new</span> <span class="built_in">Module</span>(<span class="string">&quot;if&quot;</span>);                 </span><br><span class="line">    <span class="keyword">auto</span> builder = <span class="keyword">new</span> <span class="built_in">IRBuilder</span>(<span class="literal">nullptr</span>, <span class="keyword">module</span>);                      <span class="comment">//使用IRBuilder创建指令</span></span><br><span class="line">    <span class="comment">//创建main函数</span></span><br><span class="line">    Type *Int32Type = Type::<span class="built_in">get_int32_type</span>(<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">auto</span> mainTy = FunctionType::<span class="built_in">get</span>(Int32Type, &#123;&#125;);                     <span class="comment">//返回值为i32，参数为空</span></span><br><span class="line">    <span class="keyword">auto</span> main = Function::<span class="built_in">create</span>(mainTy, <span class="string">&quot;main&quot;</span>, <span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">auto</span> BBEntry = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>, <span class="string">&quot;entry&quot;</span> , main);</span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(BBEntry); </span><br><span class="line">    <span class="comment">//entryBasicBlock插入指令，对应.ll的BasicBlock0</span></span><br><span class="line">    Type *FloatType = Type::<span class="built_in">get_float_type</span>(<span class="keyword">module</span>);                     <span class="comment">//浮点类型</span></span><br><span class="line">    <span class="keyword">auto</span> aP = builder-&gt;<span class="built_in">create_alloca</span>(FloatType);                        <span class="comment">//为float a分配空间并返回指针</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_store</span>(<span class="built_in">CONST_FP</span>(<span class="number">5.555</span>),aP);                          <span class="comment">//a = 5.555</span></span><br><span class="line">    <span class="keyword">auto</span> a = builder-&gt;<span class="built_in">create_load</span>(aP);                                  <span class="comment">//取出a</span></span><br><span class="line">    <span class="keyword">auto</span> fcmp = builder-&gt;<span class="built_in">create_fcmp_gt</span>(a, <span class="built_in">CONST_FP</span>(<span class="number">1.0</span>));              <span class="comment">//fcmp = if a&gt;1</span></span><br><span class="line">    <span class="comment">//创建true, false对应的BasicBlock</span></span><br><span class="line">    <span class="keyword">auto</span> BBTrue = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>, <span class="string">&quot;true&quot;</span> , main);</span><br><span class="line">    <span class="keyword">auto</span> BBFalse = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>, <span class="string">&quot;false&quot;</span>, main);</span><br><span class="line">    builder-&gt;<span class="built_in">create_cond_br</span>(fcmp, BBTrue, BBFalse);                     <span class="comment">//br跳转指令</span></span><br><span class="line">    <span class="comment">//true和false对应的BasicBlock插入指令，对应.ll的BasicBlock4,5</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(BBTrue);</span><br><span class="line">    builder-&gt;<span class="built_in">create_ret</span>(<span class="built_in">CONST_INT</span>(<span class="number">233</span>));</span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(BBFalse);</span><br><span class="line">    builder-&gt;<span class="built_in">create_ret</span>(<span class="built_in">CONST_INT</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//指令创建结束</span></span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">module</span>-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">module</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">运行程序验证：</p><p><img src="/2022/11/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%89/image-20221121171447083.png" alt="image-20221121171447083" style="zoom: 67%;"></p><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p style="text-indent:2em">对应的.ll代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">define i32 @main() #0 &#123;</span><br><span class="line">    %1 = alloca i32        ;%1 = a addr</span><br><span class="line">    %2 = alloca i32        ;%2 = i addr</span><br><span class="line">    store i32 0, i32* %2   ;i = 0</span><br><span class="line">    store i32 10, i32* %1  ;a = 10</span><br><span class="line">    br label %3             </span><br><span class="line"></span><br><span class="line">;if i&lt;10</span><br><span class="line">3:</span><br><span class="line">    %4 = load i32, i32* %2        ;%4 = i</span><br><span class="line">    %5 = icmp slt i32 %4, 10      ;i &lt; 10?</span><br><span class="line">    br i1 %5, label %6, label %10</span><br><span class="line">    </span><br><span class="line">6:</span><br><span class="line">    %7 = add nsw i32 %4, 1        ;i + 1</span><br><span class="line">    store i32 %7, i32* %2         ;i = i + 1</span><br><span class="line">    %8 = load i32, i32* %1        ;%8 = a</span><br><span class="line">    %9 = add nsw i32 %7, %8       ;%9 = a + i</span><br><span class="line">    store i32 %9, i32* %1         ;a = a + i</span><br><span class="line">    br label %3</span><br><span class="line">    </span><br><span class="line">10:</span><br><span class="line">    ret i32 %9                    ;return a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">以上的.ll程序共有四个BasicBlock，逐个添加指令即可。.cpp中的BasicBlock与.ll的对应在注释中说明。.cpp的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">module</span> = <span class="keyword">new</span> <span class="built_in">Module</span>(<span class="string">&quot;while&quot;</span>);                 </span><br><span class="line">    <span class="keyword">auto</span> builder = <span class="keyword">new</span> <span class="built_in">IRBuilder</span>(<span class="literal">nullptr</span>, <span class="keyword">module</span>);                      <span class="comment">//使用IRBuilder创建指令</span></span><br><span class="line">    <span class="comment">//创建main函数和4个BasicBlock</span></span><br><span class="line">    Type *Int32Type = Type::<span class="built_in">get_int32_type</span>(<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">auto</span> mainTy = FunctionType::<span class="built_in">get</span>(Int32Type, &#123;&#125;);                     <span class="comment">//返回值为i32，参数为空</span></span><br><span class="line">    <span class="keyword">auto</span> main = Function::<span class="built_in">create</span>(mainTy, <span class="string">&quot;main&quot;</span>, <span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">auto</span> BBEntry = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>, <span class="string">&quot;entry&quot;</span> , main);</span><br><span class="line">    <span class="keyword">auto</span> BBWhile = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>, <span class="string">&quot;while&quot;</span> , main);</span><br><span class="line">    <span class="keyword">auto</span> BBTrue = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>, <span class="string">&quot;true&quot;</span> , main);</span><br><span class="line">    <span class="keyword">auto</span> BBFalse = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>, <span class="string">&quot;false&quot;</span> , main);</span><br><span class="line">    <span class="comment">//entryBasicBlock插入指令，即.ll的BasicBlock0</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(BBEntry);</span><br><span class="line">    <span class="keyword">auto</span> aP = builder-&gt;<span class="built_in">create_alloca</span>(Int32Type);                        <span class="comment">//分配a的空间，返回指针aP</span></span><br><span class="line">    <span class="keyword">auto</span> iP = builder-&gt;<span class="built_in">create_alloca</span>(Int32Type);                        <span class="comment">//分配i的空间，返回指针iP</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_store</span>(<span class="built_in">CONST_INT</span>(<span class="number">0</span>), iP);                            <span class="comment">//i = 0</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_store</span>(<span class="built_in">CONST_INT</span>(<span class="number">10</span>), aP);                           <span class="comment">//a = 10</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_br</span>(BBWhile);                                        <span class="comment">//br跳转到while循环的判断BasicBlock</span></span><br><span class="line">    <span class="comment">//whileBasicBlock插入指令，即.ll的BasicBlock3</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(BBWhile);</span><br><span class="line">    <span class="keyword">auto</span> temp = builder-&gt;<span class="built_in">create_load</span>(iP);</span><br><span class="line">    <span class="keyword">auto</span> icmp = builder-&gt;<span class="built_in">create_icmp_lt</span>(temp, <span class="built_in">CONST_INT</span>(<span class="number">10</span>));</span><br><span class="line">    builder-&gt;<span class="built_in">create_cond_br</span>(icmp, BBTrue, BBFalse);                     <span class="comment">//br跳转到True或False的BasicBlock</span></span><br><span class="line">    <span class="comment">//TrueBasicBlock插入指令，即.ll的BasicBlock6</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(BBTrue);</span><br><span class="line">    <span class="keyword">auto</span> newi = builder-&gt;<span class="built_in">create_iadd</span>(temp, <span class="built_in">CONST_INT</span>(<span class="number">1</span>));               <span class="comment">//i + 1</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_store</span>(newi, iP);                                    <span class="comment">//i = i + 1</span></span><br><span class="line">    <span class="keyword">auto</span> a = builder-&gt;<span class="built_in">create_load</span>(aP);</span><br><span class="line">    <span class="keyword">auto</span> newa = builder-&gt;<span class="built_in">create_iadd</span>(newi, a);                          <span class="comment">//a + i</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_store</span>(newa, aP);                                    <span class="comment">//a = a + i</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_br</span>(BBWhile);                                        <span class="comment">//br跳转到while循环的判断BasicBlock</span></span><br><span class="line">    <span class="comment">//FalseBasicBlock插入指令，即.ll的BasicBlock10</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(BBFalse);</span><br><span class="line">    builder-&gt;<span class="built_in">create_ret</span>(newa);                                          <span class="comment">//return a</span></span><br><span class="line">    <span class="comment">//指令创建结束</span></span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">module</span>-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">module</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">运行程序验证：</p><p><img src="/2022/11/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%89/image-20221121175730205.png" alt="image-20221121175730205" style="zoom:67%;"></p><p style="text-indent:2em">以上的.ll代码和.cpp编译运行后的.ll代码运行后均能产生正确的结果，与原.c程序的逻辑相同.</p><h2 id="问题2-Visitor-Pattern"><a href="#问题2-Visitor-Pattern" class="headerlink" title="问题2: Visitor Pattern"></a>问题2: Visitor Pattern</h2><p>请指出visitor.cpp中，<code>treeVisitor.visit(exprRoot)</code>执行时，以下几个Node的遍历序列:numberA、numberB、exprC、exprD、exprE、numberF、exprRoot。<br>序列请按如下格式指明：<br>exprRoot-&gt;numberF-&gt;exprE-&gt;numberA-&gt;exprD</p><p style="text-indent:2em">根据visitor.cpp中的内容，每个节点会返回自身的引用，visitor会进行访问该节点，计算该节点的值，计算的方式是访问其左右节点并获取值，然后根据节点的操作类型完成值的计算，然后返回。子节点的值的获取也是相同的，直到访问到数值节点，就直接返回相应的数值。可以看出访问的过程是自顶向下递归访问的过程。main函数中创建的计算树如下：</p><p><img src="/2022/11/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%89/image-20221121194007554.png" alt="image-20221121194007554" style="zoom: 50%;"></p><p style="text-indent:2em">根据visit()函数中的实现，对于AddSubNode的访问，是先访问右子节点，然后访问左子节点，对于MulDivNode的访问，先访问左子节点，后访问右子节点。因此可以得出visitor.cpp中访问该树的序列为：</p><p style="text-indent:2em">exprRoot->numberF->exprE->exprD->numberB->numberA->exprC->numberA->numberB</p><h2 id="问题3-getelementptr"><a href="#问题3-getelementptr" class="headerlink" title="问题3: getelementptr"></a>问题3: getelementptr</h2><p>请给出<code>IR.md</code>中提到的两种getelementptr用法的区别,并稍加解释:</p><ul><li><code>%2 = getelementptr [10 x i32], [10 x i32]* %1, i32 0, i32 %0</code> </li><li><code>%2 = getelementptr i32, i32* %1 i32 %0</code> </li></ul><p>第一种用法：</p><p style="text-indent:2em">指针类型为[10 x i32]*，指向的数据类型为[10 x i32]，因此首先用i32 0表示偏移为0，这表示直接取第一个[10 x i32]数组，然后的i32 %0表示在第一个[10 x i32]数组内，偏移%0的元素地址。</p><p>第二种用法：</p><p style="text-indent:2em">指针类型为i32*，%1表示的是数组的起始地址，偏移量为%0，直接取出了数组偏移%0位置的元素地址。</p><p>区别：</p><p style="text-indent:2em">在第一种用法中，指针类似于指针数组，首先确定在这个指针数组上的偏移，才能得到一个数组的指针，然后通过偏移找到元素的地址。而在第二种用法中，直接对数组的指针进行偏移，找到元素的地址。</p><p style="text-indent:2em">当定义全局数组或结构体时，定义的是指针，例如在给出的gcd_array.c中声明的全局数组x，y，就是[1 x i32]*类型，因此取出元素时使用的是第一种用法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局数组x[1]</span></span><br><span class="line">@x = common dso_local global [<span class="number">1</span> x i32] zeroinitializer, align <span class="number">4</span></span><br><span class="line"><span class="comment">//取出元素地址</span></span><br><span class="line">getelementptr inbounds ([<span class="number">1</span> x i32], [<span class="number">1</span> x i32]* @x, i64 <span class="number">0</span>, i64 <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h2><h3 id="1-编写-ll"><a href="#1-编写-ll" class="headerlink" title="1.编写.ll"></a>1.编写.ll</h3><p style="text-indent:2em">在编写if.c对应的.ll时，提示error: floating point constant invalid for type，不能用浮点常量给浮点数赋值。经查询，这是因为浮点数5.55不能用浮点数精确表示，因此不能直接给浮点数赋值。如果是4.0等可以精确表示的数，就可以直接赋值。此处只能使用十六进制的浮点数机器表示进行赋值，为0x40163851E0000000。</p><p style="text-indent:2em">编写while.c对应的.ll时注意到，编号顺序必须是连续的，除了if对应的块跳转语句可以出现不连续的编号，其他编号都必须是连续的。因此br语句中的跳转编号应该最后填写。</p><p style="text-indent:2em">编写.ll后，与.c源文件产生的.ll文件进行了比较，clang产生的.ll文件中的指令更多，对于值进行了更多的存储和取出的操作，但是逻辑上是和自行编写的.ll指令是相同的。自行编写时，临时变量直接使用寄存器存储，还有一些寄存器值也重复使用，相当于对直接产生的.ll指令优化后的结果。</p><h3 id="2-编写cpp"><a href="#2-编写cpp" class="headerlink" title="2.编写cpp"></a>2.编写cpp</h3><p style="text-indent:2em">编写cpp时，由于对接口不熟悉，创建对应的指令有些困难，在经过阅读gcd_array.cpp中创建指令的部分和整体结构，仿照并逐个指令完成assign.cpp后，后三个cpp代码的编写才比较顺利。</p><p style="text-indent:2em">创建比较指令时，指令名使用了lightIR中的ugt来表示小于，编译时提示不存在这条指令，从lightIR.h中找到，比较的指令使用的是下面的表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CmpOp</span></span><br><span class="line">    &#123;</span><br><span class="line">        EQ, <span class="comment">// ==</span></span><br><span class="line">        NE, <span class="comment">// !=</span></span><br><span class="line">        GT, <span class="comment">// &gt;</span></span><br><span class="line">        GE, <span class="comment">// &gt;=</span></span><br><span class="line">        LT, <span class="comment">// &lt;</span></span><br><span class="line">        LE  <span class="comment">// &lt;=</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">因此修改相应的比较指令为以下形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fcmp = builder-&gt;<span class="built_in">create_fcmp_gt</span>(a, <span class="built_in">CONST_FP</span>(<span class="number">1.0</span>)); </span><br><span class="line"><span class="keyword">auto</span> icmp = builder-&gt;<span class="built_in">create_icmp_lt</span>(temp, <span class="built_in">CONST_INT</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><h2 id="实验反馈"><a href="#实验反馈" class="headerlink" title="实验反馈"></a>实验反馈</h2><p style="text-indent:2em">通过本次实验学习了llvm，LightIR相关知识。对于LightIR的接口，文档内容没有特别清晰，通过结合实例和.h文件中的内容才逐渐熟悉。编写.ll文件时，注意到了与clang编译代码的不同，自行编写可以在许多位置直接进行优化，而编译器可能第一步只能生成未优化的代码。对于自行编写的.ll指令，使用C++生成的过程也相对较为简洁。最后通过visitor.cpp了解了访问者模式，对于这种模式比较陌生，但是通过实例理解了其工作原理和访问过程。</p>]]></content>
      
      
      <categories>
          
          <category> cs基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理实验二：Bison</title>
      <link href="/2022/11/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9ABison/"/>
      <url>/2022/11/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9ABison/</url>
      
        <content type="html"><![CDATA[<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>1.了解Bision基础知识，如何将文法产生式转换为Bison语句</p><p>2.阅读/src/common/SyntaxTree.c，对应头文件 /include/SyntaxTree.h，理解分析树生成的过程。</p><p>3.了解Bison与Flex的协同工作过程，理解pass_node函数并改写lab1代码。了解yylval工作原理。</p><p>4.补全 src/parser/syntax_analyzer.y 文件和lexical_analyzer.l文件</p><span id="more"></span><h2 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h2><h3 id="1-Bison的使用"><a href="#1-Bison的使用" class="headerlink" title="1.Bison的使用"></a>1.Bison的使用</h3><p style="text-indent:2em">Bison是一个语法分析器的生成工具，用于生成语法分析器。Bison可以将LALR文法转换可编译的c代码。Bison文件的扩展名为.y，在Bison文件中给出LALR文法以及一些分析动作，编译就可以产生一个语法分析器。</p><p style="text-indent:2em">Bison文件以.y结尾，与Lex文件的编写规则类似，由%%区分的三部分构成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="comment">/* 这部分代码会被原样拷贝到生成的 .c 文件的开头 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">yylex</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yyerror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*一些指令，如用%start指定起始符号，%token定义token*/</span></span><br><span class="line">%start reimu</span><br><span class="line">%token REIMU</span><br><span class="line">    </span><br><span class="line">%%</span><br><span class="line"><span class="comment">/*解析规则*/</span></span><br><span class="line">产生式  &#123;动作代码&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"><span class="comment">/*辅助函数，会被复制到生成的.c文件的末尾*/</span></span><br></pre></td></tr></table></figure><p style="text-indent:2em">Bison需要一个yylex来获取下一个词法单元，还需要一个yyerror提供报错。定义主函数，调用yyparse()，就可以让语法分析器工作。</p><p style="text-indent:2em">在语法分析过程中，语法分析树的叶子节点是一个具体的语义值，该值的类型是YYSTYPE，在Bison中用%union指明。不同的节点对应着不同的终结符，可能为不同的类型，因此union中可以包含不同的数据类型。可以指明一个终结符或是非终结符的类型，以便后续的使用。可以使用%type <>或%token <>指明类型。其中%token是在声明词法单元名的同时指明类型，声明的token会由Bison导出到最终的.h文件中，让词法分析器也可以直接使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%token &lt;num&gt; NUMBER<span class="comment">/*声明词法单元名，并在&lt;&gt;中指明类型*/</span></span><br><span class="line">%type  &lt;typex&gt; expr<span class="comment">/*指明类型*/</span></span><br><span class="line">...</span><br><span class="line">%<span class="keyword">union</span>&#123;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="type">double</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">下面说明语法分析时的动作怎么编写。以一个边进行语法分析边按照语义执行的计算器为例，识别到加法语句的动作为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E→E+E&#123;E=E1+E2&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">在Bison中的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">term : term ADDOP factor</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">switch</span> $<span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: $$ = $<span class="number">1</span> + $<span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: $$ = $<span class="number">1</span> - $<span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">其中$$表示当前节点，$1,$2,$3表示产生式的成分，也是当前节点的子节点。由于采用自底向上分析(LALR)文法，构建语法树是推导的过程，这些子节点是已经解析的，当前节点则是规约产生的。使用节点union的哪个类型操作，是已经用<>在开头的%token和%type中指明的。</p><p style="text-indent:2em">实际的编译器中，语法分析相应的动作通常是建立抽象语法树，进行语义分析，或是直接产生中间或目标代码。在本实验中，动作为自底向上构建语法分析树。</p><h3 id="2-Bison与Flex的协同工作"><a href="#2-Bison与Flex的协同工作" class="headerlink" title="2.Bison与Flex的协同工作"></a>2.Bison与Flex的协同工作</h3><p style="text-indent:2em">Bison需要一个yylex来完成词法分析，这部分的工作是词法分析器完成的。词法分析器不仅要将词素识别为词法单元并返回词法单元值，还要返回词法单元的属性。这是通过yylval完成的。yylval是使用Bison生成的.c文件中声明的一个全局的变量，类型为YYSTYPE，即在Bison文件中%union声明的类型，使用这个类型将属性值传递。进行词法分析时，只要将属性值存入yylval，语法分析器就可以从yylval获取识别到的词法单元的属性值。</p><p style="text-indent:2em">在实验中，yylval仅包含一个语法分析树的节点指针。节点中包含一个节点名。对于语法分析树的叶子节点，这个节点名就是词法单元的值，对于非叶子节点，这个节点名为语法成分名。在以下分析语法分析树的生成过程中，分析了节点及分析树是如何构造的。</p><h3 id="3-分析树的生成过程"><a href="#3-分析树的生成过程" class="headerlink" title="3.分析树的生成过程"></a>3.分析树的生成过程</h3><p style="text-indent:2em">分析树的相关数据结构和方法定义在/include/SyntaxTree.h文件中，分析树的节点记录了父节点，子节点的指针，以及子节点数和节点名信息，相关的方法包括生成新的节点，添加子节点，创建语法树等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法分析树的节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_syntax_tree_node</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_syntax_tree_node</span> * parent;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_syntax_tree_node</span> * children[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> children_num;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> name[SYNTAX_TREE_NODE_NAME_MAX];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_syntax_tree_node</span> syntax_tree_node;</span><br><span class="line"><span class="comment">//相关函数</span></span><br><span class="line"><span class="function">syntax_tree_node * <span class="title">new_anon_syntax_tree_node</span><span class="params">()</span></span>;<span class="comment">//创建新节点</span></span><br><span class="line"><span class="function">syntax_tree_node * <span class="title">new_syntax_tree_node</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * name)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">syntax_tree_add_child</span><span class="params">(syntax_tree_node * parent, syntax_tree_node * child)</span></span>;<span class="comment">//添加子节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del_syntax_tree_node</span><span class="params">(syntax_tree_node * node, <span class="type">int</span> recursive)</span></span>;<span class="comment">//删除节点</span></span><br><span class="line"><span class="function">syntax_tree* <span class="title">new_syntax_tree</span><span class="params">()</span></span>;<span class="comment">//创建语法分析树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del_syntax_tree</span><span class="params">(syntax_tree * tree)</span></span>;<span class="comment">//删除分析树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_syntax_tree</span><span class="params">(FILE * fout, syntax_tree * tree)</span></span>;<span class="comment">//输出分析树</span></span><br></pre></td></tr></table></figure><p style="text-indent:2em">每个终结符都对应着一个叶子节点，这个叶子节点在词法分析时就可以产生。在自底向上的分析过程中，首先产生的是叶子节点，在用产生式进行规约时向上构建语法分析树。叶子节点的产生在词法分析器中的pass_node()函数中实现，创建一个新的节点，并将其指针赋值给yylval，节点名为其成分(非终结符名或终结符名)，这样语法分析器就可以使用该节点构造语法分析树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成节点并存入yylval传递给语法分析器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pass_node</span><span class="params">(<span class="type">char</span> *text)</span></span>&#123;</span><br><span class="line">     yylval.node = <span class="built_in">new_syntax_tree_node</span>(text);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//识别词法单元时调用pass_node</span></span><br><span class="line">\+  &#123; pos_start = pos_end; pos_end += <span class="number">1</span>; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> ADD; &#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">词法分析完成了叶子节点的产生，剩下的工作就由语法分析来完成了。构建的过程就是在每使用一个产生式进行规约时，建立一个新的节点表示当前产生式的非终结符，然后将产生式中的成分，也就是子节点的指针存入这个新节点中。当最后使用起始产生式规约时，产生的新节点就是语法分析树的根节点，就完成了向上构建语法分析树的工作。实验在Bison的.y文件中，已经给出了创建新节点并建立节点关系的函数，为node()函数，参数为产生式的非终结符名，产生式成分个数(也即子节点个数)，子节点的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产生一个语法分析树新节点的函数</span></span><br><span class="line"><span class="function">syntax_tree_node *<span class="title">node</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *node_name, <span class="type">int</span> children_num, ...)</span></span>;</span><br><span class="line"><span class="comment">//应用该函数构造语法分析树，根节点的构造</span></span><br><span class="line">program : declaration-list &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;program&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); gt-&gt;root = $$; &#125;</span><br></pre></td></tr></table></figure><h2 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h2><h3 id="1-词法分析部分"><a href="#1-词法分析部分" class="headerlink" title="1.词法分析部分"></a>1.词法分析部分</h3><p style="text-indent:2em">完善词法分析部分，即./src/parser/lexical_analyzer.l文件。只需要在识别动作中添加pass_node(yytext)产生词法单元叶子节点，通过yylval传递给语法分析器。对于注释，换行符和空格，不需要添加到语法分析树当中，因此创建节点和返回值，如果读到了就更新lines与pos，保证出错时可以定位，然后进行下一个词法单元的识别就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">%%</span><br><span class="line"></span><br><span class="line">\+  &#123; pos_start = pos_end; pos_end += <span class="number">1</span>; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> ADD; &#125;</span><br><span class="line">\-   &#123;pos_start = pos_end; pos_end++; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> SUB;&#125;</span><br><span class="line">\*   &#123;pos_start = pos_end; pos_end++; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> MUL;&#125;</span><br><span class="line">\/   &#123;pos_start = pos_end; pos_end++; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> DIV;&#125;</span><br><span class="line">\&lt;   &#123;pos_start = pos_end; pos_end++; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> LT;&#125;</span><br><span class="line"><span class="string">&quot;&lt;=&quot;</span> &#123;pos_start = pos_end; pos_end+=<span class="number">2</span>; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> LTE;&#125;</span><br><span class="line">\&gt;   &#123;pos_start = pos_end; pos_end++; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> GT;&#125;</span><br><span class="line"><span class="string">&quot;&gt;=&quot;</span> &#123;pos_start = pos_end; pos_end+=<span class="number">2</span>; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> GTE;&#125;</span><br><span class="line"><span class="string">&quot;==&quot;</span> &#123;pos_start = pos_end; pos_end+=<span class="number">2</span>; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> EQ;&#125;</span><br><span class="line"><span class="string">&quot;!=&quot;</span> &#123;pos_start = pos_end; pos_end+=<span class="number">2</span>; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> NEQ;&#125;</span><br><span class="line">\=   &#123;pos_start = pos_end; pos_end++; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> ASSIN;&#125;</span><br><span class="line">\;   &#123;pos_start = pos_end; pos_end++; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> SEMICOLON;&#125;</span><br><span class="line">\,   &#123;pos_start = pos_end; pos_end++; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> COMMA;&#125;</span><br><span class="line">\(  &#123;pos_start = pos_end; pos_end++; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> LPARENTHESE;&#125;</span><br><span class="line">\)  &#123;pos_start = pos_end; pos_end++; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> RPARENTHESE;&#125;</span><br><span class="line">\[  &#123;pos_start = pos_end; pos_end++; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> LBRACKET;&#125;</span><br><span class="line">\]  &#123;pos_start = pos_end; pos_end++; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> RBRACKET;&#125;</span><br><span class="line">\&#123;  &#123;pos_start = pos_end; pos_end++; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> LBRACE;&#125;</span><br><span class="line">\&#125;  &#123;pos_start = pos_end; pos_end++; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> RBRACE;&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;pos_start = pos_end; pos_end+=<span class="number">4</span>; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> ELSE;&#125;</span><br><span class="line"><span class="keyword">if</span>   &#123;pos_start = pos_end; pos_end+=<span class="number">2</span>; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> IF;&#125;</span><br><span class="line"><span class="type">int</span>  &#123;pos_start = pos_end; pos_end+=<span class="number">3</span>; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> INT;&#125;</span><br><span class="line"><span class="type">float</span> &#123;pos_start = pos_end; pos_end+=<span class="number">5</span>; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> FLOAT;&#125;</span><br><span class="line"><span class="keyword">return</span> &#123;pos_start = pos_end; pos_end+=<span class="number">6</span>; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> RETURN;&#125;</span><br><span class="line"><span class="type">void</span>   &#123;pos_start = pos_end; pos_end+=<span class="number">4</span>; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> VOID;&#125;</span><br><span class="line"><span class="keyword">while</span>  &#123;pos_start = pos_end; pos_end+=<span class="number">5</span>; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> WHILE;&#125;</span><br><span class="line">[a-zA-Z]+ &#123;pos_start = pos_end; pos_end+=<span class="built_in">strlen</span>(yytext); <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> IDENTIFIER;&#125;</span><br><span class="line">[a-zA-Z]  &#123;pos_start = pos_end; pos_end++; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> LETTER;&#125;  </span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>]+    &#123;pos_start = pos_end; pos_end+=<span class="built_in">strlen</span>(yytext); <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> INTEGER;&#125;</span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>]+\.|[<span class="number">0</span><span class="number">-9</span>]*\.[<span class="number">0</span><span class="number">-9</span>]+ &#123;pos_start = pos_end; pos_end+=<span class="built_in">strlen</span>(yytext); <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> FLOATPOINT;&#125;</span><br><span class="line"><span class="string">&quot;[]&quot;</span> &#123;pos_start = pos_end; pos_end+=<span class="number">2</span>; <span class="built_in">pass_node</span>(yytext); <span class="keyword">return</span> ARRAY;&#125;</span><br><span class="line">\n  &#123;lines++;pos_end = <span class="number">1</span>;&#125; </span><br><span class="line"><span class="string">&quot;/*&quot;</span>([^*]|\*+[^*/])*\*+<span class="string">&quot;/&quot;</span>  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(yytext);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(yytext[i]==<span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            lines++;</span><br><span class="line">            pos_end = <span class="number">1</span>;<span class="comment">//pos_start由pos_end得到，这里就不需要置1了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> pos_end++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="string">&quot; &quot;</span>|\t] &#123;pos_start = pos_end; pos_end+=<span class="built_in">strlen</span>(yytext);&#125;</span><br><span class="line">. &#123;pos_start = pos_end; pos_end+=<span class="built_in">strlen</span>(yytext);<span class="built_in">printf</span>(<span class="string">&quot;lexical analyze error at line %d pos %d\n&quot;</span>,lines,pos_start);&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br></pre></td></tr></table></figure><h3 id="2-语法分析部分"><a href="#2-语法分析部分" class="headerlink" title="2.语法分析部分"></a>2.语法分析部分</h3><p style="text-indent:2em">完善词法分析部分，即./src/parser/lexical_analyzer.l文件。首先完成yylval的定义，在union中只含有一个节点指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%<span class="keyword">union</span> &#123;</span><br><span class="line">    syntax_tree_node *node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">接下来进行终结符(词法单元)的声明和非终结符的类型声明，类型都是语法分析树的节点指针，其中终结符名要和词法分析部分中的token一致，非终结符名和Cminus-f的语法规则中一致。声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%start program</span><br><span class="line">%token &lt;node&gt; ADD SUB MUL DIV</span><br><span class="line">%token &lt;node&gt; LT LTE GT GTE EQ NEQ ASSIN</span><br><span class="line">%token &lt;node&gt; SEMICOLON COMMA LPARENTHESE RPARENTHESE LBRACKET RBRACKET LBRACE RBRACE</span><br><span class="line">%token &lt;node&gt; ELSE IF INT FLOAT RETURN VOID WHILE IDENTIFIER LETTER INTEGER FLOATPOINT ARRAY</span><br><span class="line">%type &lt;node&gt; type-specifier relop addop mulop</span><br><span class="line">%type &lt;node&gt; declaration-list declaration var-declaration fun-declaration local-declarations</span><br><span class="line">%type &lt;node&gt; compound-stmt statement-list statement expression-stmt iteration-stmt selection-stmt <span class="keyword">return</span>-stmt</span><br><span class="line">%type &lt;node&gt; simple-expression expression var additive-expression term factor integer <span class="type">float</span> call</span><br><span class="line">%type &lt;node&gt; params param-list param args arg-list program</span><br></pre></td></tr></table></figure><p style="text-indent:2em">最后补充语法规则的部分，规则按照给出的Cminus-f的语法编写，动作则是调用node()函数构造语法分析树的节点，参数为子节点个数和使用$n表示的子节点的指针，当产生式为空输入时，参数为0，子节点为空串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">program : declaration-list &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;program&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); gt-&gt;root = $$; &#125; ;</span><br><span class="line">declaration-list : declaration-list declaration &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;declaration-list&quot;</span>, <span class="number">2</span>, $<span class="number">1</span>, $<span class="number">2</span>); &#125;</span><br><span class="line">                 | declaration &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;declaration-list&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">                 ;</span><br><span class="line">declaration : var-declaration &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;declaration&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">            | fun-declaration &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;declaration&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">            ;</span><br><span class="line">var-declaration : type-specifier IDENTIFIER SEMICOLON &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;var-declaration&quot;</span>, <span class="number">3</span>, $<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>); &#125;</span><br><span class="line">                | type-specifier IDENTIFIER LBRACKET INTEGER RBRACKET SEMICOLON &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;var-declaration&quot;</span>, <span class="number">6</span>, $<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>, $<span class="number">4</span>, $<span class="number">5</span>, $<span class="number">6</span>); &#125;</span><br><span class="line">                ;</span><br><span class="line">type-specifier : INT &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;type-specifier&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">               | FLOAT &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;type-specifier&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">               | VOID &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;type-specifier&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">               ;</span><br><span class="line">fun-declaration : type-specifier IDENTIFIER LPARENTHESE params RPARENTHESE compound-stmt &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;fun-declaration&quot;</span>, <span class="number">6</span>, $<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>, $<span class="number">4</span>, $<span class="number">5</span>, $<span class="number">6</span>); &#125; ;</span><br><span class="line">params : param-list &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;params&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">       | VOID &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;params&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">       ;</span><br><span class="line">param-list : param-list COMMA param &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;param-list&quot;</span>, <span class="number">3</span>, $<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>); &#125;</span><br><span class="line">           | param &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;param-list&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">           ;</span><br><span class="line">param : type-specifier IDENTIFIER &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;param&quot;</span>, <span class="number">2</span>, $<span class="number">1</span>, $<span class="number">2</span>); &#125;</span><br><span class="line">      | type-specifier IDENTIFIER ARRAY &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;param&quot;</span>, <span class="number">3</span>, $<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>); &#125;</span><br><span class="line">      ;</span><br><span class="line">compound-stmt : LBRACE local-declarations statement-list RBRACE &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;compound-stmt&quot;</span>, <span class="number">4</span>, $<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>, $<span class="number">4</span>); &#125; ;</span><br><span class="line">local-declarations : &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;local-declarations&quot;</span>, <span class="number">0</span>); &#125;</span><br><span class="line">                   | local-declarations var-declaration &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;local-declarations&quot;</span>, <span class="number">2</span>, $<span class="number">1</span>, $<span class="number">2</span>); &#125;</span><br><span class="line">                   ;</span><br><span class="line">statement-list : &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;statement-list&quot;</span>, <span class="number">0</span>); &#125;</span><br><span class="line">               | statement-list statement &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;statement-list&quot;</span>, <span class="number">2</span>, $<span class="number">1</span>, $<span class="number">2</span>); &#125;</span><br><span class="line">               ;</span><br><span class="line">statement : expression-stmt &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;statement&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">          | compound-stmt &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;statement&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">          | selection-stmt &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;statement&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">          | iteration-stmt &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;statement&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">          | <span class="keyword">return</span>-stmt &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;statement&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">          ;</span><br><span class="line">expression-stmt : expression SEMICOLON &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;expression-stmt&quot;</span>, <span class="number">2</span>, $<span class="number">1</span>, $<span class="number">2</span>); &#125;</span><br><span class="line">                | SEMICOLON &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;expression-stmt&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">                ;</span><br><span class="line">selection-stmt : IF LPARENTHESE expression RPARENTHESE statement &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;selection-stmt&quot;</span>, <span class="number">5</span>, $<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>, $<span class="number">4</span>, $<span class="number">5</span>); &#125;</span><br><span class="line">               | IF LPARENTHESE expression RPARENTHESE statement ELSE statement &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;selection-stmt&quot;</span>, <span class="number">7</span>, $<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>, $<span class="number">4</span>, $<span class="number">5</span>, $<span class="number">6</span>, $<span class="number">7</span>); &#125;</span><br><span class="line">               ;</span><br><span class="line">iteration-stmt : WHILE LPARENTHESE expression RPARENTHESE statement &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;iteration-stmt&quot;</span>, <span class="number">5</span>, $<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>, $<span class="number">4</span>, $<span class="number">5</span>); &#125; ;</span><br><span class="line"><span class="keyword">return</span>-stmt : RETURN SEMICOLON &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;return-stmt&quot;</span>, <span class="number">2</span>, $<span class="number">1</span>, $<span class="number">2</span>); &#125;</span><br><span class="line">            | RETURN expression SEMICOLON &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;return-stmt&quot;</span>, <span class="number">3</span>, $<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>); &#125;</span><br><span class="line">            ;</span><br><span class="line">expression : var ASSIN expression &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;expression&quot;</span>, <span class="number">3</span>, $<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>); &#125;</span><br><span class="line">           | simple-expression &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;expression&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">           ;</span><br><span class="line">var : IDENTIFIER &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;var&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">    | IDENTIFIER LBRACKET expression RBRACKET &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;var&quot;</span>, <span class="number">4</span>, $<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>, $<span class="number">4</span>); &#125;</span><br><span class="line">    ;</span><br><span class="line">simple-expression : additive-expression relop additive-expression &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;simple-expression&quot;</span>, <span class="number">3</span>, $<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>); &#125;</span><br><span class="line">                  | additive-expression &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;simple-expression&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">                  ;</span><br><span class="line">relop : LTE &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;relop&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">      | LT &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;relop&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">      | GT &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;relop&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">      | GTE &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;relop&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">      | EQ &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;relop&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">      | NEQ &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;relop&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">      ;</span><br><span class="line">additive-expression : additive-expression addop term &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;additive-expression&quot;</span>, <span class="number">3</span>, $<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>); &#125;</span><br><span class="line">                    | term &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;additive-expression&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">                    ;</span><br><span class="line">addop : ADD &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;addop&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">      | SUB &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;addop&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">      ;</span><br><span class="line">term : term mulop factor &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;term&quot;</span>, <span class="number">3</span>, $<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>); &#125;</span><br><span class="line">     | factor &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;term&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">     ;</span><br><span class="line">mulop : MUL &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;mulop&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">      | DIV &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;mulop&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">      ;</span><br><span class="line">factor : LPARENTHESE expression RPARENTHESE &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;factor&quot;</span>, <span class="number">3</span>, $<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>); &#125;</span><br><span class="line">       | var &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;factor&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">       | call &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;factor&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">       | integer &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;factor&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">       | <span class="type">float</span> &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;factor&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">       ;</span><br><span class="line">integer : INTEGER &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;integer&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125; ;</span><br><span class="line"><span class="type">float</span> : FLOATPOINT &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;float&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125; ;</span><br><span class="line">call : IDENTIFIER LPARENTHESE args RPARENTHESE &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;call&quot;</span>, <span class="number">4</span>, $<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>, $<span class="number">4</span>); &#125; ;</span><br><span class="line">args : &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;args&quot;</span>, <span class="number">0</span>); &#125;</span><br><span class="line">     | arg-list &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;args&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">     ;</span><br><span class="line">arg-list : arg-list COMMA expression &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;arg-list&quot;</span>, <span class="number">3</span>, $<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>); &#125;</span><br><span class="line">         | expression &#123; $$ = <span class="built_in">node</span>(<span class="string">&quot;arg-list&quot;</span>, <span class="number">1</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">         ;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">完成了以上的补充后，语法分析和词法分析就应该都可以正常进行了。尝试编译时提示缺少yyin的声明，在语法分析函数parse中使用了yyin来进行读入，yyin是词法分析Flex产生的变量，这里需要引入，因此在开头补充引入该文件指针变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> FILE *yyin;</span><br></pre></td></tr></table></figure><h2 id="实验结果验证"><a href="#实验结果验证" class="headerlink" title="实验结果验证"></a>实验结果验证</h2><h3 id="1-给出的测试样例"><a href="#1-给出的测试样例" class="headerlink" title="1.给出的测试样例"></a>1.给出的测试样例</h3><p style="text-indent:2em">编译成功后执行命令./tests/lab2/test_syntax.sh easy和./tests/lab2/test_syntax.sh normal生成语法分析树。</p><p><img src="/2022/11/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9ABison/image-20221117225728888.png" alt="image-20221117225728888" style="zoom:50%;"></p><p><img src="/2022/11/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9ABison/image-20221117225129353.png" alt="image-20221117225129353" style="zoom:50%;"></p><p style="text-indent:2em">diff命令验证结果是否正确。</p><p><img src="/2022/11/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9ABison/image-20221117225853308.png" alt="image-20221117225853308" style="zoom:67%;"></p><h3 id="2-自行编写的测试样例"><a href="#2-自行编写的测试样例" class="headerlink" title="2.自行编写的测试样例"></a>2.自行编写的测试样例</h3><p style="text-indent:2em">编写一个cminus-f程序进行语法分析，产生语法分析树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;<span class="type">int</span> a[<span class="number">10</span>];<span class="type">int</span> j;</span><br><span class="line">    i=<span class="number">0</span>;j=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">quicksort</span>(a,i,j);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        p = <span class="built_in">partition</span>(a,l,r);</span><br><span class="line">        <span class="built_in">quicksort</span>(a,l,p<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quicksort</span>(a,l,p+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = a[l];</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">while</span>(temp&lt;=a[r])&#123;</span><br><span class="line">            r = r<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">                a[l] = temp;</span><br><span class="line">                <span class="keyword">return</span> l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[l] = a[r];</span><br><span class="line">        <span class="keyword">while</span>(temp&gt;=a[l])&#123;</span><br><span class="line">            l = l+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">                a[l] = temp;</span><br><span class="line">                <span class="keyword">return</span> l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">没有语法错误，相应的语法分析树也是正确的。部分结果如下：</p><p><img src="/2022/11/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9ABison/image-20221120100609743.png" alt="image-20221120100609743" style="zoom:80%;"></p><p><img src="/2022/11/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9ABison/image-20221120100740684.png" alt="image-20221120100740684" style="zoom: 67%;"></p><p style="text-indent:2em">编写一个存在语法错误的程序，cminus语法中变量不可以在一个声明语句声明多个同类型变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i,sum;</span><br><span class="line">    i = n;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        sum = sum+a[i];</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">程序给出了语法错误的位置。</p><p><img src="/2022/11/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9ABison/image-20221120101730192.png" alt="image-20221120101730192" style="zoom:80%;"></p>]]></content>
      
      
      <categories>
          
          <category> cs基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络自顶向下方法笔记03</title>
      <link href="/2022/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B003/"/>
      <url>/2022/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B003/</url>
      
        <content type="html"><![CDATA[<p style="text-indent:2em">《计算机网络自顶向下方法》学习笔记03:网络层。</p><p style="text-indent:2em">网络层提供了主机到主机的通信服务。网络中的每一台主机和路由器都有网络层部分。网络层能够被分解为两部分，数据平面和控制平面。</p><h1 id="第四章-网络层：数据平面"><a href="#第四章-网络层：数据平面" class="headerlink" title="第四章 网络层：数据平面"></a>第四章 网络层：数据平面</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p style="text-indent:2em">网络层的任务是取得源主机的报文段，将其封装为数据报，通过路由器的转发，将数据报发送到目的主机的网络层。可以说，网络层的作用就是将分组从一台主机移动到另一台主机。网络层的功能可分为两部分：</p><ul><li>转发：路由器将输入链路的分组移动到适当的输出链路的路由器本地动作。是数据平面的主要任务。</li><li>路由选择：决定分组移动所采用的端到端路径。</li></ul><p style="text-indent:2em">本章主要讨论的是网络层的<b>转发</b>功能。</p><span id="more"></span><h2 id="2-路由器工作原理"><a href="#2-路由器工作原理" class="headerlink" title="2.路由器工作原理"></a>2.路由器工作原理</h2><p style="text-indent:2em">路由器由如下几个组件构成：</p><ul><li>输入端口</li><li>交换结构</li><li>输出端口</li><li>路由选择处理器</li></ul><h3 id="输入端口处理"><a href="#输入端口处理" class="headerlink" title="输入端口处理"></a>输入端口处理</h3><p style="text-indent:2em">输入端口的处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线路端接-----&gt;数据链路处理(协议，拆封)-----&gt;查找，转发，排队-----&gt;交换结构</span><br></pre></td></tr></table></figure><p style="text-indent:2em">在输入端口，路由器将使用转发表查找输出端口，然后将分组交给交换结构。转发表是由路由选择处理器计算和更新的。转发表可能由路由选择协议计算，也可能接收远程SDN控制器的内容，再复制到线路卡上。</p><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p style="text-indent:2em">通过交换结构，路由器将分组从输入端口转发到一个输出端口。交换的方式有以下几种：</p><ul><li>经内存交换：最早的路由器的交换是由路由选择处理器的直接控制完成的，输入输出端口类似于IO设备，收到分组后，通过中断向处理器发出信号，处理器提取目的地址，并将分组复制到输出端口的缓存中。现代路由器对目的地址的查找和分组存储是由输入线路卡来处理的。</li><li>经总线交换：输入端口经一根总线将分组直接传送到输出端口。需要输入端口提前为分组计划一个标签，指示本地输出端口，所有输出端口都能收到总线的该分组，但只有与标签匹配的输出端口才保存该分组，并将标签去掉。</li><li>经互联网络交换：通过更加复杂的互联网络进行交换，例如纵横式网络。</li></ul><h3 id="输出端口处理"><a href="#输出端口处理" class="headerlink" title="输出端口处理"></a>输出端口处理</h3><p style="text-indent:2em">输出端口的处理如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">交换结构-----&gt;排队(缓存管理)-----&gt;数据链路处理(协议，封装)-----&gt;线路端接</span><br></pre></td></tr></table></figure><h3 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h3><p style="text-indent:2em">排队可能出现在输入端口，也可能出现在输出端口，这取决于流量负载，交换结构的速率等。随着队列增长，路由器缓存空间耗尽，就会发生丢包。</p><p style="text-indent:2em">在输入端口，如果两个分组是发往同一个输出端口，就会有一个分组被阻塞，必须在队列中等待。而排在该等待分组后面的分组也要等待，尽管他的输出端口没有被占用，这种现象叫做输入排队交换机中的线路前部阻塞。</p><p style="text-indent:2em">在输出端口，由于输出端口的发送速率是受到限制的，也可能形成排队的队列。当没有足够内存缓存分组时，必须丢弃到达的分组，或者删除一个或多个排队的分组为新分组留出空间。某些情况下，缓存填满前就丢弃一个分组，可以向发送方提供一个拥塞信号。关于分组丢弃和标记的策略，被称为主动队列管理算法。</p><p style="text-indent:2em">路由器需要缓存来吸收流量负载的波动。多年以来，缓存长度的经验值是RTT乘链路容量C。最近的研究表明，有大量的TCP流过一条链路时，缓存数为B=RTT*C*n^(-1/2)。</p><p style="text-indent:2em">排队分组如何经输出链路传输，需要使用到分组调度策略。常用的策略有以下几种：</p><ul><li>先进先出</li><li>优先权排队</li><li>循环排队</li><li>加权公平排队(WFQ)：在循环排队的基础上，为每个类分配一个权，该类收到的服务为这个权值/所有类别权值之和。然而事实上，不能打断一个分组的传输开始传输另一个分组，因此保证权重是不现实的。</li></ul><h2 id="3-网际协议"><a href="#3-网际协议" class="headerlink" title="3.网际协议"></a>3.网际协议</h2><h3 id="3-1-IPv4数据报首部格式"><a href="#3-1-IPv4数据报首部格式" class="headerlink" title="3.1 IPv4数据报首部格式"></a>3.1 IPv4数据报首部格式</h3><ul><li>版本：表示IP协议的版本</li><li>首部长度：4字节，表示IP数据报首部的长度，该字段的取值以4字节为单位，最小取值为5，表示只有20字节固定部分，最大取值为15，表示IP数据报首部包含20字节固定部分和最大40字节可变部分</li><li>可选字段：用于支持排错，测量，安全等，由于长度不定增加了路由器处理IP数据报的开销，实际上很少使用</li><li>填充：填充保证IP数据报首部为4字节的整数倍</li><li>区分服务字段：用数值提供不同等级的服务质量，一般情况下都不使用该字段</li><li>总长度字段：表示IP数据报总长度(首部+数据载荷)</li><li>标识，标志，片偏移用于IP数据报分片。当IP数据报长度超过帧的数据载荷的最大长度(最大传输单元MTU)，无法封装，需要分片<ul><li>标识：同一个数据报的各分片数据报有相同标识。IP软件维持计数器，每产生一个数据报，计数加1，并将该值赋给标识字段</li><li>标志：3bit<ul><li>DF位：1表示允许分片</li><li>MF位：1表示还有分片，0表示这是最后一个分片</li><li>保留位：必须为0</li></ul></li><li>片偏移：以8个字节为单位。指出分片数据报的数据载荷部分偏移其原数据报的位置</li></ul></li><li>生存时间TTL：最初以秒为单位，最大生存周期为255秒，在路由器转发时减去在本路由器上耗费的时间。现在以跳数为单位，路由器转发时-1。</li><li>协议字段：指明数据部分是何种协议数据单元<ul><li>1：ICMP报文</li><li>6：TCP报文</li></ul></li><li>首部检验和：使用因特网检验和检测首部在传输过程中是否出现差错。由于IP层不提供可靠传输服务，因此IPv6中，路由器不再计算首部校验和。</li></ul><h3 id="3-2-IPv4数据报分片"><a href="#3-2-IPv4数据报分片" class="headerlink" title="3.2 IPv4数据报分片"></a>3.2 IPv4数据报分片</h3><p style="text-indent:2em">一个链路层帧能承载的最大数据量叫做<b>最大传送单元MTU</b>。每个IP数据报的大小都受到MTU的限制。在传输过程中，不同链路可能存在不同的MTU，这导致IP数据报可能不得不被分成多部分。为了避免路由器的性能受影响，IPv4的设计者将数据报的重组工作放到<b>端系统</b>中。当目的主机的网络层收到一系列数据报时，通过IP数据报首部的标识，标志和片偏移字段将IPv4数据报重组。</p><h3 id="3-3-IPv4编址"><a href="#3-3-IPv4编址" class="headerlink" title="3.3 IPv4编址"></a>3.3 IPv4编址</h3><p style="text-indent:2em">主机与物理链路的边界称为接口，路由器与任何一条链路的边界也称为接口。每台主机与路由器都能发送和接收IP数据报，因此每个接口都有自己的IP地址。每个IP地址长度为32bit，用点分十进制表示。例如：192.32.216.9/24。/24表示<b>子网掩码</b>，表示一个子网络的前24位都是相同的，后8位用于区分子网中的主机。需要注意，<font color="blue">路由器接口也可以构成子网。</font></p><p style="text-indent:2em">早期的IP地址，网络部分被限制为8,16,24位，从而将子网分为A,B,C三类网络，这种编址被称为<b>分类编址</b>。由于分类编址不够灵活，只有三种分类，现在采用的是<b>CIDR无类别域间路由选择</b>，IP地址都表示为a.b.c.d/x。</p><p style="text-indent:2em">每个接口都需要有一个IP地址，这个地址并不是随着设备的产生就分配好的，而是获取的。首先，一个组织要获取一块地址，需要向ISP请求，而ISP的IP地址分配是由因特网名字和编号分配机构管理的。一个组织获取了一块地址，就可以为组织内的主机与路由器接口逐个分配IP地址。路由器中的IP地址常由管理员手工配置。而主机地址的配置，可以手工进行，但主要是使用<b>动态主机配置协议DHCP</b>完成的。DHCP允许主机自动获取一个临时的IP地址，还允许主机获取子网掩码，第一跳路由器地址(默认网关)，DNS服务器地址等信息。DHCP被称为即插即用协议或零配置协议，因为有能让主机自动连接进一个网络的能力。每个子网都有一个DHCP服务器，或一个中继代理。一个主机通过DHCP获取一个IP地址的过程如下：</p><ul><li>DHCP服务器发现：主机在UDP分组中向端口67发送<strong>DHCP发现报文</strong>。源IP地址为0.0.0.0，目的IP地址为广播地址255.255.255.255。</li><li>DHCP服务器提供：接收到DHCP发现报文后，DHCP服务器广播响应报文，报文的内容包含IP地址，租用期等。</li><li>DHCP请求：客户向选中的DHCP服务器(可能有多个DHCP服务器，客户可以择优选择)发送DHCP请求报文，回显配置参数。</li><li>DHCP ACK：服务器用DHCP ACK报文响应请求。</li></ul><h3 id="3-4-网络地址转换"><a href="#3-4-网络地址转换" class="headerlink" title="3.4 网络地址转换"></a>3.4 网络地址转换</h3><p style="text-indent:2em">一个子网从ISP获取一块地址后，就可以管理和分配地址了，但一个子网很可能扩张，例如在一个家庭中，电子设备越来越多。对于这种情况，可以使用一种简单的方法来管理地址：<b>网络地址转换NAT</b>。家庭网络内的编址可以为10.0.0.0/8，这是RFC保留的一部分IP地址空间，用于家庭网络等专用网络或具有专用地址的地域。这些地址只能在特定的网络中使用，不能在更大的网络空间使用。NAT使能路由器的作用就是将家庭网络中的专用地址进行转换，对外界隐藏网络内部细节。所有离开家庭网络的地址都是同一个，所有进入该网络的目的IP地址也是同一个。NAT路由器有一张<b>NAT路由表</b>，将内部主机IP地址，源端口号，与一个新端口号联系起来。NAT路由器完成了数据报到内部网络的转发工作。</p><p style="text-indent:2em">采用这种方式，内部网络的端口号和IP都被NAT转换为新IP和新端口号了，如果内部网络运行服务器，就会导致没有确定的用于等待的周知端口，解决方案是采用<b>NAT穿越</b>工具和通用即插即用协议。</p><h3 id="3-5-IPv6"><a href="#3-5-IPv6" class="headerlink" title="3.5 IPv6"></a>3.5 IPv6</h3><p style="text-indent:2em">为了应对IPv4地址空间耗尽的问题，以及对IPv4实践中的问题进行优化，IPv6发布了。IPv6有128bit的地址容量，这样地址将不会耗尽了。比起IPv4，IPv6不支持分片和重新组装，直接丢弃数据报，使用ICMP报文告知发送方发送更小的IP数据报。首部检验和也不存在了，因为运输层和数据链路层已经提供了检验操作，所以去除了IP数据报的检验，这也减少了处理分组的时间，因为首部中有TTL字段，原来每一条都要重新计算检验和。现在从IPv4到IPv6的迁移正在进行中，实践出了建隧道等方法，但要完全完成这个迁移，仍然需要解决很多困难和时间。</p><h1 id="第五章-网络层：控制平面"><a href="#第五章-网络层：控制平面" class="headerlink" title="第五章 网络层：控制平面"></a>第五章 网络层：控制平面</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h2><p style="text-indent:2em">网络层的控制功能包括控制沿着源主机到目的主机的端到端路径间的路由器如何转发数据报，以及控制网络层组件和服务如何配置和管理。完成这些控制功能有两种方式：</p><ul><li>每路由器控制：每个路由器都包含转发和路由选择功能，路由器都有一个路由选择组件，和其他路由器通信计算转发表的值。</li><li>逻辑集中式控制：由逻辑集中式控制器计算并分发转发表供每台路由器使用。</li></ul><h2 id="2-路由选择算法"><a href="#2-路由选择算法" class="headerlink" title="2.路由选择算法"></a>2.路由选择算法</h2><p style="text-indent:2em">路由选择算法是选择从发送方到接收方的一条最好路径的算法。最好的路径通常指最小开销的路径，而开销可能由多种因素决定，在考虑路由选择算法时，先假定开销都是给出的。路由选择算法有很多种分类方式：</p><p style="text-indent:2em">按照集中和分散进行分类：</p><ul><li>集中式路由选择算法：用完整的全局的网络状态信息计算最低开销路径。该类算法常被称作链路状态算法LS。</li><li>分散式路由选择算法：路由器以迭代，分布式的方式计算最低开销路径。节点通过迭代计算以及与相邻节点的信息交换逐渐算出最低开销路径。例如距离向量算法DV就是一个分散式路由选择算法。</li></ul><p style="text-indent:2em">按照静态动态分类：</p><ul><li>静态路由选择算法：通常人工进行调整。</li><li>动态路由选择算法：随着网络负载和拓扑变化而改变路径。</li></ul><p style="text-indent:2em">根据对负载是否敏感划分：</p><ul><li>负载敏感算法：链路开销动态变化，反映底层链路拥塞水平没路由选择算法趋于绕开拥塞链路。</li><li>负载迟钝算法：开销不变化。因为开销不明确反映拥塞水平，当今的路由器选择算法都是负载迟钝的。</li></ul><h2 id="3-因特网自治系统内部的路由选择算法：OSPF"><a href="#3-因特网自治系统内部的路由选择算法：OSPF" class="headerlink" title="3.因特网自治系统内部的路由选择算法：OSPF"></a>3.因特网自治系统内部的路由选择算法：OSPF</h2><p style="text-indent:2em">让所有路由器执行相同的路由选择算法是不可能的。一方面，因特网的规模十分庞大，在所有主机中存储所有路由选择信息是不现实的。另一方面，每个ISP有自己的路由器网络，希望按自己的意愿运行路由器，或对外部隐藏网络内部的组织面貌。因此路由器通常被组织进自治系统(AS)，每个AS由一组处在相同管理控制下的路由器组成。在相同AS中的路由器运行相同的路由选择协议且有彼此的信息。在一个自治系统内运行的路由选择算法叫做自治系统内部路由选择协议。</p><p style="text-indent:2em"><font color="red">开放最短路优先(OSPF)</font>算法是广泛应用于因特网的AS内部路由选择的一种算法。OSPF使用洪泛链路状态信息和Dijkstra最短路径算法。链路的开销由网络管理员配置。例如将链路开销都设置为1，实现的就是最少跳数路由选择。使用OSPF时，路由器向自治系统内所有其他路由器<b>广播</b>路由选择信息，当链路状态变化或经过一个特定周期，路由器就会广播链路状态信息。OSPF的优点包括：</p><ul><li>安全：使用鉴别，仅有受信任的路由器能参与一个AS内的OSPF协议。</li><li>多条相同开销的路径：对于多条相同开销路径，OSPF允许使用多条路径。</li><li>对单播与多播路由选择的综合支持。</li><li>支持单个AS中的层次结构：一个OSPF自治系统能够层次化配置多个区域，每个区域都运行自己的OSPF链路状态路由选择算法，路由器只在区域内进行广播，一台或多台边界路由器负责为流向区域外的分组提供路由选择。</li></ul><h2 id="4-ISP之间的路由选择：BGP"><a href="#4-ISP之间的路由选择：BGP" class="headerlink" title="4.ISP之间的路由选择：BGP"></a>4.ISP之间的路由选择：BGP</h2><p style="text-indent:2em">上述的OSPF是AS内部的路由选择协议，当分组跨越多个AS时，需要使用不同AS之间的路由选择协议。在因特网中，AS运行相同的AS间路由选择协议，称为<font color="red">边界网关协议BGP</font>。</p><p style="text-indent:2em">对于BGP来说，只要把分组送到分组的目标网络，不需要考虑送到目标主机的问题。因此BGP中，一个目的地是一个地址前缀，即一个网络。BGP通过两个手段将分组送到目标网络：</p><ul><li>从邻居AS获取前缀的可达性信息。BGP允许每个子网向因特网中的其他部分通告自己的存在，这样一个AS就知道一个子网的存在，才可能将分组送达这个子网。</li><li>确定最好的路由路径：基于策略和可达性信息，路由器会选择一条尽可能好的路由路径传送分组。</li></ul><p style="text-indent:2em">下面从这两个方面分析BGP的工作原理。</p><h3 id="4-1-通告BGP路由信息"><a href="#4-1-通告BGP路由信息" class="headerlink" title="4.1 通告BGP路由信息"></a>4.1 通告BGP路由信息</h3><p style="text-indent:2em">一个路由器总是在一个AS内或在AS边缘，因此不是网关路由器就是内部路由器。其中网关路由器在AS的边缘，且与另一个AS的路由器相连。一个网络的存在和到达的路径，是路由器发送BGP报文进行通告的。路由器通过使用179端口的半永久TCP连接交换路由选择信息，每条路由器之间的连接和发送的BGP报文，称为<b>BGP连接</b>。跨越两个AS的BGP连接为外部BGP(eBGP)，AS内部路由器的BGP会话为内部BGP(iBGP)。网关路由器首先通过eBGP告知另一个AS的网关路由器自己的存在和可达性信息(路径)，收到该信息的路由器使用iBGP将信息告知同一个AS内的其他路由器，这样该AS的所有路由器就知道了到达另一个AS的路径。</p><h3 id="4-2-路由选择"><a href="#4-2-路由选择" class="headerlink" title="4.2 路由选择"></a>4.2 路由选择</h3><p style="text-indent:2em">在考虑BGP的路由选择策略前，需要理解AS-PATH和NEXT-HOP。AS-PATH就是从当前AS到达一个AS的路径，当然，如果要通告给其他AS，路径还要加上自己。例如AS1到达AS10的路径为AS2-AS5-AS10，那么通告的路径就是AS1-AS0-AS2-AS10。到达一个AS可能有多条路径，因此有多个AS-PATH。NEXT-HOP则是AS-PATH起始地址的路由器接口IP地址。路由选择算法就是在多个AS-PATH中选择一个合适的路径的算法。BGP按照顺序使用以下规则选择路由，直到只剩下一条路径：</p><ul><li>路由器的本地偏好将被优先选择。本地偏好是网络管理员设置的。</li><li>余下的路由中，选择具有最短AS的路由，使用距离向量算法，距离是AS的跳数而不是路由器的跳数。</li><li>余下的路由中，选择最靠近NEXT-HOP路由器的路由。</li><li>如果仍留下多条路由，使用BGP标识符来选择路由。</li></ul>]]></content>
      
      
      <categories>
          
          <category> cs基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EffectiveCPP笔记</title>
      <link href="/2022/10/10/EffectiveCPP/"/>
      <url>/2022/10/10/EffectiveCPP/</url>
      
        <content type="html"><![CDATA[<p>Effective C++ 笔记。</p><span id="more"></span><h2 id="一-习惯使用C"><a href="#一-习惯使用C" class="headerlink" title="一.习惯使用C++"></a>一.习惯使用C++</h2><h3 id="1-C-有不同的特性"><a href="#1-C-有不同的特性" class="headerlink" title="1.C++有不同的特性"></a>1.C++有不同的特性</h3><p>C++是个多重泛型语言，支持面向过程，面向对象，函数，泛型，元编程的语言。理解C++最简单的方法是将其视为多个次语言构成的集合。在使用C++时，可能需要从一个次语言迁移到另一个次语言，在这个过程中，守则可能改变。主要的次语言只有四个：</p><ul><li>C</li><li>Object-Oriented C++</li><li>Template C++</li><li>STL</li></ul><p>从这四个次语言相互切换时，切换守则来进行高效编程是必要的。</p><h3 id="2-使用enum，const，inline替换-define"><a href="#2-使用enum，const，inline替换-define" class="headerlink" title="2.使用enum，const，inline替换#define"></a>2.使用enum，const，inline替换#define</h3><h1 id="define的部分可能不被视为语言的一部分，名称可能被预处理器处理，而编译时没有出现，没有进入符号表，这会导致当该宏定义的量发生错误时，编译错误信息可能提到的不是宏定义的名称，而是名称对应的值。如果宏定义在一个非自己所写的头文件中，遇到这种错误就很难定位到错误的位置。因此，最好用常量来替换宏定义。"><a href="#define的部分可能不被视为语言的一部分，名称可能被预处理器处理，而编译时没有出现，没有进入符号表，这会导致当该宏定义的量发生错误时，编译错误信息可能提到的不是宏定义的名称，而是名称对应的值。如果宏定义在一个非自己所写的头文件中，遇到这种错误就很难定位到错误的位置。因此，最好用常量来替换宏定义。" class="headerlink" title="define的部分可能不被视为语言的一部分，名称可能被预处理器处理，而编译时没有出现，没有进入符号表，这会导致当该宏定义的量发生错误时，编译错误信息可能提到的不是宏定义的名称，而是名称对应的值。如果宏定义在一个非自己所写的头文件中，遇到这种错误就很难定位到错误的位置。因此，最好用常量来替换宏定义。"></a>define的部分可能不被视为语言的一部分，名称可能被预处理器处理，而编译时没有出现，没有进入符号表，这会导致当该宏定义的量发生错误时，编译错误信息可能提到的不是宏定义的名称，而是名称对应的值。如果宏定义在一个非自己所写的头文件中，遇到这种错误就很难定位到错误的位置。因此，最好用常量来替换宏定义。</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxN = <span class="number">1e6</span>+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>以常量替换宏定义，有两种特殊情况：</p><ul><li>定义常量指针，有必要将指针声明为const，例如一个常量的char*-based字符串需要定义为const char* const name = “Y”。</li><li>类中的专属常量，为了保证所有对象只有一份该常量，需要声明为static成员。</li></ul><p>static const成员可以在类声明中直接给出值并使用，也可以在类的实现文件中单独给出其定义。如果是static成员而不是常量，则需要在实现文件中给出定义。</p><blockquote id="fn_声明时初始化"><sup>声明时初始化</sup>. 对于静态成员不能在类声明初始化的注解：非常量的静态成员是强符号，如果在类中设定初值，每个对象都包含该成员，多文件可能就会出现强符号重复定义；如果定义为常量，则为弱符号，如果不取地址，可能不会分配空间，直接在汇编指令中使用立即数代替，如果取地址，就又会变成强符号，多文件可能产生重复定义的错误。<a href="#reffn_声明时初始化" title="Jump back to footnote [声明时初始化] in the text."> &#8617;</a></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*非常量静态成员定义与声明分开*/</span></span><br><span class="line"><span class="comment">//student.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//student.cpp</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> student::num = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>对于一些编译器，可能不支持static const成员在类声明中设定初值，可以使用enum代替，enum不可以获取地址，许多代码都使用enum作为类的常量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123;num = <span class="number">5</span>&#125;;<span class="comment">//令num成为5的一个记号名称</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>宏定义的另一个问题是宏定义函数，由于宏定义只是简单的替换，错误传入参数可能带来的结果完全不同，因此最好使用inline内联函数替换函数形式的宏定义。</p><p><strong>总结：</strong></p><ul><li>使用单纯常量，最好使用const或enums，而不是#defines</li><li>形式函数的宏，最好使用inline函数替换</li></ul><h3 id="3-尽可能使用const"><a href="#3-尽可能使用const" class="headerlink" title="3.尽可能使用const"></a>3.尽可能使用const</h3><p>如果关键字const出现在<em>左侧，表示被指物是常量，如果在\</em>右侧，则指针是常量。</p><ul><li>将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何对象，函数参数，函数返回类型，函数本题。</li><li>编译器强制实施bitwise constness(通过赋值语句判断是否为const函数)，但编写程序应该使用概念性的常量性(例如如果成员有指针，那么指针指向的内容也不被修改，才是具有常量性)。</li><li>当const和non-const成员函数有着实质等价的实现时，令non-const调用const版本可避免代码重复。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">line</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> pos) <span class="type">const</span>&#123;</span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> &amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> pos)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;<span class="type">char</span>&amp;&gt;(</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;<span class="type">const</span> line&amp;&gt; (*<span class="keyword">this</span>)[pos]</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-确定对象被使用前已被初始化"><a href="#4-确定对象被使用前已被初始化" class="headerlink" title="4.确定对象被使用前已被初始化"></a>4.确定对象被使用前已被初始化</h3><ul><li>为内置型对象进行手工初始化。</li><li>构造函数最好使用成员初值列，而不要在构造函数本体内使用赋值操作，且排列顺序应该和声明顺序相同。</li><li>使用local static对象替换non-local static对象。</li></ul><h2 id="二-构造-析构-赋值"><a href="#二-构造-析构-赋值" class="headerlink" title="二.构造/析构/赋值"></a>二.构造/析构/赋值</h2><h3 id="1-了解C-提供了哪些函数"><a href="#1-了解C-提供了哪些函数" class="headerlink" title="1.了解C++提供了哪些函数"></a>1.了解C++提供了哪些函数</h3><ul><li>C++默认为类提供无参构造函数，拷贝构造函数，赋值运算符，析构函数。</li></ul><h3 id="2-如果不想使用编译器自动生成的函数，应明确拒绝"><a href="#2-如果不想使用编译器自动生成的函数，应明确拒绝" class="headerlink" title="2.如果不想使用编译器自动生成的函数，应明确拒绝"></a>2.如果不想使用编译器自动生成的函数，应明确拒绝<a id="mark1"></a></h3><ul><li>为驳回编译器自动生成函数，可以将相应的成员函数声明为private并不予实现。或者使用一个uncopyable基类，在这个基类将一些成员函数声明为private并不予以实现，然后继承这个类。</li></ul><h3 id="3-为多态基类声明virtual析构函数"><a href="#3-为多态基类声明virtual析构函数" class="headerlink" title="3.为多态基类声明virtual析构函数"></a>3.为多态基类声明virtual析构函数</h3><p>一般情况下使用多态，总是会使用基类的指针指向一个派生类，然而如果使用基类指针释放空间，可能会导致派生类的成员的空间没有释放，因为派生类的析构函数没有被调用。正确的做法是：</p><ul><li>带有多态性质的基类应该声明一个virtual析构函数，如果类有任何virtual函数，就应该有一个virtual析构函数，并且应该提供实现。</li><li>类的设计目的如果不是作为基类或不是为了实现多态，就不该声明virtual析构函数。</li></ul><h3 id="4-别让异常逃离析构函数"><a href="#4-别让异常逃离析构函数" class="headerlink" title="4.别让异常逃离析构函数"></a>4.别让异常逃离析构函数</h3><ul><li>析构函数不应该产生异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该能捕捉任何异常，然后不传播异常或结束程序。</li><li>如果客户需要对某个操作函数抛出的异常作出反应，那么类应该提供一个普通函数而不是在析构函数中进行操作。</li></ul><h3 id="5-不在构造函数和析构函数中调用virtual函数"><a href="#5-不在构造函数和析构函数中调用virtual函数" class="headerlink" title="5.不在构造函数和析构函数中调用virtual函数"></a>5.不在构造函数和析构函数中调用virtual函数</h3><ul><li>在构造和析构期间不要调用virtual函数，因为这类调用不下降到derived class。</li></ul><h3 id="6-令operator-返回一个reference-to-this"><a href="#6-令operator-返回一个reference-to-this" class="headerlink" title="6.令operator=返回一个reference to *this"></a>6.令operator=返回一个reference to *this</h3><h3 id="7-在operator-中处理自我赋值"><a href="#7-在operator-中处理自我赋值" class="headerlink" title="7.在operator=中处理自我赋值"></a>7.在operator=中处理自我赋值</h3><p>别名（使用指针，数组下标）可能会导致潜在的自我赋值，必须避免这种情况的发生。</p><ul><li>确保当对象自我赋值时有正确的行为，其中的技术包括比较来源对象和目标对象的地址，调整语句顺序(最后删除原对象的内容)，copy-and-swap。</li><li>确定任何函数操作一个及以上的对象，其中多个对象是同一个对象时，行为正确。</li></ul><h3 id="8-复制对象时别忘记任何一个成分"><a href="#8-复制对象时别忘记任何一个成分" class="headerlink" title="8.复制对象时别忘记任何一个成分"></a>8.复制对象时别忘记任何一个成分</h3><ul><li>拷贝函数应该确保复制对象内的所有成员变量及所有base class成分。</li><li>不要尝试以某个拷贝函数实现另一个拷贝函数。应该将共同的部分放进第三个函数中，共同调用。</li></ul><h2 id="三-资源管理"><a href="#三-资源管理" class="headerlink" title="三.资源管理"></a>三.资源管理</h2><h3 id="1-以对象管理资源"><a href="#1-以对象管理资源" class="headerlink" title="1.以对象管理资源"></a>1.以对象管理资源</h3><ul><li>为防止资源泄露，应该使用资源管理类，他们在构造函数中获得资源并在析构函数中释放资源。</li><li>两个常被使用的对象是智能指针shared_ptr和auto_ptr。auto_ptr指向资源的所有权只能有一个指针持有，如果进行赋值，原指针会被设为null，而shared_ptr会进行计数，可以多个指针指向一个资源，最后释放。</li></ul><h3 id="2-资源管理类的复制行为"><a href="#2-资源管理类的复制行为" class="headerlink" title="2.资源管理类的复制行为"></a>2.资源管理类的复制行为</h3><ul><li><p>复制资源管理类对象必须一并复制所管理的资源，资源的复制行为决定资源管理类对象的复制行为。</p></li><li><p>通常对于资源管理类的复制行为是：</p><ul><li><a href="#mark1">禁止复制</a></li><li>使用引用计数法：内含一个shared_ptr指针，并以期望的资源释放函数作为删除器</li><li>复制底部资源</li><li>转移底部资源的所有权</li></ul><p>引用计数的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* pm)</span>: mutexPtr(pm, unlock)&#123;</span></span><br><span class="line">        <span class="built_in">lock</span>(mutexPtr.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Mutex&gt; mutexPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-在资源管理类提供对原始资源的访问"><a href="#3-在资源管理类提供对原始资源的访问" class="headerlink" title="3.在资源管理类提供对原始资源的访问"></a>3.在资源管理类提供对原始资源的访问</h3><ul><li>APIs往往要求访问原始资源，所以每个资源管理类应该提供一个get方法。</li><li>对原始资源的访问可能经显式转换或隐式转换。一般而言显式转换比较安全，但隐式转换对客户比较方便。</li></ul><h3 id="4-成对使用new和delete时要采取相同形式"><a href="#4-成对使用new和delete时要采取相同形式" class="headerlink" title="4.成对使用new和delete时要采取相同形式"></a>4.成对使用new和delete时要采取相同形式</h3><h3 id="5-以独立语句将new对象存储于智能指针内"><a href="#5-以独立语句将new对象存储于智能指针内" class="headerlink" title="5.以独立语句将new对象存储于智能指针内"></a>5.以独立语句将new对象存储于智能指针内</h3><ul><li>以独立语句将new对象存储于智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的内存泄露。</li></ul><p>例如，以下的函数调用，可能先执行new产生对象，然后执行priority()发生异常终止程序，导致资源泄露。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//会产生异常的做法</span></span><br><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">shared_ptr</span>&lt;Widgt&gt;(<span class="keyword">new</span> Widget), <span class="built_in">priority</span>());<span class="comment">//参数操作执行顺序不确定</span></span><br><span class="line"><span class="comment">//独立语句存储对象指针</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Widgt&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line"><span class="built_in">processWidget</span>(pw, <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure><h2 id="四-设计与声明"><a href="#四-设计与声明" class="headerlink" title="四.设计与声明"></a>四.设计与声明</h2><h3 id="1-让接口容易被正确使用，不易被误用"><a href="#1-让接口容易被正确使用，不易被误用" class="headerlink" title="1.让接口容易被正确使用，不易被误用"></a>1.让接口容易被正确使用，不易被误用</h3><ul><li>好的接口应该容易使用，不易被误用</li><li>促进正确使用的方法包括接口的一致性，以及与内置类型的行为兼容</li><li>阻止误用的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任</li><li>shared_ptr支持定制删除器。可以防范DLL问题，可被用来自动解除互斥锁等</li></ul><h3 id="2-设计class犹如设计type"><a href="#2-设计class犹如设计type" class="headerlink" title="2.设计class犹如设计type"></a>2.设计class犹如设计type</h3><h3 id="3-使用常引用传参"><a href="#3-使用常引用传参" class="headerlink" title="3.使用常引用传参"></a>3.使用常引用传参</h3><ul><li>尽量以引用传参替换值传递。引用传参更高效，并可避免切割问题</li><li>对于内置类型，STL的迭代器和函数对象，使用值传递更合适</li></ul><h3 id="4-必须返回对象时，不要想返回引用"><a href="#4-必须返回对象时，不要想返回引用" class="headerlink" title="4.必须返回对象时，不要想返回引用"></a>4.必须返回对象时，不要想返回引用</h3><h3 id="5-将成员变量声明为private"><a href="#5-将成员变量声明为private" class="headerlink" title="5.将成员变量声明为private"></a>5.将成员变量声明为private</h3><h3 id="6-以non-member、non-friend替换member函数"><a href="#6-以non-member、non-friend替换member函数" class="headerlink" title="6.以non-member、non-friend替换member函数"></a>6.以non-member、non-friend替换member函数</h3><h3 id="7-如果所有参数都需要类型转换，使用non-member函数"><a href="#7-如果所有参数都需要类型转换，使用non-member函数" class="headerlink" title="7.如果所有参数都需要类型转换，使用non-member函数"></a>7.如果所有参数都需要类型转换，使用non-member函数</h3><h3 id="8-不抛出异常的swap函数"><a href="#8-不抛出异常的swap函数" class="headerlink" title="8.不抛出异常的swap函数"></a>8.不抛出异常的swap函数</h3><ul><li>当std::swap函数对类型效率不高时，提供一个不抛出异常的成员swap函数</li><li>提供一个成员swap函数，应该相应的提供一个非成员swap函数调用前者，对于class，特化std:;swap</li><li>调用swap应对std::swap使用using声明式</li><li>为用户定义类型进行std templates全特化是好的，但不要在std中加入全新的东西</li></ul><h2 id="五-实现"><a href="#五-实现" class="headerlink" title="五.实现"></a>五.实现</h2><h3 id="1-尽可能延后变量定义式的出现时间"><a href="#1-尽可能延后变量定义式的出现时间" class="headerlink" title="1.尽可能延后变量定义式的出现时间"></a>1.尽可能延后变量定义式的出现时间</h3><ul><li>尽可能延后变量定义式的出现，这样做可增加程序的清晰度并改善程序效率</li><li>对于循环中使用的变量，如果赋值成本比构造+析构低，或者正在处理代码中效率高度敏感的部分，可以在循环外定义变量，否则在循环内直接构造变量</li></ul><h3 id="2-尽量少做转型动作"><a href="#2-尽量少做转型动作" class="headerlink" title="2.尽量少做转型动作"></a>2.尽量少做转型动作</h3><ul><li>如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_casts</li><li>如果转型是必要的，尽量隐藏在函数后，使客户不需要将转型放入代码中</li><li>尽可能使用新式转型</li></ul><h3 id="3-避免返回引用，指针，迭代器"><a href="#3-避免返回引用，指针，迭代器" class="headerlink" title="3.避免返回引用，指针，迭代器"></a>3.避免返回引用，指针，迭代器</h3><h3 id="4-异常安全性"><a href="#4-异常安全性" class="headerlink" title="4.异常安全性"></a>4.异常安全性</h3><ul><li>异常安全函数即时发生一场也不会泄露资源或允许任何数据结构败坏，这样的函数分为三类：基本型，强烈型，不抛异常型</li><li>强烈保证往往能够以copy-and-swap实现，但不是所有函数都可实现强烈保证</li><li>函数提供的异常安全保证最高只等于所有调用函数的异常安全保证中的最低级</li></ul><h3 id="5-理解inline"><a href="#5-理解inline" class="headerlink" title="5.理解inline"></a>5.理解inline</h3><ul><li>将大多数inline限制在小型被频繁调研的函数身上，使潜在的代码膨胀问题最小化</li><li>不要只因为function templates出现在头文件，就将其声明为inline</li></ul><h3 id="6-将文件间的编译依存关系降低"><a href="#6-将文件间的编译依存关系降低" class="headerlink" title="6.将文件间的编译依存关系降低"></a>6.将文件间的编译依存关系降低</h3><ul><li><p>如果使用对象引用或指针可以完成任务，就不要使用对象本身</p></li><li><p>支持编译依存最小化的一般构想是：依赖声明式，不要依赖定义式，基于此构想的两个手段是Handle-class和Interface-class(提供一个factory函数，返回指向该类的一个新对象的指针)</p></li><li>头文件应该完全且仅有声明式</li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序设计语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理实验一：词法分析工具Flex</title>
      <link href="/2022/10/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7Flex/"/>
      <url>/2022/10/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7Flex/</url>
      
        <content type="html"><![CDATA[<p style="text-indent:2em">中科大-编译原理实验。实验指导书和文件见https://github.com/A-Y-1/HNU。</p><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p style="text-indent:2em">根据cminux-f的词法补全[lexical_analyer.l](../../src/lexer/lexical_analyzer.l)文件，完成词法分析器，能够输出识别出的token，type ,line(刚出现的行数)，pos_start(该行开始位置)，pos_end(结束的位置,不包含)。如：</p><p style="text-indent:2em">文本输入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">则识别结果应为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int     280     1       2       5</span><br><span class="line">a       285     1       6       7</span><br><span class="line">;       270     1       7       8</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h2><h3 id="1-Flex的使用"><a href="#1-Flex的使用" class="headerlink" title="1.Flex的使用"></a>1.Flex的使用</h3><p style="text-indent:2em">将词素转换为词法单元有两种方式：第一种是手动用代码实现(需要画状态转移图辅助)，另一种是使用词法分析器生成工具(需要使用正则表达式描述出词素的模式)。而Flex就是一个词法分析器生成工具。词法分析器工具的工作过程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lex源程序-----&gt;Lex编译器-----&gt;lex.yy.c</span><br><span class="line">lex.yy.c-----&gt; C编译器 -----&gt;a.out</span><br><span class="line"> 输入流  -----&gt; a.out-----&gt;词法单元的序列</span><br></pre></td></tr></table></figure><p style="text-indent:2em">而Lex源程序的格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">声明部分:变量的定义和声明，会直接复制到lex.yy.c中。</span><br><span class="line">%%</span><br><span class="line">转换规则:形式为：模式&#123;动作&#125;，模式为正则表达式，动作则是代码片段。</span><br><span class="line">%%</span><br><span class="line">辅助函数:各个动作需要的辅助函数。用户自定义，直接复制到lex.yy.c末尾。</span><br></pre></td></tr></table></figure><p style="text-indent:2em">Lex中还有一些变量和函数，以下只给出了实验涉及的一部分：</p><ul><li><p>yyin：FILE*，指向正在解析的文件。</p></li><li><p>yyout：FILE*，指向记录lexer输出的位置，缺省时yyin和yyout都指向标准输入和输出流。</p></li><li>yytext：char*，存储匹配模式的文本。</li><li>yylex()：这一函数开始词法分析，由Lex自动生成。</li><li>yywrap()：这一函数在文件或输入的末尾调用，返回值是1则停止解析。可以通过改变yyin指针指向不同文件，进行多文件的解析。</li></ul><p style="text-indent:2em">本实验主要是需要完成转换规则部分，给出cminux-f中词法单元的正则表达式和动作。</p><h3 id="2-识别到词法单元的动作"><a href="#2-识别到词法单元的动作" class="headerlink" title="2.识别到词法单元的动作"></a>2.识别到词法单元的动作</h3><p style="text-indent:2em">运算符，符号，关键字，ID和NUM类型的词法单元在识别后，需要确定出现的行数，开始位置，结束的位置。出现的行数可以在识别到换行符时lines++实现，开始的位置为上一个识别的词法单元结束的位置，结束的位置为开始位置加上词素长度。最后返回token值结束完成一个词素的识别。因此识别到词法单元的动作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RE &#123;pos_start=pos_end;pos_end=pos_start+<span class="built_in">strlen</span>(yytext);<span class="keyword">return</span> token&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">对于运算符，符号和关键字，长度是确定的，可以直接加上长度，不需要调用sterlen。</p><h3 id="3-识别到特殊词法单元的动作"><a href="#3-识别到特殊词法单元的动作" class="headerlink" title="3.识别到特殊词法单元的动作"></a>3.识别到特殊词法单元的动作</h3><p style="text-indent:2em">对于注释，空格，换行符，只需要进行识别，不需要输出到分析结果中。这些token与程序运行无关。其中空格对接下来的词法单元无影响，与一般词法单元的动作相同；识别到换行符需要将lines++，并将开始位置置1；识别到注释时，由于注释中内容全部都与程序无关，需要判断注释中是否含有换行符，并将lines加上换行符的个数。因此在识别到这些词法单元时，处理如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>(token = yylex())&#123;</span><br><span class="line">       <span class="keyword">switch</span>(token)&#123;</span><br><span class="line">           <span class="keyword">case</span> COMMENT:</span><br><span class="line">               len = <span class="built_in">strlen</span>(yytext);</span><br><span class="line">               <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(yytext[i]==<span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                       lines++;</span><br><span class="line">                       pos_end = <span class="number">1</span>;<span class="comment">//pos_start由pos_end得到，这里就不需要置1了</span></span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">else</span> pos_end++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> BLANK:</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> EOL:</span><br><span class="line">               lines++;</span><br><span class="line">               pos_end = <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> ERROR:</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;[ERR]: unable to analysize %s at %d line, from %d to %d\n&quot;</span>, yytext, lines, pos_start, pos_end);</span><br><span class="line">           <span class="keyword">default</span> :</span><br><span class="line">               <span class="keyword">if</span> (token == ERROR)&#123;</span><br><span class="line">                   <span class="built_in">sprintf</span>(token_stream[index].text, <span class="string">&quot;[ERR]: unable to analysize %s at %d line, from %d to %d&quot;</span>, yytext, lines, pos_start, pos_end);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="built_in">strcpy</span>(token_stream[index].text, yytext);</span><br><span class="line">               &#125;</span><br><span class="line">               token_stream[index].token = token;</span><br><span class="line">               token_stream[index].lines = lines;</span><br><span class="line">               token_stream[index].pos_start = pos_start;</span><br><span class="line">               token_stream[index].pos_end = pos_end;</span><br><span class="line">               index++;</span><br><span class="line">               <span class="keyword">if</span> (index &gt;= MAX_NUM_TOKEN_NODE)&#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;%s has too many tokens (&gt; %d)&quot;</span>, input_file, MAX_NUM_TOKEN_NODE);</span><br><span class="line">                   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="4-注释的正则表达式"><a href="#4-注释的正则表达式" class="headerlink" title="4.注释的正则表达式"></a>4.注释的正则表达式</h3><p style="text-indent:2em">注释的正则表达式需要注意，因为匹配的原则是最长匹配，但是如果有多个注释，中间的代码会被当作注释的内容匹配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*comments*/</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span></span><br><span class="line"><span class="comment">/*comments again*/</span></span><br></pre></td></tr></table></figure><p style="text-indent:2em">因此在进行匹配时，/\*和\*/之间不能有*/，即中间的连续字符可以划分为两种情况：</p><ul><li>没有出现<em>：可以表示为[^\</em>]</li><li><em>后加除/以外的任何字符：\\\</em>+[^/]</li></ul><p style="text-indent:2em">将注释的正则表达式写为"/\*"(\[^\*] | \\\*+\[^\\])+"\*/"，但是这样写出现了一个问题，\*\*\*被匹配到一起了，导致\*和/分离。修改第二种情况为\\\*\[^*/]，将\*\*\*/这种情况放到最后来解决这个问题。最终修改后注释的正则表达式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;/*&quot;</span>([^*]|\*+[^*/])*\*+<span class="string">&quot;/&quot;</span></span><br></pre></td></tr></table></figure><h2 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h2><p style="text-indent:2em">需要识别的token定义在lexical_analyzer.h中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">cminus_token_type</span> &#123;</span></span><br><span class="line">    <span class="comment">//运算</span></span><br><span class="line">    ADD = <span class="number">259</span>,</span><br><span class="line">    SUB = <span class="number">260</span>,</span><br><span class="line">    MUL = <span class="number">261</span>,</span><br><span class="line">    DIV = <span class="number">262</span>,</span><br><span class="line">    LT = <span class="number">263</span>,</span><br><span class="line">    LTE = <span class="number">264</span>,</span><br><span class="line">    GT = <span class="number">265</span>,</span><br><span class="line">    GTE = <span class="number">266</span>,</span><br><span class="line">    EQ = <span class="number">267</span>,</span><br><span class="line">    NEQ = <span class="number">268</span>,</span><br><span class="line">    ASSIN = <span class="number">269</span>,</span><br><span class="line">    <span class="comment">//符号</span></span><br><span class="line">    SEMICOLON = <span class="number">270</span>,</span><br><span class="line">    COMMA = <span class="number">271</span>,</span><br><span class="line">    LPARENTHESE = <span class="number">272</span>,</span><br><span class="line">    RPARENTHESE = <span class="number">273</span>,</span><br><span class="line">    LBRACKET = <span class="number">274</span>,</span><br><span class="line">    RBRACKET = <span class="number">275</span>,</span><br><span class="line">    LBRACE = <span class="number">276</span>,</span><br><span class="line">    RBRACE = <span class="number">277</span>,</span><br><span class="line">    <span class="comment">//关键字</span></span><br><span class="line">    ELSE = <span class="number">278</span>,</span><br><span class="line">    IF = <span class="number">279</span>,</span><br><span class="line">    INT = <span class="number">280</span>,</span><br><span class="line">    FLOAT = <span class="number">281</span>,</span><br><span class="line">    RETURN = <span class="number">282</span>,</span><br><span class="line">    VOID = <span class="number">283</span>,</span><br><span class="line">    WHILE = <span class="number">284</span>,</span><br><span class="line">    <span class="comment">//ID和NUM</span></span><br><span class="line">    IDENTIFIER = <span class="number">285</span>,</span><br><span class="line">    INTEGER = <span class="number">286</span>,</span><br><span class="line">    FLOATPOINT = <span class="number">287</span>,</span><br><span class="line">    ARRAY = <span class="number">288</span>,</span><br><span class="line">    LETTER = <span class="number">289</span>,</span><br><span class="line">    <span class="comment">//others</span></span><br><span class="line">    EOL = <span class="number">290</span>,</span><br><span class="line">    COMMENT = <span class="number">291</span>,</span><br><span class="line">    BLANK = <span class="number">292</span>,</span><br><span class="line">    ERROR = <span class="number">258</span></span><br><span class="line"></span><br><span class="line">&#125; Token;</span><br></pre></td></tr></table></figure><p>​        在lexical_analyer.l中写出每个词法单元的正则表达式和动作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">\+   &#123;pos_start = pos_end; pos_end++; <span class="keyword">return</span> ADD;&#125;</span><br><span class="line">\-   &#123;pos_start = pos_end; pos_end++; <span class="keyword">return</span> SUB;&#125;</span><br><span class="line">\*   &#123;pos_start = pos_end; pos_end++; <span class="keyword">return</span> MUL;&#125;</span><br><span class="line">\/   &#123;pos_start = pos_end; pos_end++; <span class="keyword">return</span> DIV;&#125;</span><br><span class="line">\&lt;   &#123;pos_start = pos_end; pos_end++; <span class="keyword">return</span> LT;&#125;</span><br><span class="line"><span class="string">&quot;&lt;=&quot;</span> &#123;pos_start = pos_end; pos_end+=<span class="number">2</span>; <span class="keyword">return</span> LTE;&#125;</span><br><span class="line">\&gt;   &#123;pos_start = pos_end; pos_end++; <span class="keyword">return</span> GT;&#125;</span><br><span class="line"><span class="string">&quot;&gt;=&quot;</span> &#123;pos_start = pos_end; pos_end+=<span class="number">2</span>; <span class="keyword">return</span> GTE;&#125;</span><br><span class="line"><span class="string">&quot;==&quot;</span> &#123;pos_start = pos_end; pos_end+=<span class="number">2</span>; <span class="keyword">return</span> EQ;&#125;</span><br><span class="line"><span class="string">&quot;!=&quot;</span> &#123;pos_start = pos_end; pos_end+=<span class="number">2</span>; <span class="keyword">return</span> NEQ;&#125;</span><br><span class="line">\=   &#123;pos_start = pos_end; pos_end++; <span class="keyword">return</span> ASSIN;&#125;</span><br><span class="line">\;   &#123;pos_start = pos_end; pos_end++; <span class="keyword">return</span> SEMICOLON;&#125;</span><br><span class="line">\,   &#123;pos_start = pos_end; pos_end++; <span class="keyword">return</span> COMMA;&#125;</span><br><span class="line">\(  &#123;pos_start = pos_end; pos_end++; <span class="keyword">return</span> LPARENTHESE;&#125;</span><br><span class="line">\)  &#123;pos_start = pos_end; pos_end++; <span class="keyword">return</span> RPARENTHESE;&#125;</span><br><span class="line">\[  &#123;pos_start = pos_end; pos_end++; <span class="keyword">return</span> LBRACKET;&#125;</span><br><span class="line">\]  &#123;pos_start = pos_end; pos_end++; <span class="keyword">return</span> RBRACKET;&#125;</span><br><span class="line">\&#123;  &#123;pos_start = pos_end; pos_end++; <span class="keyword">return</span> LBRACE;&#125;</span><br><span class="line">\&#125;  &#123;pos_start = pos_end; pos_end++; <span class="keyword">return</span> RBRACE;&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;pos_start = pos_end; pos_end+=<span class="number">4</span>; <span class="keyword">return</span> ELSE;&#125;</span><br><span class="line"><span class="keyword">if</span>   &#123;pos_start = pos_end; pos_end+=<span class="number">2</span>; <span class="keyword">return</span> IF;&#125;</span><br><span class="line"><span class="type">int</span>  &#123;pos_start = pos_end; pos_end+=<span class="number">3</span>; <span class="keyword">return</span> INT;&#125;</span><br><span class="line"><span class="type">float</span> &#123;pos_start = pos_end; pos_end+=<span class="number">5</span>; <span class="keyword">return</span> FLOAT;&#125;</span><br><span class="line"><span class="keyword">return</span> &#123;pos_start = pos_end; pos_end+=<span class="number">6</span>; <span class="keyword">return</span> RETURN;&#125;</span><br><span class="line"><span class="type">void</span>   &#123;pos_start = pos_end; pos_end+=<span class="number">4</span>; <span class="keyword">return</span> VOID;&#125;</span><br><span class="line"><span class="keyword">while</span>  &#123;pos_start = pos_end; pos_end+=<span class="number">5</span>; <span class="keyword">return</span> WHILE;&#125;</span><br><span class="line">[a-zA-Z]+ &#123;pos_start = pos_end; pos_end+=<span class="built_in">strlen</span>(yytext); <span class="keyword">return</span> IDENTIFIER;&#125;</span><br><span class="line">[a-zA-Z]  &#123;pos_start = pos_end; pos_end++; <span class="keyword">return</span> LETTER;&#125;  </span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>]+    &#123;pos_start = pos_end; pos_end+=<span class="built_in">strlen</span>(yytext); <span class="keyword">return</span> INTEGER;&#125;</span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>]+\.|[<span class="number">0</span><span class="number">-9</span>]*\.[<span class="number">0</span><span class="number">-9</span>]+ &#123;pos_start = pos_end; pos_end+=<span class="built_in">strlen</span>(yytext); <span class="keyword">return</span> FLOATPOINT;&#125;</span><br><span class="line"><span class="string">&quot;[]&quot;</span> &#123;pos_start = pos_end; pos_end+=<span class="number">2</span>; <span class="keyword">return</span> ARRAY;&#125;</span><br><span class="line">\n  &#123;<span class="keyword">return</span> EOL;&#125; </span><br><span class="line"><span class="string">&quot;/*&quot;</span>([^*]|\*+[^*/])*\*+<span class="string">&quot;/&quot;</span>  &#123;<span class="keyword">return</span> COMMENT;&#125;</span><br><span class="line">[<span class="string">&quot; &quot;</span>|\t] &#123;pos_start = pos_end; pos_end+=<span class="built_in">strlen</span>(yytext);<span class="keyword">return</span> BLANK;&#125;</span><br><span class="line">. &#123;<span class="keyword">return</span> ERROR;&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">这里需要注意的是标识符的识别规则要在letter的上方，否则单个字符不会被识别为标识符。</p><h2 id="实验结果验证"><a href="#实验结果验证" class="headerlink" title="实验结果验证"></a>实验结果验证</h2><p><strong>提供的测试样例</strong></p><p style="text-indent:2em">编译后先使用提供的6个测试样例进行测试，可以正常完成词法单元的分析。</p><p style="text-indent:2em">与提供的正确识别结果相比较，没有输出，结果正确。</p><p><strong>自行设计的测试样例</strong></p><p style="text-indent:2em">查看6个testcase的具体内容，已经包含了所有的词法单元的识别和大部分情况。自行设计的样例中，只对注释特别进行测试，其他的只选择几个进行测试，测试代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;<span class="type">int</span> b[];<span class="type">int</span> c[<span class="number">5</span>];</span><br><span class="line">    <span class="type">float</span> d = <span class="number">.05</span>;</span><br><span class="line">    <span class="comment">/*** COMMENT1 </span></span><br><span class="line"><span class="comment">    ***/</span></span><br><span class="line">    <span class="keyword">while</span>(a) &#123;</span><br><span class="line">        a = a<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*** /*COMMENT2 </span></span><br><span class="line"><span class="comment">    ***/</span></span><br><span class="line">    d = d+<span class="number">1.</span>;</span><br><span class="line">    d = d+<span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">运行lexer，可以完成所有词素的识别。</p><p style="text-indent:2em">经验证，输出文件中的识别结果是正确的。由于识别结果较长，这里省略。</p><h2 id="实验反馈"><a href="#实验反馈" class="headerlink" title="实验反馈"></a>实验反馈</h2><p style="text-indent:2em">通过本次实验学习了词法分析器生成工具Flex的使用，并在完成实验的过程中对Lex格式，正则表达式等相关内容进行进一步的学习。在实验中也遇到了一些问题，例如注释的正则表达式的书写，标识符被错误识别等，通过解决这些问题，加深了对于Lex中遇到冲突的最长匹配和选择先被列出的模式的规则的理解。最后也通过自行设计的测试样例验证了结果的正确性。</p>]]></content>
      
      
      <categories>
          
          <category> cs基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络自顶向下方法笔记02</title>
      <link href="/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B002/"/>
      <url>/2022/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B002/</url>
      
        <content type="html"><![CDATA[<p style="text-indent:2em">《计算机网络自顶向下方法》学习笔记02:运输层。</p><p style="text-indent:2em">运输层介于应用层与网络层之间，为应用层提供了直接的通信服务。在应用层时已经介绍了两种运输层协议UDP和TCP，本章主要介绍这两个协议和运输层的原理及实现。</p><h1 id="第三章-运输层"><a href="#第三章-运输层" class="headerlink" title="第三章 运输层"></a>第三章 运输层</h1><h2 id="1-概述和运输层服务"><a href="#1-概述和运输层服务" class="headerlink" title="1.概述和运输层服务"></a>1.概述和运输层服务</h2><p style="text-indent:2em">运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信功能。运输层协议是在端系统实现的，将应用程序的报文转换为较小的块，加上运输层首部生成运输层分组，称为<b>报文段</b>，将报文段交给网络层，由网络层发送到目的地。</p><p style="text-indent:2em">因特网提供了两种可用的运输层协议：UDP(用户数据报协议)，TCP(传输控制协议)。UDP提供不可靠服务，而TCP提供面向连接的可靠数据传输，还提供拥塞控制。网络层的协议即网际协议IP，提供的是不可靠服务，不确保报文段的交付和按序交付，因此本章主要讨论的一个问题是TCP如何提供<font color="red">可靠数据传输</font>，另一个主要讨论的问题是TCP如何实现<font color="red">拥塞控制</font>。</p><span id="more"></span><h2 id="2-多路复用与多路分解"><a href="#2-多路复用与多路分解" class="headerlink" title="2.多路复用与多路分解"></a>2.多路复用与多路分解</h2><p style="text-indent:2em">运输层从紧邻其下的网络层接收报文段。运输层负责将报文段进程交付给主机上运行的适当进程。一个进程有一个或多个<b>套接字</b>，运输层实际上是将数据交给中间的套接字。接收主机可能同时有多个套接字，因此每个套接字都有一个唯一的标识符。为了将运输层报文段定向到合适的套接字，运输层报文段有一些字段，包含了套接字的标识符。通过这些字段，将运输层报文段中的数据交付到正确的套接字的工作称为<b>多路分解</b>。从不同套接字中收集数据块，将数据块封装并添加首部信息产生报文段，发送到网络层的过程工作称为<b>多路复用</b>。</p><p style="text-indent:2em">每个套接字都有唯一的标识符，每个报文段都有特殊字段来指示该报文要交付到的套接字。套接字需要使用端口号进行标识。端口号是一个16bit的数，其中0-1023为熟知端口号。保留给HTTP,FTP等熟知的应用层协议。</p><p style="text-indent:2em">一个UDP套接字是一个二元组标识的，包含一个目的IP地址(标识主机)和一个目的端口号(标识具体的套接字)。接收主机的运输层收到报文段后，通过首部中的目的端口号，将报文段定向到相应的套接字。</p><p style="text-indent:2em">一个TCP套接字是由一个四元组(源IP地址，源端口号，目的IP地址，目的端口号)标识的。这四个值标识了一个连接，接收主机通过四个值将报文段定向到对应套接字。由于TCP是面向连接的，不同的源IP地址和源端口号与同一个目的IP的同个目的端口号建立的是不同的连接，使用的也是不同的套接字。但是初始创建连接时，连接还没有建立，因此使用的是同一个套接字(欢迎套接字)。连接建立后，接收端进程将创建一个新的套接字供该连接使用。</p><h2 id="3-无连接运输-UDP"><a href="#3-无连接运输-UDP" class="headerlink" title="3.无连接运输:UDP"></a>3.无连接运输:UDP</h2><p style="text-indent:2em">UDP是无连接的运输，只在IP的基础上进行复用和分解，并增加了少量的差错检测。UDP不能提供可靠的传输服务，但有以下优点：</p><ul><li>控制更加精细。采用UDP时，UDP会将数据打包直接传递给网络层，不像TCP存在拥塞控制机制，发送可能受到遏制。</li><li>无需建立连接。UDP不会引入建立连接的时延。因此DNS就是运行在UDP之上的。</li><li>无连接状态。UDP不维护连接状态。而TCP则需要维护包括接收和发送缓存，拥塞控制参数和确认号等连接状态。</li><li>分组首部开销小。仅有8字节。</li></ul><p style="text-indent:2em">除了不能提供可靠传输，UDP还可能导致其他问题，因为缺乏拥塞控制，UDP可能导致发送方接收方之间的高丢包率，挤垮TCP会话。</p><p style="text-indent:2em">UDP报文段由源端口号，目的端口号，长度和校验和组成，共8个字节。其中的校验和提供了差错检测功能，因为链路层协议可能没有提供差错检测，而报文段的传输可能经过一条没有使用差错检测协议的链路。因此UDP在端到端基础上，在运输层提供差错检测，这称为端到端原则。</p><h2 id="4-可靠数据传输原理"><a href="#4-可靠数据传输原理" class="headerlink" title="*4.可靠数据传输原理"></a>*4.可靠数据传输原理</h2><p style="text-indent:2em">可靠传输问题不仅在运输层出现，也在链路层及应用层出现。实现可靠传输服务是<b>可靠数据传输协议</b>的任务。一般情况下，都是在下层协议提供不可靠数据传输(udt)下，建立可靠数据传输协议。由于可靠数据传输(rdt)不仅适用于运输层，收发端交换的数据以下称为<font color="red">分组</font>，而不是运输层的报文段。</p><h3 id="4-1-构造可靠数据传输协议"><a href="#4-1-构造可靠数据传输协议" class="headerlink" title="4.1 构造可靠数据传输协议"></a>4.1 构造可靠数据传输协议</h3><p><strong>经完全可靠信道的可靠数据传输</strong> <strong>rdt1.0</strong></p><p style="text-indent:2em">经完全可靠信道的可靠数据传输，接收与发送方不需要进行任何通信。发送方只需接收高层的数据，产生分组并发送到信道中，而接收方只需要从信道接收分组，从分组中取出数据交给上层。</p><p><strong>经具有比特差错信道的可靠数据传输</strong> <strong>rdt2.0</strong></p><p style="text-indent:2em">实际情况下，底层信道的模型是会出现比特差错的模型，在分组的传输，传播或缓存的过程中都可能出现比特差错。为了处理差错，接收方需要对接收到的分组进行确认，发出<b>肯定确认</b>告知发送方分组被接收，发出<b>否定确认</b>告知发送方重发分组。基于这种重传机制的可靠数据传输协议称为<font color="red">自动重传协议(ARQ)</font>。ARQ协议需要三种功能处理比特差错的情况：</p><ul><li>差错检测：通过检验和字段，使接收方能够检测到比特差错。</li><li>接收方反馈：接收方需要进行肯定确认(ACK)，否定确认(NAK)，只需要一个bit的分组就可以进行确认。</li><li>重传：接收方接收到有差错的分组时，发送方重传分组。</li></ul><p style="text-indent:2em">采用以上这种重传机制，发送方在发送分组后，将等待接收方的确认分组，决定是否重传还是传输新的分组。由于这种行为，rdt2.0这样的协议被称为<font color="red">停等协议</font>。</p><p style="text-indent:2em">由于信道本身可能出现差错，因此必须考虑确认分组ACK或NAK出现差错的情况。在这种情况下，发送方不知道接收方是否正确收到了分组。解决该问题的方式是，如果发送分组不能确定接收方是否接收到了正确的分组，就重新发送分组。这种方式给信道引入了<b>冗余分组</b>。但是接收方还需要知道接收到的是新的分组还是重传的分组，因此对于分组需要进行一个序号，需要只需要为0或1，让接收方能够区别分组是否和上一个接收到的分组一样就可以。</p><p><strong>经具有比特差错的丢包信道的可靠数据传输</strong> <strong>rdt3.0</strong></p><p style="text-indent:2em">除了比特差错，丢包也是常见的一种情况。解决丢包的方式和处理比特差错一样，如果没有接收到确认分组(发送的分组丢失或确认的ACK丢失，又或者只是分组或ACK延时)，就重传数据分组。新的问题是，到底等待多久才能判断分组丢失。这个时间至少大于一个往返时延，要根据情况设置。为了实现以上这种基于时间的重传机制，还需要一个倒计数定时器，发送方每发送一个分组就启动一个定时器，定时器超时就进行重传。解决冗余分组的方式则和rdt2.0相同。因为分组序号在0和1之间交替，rdt3.0也被称为是<b>比特交替协议</b>。</p><h3 id="4-2-流水线可靠数据传输协议"><a href="#4-2-流水线可靠数据传输协议" class="headerlink" title="4.2 流水线可靠数据传输协议"></a>4.2 流水线可靠数据传输协议</h3><p style="text-indent:2em">以上所形成的以停等协议为核心的可靠数据传输协议是功能正确的，但是在性能方面存在大的问题，因为发送方的信道利用率太低了，大量时间都在等待确认分组。而确认分组至少需要一个往返时延RTT才能回到发送方，还要加上协议处理时间和中间路由器的时延。这个性能问题的解决办法就是不以停等方式运行，允许发送方发送多个分组。例如发送方可以发送三个分组后再等待确认，这样的方式被称为<b>流水线</b>。不过，在提升性能的同时，采用流水线也会带来新的问题。</p><ul><li>必须增加序号范围，因为输送中的分组有多个。</li><li>发送方和接收方需要缓存多个分组。</li><li>需要处理丢失，损坏及延时过大的分组。两种基本方法是：<font color="red">回退N步</font>；<font color="red">选择重传</font>。</li></ul><h3 id="4-3-回退N步-GBN"><a href="#4-3-回退N步-GBN" class="headerlink" title="4.3 回退N步(GBN)"></a>4.3 回退N步(GBN)</h3><p style="text-indent:2em">在<b>回退N步协议GBN</b>中，允许发送方发送多个分组，不需等待确认，但是未确认的分组数不能超过某个最大允许数N，称为窗口长度。定义基序号base为最早未确认分组的序号，下一个序号nextseqnum为下一个待发分组的序号，则：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|base|nextseqnum</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">  已发送且确认的  |  已发送未确认|未发送的|</span><br><span class="line">                ----------------------------------------</span><br><span class="line">                    窗口长度 N</span><br></pre></td></tr></table></figure><p style="text-indent:2em">GBN协议也常被称为滑动窗口协议。分组的序号在分组首部的字段(k位)，范围为0-2^k-1。窗口的大小受到限制，最大为2^k-1，否则接收方将无法判断下一个分组是重发的还是新分组。例如序号k有2位，可表示0,1,2,3，窗口大小最大为3，如果为4，假设发送方发送0,1,2,3，接收方接收到这4个分组，下一次接受到序号为0的分组，就不能确认是重发分组的还是新的分组，如果4个确认分组全部丢失，这个分组就是重发分组，如果有一个确认分组到达，这个分组就是新的分组，但接收方并不能确认是哪种情况，因此窗口必须小于等于2^k-1。</p><p style="text-indent:2em">GBN发送方响应三种事件：</p><ul><li>上层调用：窗口未满，则发送分组，否则告知上层。上层可能过一会儿再试，也可能发送方直接把上层数据缓存。</li><li>接收ACK：GBN协议中，对分组的确认方式为<b>累积确认</b>。接收到n的ACK，则序号小于等于n的分组都被确认接收。</li><li>超时：如果出现超时，重传所有已发送但未被确认过的分组。GBN协议中只有一个定时器，最早发送且未被确认的分组启动计时器，接收到确认分组则重启计时器。</li></ul><p style="text-indent:2em">GBN协议中，接收方会丢弃所有失序的分组，因为发送方会重传这些分组。直接丢弃这些分组，接收缓存简单，不需要缓存失序分组，接收方唯一需要维护的信息就是下一个按序接收的分组的序号。</p><h3 id="4-4-选择重传-SR"><a href="#4-4-选择重传-SR" class="headerlink" title="4.4 选择重传(SR)"></a>4.4 选择重传(SR)</h3><p style="text-indent:2em">如果采用GBN协议，一旦最早发送的未确认分组超时，就需要从该分组开始重传，且接收方接收到的不按序的分组都会被丢掉。在信道差错率增加，时延很大的情况下，GBN可能大量重传分组。<b>选择重传协议SR</b>改进了这一点，只让发送方重传可能出错的分组。接收方将缓存失序的分组，并逐个对分组进行确认，连续的几个分组都收到后一起交付给上层。而发送方的每一个分组都有自己的定时器，超时后只重传一个分组，如果收到了最小未收到确认的分组的对应ACK，就将窗口重新移动到具有最小序号的未确认分组处。</p><p style="text-indent:2em">对于已收到的那些分组，接收方会重新进行确认，这是有必要的，否则发送方可能停留在一个固定的窗口(因为不进行累积确认了，不重新确认窗口就不移动了)。</p><p style="text-indent:2em">另外，考虑到序号是有限的，发送方与接收方窗口的不同步会导致严重的问题，所以窗口大小最大为序号空间大小的一半，问题的原因和GBN中的窗口限制原因相同。例如，假设序号只有0,1,2，一种情况是正常的按照0,1,2,0来发送分组，另一种情况是分组0的ACK丢失了，发送次序是0,1,2,0(重传0)，因为有这两种不同的情况，接收方无法确认接收到的分组是重复发送的还是新的分组。因此必须限制窗口的大小，避免这种情况的发生。<b>窗口长度必须小于或等于序号空间大小的一半</b>。这样假设发送方没有收到正确的ACK，窗口不移动，接收方接收到了分组，一直向后移动，最后的结果就是发送方的窗口占了一半序号，接收方的窗口占了一半的序号，接收方的窗口最大值刚好停在发送方的窗口最小值前面，而不会发生序号重复。</p><h3 id="4-5-信道利用率计算"><a href="#4-5-信道利用率计算" class="headerlink" title="4.5 信道利用率计算"></a>4.5 信道利用率计算</h3><p style="text-indent:2em">对于不同的可靠传输协议，信道利用率不同，经常需要计算信道利用率。从开始发送数据到接收到第一个确认称为一个<b>发送周期T</b>，一个发送周期用于发送数据的时间占比即为信道利用率。</p><p style="text-indent:2em">发送周期T = 传输时延 + 2*传播时延 + 确认分组的传输时延</p><p style="text-indent:2em">假设一个发送周期内发送的数据共Lbit，数据传输速率为Cbps，则利用率为：(L/C)/T。</p><p style="text-indent:2em">由于不同协议可发送的数据量不同，相应的信道利用率就不同。例如对于停等协议，L只能为一个分组的大小，但如果是GBN或SR，L就与窗口大小有关，而窗口的大小又和序号字段的位数有关，常需要结合进行计算。</p><h2 id="5-面向连接的运输：TCP"><a href="#5-面向连接的运输：TCP" class="headerlink" title="*5.面向连接的运输：TCP"></a>*5.面向连接的运输：TCP</h2><h3 id="5-1-TCP连接"><a href="#5-1-TCP连接" class="headerlink" title="5.1 TCP连接"></a>5.1 TCP连接</h3><p style="text-indent:2em">TCP连接是面向连接的，这种连接是一种逻辑上的连接，因为TCP协议只在端系统运行。TCP连接是全双工的连接，也是点对点的连接。两个不同主机的进程通过三次握手来建立连接，并通过连接发送数据。</p><p style="text-indent:2em">TCP连接建立后，应用进程就可以互相发送数据了。客户进程通过套接字将数据交给TCP，TCP将数据存储到连接的<b>发送缓存</b>中，接下来TCP会从发送缓存中取出数据交给网络层。TCP可取出并添加到报文段的数据大小受限于<b>最大报文长度MSS</b>，而MSS又通常根据最大链路层帧长度(最大传输单元MTU)来设置，MSS要保证一个报文段加上TCP/IP首部长度(40字节)适合链路层帧。以太网和PPP链路层协议都有1500字节的MTU，因此MSS的典型值为1460字节。TCP接收端接收到报文段，将数据放到接收缓存中，应用程序从该缓存中读取数据。</p><p style="text-indent:2em">根据以上的讨论，TCP连接的组成包括：一台主机上的缓存，变量和与进程连接的套接字，另一台主机上的缓存，变量和与进程连接的套接字。</p><h3 id="5-2-TCP报文"><a href="#5-2-TCP报文" class="headerlink" title="5.2 TCP报文"></a>5.2 TCP报文</h3><p style="text-indent:2em">TCP报文的结构如下：</p><ul><li>源端口：16bit，写入源端口号，用来标识发送该TCP报文段的应用进程。</li><li>目的端口：16bit，写入目的端口号，用来标识接收该TCP报文段的应用进程。</li><li>序号：32bit，指出本TCP报文段数据载荷的第一个字节的序号。</li><li><font color="red">确认号：32bit，指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号</font>，同时也是对之前收到的所有数据的确认。<font color="orange"><b>(这和GBN和SR中的分组确认ACK是不一样的！)</b></font></li><li>确认标志位ACK：取值为1时确认号字段才有效，取值为0时确认号字段无效。TCP规定，连接建立后所有传送的TCP报文ACK均置1。</li><li>数据偏移：4bit，以4字节为单位。用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远。这个字段实际上是指出了TCP报文段的首部长度。取值为20-60。</li><li>保留：6bit，保留，目前置为0。</li><li>窗口：16bit，字节为单位，指出<font color="red">发送本报文段的一方的接收窗口</font>。</li><li>校验和：16bit，检查范围包括TCP报文段的首部和数据载荷两部分。在计算校验和时，要在TCP报文段的前面加上12字节的伪首部。</li><li>同步标志位SYN：在TCP连接建立时用来同步序号。</li><li>终止标志位FIN：用来释放TCP连接。</li><li>复位标志位RST：用来复位TCP连接。当RST=1时，表明TCP连接出现了异常，必须释放连接，然后再重新建立连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个TCP连接。</li><li>推送标志位PSH：接收方的TCP收到该标志位为1的报文段会<font color="red">尽快上交应用进程</font>，而不必等到接受缓存都填满后再向上交付。</li><li>紧急标志位URG：取值为1时紧急指针字段有效。取值为0时紧急指针字段无效。</li><li>紧急指针：占16bit，以字节为单位，用来指明紧急数据的长度。</li></ul><blockquote><p>​        当发送方有紧急数据时，可将紧急数据插队到发送缓存的最前面，并立即封装到一个TCP报文段中进行发送。紧急指针会指出本报文段数据再和部分包含了多长的紧急数据，紧急数据之后是普通数据。</p></blockquote><ul><li>扩展首部<ul><li>最大报文段长度MSS选项：TCP报文段数据载荷部分的最大长度。</li><li>窗口扩大选项：为了扩大窗口(提高吞吐率)。</li><li>时间戳选项：用来计算往返时间RTT；处理序号超范围的情况，又称为防止序号绕回PAWS。</li><li>选择确认选项</li></ul></li><li>填充：保证报文段首部能被4整除</li></ul><h3 id="5-3-往返时间的估计与超时"><a href="#5-3-往返时间的估计与超时" class="headerlink" title="5.3 往返时间的估计与超时"></a>5.3 往返时间的估计与超时</h3><p style="text-indent:2em">TCP与rdt一样，采用超时重传机制来处理报文段的丢失问题。对于超时重传机制，一个重要的问题就是超时时间的设置，该时间必须大于往返时间RTT，因此需要估计RTT，并根据RTT设置时间间隔。</p><p style="text-indent:2em">TCP连接的往返时间通过某个时刻测量的SAMPLERTT进行估计，且为了得到一个典型的RTT，要对SAMPLERTT取均值，还要反映RTT的波动。因此SAMPLERTT均值如下：</p><script type="math/tex; mode=display">EsitimatedRTT=(1-α)RTT+αRTT</script><p style="text-indent:2em">按照RFC文档，α取1/8。除了RTT均值外，RTT偏差也有计算意义，定义如下：</p><script type="math/tex; mode=display">DevRTT=(1-β)DevRTT+β|SampleRTT-EstimatedRTT|</script><p style="text-indent:2em">β推荐值为0.25。根据以上的平均RTT和RTT偏差，超时间隔定义如下：</p><script type="math/tex; mode=display">TimeoutInterval=EstimatedRTT+4DevRTT</script><p style="text-indent:2em">使用上式计算，当波动较小时，间隔就小一些，波动较大，间隔大一些。初始的TimeoutInterval推荐为1s。<b>出现超时后，该值加倍</b>，以免后继报文段过早出现超时。只要收到报文段并更新EstimatedRTT，就更新该值。</p><h3 id="5-4-可靠数据传输"><a href="#5-4-可靠数据传输" class="headerlink" title="5.4 可靠数据传输"></a>5.4 可靠数据传输</h3><p style="text-indent:2em">TCP在IP的不可靠的尽力而为服务上创建了可靠数据传输服务，基于可靠传输的基本原理。由于定时器的管理需要相当大的开销，因此TCP使用单一的定时器。TCP发送方只处理三类时间：从上层程序接收数据；定时器超时；收到ACK；。简化的描述如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">loop&#123;</span><br><span class="line">switch(event)</span><br><span class="line">event1:</span><br><span class="line">接收上层应用的数据e，生成具有nextseqnum的TCP报文段</span><br><span class="line">if（定时器没有运行）启动定时器</span><br><span class="line">向IP传输报文段</span><br><span class="line">nextseqnum=nextseqnum+length(data)</span><br><span class="line">break;</span><br><span class="line">event2：</span><br><span class="line">重传具有最小序号且仍未应答的报文段</span><br><span class="line">启动定时器</span><br><span class="line">break;</span><br><span class="line">event3：</span><br><span class="line">if（y&gt;sendbase）｛</span><br><span class="line">sendbase = y;</span><br><span class="line">if（存在未被确认的报文段） 启动定时器</span><br><span class="line">｝</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">每当超时重传发生后，TCP都会重传该报文段，并将超时间隔设置为先前值的两倍。这提供了一个形式受限的拥塞控制，避免持续重传分组，导致拥塞更加严重。</p><p style="text-indent:2em">超时重传的一个问题是超时周期可能过长，从而增加了端到端的时延。实际上发送方除了超时外，还可以通过注意到<b>冗余ACK</b>来提前重发报文。接收方在一定间隔没有等到新的报文，或是收到了失序的报文，都会发送ACK，如果报文段丢失，那么接收方很可能发送多个冗余ACK。一旦发送方接收到三个冗余ACK，就执行<b>快速重传</b>。采用快速重传，事件三的处理修改如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">event3:</span><br><span class="line">if（y&gt;sendbase）｛</span><br><span class="line">sendbase=y;</span><br><span class="line">if（存在未被确认的报文段） 启动定时器</span><br><span class="line">｝</span><br><span class="line">else｛</span><br><span class="line">对y收到的冗余ACK+1</span><br><span class="line">if（冗余ACK数==3） 重新发送具有序号y的报文段</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p style="text-indent:2em">TCP采用的是累积确认的方式，看起来符合GBN可靠传输，但许多TCP实现会将失序但正确的报文缓存起来。TCP接收方也可以有选择的确认，采用类似SR的方式。</p><h3 id="5-5-流量控制"><a href="#5-5-流量控制" class="headerlink" title="5.5 流量控制"></a>5.5 流量控制</h3><p style="text-indent:2em">接受方接收到报文段后，将报文段存放到接收缓存当中，应用进程从中取出数据。如果应用程序读取的速度较慢，而发送方发送的数据太多太快，就会导致接收缓存溢出。因此TCP提供了<b>流量控制服务</b>，使发送方的发送速率与接收方应用程序的读取速率匹配。这与拥塞控制很相似，但是完全是出于不同的原因。</p><p style="text-indent:2em">TCP通过让发送方维护一个称为接收窗口的变量来进行流量控制。接收窗口表示接收方可用缓存的大小。发送方需要维护两个变量：</p><ul><li>lastbyteread：读出的最后一个字节</li><li>lastbyterecv：已到达接收缓存的最后一个字节</li></ul><p style="text-indent:2em">不允许接收缓存溢出，则lastbyterecv-lastbyteread<=rcvbuffer。则接收窗口为：< p><script type="math/tex; mode=display">rwnd=rcvbuffer-[lastbyterecv-lastbyteread]</script><p style="text-indent:2em">rwnd是一个动态的值。在起始时，rwnd=recvbuffer，此后接收主机会维护该值，并将其发给发送主机，而发送主机需要进行如下的控制：</p><script type="math/tex; mode=display">lastbytesent-lastbyteacked<=rwnd</script><p style="text-indent:2em">为了避免发送主机收到rwnd=0后被阻塞，如果接收窗口为0，发送主机将发送一个只有一个字节的报文段，接收主机将会回发确认，并在确认报文中包含一个新的非0rwnd值。</p><p style="text-indent:2em">TCP提供了以上的流量控制服务，UDP是不提供这样的服务的。因此如果使用UDP，进程从缓存中读取报文段的速度不够快，缓存将会溢出，并丢失报文段。</p><h3 id="5-6-TCP连接建立和拆除"><a href="#5-6-TCP连接建立和拆除" class="headerlink" title="5.6 TCP连接建立和拆除"></a>5.6 TCP连接建立和拆除</h3><p style="text-indent:2em">TCP连接建立的过程如下：</p><ul><li>第一步：SYN报文段发送。客户端向服务器发送特殊的TCP报文段，其中SYN字段为1，初始序号client_isn随机选择。</li><li>第二步：SYNACK报文段发送。服务器接收到SYN报文段后，会为连接建立缓存和变量，并向客户发送允许连接的报文段，这个报文段中SYN为1，确认号字段为client_isn+1，服务器的初始序号为随机的server_isn。</li><li>第三步：收到SYNACK后，客户端也为该连接分配缓存和变量，并发送一个报文给服务器，对允许连接的报文进行确认，确认字段为server_isn+1，SYN=0，此时报文段负载中可以携带数据了。</li></ul><p style="text-indent:2em">TCP连接的释放比较简单，客户进程发送一个特殊的报文段，FIN字段为1，服务器接收到后发送确认报文段，此时客户到服务器的TCP连接就关闭了，接下来服务器到客户的TCP连接的关闭也是一样的。客户接收到服务器的FIN报文段后，会进入等待状态，并发送ACK，经过等待后，这个连接就正式关闭了。</p><h2 id="6-拥塞控制原理"><a href="#6-拥塞控制原理" class="headerlink" title="6.拥塞控制原理"></a>6.拥塞控制原理</h2><p style="text-indent:2em">本节要解决的是网络拥塞的相关问题。包括网络拥塞是如何在上层的服务中体现的，怎样避免网络拥塞，或是至少对它作出反应。</p><h3 id="6-1-拥塞原因与代价"><a href="#6-1-拥塞原因与代价" class="headerlink" title="6.1 拥塞原因与代价"></a>6.1 拥塞原因与代价</h3><p style="text-indent:2em">通常出现拥塞有以下几种情况：</p><ul><li>当发送速率超过吞吐量时，平均排队分组数不断增长，源与目的之间的时延也变为无穷大(假设不停发送，有无限大的缓存)。</li><li>当缓存已满，部分分组被丢弃，这将引起发送方的重传，此外，提前发生超时还可能导致发送方重传没有丢失的分组。</li><li>在有许多跳的情况下，不同的链路中不同连接的载荷不同。</li></ul><p style="text-indent:2em">从以上几种情况来看，由于拥塞丢弃分组产生了以下的代价：</p><ul><li>分组的到达速率接近链路容量时，分组经历巨大的排队时延</li><li>发送方必须重传以补偿因为缓存溢出而丢弃的分组</li><li>发送方在遇到大时延时进行的不必要重传会引起路由器利用链路带宽来转发不必要的分组副本</li><li>一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组的传输容量最终被浪费掉了</li></ul><h3 id="6-2-拥塞控制方法"><a href="#6-2-拥塞控制方法" class="headerlink" title="6.2 拥塞控制方法"></a>6.2 拥塞控制方法</h3><p style="text-indent:2em">拥塞控制方法分为两种：</p><ul><li>端到端拥塞控制：端系统通过对网络行为(如分组丢失与时延)的观察推断拥塞情况，在端到端进行拥塞控制</li><li>网络辅助的拥塞控制：路由器向发送方提供关于网络中拥塞状态的显式反馈信息</li></ul><p style="text-indent:2em">TCP采用端到端的拥塞控制。</p><h2 id="7-TCP拥塞控制"><a href="#7-TCP拥塞控制" class="headerlink" title="*7.TCP拥塞控制"></a>*7.TCP拥塞控制</h2><h3 id="7-1-拥塞控制"><a href="#7-1-拥塞控制" class="headerlink" title="*7.1 拥塞控制"></a>*7.1 拥塞控制</h3><p style="text-indent:2em">当出现了网络拥塞时，TCP应该降低发送速率，进行拥塞控制。实现这样的控制，有三个问题需要解决。</p><ol><li>TCP发送方如何感知到与目的地之间的路径上存在拥塞，或是不存在拥塞</li><li>TCP如何限制其向连接上发送流量的速率</li><li>采用什么算法改变发送速率</li></ol><p style="text-indent:2em">下面逐个解决以上的问题。</p><p><strong>1.拥塞检测与速率的确定</strong></p><p style="text-indent:2em">当发生拥塞时，路径上的路由器缓存溢出，就会引起丢包。对于发送方而言，丢包导致的是出现超时和收到3个冗余ACK。如果发生了这两种情况，就表示发生了拥塞，就应该减小发送速率。这就解决了拥塞检测的问题。在没有拥塞时，为了充分利用所有可用的带宽，TCP发送方还应该可以加快发送的速率。当TCP发送方接收到确认报文段ACK时，就认为一切顺利，网络不拥塞，可以增加发送速率。</p><p><strong>2.限制速率</strong></p><p style="text-indent:2em">TCP采用了一个<font color="red">拥塞窗口cwnd</font>来限制发送速率。注意这与流量控制相似但是不同。发送方未被确认的数据量不会超过cwnd与rwnd的最小值，即LastByteSent-LastByteAcked<=min{rwnd，cwnd}。由于此处仅探讨拥塞控制，先假设接收缓存无限大，这样发送速率就只与cwnd有关。通过cwnd的值，就可以调整向连接发送数据的速率了。 < p><p><strong>3.TCP拥塞控制算法</strong></p><p style="text-indent:2em">解决了上面两个问题，只要使用特定的算法控制cwnd就可以实现拥塞避免了。TCP拥塞控制算法包括三个部分：慢启动；拥塞避免；快恢复。</p><ul><li>慢启动<ul><li>起始时，cwnd的值以一个MSS开始，每当一个报文被确认，就增加一个MSS</li><li>维护一个慢启动阈值<font color="red">ssthresh</font>，当cwnd达到ssthresh，就进入拥塞避免模式</li><li>出现丢包时，cwnd设置为1，重新开始慢启动，ssthresh值设置为检测到拥塞时的cwnd/2</li></ul></li><li>拥塞避免<ul><li>每个RTT，增加一个MSS</li><li>发生丢包时，与慢启动的反应相同</li><li>收到三个冗余ACK时，进入快恢复状态</li></ul></li><li>快恢复<ul><li>cwnd减半后加上三个MSS，将ssthresh的值减半，进入拥塞避免状态</li></ul></li></ul><p style="text-indent:2em">早期的TCP版本<b>Tahoe</b>没有快恢复机制，无论是收到冗余ACK还是丢包，都直接将cwnd设置为1。TCP的较新版本<b>TCP Reno</b>则加入了快恢复机制。现在已有Reno的许多变种，例如Vegas，该算法在分组发生丢失之前检查源与目的地之间的拥塞，当检测出快要发生的分组丢失时(通过RTT的变化)，线性降低发送速率。</p><h3 id="7-2-对TCP吞吐量的宏观描述"><a href="#7-2-对TCP吞吐量的宏观描述" class="headerlink" title="7.2 对TCP吞吐量的宏观描述"></a>7.2 对TCP吞吐量的宏观描述</h3><p style="text-indent:2em">有了TCP的拥塞控制算法，可以考虑长期存活的TCP连接的吞吐量了。当窗口长度是w，往返时间为RTT，TCP的发送速率大约是W/RTT，在一个窗口内发送了w后，收到前一半发送的分组的ACK，因此发送速率约为W/RTT。不考虑慢开始阶段(指数增长，很快结束)，发生丢包时，假设速率减半，再增加到W/RTT。在以上情况下，TCP的速率重复从W/2RTT到W/RTT的过程，在两个值之间线性增长，可以得出一个高度理想化的TCP稳态动态性模型：</p><script type="math/tex; mode=display">一条连接的平均吞吐量 = \frac{0.75W}{RTT}</script><p style="text-indent:2em">在高带宽路径中，结合MSS和丢包率L，可以得出一条TCP连接的吞吐量公式：</p><script type="math/tex; mode=display">一条连接的平均吞吐量 = \frac{1.22MSS}{RTT\sqrt{L}}</script><h3 id="7-3-公平性"><a href="#7-3-公平性" class="headerlink" title="7.3 公平性"></a>7.3 公平性</h3><p style="text-indent:2em">如果有多条TCP连接，通过同一段瓶颈链路，TCP趋于给竞争的多条TCP连接提供平等的带宽共享。书上给出了理想化的证明，在连接有相同MSS和RTT的情况下，公平性是可以保证的。然而现实中这种理想情况并不存在，多媒体应用可以使用UDP连接压制TCP流量，Web浏览器常使用并行连接传输多个对象，带宽的占用并不是公平的。</p><h3 id="7-4-明确拥塞通告"><a href="#7-4-明确拥塞通告" class="headerlink" title="7.4 明确拥塞通告"></a>7.4 明确拥塞通告</h3><p style="text-indent:2em">拥塞控制的另一类是网络明确向TCP双方发送拥塞信号，这种形式的网络辅助拥塞控制称为明确网络拥塞控制通告ECN。这种形式下，路由器使用一种ECNbit指示该路由器正在经历拥塞，并将该标记携带在IP数据报中，发送给目的主机，再由目的主机告知源主机，实现拥塞控制。</p></=min{rwnd，cwnd}。由于此处仅探讨拥塞控制，先假设接收缓存无限大，这样发送速率就只与cwnd有关。通过cwnd的值，就可以调整向连接发送数据的速率了。></p></=rcvbuffer。则接收窗口为：<></p>]]></content>
      
      
      <categories>
          
          <category> cs基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络自顶向下方法笔记01</title>
      <link href="/2022/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B001/"/>
      <url>/2022/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B001/</url>
      
        <content type="html"><![CDATA[<p style="text-indent:2em">《计算机网络自顶向下方法》学习笔记。之前学习过计算机网络微课，已经对计网中的很多概念都有了印象和一定的了解了，这时候再读自顶向下感觉比较轻松了。但是自己还是更喜欢自底向上的方式，因为自顶向下时，尽管只需要知道下层能为上层提供服务，但是对下层的大致了解没有建立，感觉并不够顺畅。这本书没有涉及太多物理层的内容，第一章为概述。从第二章应用层开始，自顶向下讲解计算机网络。以下是阅读笔记。</p><h1 id="第二章-应用层"><a href="#第二章-应用层" class="headerlink" title="第二章 应用层"></a>第二章 应用层</h1><p style="text-indent:2em">本章的内容主要是网络应用的相关原理，网络应用的实例(Web，电子邮件，DNS，视频流)，以及简单的网络应用开发(主要学习套接字接口)。</p><h2 id="1-应用层协议原理"><a href="#1-应用层协议原理" class="headerlink" title="1.应用层协议原理"></a>1.应用层协议原理</h2><h3 id="1-1-应用程序体系结构"><a href="#1-1-应用程序体系结构" class="headerlink" title="1.1 应用程序体系结构"></a>1.1 应用程序体系结构</h3><ul><li>客户服务器体系结构</li><li>对等体系结构(P2P)</li></ul><p style="text-indent:2em">客户-服务器体系结构中，服务器服务来自许多其他客户主机的请求、客户之间不进行通信。服务器通常有确定的地址(IP地址)，客户通过IP地址向服务器请求服务。为了能够处理请求，通常有配备大量主机的数据中心作为虚拟服务器，而不是单独的服务器主机进行服务。</p><p style="text-indent:2em">P2P体系结构下，主机之间相互通信，他们被称为对等方。许多流量密集型应用都是P2P体系结构。P2P体系的特性是其具有自扩展性，每个对等方由于请求产生工作负载，同时也分发文件为系统增加服务能力。P2P体系结构不需要庞大的服务器基础设施和带宽，但由于高度非集中式结构，有安全性、性能、可靠性方面的挑战。</p><h3 id="1-2-数据通信"><a href="#1-2-数据通信" class="headerlink" title="1.2 数据通信"></a>1.2 数据通信</h3><p style="text-indent:2em">两个不同端系统上的进程，通过报文来通信。网络应用程序由成对的进程组成，他们通过网络相互发送报文。两个进程常被标识为客户与服务器。<b>发起通信的进程被标识为客户，在会话开始时等待联系的进程是服务器。</b></p><p style="text-indent:2em">进程是通过称为套接字的软件接口来发送和接收报文的。套接字是应用程序和网络之间的应用程序编程接口。对于套接字，后续有详细的讨论。</p><p style="text-indent:2em">两进程间通信，发送分组的进程需要知道接收分组的进程地址。地址由两部分构成：主机地址；主机中接收进程的标识符。这两部分由IP地址和目的地端口号来标识。</p><h3 id="1-3-可供应用程序使用的运输服务"><a href="#1-3-可供应用程序使用的运输服务" class="headerlink" title="1.3 可供应用程序使用的运输服务"></a>1.3 可供应用程序使用的运输服务</h3><p style="text-indent:2em">运输层为应用层提供服务，应用程序服务的要求有以下四个方面：</p><ul><li>可靠数据传输</li><li>吞吐量</li><li>定时</li><li>安全性</li></ul><h3 id="1-4-因特网提供的运输服务"><a href="#1-4-因特网提供的运输服务" class="headerlink" title="1.4 因特网提供的运输服务"></a>1.4 因特网提供的运输服务</h3><ul><li>TCP服务<ul><li>面向连接</li><li>可靠数据传输</li><li>安全性：安全套接字层(SSL)加强了TCP，提供安全服务</li></ul></li><li>UDP服务：仅提供最小服务，无连接，不保证报文到达接收进程。</li></ul><p style="text-indent:2em">定时和吞吐量是因特网运输协议不能保证的，但通常因特网是可以为时间敏感应用提供满意的服务的。</p><span id="more"></span><h2 id="2-Web和HTTP"><a href="#2-Web和HTTP" class="headerlink" title="2.Web和HTTP"></a>2.Web和HTTP</h2><h3 id="2-1-HTTP概况"><a href="#2-1-HTTP概况" class="headerlink" title="2.1 HTTP概况"></a>2.1 HTTP概况</h3><p style="text-indent:2em">Web的应用层协议是超文本传输协议HTTP，客户程序和服务器程序中通过HTTP报文进行会话。</p><ul><li>Web页面由对象组成，一个对象是一个文件。</li><li>Web浏览器实现了HTTP的客户端，Web服务器是HTTP的服务器端。</li><li>HTTP是一个<strong>无状态协议</strong>：服务器不保存关于客户的任何信息。</li></ul><h3 id="2-2-非持续连接和持续连接"><a href="#2-2-非持续连接和持续连接" class="headerlink" title="2.2 非持续连接和持续连接"></a>2.2 非持续连接和持续连接</h3><ul><li>每个请求响应对是经一个单独的TCP连接发送，则为非持续连接(HTTP1.0)。</li><li>所有的请求及响应经相同的TCP连接发送，则为持续连接(HTTP1.1)。HTTP在默认方式下使用带流水线的持续连接，允许请求连续发出，而不需要等待未决请求的回答。</li></ul><h3 id="2-3-HTTP报文格式"><a href="#2-3-HTTP报文格式" class="headerlink" title="2.3 HTTP报文格式"></a>2.3 HTTP报文格式</h3><p>HTTP<strong>请求报文</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /somdir/page.html HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.someschool.edu</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">User-agent</span><span class="punctuation">: </span>Mozilla/5.0</span><br><span class="line"><span class="attribute">Accept-language</span><span class="punctuation">: </span>fr</span><br></pre></td></tr></table></figure><p style="text-indent:2em">请求报文的第一行为请求行，包含方法字段，URL字段和HTTP版本字段，后继的行为首部行，包含了主机地址及连接方式等信息。在首部行后还有一个实体体，用于POST方法。共有5种方法：GET,POST,HEAD,PUT,DELETE。其中最常用的是GET方法，包括提交表单时也可以使用GET方法。</p><p>HTTP<strong>响应报文</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Tue, 18 Gug 2015 15:44:04 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/2.2.3 (CentOS)</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Tue, 18 Gug 2015 15:11:03 GMT</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>6821</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line">(data data ......)</span><br></pre></td></tr></table></figure><p style="text-indent:2em">响应报文包含三个部分：初始状态行，首部行，实体体。其中初始状态行包含了协议版本，状态码和相应状态信息。以下是常见的状态码：</p><ul><li>200 OK</li><li>301 Moved Permanently</li><li>400 Bad Request</li><li>404 Not Found</li><li>505 HTTP Version Not Supported</li></ul><h3 id="2-4-cookie"><a href="#2-4-cookie" class="headerlink" title="2.4 cookie"></a>2.4 cookie</h3><p style="text-indent:2em">HTTP是一个无状态协议，服务器不保存用户的信息。使用cookie可以让服务器标识一个客户，提供服务。cookie有以下4个组件：</p><ul><li>响应报文中的一个cookie首部行</li><li>请求报文中的一个cookie首部行</li><li>用户端系统中保留一个cookie文件，由浏览器管理</li><li>位于Web站点的一个数据库，记录用户信息</li></ul><h3 id="2-5-Web缓存"><a href="#2-5-Web缓存" class="headerlink" title="2.5 Web缓存"></a>2.5 Web缓存</h3><p style="text-indent:2em">Web缓存器也叫代理服务器，能够代表初始Web服务器满足HTTP请求。Web缓存器可以在存储器空间中保留最近请求过的对象的副本。使用Web缓存器可以大大减少对客户请求的响应时间，还能够大大减少一个机构的接入链路到因特网的通信量。Web缓存器通常由ISP购买和安装。</p><p style="text-indent:2em">Web缓存器带来的一个问题是存放在缓存器中的副本可能不是最新的，因此需要有方式去证实请求的对象是最新的。解决这个问题的方式是使用条件GET方法，在首部行中添加"If-Modified-Since"，这样只在指定日期后对象被修改过，才发送该对象。</p><h2 id="3-因特网中的电子邮件"><a href="#3-因特网中的电子邮件" class="headerlink" title="3.因特网中的电子邮件"></a>3.因特网中的电子邮件</h2><p style="text-indent:2em">因特网邮件系统有三个主要组成部分：<b>用户代理，邮件服务器，简单邮件传输协议(SMTP)。</b></p><p style="text-indent:2em">发送邮件的过程如下：    用户代理------>邮件服务器-----SMTP----->邮件服务器----->用户代理</p><ul><li>用户代理允许用户阅读、回复、转发、保存和撰写报文。</li><li>邮件服务器负责发送和接收邮件，服务器上有一个邮箱，管理和维护着接收到的报文。</li><li>SMTP是电子邮件使用的应用层协议，使用该协议从发送方的邮件服务器向接收方的邮件服务器发送邮件。<ul><li>SMTP一般不使用中间邮件服务器发送邮件，而是两个服务器之间发送。</li><li>SMTP限制报文体只能采用简单的7bitASCII表示。</li><li>SMTP使用持续的TCP连接发送报文。</li></ul></li></ul><p><img src="/2022/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B001/SMTP.jpg" style="zoom:100%;"></p><ul><li>SMTP与HTTP的对比<ul><li>HTTP是一个拉协议，SMTP是一个推协议。</li><li>SMTP要求每个报文采用7bitASCII码格式</li><li>HTTP将每个对象封装到自己的HTTP响应报文中，而SMTP把所有报文对象放在一个报文之中。</li></ul></li></ul><p style="text-indent:2em">SMTP是一个推协议，由发送邮件的服务器将文件发给接收邮件的服务器，接收邮件的用户是不能使用该协议获取接收到的邮件的。获取接收到的邮件使用的是<b>邮件访问协议</b>。流行的邮件访问协议有：第三版的邮局协议<font color="red">POP3</font>；因特网邮件访问协议<font color="red">IMAP</font>。</p><p><strong>POP3</strong></p><p style="text-indent:2em">POP3协议简单，但功能有限。用户代理打开与邮件服务器的TCP连接后，POP3开始工作。POP3工作有三个阶段：</p><ul><li>特许：用户代理发送用户名和口令以鉴别用户。</li><li>事务处理：用户代理取回报文，对报文进行删除标记，取消删除标记，获取邮件的统计信息。获取报文有以下两种方式：<ul><li>下载并保留</li><li>下载并删除</li></ul></li><li>更新：结束POP3会话，删除被标记为删除的报文。</li></ul><p><strong>IMAP</strong></p><p style="text-indent:2em">使用POP3协议只能获取报文，不能在服务器上创建文件夹对报文进行管理。为了解决这个或一些其他问题，产生了IMAP协议。IMAP服务器把每个报文与一个文件夹联系起来，报文到达时与INBOX文件夹相关联，而收件人能够把邮件移到一个新的文件夹中，阅读，删除或是移动到别的文件夹。IMAP还提供了查询邮件的命令，且IMAP维护了IMAP会话的用户状态信息(文件夹的名字等)。另外，IMAP还<b>允许用户代理获取报文某些部分的命令</b>。这样当用户处于低带宽连接时，可以选择性的只取回(MIME)报文的一部分。</p><p><strong>基于Web的电子邮件</strong></p><p style="text-indent:2em">今天，基于Web的邮件已经非常常见了。这种电子邮件，用户代理就是浏览器，用户和远程邮箱之间的通信通过HTTP进行。用户发送和获取电子邮件时，都通过HTTP协议在浏览器和邮件服务器之间进行报文传输，但是邮件服务器之间发送和接收报文仍然使用SMTP。</p><h2 id="4-DNS：因特网的目录服务"><a href="#4-DNS：因特网的目录服务" class="headerlink" title="4.DNS：因特网的目录服务"></a>4.DNS：因特网的目录服务</h2><h3 id="4-1-DNS概述与DNS服务"><a href="#4-1-DNS概述与DNS服务" class="headerlink" title="4.1 DNS概述与DNS服务"></a>4.1 DNS概述与DNS服务</h3><p style="text-indent:2em">因特网上的主机可以使用多种方式标识。一种易于记忆的方式是主机名，而路由器所需要的标识则是更为具体的IP地址。将主机名转换到IP地址，就是<b>域名系统</b>DNS的任务。</p><ul><li>DNS是由分层的DNS服务器实现的分布式数据库。</li><li>DNS是使主机能够查询分布式数据库的应用层协议。</li><li>DNS协议运行在UDP上，使用53端口。</li></ul><p style="text-indent:2em">除了进行主机名到IP地址的转换，DNS还提供了以下服务：</p><ul><li>主机别名：一个主机除了规范主机名外，还可以有其他别名。通过DNS可以获取别名对应的规范主机名和IP地址。</li><li>邮件服务器别名：和主机别名相同，邮件服务器也可以使用别名，通过DNS获取规范主机名和IP地址。</li><li>负载分配：一个站点可能会被冗余分布在多台服务器上，有不同的IP地址。这些IP地址构成了一个IP地址集，DNS服务器可以在返回这些IP地址时循环改变次序，客户通常选择先返回的IP地址请求服务，这样通过更改返回IP地址的顺序，就能起到负载分配的作用。</li></ul><h3 id="4-2-DNS工作原理"><a href="#4-2-DNS工作原理" class="headerlink" title="4.2 DNS工作原理"></a>4.2 DNS工作原理</h3><p style="text-indent:2em">使用单个DNS服务器有单点故障、通信容量，远距离集中(高时延)，维护等问题，因此DNS采用了分布式的设计方案。按照层次，DNS服务器分为三种：<font color="red">根DNS服务器；顶级域服务器；权威DNS服务器</font>。除了以上三个层次外，还有一类重要的DNS服务器是<font color="red">本地DNS服务器</font>。本地DNS服务器一般离主机很近，起到代理的作用。在进行DNS查询时，有两种查询方式：递归查询和迭代查询。<b>通常，请求主机到本地DNS服务器的查询是递归的，其余的查询是迭代的。</b></p><p style="text-indent:2em">为了改善时延性能和减少报文传输，DNS还广泛使用了<b>缓存技术</b>。DNS服务器会缓存主机名/IP地址对，一段时间后才丢弃缓存信息。</p><h2 id="5-P2P文件分发"><a href="#5-P2P文件分发" class="headerlink" title="5.P2P文件分发"></a>5.P2P文件分发</h2><p style="text-indent:2em">使用P2P体系结构的网络应用对总是打开的基础设施服务器有最小的依赖。P2P体系结构具有内在自扩展性，无论有多少对等方，P2P体系结构的应用的文件分发时间都小于客户-服务器体系结构的应用。BitToreent是一种用于文件分发的流行P2P协议，以下是BitTorrent的部分功能原理。</p><p style="text-indent:2em">在BitTorrent协议中，参与一个文件分发的所有对等方的集合称为一个<b>洪流</b>。洪流中的对等方互相下载等长度的文件块(典型长度256KB)。对等方刚进入洪流时没有块，一段时间后就持有了块，并可为其他对等方上载块。每个洪流有一个<b>追踪器</b>，当对等方加入洪流时，将向追踪器注册自己，并周期性通知追踪器自己仍在洪流中。</p><p style="text-indent:2em">当一个对等方A加入洪流后，追踪器会给出一个对等方子集及这些对等方的IP地址，A可以从中选择临近的对等方建立TCP连接，交换块列表。选择向邻居请求哪些块使用的策略是<b>最稀缺优先</b>，首先请求邻居中副本最少的块，从而加快这些块的分发。而响应邻居的哪些请求则使用的是一种对换算法，优先响应前四个给A提供数据最高速率的邻居(他们被称为<b>疏通</b>)，并且还会每30s随机选择一个对等方B，如果B的速率够高，就把B换进前四位列表。这样对等方能够趋向于找到彼此的协调的速率上载。除了这五个对等方外，其他相邻的对等方不会收到A的块。这种激励机制被称为“一报还一报”。</p><h2 id="6-视频流和内容分发网"><a href="#6-视频流和内容分发网" class="headerlink" title="6.视频流和内容分发网"></a>6.视频流和内容分发网</h2><h3 id="6-1-视频流"><a href="#6-1-视频流" class="headerlink" title="6.1 视频流"></a>6.1 视频流</h3><p style="text-indent:2em">视频是一系列的图像，可以被压缩，通常用比特率来衡量质量。视频可以被压缩到不同的比特率，让用户根据网络带宽来选择观看的版本。对流式视频最重要的性能度量是平均端到端吞吐量，流式视频应用得到的平均吞吐量至少与压缩视频的比特率一样大。</p><p style="text-indent:2em">在HTTP流中，视频只是一个普通的文件。用户请求视频文件，将收到的字节进行缓存，一旦超过了预先设定的门限就开始播放，将字节处理成帧，并将这些帧解压缩展现在视频上。视频编码为不同比特率的版本经HTTP传输，被称为<b>经HTTP的动态适应流(DASH)</b>。使用DASH后，视频有不同版本存放在服务器中，服务器会有一个<b>告示文件</b>，提供每个版本的URL和比特率信息。客户可以根据可用带宽指定URL和一个字节范围，对视频数据块请求。</p><h3 id="6-2-内容分发网"><a href="#6-2-内容分发网" class="headerlink" title="6.2 内容分发网"></a>6.2 内容分发网</h3><p style="text-indent:2em">因特网视频公式每天都需要向百万计的用户发送数据，如果在数据中心存储所有视频，会产生很大的问题。主要有三个问题：1.如果用户离数据中心太远，很可能产生停滞时延。2.流行的视频可能经相同链路发送多次，浪费带宽。3.单个数据中心出现单点故障，就不能分发视频流了。为了解决分发视频数据的问题，，几乎所有的视频流公司都使用<b>内容分发网CDN</b>。CDN管理分布在多个位置的服务器，将用户请求定位到能提供最好服务的CDN位置。CDN包括<b>专用CDN(内容提供商自己的)</b>和<b>第三方CDN(代表多个内容提供商分发内容)</b>。</p><p style="text-indent:2em">CDN通常集群部署。每个集群只保留一些视频，当用户请求视频时，如果集群中没有该视频，再从其他集群或中心仓库拉取视频到集群，并在本地存储一个副本。CDN的部署通常采用两种原则：</p><ul><li>深入：在全球接入ISP中部署服务器集群，靠近端用户。</li><li>邀请做客：在少量关键的位置建造大集群，邀请ISP做客。</li></ul><p style="text-indent:2em">使用CDN，用户的请求需要被重定向到CDN服务器，这通常是由DNS进行截获和重定向的。DNS检测到URL中有video以及内容提供商的名字，就返回一个CDN域的主机名，用户将再次发送请求到这个CDN域的DNS系统，并得到CDN节点的IP地址。CDN的集群选择策略是CDN部署的核心，一种简单的策略是指派用户到地理上最为临近的集群，也有周期性实时测量集群和用户到集群时延和丢包性能来选择集群的策略。</p><h2 id="7-套接字编程"><a href="#7-套接字编程" class="headerlink" title="7.套接字编程"></a>7.套接字编程</h2><p style="text-indent:2em">网络应用程序有两类，一种使用协议标准(如RFC)定义的操作实现的，另一种是使用专用的应用层协议。如果是开发专用的网络应用程序，应该避免使用熟知端口号。另外一个实现网络应用程序的问题是，该选择TCP还是UDP。这两种协议有各自的特点。以下是分别使用UDP和TCP实现的简单客户-服务器程序(Python实现)。</p><h3 id="7-1-UDP套接字编程"><a href="#7-1-UDP套接字编程" class="headerlink" title="7.1 UDP套接字编程"></a>7.1 UDP套接字编程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Client</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    serverName = <span class="string">&#x27;127.0.0.1&#x27;</span><span class="comment">#本机IP</span></span><br><span class="line">    serverPort = <span class="number">12000</span><span class="comment">#端口</span></span><br><span class="line">    clientSocket = socket(AF_INET, SOCK_DGRAM)<span class="comment">#IPV4,UDP</span></span><br><span class="line">    message = <span class="built_in">input</span>(<span class="string">&quot;Input lowercase sentence:&quot;</span>)</span><br><span class="line">    clientSocket.sendto(message.encode(), (serverName,serverPort))</span><br><span class="line">    modifiedMessage,serverAddress = clientSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line">    <span class="built_in">print</span>(modifiedMessage.decode())</span><br><span class="line">    clientSocket.close()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Server</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    serverPort = <span class="number">12000</span></span><br><span class="line">    serverSocket = socket(AF_INET,SOCK_DGRAM)</span><br><span class="line">    serverSocket.bind((<span class="string">&#x27;&#x27;</span>,serverPort))</span><br><span class="line">    message,clientAddress = serverSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line">    modifiedMessage = message.decode().upper()</span><br><span class="line">    serverSocket.sendto(modifiedMessage.encode(),clientAddress)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="7-2-TCP套接字编程"><a href="#7-2-TCP套接字编程" class="headerlink" title="7.2 TCP套接字编程"></a>7.2 TCP套接字编程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Client</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    serverName = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">    serverPort = <span class="number">12000</span></span><br><span class="line">    clientSocket = socket(AF_INET,SOCK_STREAM)<span class="comment">#IPv4,TCP</span></span><br><span class="line">    clientSocket.connect((serverName,serverPort))<span class="comment">#建立连接</span></span><br><span class="line">    sentence = <span class="built_in">input</span>(<span class="string">&quot;Input lowercase sentence:&quot;</span>)</span><br><span class="line">    clientSocket.send(sentence.encode())<span class="comment">#已建立连接，不需要地址了</span></span><br><span class="line">    modifiedSentence = clientSocket.recv(<span class="number">2048</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;From Server:&quot;</span>,modifiedSentence.decode())</span><br><span class="line">    clientSocket.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"><span class="comment"># Server</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    serverPort = <span class="number">12000</span></span><br><span class="line">    serverSocket = socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    serverSocket.bind((<span class="string">&#x27;&#x27;</span>,serverPort))</span><br><span class="line">    serverSocket.listen(<span class="number">1</span>)<span class="comment">#欢迎套接字，等待建立连接</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The server is ready to receive&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        connectionSocket,addr = serverSocket.accept()<span class="comment">#客户专用套接字</span></span><br><span class="line">        sentence = connectionSocket.recv(<span class="number">2048</span>).decode()</span><br><span class="line">        modifiedSentence = sentence.upper()</span><br><span class="line">        connectionSocket.send(modifiedSentence.encode())</span><br><span class="line">        connectionSocket.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cs基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理笔记</title>
      <link href="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p style="text-indent:2em">编译原理学习笔记。参考：</p><p>​        编译原理(中科大)：<a href="https://www.bilibili.com/video/BV16h411X7JY?p=1">https://www.bilibili.com/video/BV16h411X7JY?p=1</a></p><p>​        编译原理(哈工大)：<a href="https://www.bilibili.com/video/BV1zW411t7YE?p=1">https://www.bilibili.com/video/BV1zW411t7YE?p=1</a></p><p style="text-indent:2em">笔记是根据书+网课+本校课程按照理解过程记录，和书或网课的顺序不一致。主要的算法都是来自《现代编译原理：c语言描述》(虎书)，因为与一般学习编译原理用的龙书有差异，将需要注意的情况在下面列出，这些不同主要在语法分析部分，不影响语法分析的算法思想和过程，列出来仅是为了避免在学习过程中产生困惑。</p><ul><li>自顶向下的语法分析计算了NULLABLE集，FIRST集，FOLLOW集，FIRST_S集，其中的FIRST_S集更常见的说法是SELECT集。</li><li>使用算法计算FIRST(N)集时，没有将空串加入FIRST集，这是因为已经计算了NULLABLE集，不需要把空串包含到FIRST集当中了。</li><li>在使用虎书的方法计算FIRST集，FOLLOW集中，不包含#符号和$符号，实际这两个符号也只是标记结束，不影响语法分析过程。</li></ul><h1 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h1><h2 id="1-语言处理器"><a href="#1-语言处理器" class="headerlink" title="1.语言处理器"></a>1.语言处理器</h2><ul><li>编译器</li><li>解释器</li></ul><h2 id="2-编译器的结构"><a href="#2-编译器的结构" class="headerlink" title="2.编译器的结构"></a>2.编译器的结构</h2><ul><li>词法分析：将语素转换为词法单元</li><li>语法分析：使用词法单元创建树形的中间表示，常用语法树。</li><li>语义分析：检查源程序是否和语言定义的语义一致，并进行类型检查。</li><li>中间代码生成</li><li>代码优化</li><li>代码生成：以源程序的中间表示形式作为输入，映射到目标语言。</li></ul><span id="more"></span><h2 id="3-程序设计语言的发展历程"><a href="#3-程序设计语言的发展历程" class="headerlink" title="3.程序设计语言的发展历程"></a>3.程序设计语言的发展历程</h2><h2 id="4-编译器相关科学"><a href="#4-编译器相关科学" class="headerlink" title="4.编译器相关科学"></a>4.编译器相关科学</h2><h2 id="5-编译技术应用"><a href="#5-编译技术应用" class="headerlink" title="5.编译技术应用"></a>5.编译技术应用</h2><h2 id="6-程序设计语言基础"><a href="#6-程序设计语言基础" class="headerlink" title="6.程序设计语言基础"></a>6.程序设计语言基础</h2><ul><li>静态和动态的区别：使用的策略可处理编译时刻可决定的问题，则为静态策略；一个只允许在运行程序时作出决定的策略则为动态策略。</li><li>声明的作用域：仅阅读程序就可以确定一个声明的作用域，则该语言使用的是静态作用域。</li><li>环境：名字到存储位置的映射。</li><li>状态：内存位置到值的映射。</li><li>块结构：{}界定一个块。</li><li>静态作用域规则：如果名字x的声明D属于B块，那么D的作用域包含整个B，但是以任意深度嵌套在B中，重新声明了x的所有块C不在此作用域中。</li><li>动态作用域：一个作用域策略依赖于一个或多个在程序执行时刻才能知道的因素，就是动态的。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态作用域例：</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> a (x+1)</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">b</span><span class="params">()</span> &#123; <span class="type">int</span> x =<span class="number">1</span>; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">c</span><span class="params">()</span> &#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;b();c();&#125;</span><br></pre></td></tr></table></figure><ul><li>参数传递：参数可以通过值或引用的方式从调用过程传递给被调用过程。通过值传递传递大型对象时，实际被传递的是指向这些对象的引用。</li><li>别名：当参数被以引用传递方式传递时，两个形式参数可能会指向同一个对象，这会造成一个变量的修改改变了另一个变量的值。</li></ul><h1 id="第二章-词法分析"><a href="#第二章-词法分析" class="headerlink" title="第二章 词法分析"></a>第二章 词法分析</h1><p style="text-indent:2em">在开始词法分析之前，需要了解一些基本概念。</p><h2 id="1-词法-amp-语法分析基本概念"><a href="#1-词法-amp-语法分析基本概念" class="headerlink" title="1.词法&amp;语法分析基本概念"></a>1.词法&amp;语法分析基本概念</h2><p><strong>字母表</strong></p><p style="text-indent:2em">字母表是有穷符号的集合。两个字母表可以进行乘积，幂，正闭包，克林闭包运算。</p><ul><li>乘积：{0,1}{a,b} = {0a,0b,1a,1b}</li><li>幂：{0,1}^3 = {0,1}{0,1}{0,1}</li><li>正闭包：{a,b,c,d}+ = {a,b,c,d,aa,ab……}</li><li>克林闭包：{a,b,c,d}* = {a,b,c,d}+ ε(空串)</li></ul><p><strong>串</strong></p><p style="text-indent:2em">串是字母表中符号的一个有穷集合，串s的长度通常记作|s|。串的运算为连接和幂，串x=str1，y=str2，则xy=str1str2，幂运算同理。**文法**</p><p style="text-indent:2em">文法是用来描述<b>语法结构(语言规则)</b>的。一个自然语言的文法例子如下：- <句子> -> <名词短语><动词短语>- <名词短语> -> <形容词><名词短语>- <名词短语> -> <名词>- ...其他规则- <形容词> -> {...}- <名词> -> {...}<p style="text-indent:2em">文法的形式化定义：G=(Vt,Vn,P,S)。</p><ul><li>Vt：终结符集合。终结符是文法所定义语言的<font color="blue">基本符号</font>。例如Vt={difficult，parse，course…..}</li><li>Vn：非终结符集合。非终结符是表示<font color="blue">语法成分</font>的符号，也被称为语法变量。例：{&lt;句子&gt;，&lt;名词短语&gt;，&lt;动词&gt;……}</li><li><p>P：产生式集合。产生式描述了终结符(基本符号)和非终结符(语法成分)组成串的方式。一般形式为：α→β。例如：&lt;句子&gt;→&lt;动词短语&gt;&lt;名词短语&gt;。另外，同一个非终结符(语法成分)的产生式可以组合在一起表示，用|分隔：<br>list → list + digit，list → list-digit可以合并成list → list+digit | list-digit。(|的优先级最低)</p></li><li><p>S：开始符号，文法中最大的语法成分。例：S=&lt;句子&gt;</p></li></ul><p style="text-indent:2em">有了语言规则，就可以判断一个词串是否是一个语言的句子了。句子可以进行推导，也可以进行规约，分别对应着生成语言和识别语言的角度，下面是自然语言的例子：</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/规约推导.png" style="zoom:70%;"></p><h2 id="2-词法分析和词法分析器"><a href="#2-词法分析和词法分析器" class="headerlink" title="2.词法分析和词法分析器"></a>2.词法分析和词法分析器</h2><p style="text-indent:2em">词法分析是编译的第一个阶段，任务是<b>把源程序的输入字符(词素)转换为已知语言的成分(词法单元序列)。</b>转换后的词法单元序列会交给语法分析器进行语法分析。通常语法分析起有一个getNextToken命令让词法分析器读取输入字符，直到词法分析器能识别一个词素，并将该词素生成为词法单元交给语法分析器。实现一个词法分析器有两种方式，第一种是<font color="blue">手动用代码实现</font>(需要画状态转移图辅助)，另一种是<font color="blue">使用词法分析器生成工具</font>(需要使用正则表达式描述出词素的模式)。</p><p style="text-indent:2em">下面是词法分析使用的术语：</p><ul><li>词法单元：由一个词法单元名和一个可选属性值组成。词法单元名是表示词法单位的抽象符号，属性值表示了词法单元的相关信息。比如一个词法单元“id”表示程序设计语言的标识符，那么属性值就是指向这个具体的标识符信息(在符号表里)的指针；一个词法单元“number”表示数字常量，那么属性值就是这个数字常量的具体值。</li><li>模式：描述了一个词法单元的词素可能具有的形式。</li><li>词素：源程序的一个字符序列，和一个词法单元的模式匹配，可以被识别为一个词法单元的实例。</li></ul><p style="text-indent:2em">例：</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/词法单元.jpg" style="zoom:70%;"></p><h2 id="3-输入缓冲"><a href="#3-输入缓冲" class="headerlink" title="3.输入缓冲"></a>3.输入缓冲</h2><p style="text-indent:2em">识别输入流中的词素之前，首先要读入输入流。为了处理输入的字符，需要使用两个缓冲区。每个缓冲区容量都是N个字符，通常N是一个磁盘块的大小。处理读入字符流时有两个指针，lexemeBegin指针指向当前词素的开始处，forward指针一直扫描，直到发现某个模式匹配为止。如果forward已经扫描到了EOF，就再读入N个字符到另一个缓冲区，这样只要词素的长度不大于N，就不会在识别到词素之前覆盖掉缓冲区中的词素。EOF也被称为哨兵标记，输入的末尾和缓冲区的末尾都有该字符。</p><h2 id="4-正则表达式"><a href="#4-正则表达式" class="headerlink" title="*4.正则表达式"></a>*4.正则表达式</h2><p style="text-indent:2em">正则表达式是用来描述语言的一种方式，可以描述字母表上的符号通过并，连接，闭包这些运算而得到的语言。用符号给正则表达式命名，然后进行定义，写法与文法很相似，例如用正则表达式表示无符号数(5280,0.01234,6.336E4，1.89E-4)的串number：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">digit ——→ 0|1|...|9</span><br><span class="line">digits ——→ digit digit*</span><br><span class="line">optionalFraction ——→ . digits | e</span><br><span class="line">optionalExponent ——→ (E(+|-|e)digits) | e</span><br><span class="line">number ——→ digits optionalFraction optionalExponent</span><br></pre></td></tr></table></figure><p style="text-indent:2em">正则表达式还有一些扩展的写法，如后缀+表示语言的及其正闭包，后缀?表示零个或一个出现，字符类可以用[a-z]表示a|b|...|z。</p><h2 id="5-状态转换图"><a href="#5-状态转换图" class="headerlink" title="5.状态转换图"></a>5.状态转换图</h2><p style="text-indent:2em">构造一个状态转换图可以体现词素转换的过程，每识别一个字符，就更新到下一个状态，如果已经找到了词素对应的词法单元，当前的字符不是上一个词法单元中的一部分，则要让forward指针回退一个位置。下面这个例子清晰的表现了状态转换图是怎么体现词素识别过程的。</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/状态转换.jpg" style="zoom:70%;"></p><p style="text-indent:2em">对于保留字(if，else)的识别，通常为这些保留字建立单独的状态图。也可以将其先填入符号表中，识别该词法单元后，如果符号表中没有该符号，就说明不是保留字，添加到符号表，并返回条目指针作为属性。</p><h2 id="6-词法分析工具Lex"><a href="#6-词法分析工具Lex" class="headerlink" title="6.词法分析工具Lex"></a>6.词法分析工具Lex</h2><p style="text-indent:2em">开始介绍词法分析时，提到了将词素转换为词法单元有两种方式：第一种是<font color="blue">手动用代码实现</font>(需要画状态转移图辅助)，另一种是<font color="blue">使用词法分析器生成工具</font>(需要使用正则表达式描述出词素的模式)。画状态转移图的方式已经介绍过了。而Lex就是另一种方式的工具，即词法分析器生成工具。</p><p style="text-indent:2em">Lex中，使用正则表达式描述词法单元的模式，Lex编译器将输入的模式转换成一个状态转换图，并生成相应的实现代码，存放到lex.yy.c文件中。Lex编译器编译的内容是由Lex语言表示的。因此Lex的使用方式如下：</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/Lex.jpg" style="zoom:70%;"></p><p style="text-indent:2em">Lex程序结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">声明部分</span><br><span class="line">%%</span><br><span class="line">转换规则</span><br><span class="line">%%</span><br><span class="line">辅助函数</span><br></pre></td></tr></table></figure><ul><li>声明部分：包括变量和明示常量(如一个词法单元的名字)。</li><li>转换规则：形式为：模式{动作}，模式为正则表达式，动作则是代码片段。</li><li>辅助函数：各个动作需要的辅助函数。</li></ul><p style="text-indent:2em">仅看上面的结构很难理解Lex程序到底是怎么构造的，需要结合下面这个例子来理解各个部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="comment">/*明示常量:LT,LE,NE,...,ID,NUMBER...*/</span></span><br><span class="line">    <span class="comment">/*这部分(%&#123;%&#125;)里面的内容会直接复制到C代码中*/</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LT 10000</span></span><br><span class="line">    ......</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 一些正则表达式 */</span></span><br><span class="line">delim   [ \t\n]</span><br><span class="line">ws     &#123;delim&#125;+</span><br><span class="line">letter[a-zA-Z]</span><br><span class="line">digit[<span class="number">0</span><span class="number">-9</span>]</span><br><span class="line">id&#123;letter&#125;(&#123;letter&#125;|&#123;digit&#125;)*</span><br><span class="line">number&#123;digit&#125;+(\.&#123;digit&#125;+)?(E[+-]?&#123;digit&#125;+)?<span class="comment">//\.表示‘.’</span></span><br><span class="line">%%</span><br><span class="line">    </span><br><span class="line">&#123;ws&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">if</span>&#123;<span class="keyword">return</span>(IF);&#125;<span class="comment">//保留字先被列出</span></span><br><span class="line">then&#123;<span class="keyword">return</span>(THEN);&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="keyword">return</span>(ELSE);&#125;</span><br><span class="line">&#123;id&#125;&#123;yyval = (<span class="type">int</span>)installID();<span class="keyword">return</span>(ID);&#125;</span><br><span class="line">&#123;number&#125;&#123;yyval = (<span class="type">int</span>)installNum();<span class="keyword">return</span>(NUMBER);&#125;</span><br><span class="line"><span class="string">&quot;&lt;&quot;</span>&#123;yyval = LT;<span class="keyword">return</span>(RELOP);&#125;</span><br><span class="line">......</span><br><span class="line">%%</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">installID</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    将找到的词素放到符号表中</span></span><br><span class="line"><span class="comment">    返回一个指向符号表的指针到yyval，这是个全局变量，语法分析器或编译器等后续组件可以使用</span></span><br><span class="line"><span class="comment">    把词法单元名返回到语法分析器。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p style="text-indent:2em">最后，如果Lex遇到了冲突，即一个词素可以被识别为多种词法单元，按照以下规则处理：</p><ul><li>选择最长前缀(例如选择&lt;=，而不是&lt;)。</li><li>有多个模式可匹配，选择在Lex中先被列出的。</li></ul><p style="text-indent:2em">书中还提到了关键字不是保留字的情况，这里不讨论。</p><h2 id="7-有穷自动机"><a href="#7-有穷自动机" class="headerlink" title="*7.有穷自动机"></a>*7.有穷自动机</h2><p style="text-indent:2em">以上已经说明了Lex的使用，下面说明Lex是如何将输入程序变成一个词法分析器的。转换的核心是被称为<b>有穷自动机(FA)</b>的表示方法。自动机本质上是与状态转换图类似的图，由许多状态构成，不同状态之间通过有向的<b>标号(标记)</b>可以转换。</p><ul><li>有穷自动机是识别器，只能对可能的输入串回答’是’或’否’。</li><li>有穷自动机分为两类：<ul><li>不确定的有穷自动机(NFA)：对其边上的标号没有限制，可以是空串，且一个符号可以标记离开一个状态的多条边。(一个状态接收到一个符号后，可能到达不同的状态)</li><li>确定的有穷自动机(DFA)：对于每个状态及自动机输入字母表中的每个符号，有且只有一条离开该状态，以该符号为标号的边。(一个状态接收一种符号，只到达一种下一状态)</li></ul></li></ul><h3 id="7-1-不确定的有穷自动机-NFA"><a href="#7-1-不确定的有穷自动机-NFA" class="headerlink" title="7.1 不确定的有穷自动机(NFA)"></a>7.1 不确定的有穷自动机(NFA)</h3><p style="text-indent:2em">一个NFA由以下几个部分组成：</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/nfa.jpg" style="zoom:70%;"></p><p style="text-indent:2em">不管是NFA还是DFA，实际上都可以用转换图来表示，但是NFA与状态转换图的不同在于：</p><ul><li>同一个符号可以标记从同一状态到多个目标状态的边。(一个符号可以转换到不同状态)</li><li>标号不仅是字母表中的符号，还可以是空符号串ε</li></ul><p style="text-indent:2em">下面是一个识别正则表达式(a|b)*abb的NFA的转换图:</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/NFA例.jpg" style="zoom:70%;"></p><p style="text-indent:2em">上面的状态3表示串被接收，所有该FA接受的串构成的集合记为L(M)，称为被<b>该FA定义(或接收)的语言</b>。从状态0接收到‘a’，可能到达状态0，也可能到达状态1，因此这个FA是不确定有穷自动机NFA。除了状态转换图以外，转换表也可以表示NFA，以下是上图的NFA对应的转换表：</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/转换表.jpg" style="zoom:70%;"></p><p style="text-indent:2em">上面已经看到NFA接收一个符号，可能转换到不同状态的特点了，下面的例子展现了另一个特点，空串也可以作为状态转换的标号：</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/空串NFA.jpg" style="zoom:70%;"></p><h3 id="7-2-确定的有穷自动机-DFA"><a href="#7-2-确定的有穷自动机-DFA" class="headerlink" title="7.2 确定的有穷自动机(DFA)"></a>7.2 确定的有穷自动机(DFA)</h3><p style="text-indent:2em">DFA是NFA的特例，特点是：</p><ul><li>没有输入ε的转换动作。</li><li>每个状态s和符号a，只有一条标号为a的边离开s。</li></ul><p style="text-indent:2em">DFA相对于NFA识别更加具体和简单，因为一个符号只能导致从一个状态转换到另一个特定的状态(而不是不确定的多个状态)，由于每个NFA都可以转变为一个接收相同语言的DFA，实际上我们模拟和实现的都是DFA。</p><h2 id="8-正则表达式到自动机"><a href="#8-正则表达式到自动机" class="headerlink" title="*8.正则表达式到自动机"></a>*8.正则表达式到自动机</h2><p style="text-indent:2em">介绍自动机是要说明Lex词法分析的过程。自动机本质其实就是状态机，可以说Lex的工作就是根据自动机的状态变化产生词法分析代码。我们输入Lex的是正则表达式，因此Lex要先把这些正则表达式转化为自动机。通常先把正则表达式转换为NFA，再把NFA转换为DFA(因为直接从正则表达式构建DFA比较复杂)。</p><h3 id="8-1-正则表达式到NFA"><a href="#8-1-正则表达式到NFA" class="headerlink" title="8.1 正则表达式到NFA"></a>8.1 正则表达式到NFA</h3><p style="text-indent:2em">对正则表达式进行NFA的构造只要按照以下规则：</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/NFA构造.jpg" style="zoom:40%;"></p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/nfa构造例.jpg" style="zoom:40%;"></p><h3 id="8-2-NFA到DFA"><a href="#8-2-NFA到DFA" class="headerlink" title="8.2 NFA到DFA"></a>8.2 NFA到DFA</h3><p style="text-indent:2em">有了NFA后，需要将NFA转换为DFA。这个过程采用的是<b>子集构造法</b>。基本思想是：DFA的每个状态是NFA的状态集合(例如NFA中的某个状态A，得到字符x后可能回到A，可能到B或C，那么转换到DFA后，ABC就是为一个状态集合，表示DFA中的一个状态。)。下面直接看两个例子：</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/nfa到dfa.jpg" style="zoom:40%;"></p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/nfa到dfa1.jpg" style="zoom:40%;"></p><h3 id="8-3-DFA最小化"><a href="#8-3-DFA最小化" class="headerlink" title="8.3 DFA最小化"></a>8.3 DFA最小化</h3><p style="text-indent:2em">对于同一个语言，存在多个识别该语言的DFA。使用DFA来实现词法分析器，总是希望使用的DFA状态数最少。因此需要进行DFA最小化。DFA最小化通常使用的是Hopcroft算法，也称为基于等价类的算法。</p><p style="text-indent:2em">该算法的原理是，假设有一个状态集合S，如果有一个字符c，可以将S切割，那么这个S就被切割成S1，S2。不断的进行切割，直到不可切割时，每个集合S1，S2...中的状态就是可以合并的。字符c可以切割S这样解释，假设状态1,2,3一开始都在集合S中，状态1和状态2接收到字符c都转换为状态4，而状态3接收到c不转换到状态4，那么就说字符c可以切割集合S，集合S被切割成S1(状态1，状态2)和S2(状态3)。最开始的时候，现将所有状态分成两个集合，接收状态的集合和非接受状态的集合。该算法的描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">split</span>(S)</span><br><span class="line">    foreach (character c)</span><br><span class="line">    <span class="keyword">if</span>(c can split S)</span><br><span class="line">            split S <span class="type">int</span> T1,...,<span class="function">Tk</span></span><br><span class="line"><span class="function"><span class="title">hopcroft</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    split all nodes into N,A</span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="params">(set is still changes)</span></span></span><br><span class="line"><span class="function">    <span class="title">split</span><span class="params">(S)</span></span></span><br></pre></td></tr></table></figure><h2 id="9-DFA到词法分析器代码"><a href="#9-DFA到词法分析器代码" class="headerlink" title="9.DFA到词法分析器代码"></a>9.DFA到词法分析器代码</h2><p style="text-indent:2em">能够从正则表达式构建NFA，将NFA转换到DFA并最小化，最后一步就是将DFA转变成词法分析器的代码。DFA是一个有向图，可以表示为转移表，哈希表等不同的表示，具体的表示取决于在实际实现中对时间空间的权衡。</p><p style="text-indent:2em">先看一下转移表的表示：</p><div class="table-container"><table><thead><tr><th>状态\字符</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td>0</td><td>1</td><td></td><td></td></tr><tr><td>1</td><td></td><td>1</td><td>1</td></tr></tbody></table></div><p style="text-indent:2em">状态的变化可以直接查表，再加上驱动代码就可以构成词法分析器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nextToken</span>()&#123;</span><br><span class="line">    state = <span class="number">0</span>;</span><br><span class="line">    stack = [];</span><br><span class="line">    <span class="keyword">while</span>(state!=ERROR)&#123;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">if</span>(state is ACCEPT) <span class="built_in">clear</span>(stack);</span><br><span class="line">        <span class="built_in">push</span>(state);</span><br><span class="line">        state = table[state][c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(state is <span class="keyword">not</span> ACCEPT)&#123;</span><br><span class="line">        state = <span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">rollback</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(state is ACCEPT) <span class="keyword">return</span> ACCEPT_TOKEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">还有使用跳转表的代码实现，使用goto语句进行状态跳转，if语句进行字符判断并状态跳转。这样实现的方式优点是不需要存储状态表，当状态表很大，状态非常多的时候，这样能节省许多空间。</p><h1 id="第三章-语法分析"><a href="#第三章-语法分析" class="headerlink" title="第三章 语法分析"></a>第三章 语法分析</h1><p style="text-indent:2em">语法分析的任务是根据给定的文法识别输入句子中的各个成分，并构建<font color="red">抽象语法树</font>。在构建抽象语法树前，首先根据输入的串和给定的文法构建<font color="red">语法分析树</font>。如果输入串的各个单词从左自右为分析树的叶子节点，那么这个串就是该语言的一个句子。然后通过语法制导翻译，产生抽象语法树。</p><p style="text-indent:2em">下面先考虑语法分析树的构造，按照分析树的构造方向，语法分析可以分为两类：自顶向下的语法分析，自底向上的语法分析。</p><p style="text-indent:2em">在语法分析中，使用<b>上下文无关文法(CFG)</b>来描述语言的规则。一个上下文无关文法的定义为:G=(T,N,P,S)</p><ul><li>T：终结符集合</li><li>N：非终结符集合</li><li>P：一组产生式规则</li><li>S：唯一的开始符号</li></ul><h2 id="1-自顶向下分析概述"><a href="#1-自顶向下分析概述" class="headerlink" title="1.自顶向下分析概述"></a>1.自顶向下分析概述</h2><p style="text-indent:2em">自顶向下从根节点向底部节点构造分析树，可以看成是从文法开始符号S推导出词串w的过程。</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/语法分析例.jpg" style="zoom:40%;"></p><p style="text-indent:2em">在进行推导的过程中需要解决两个问题：</p><ul><li>替换当前句中的哪个<font color="blue">非终结符</font></li><li>用该终结符的哪个<font color="blue">候选式</font>进行替换</li></ul><p style="text-indent:2em">对于第一个问题，有两种选择方式：最左推导；最右推导。</p><ul><li>最左推导：总是选择每个句型的最左非终结符进行替换。</li><li>最右推导：总是选择每个句型的最右非终结符进行替换。</li></ul><p style="text-indent:2em">对应于推导，语法分析也可以使用规约的方式，因此有相应的最左规约和最右规约。</p><p style="text-indent:2em">在自底向上的分析中，总是采用最左归约的方式，因此把最左归约称为规范归约，而最右推导相应地称为规范推导。</p><p style="text-indent:2em">一个串总是自左向右进行语法分析，因此自顶向下的语法分析采用<b>最左推导的方式</b>。构造语法分析树时，选定最左非终结符的产生式，将串的字符与产生式相匹配。</p><p style="text-indent:2em">例：</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/最左推导例.jpg" style="zoom:40%;"></p><p style="text-indent:2em">自顶向下语法分析是具体通过<b>递归下降分析</b>实现的。递归下降分析中，每个非终结符都有一个过程，从文法开始符号的S对应过程开始，递归调用文法中其它非终结符对应的过程，直到整个输入串都被扫描。</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/递归下降分析.jpg" style="zoom:100%;"></p><h2 id="2-自顶向下分析"><a href="#2-自顶向下分析" class="headerlink" title="2.自顶向下分析"></a>2.自顶向下分析</h2><h3 id="2-1-需要回朔的自顶向下算法"><a href="#2-1-需要回朔的自顶向下算法" class="headerlink" title="2.1 需要回朔的自顶向下算法"></a>2.1 需要回朔的自顶向下算法</h3><p style="text-indent:2em">自顶向下分析的伪代码描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tokens[];</span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//栈中一开始只有开始符号</span></span><br><span class="line">stack=[s];</span><br><span class="line"><span class="keyword">while</span>(stack!=[])</span><br><span class="line">    <span class="keyword">if</span>(stack[top] is a terminal t)&#123;</span><br><span class="line">        <span class="comment">//匹配成功</span></span><br><span class="line">        <span class="keyword">if</span>(t==tokens[i++]) <span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//匹配失败，要把刚刚入栈的元素出栈，换回原来的非终结符</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">backtrack</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(stack[top] is a nonterminal T)&#123;</span><br><span class="line">        <span class="comment">//非终结符出栈，换为产生式中的成分，从右往左入栈</span></span><br><span class="line">        <span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">push</span>(the next right hand side of T)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">在尝试用产生式进行匹配时，不可避免的需要进行回朔，这导致分析效率存在极大的问题。实际情况中，总是需要线性时间的算法，因此有了<b>递归下降分析算法和LL分析算法</b>。</p><h3 id="2-2-递归下降分析-预测分析算法"><a href="#2-2-递归下降分析-预测分析算法" class="headerlink" title="2.2 递归下降分析(预测分析算法)"></a>2.2 递归下降分析(预测分析算法)</h3><p style="text-indent:2em">递归下降分析算法是自顶向下分析算法的一种，通过前看符号避免回朔，基本思想如下：</p><ul><li>每个非终结符构造一个分析函数</li><li>用前看符号指导产生式规则的选择</li></ul><p style="text-indent:2em">示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产生式</span></span><br><span class="line">X -&gt; aBcD   </span><br><span class="line">|bD</span><br><span class="line">B -&gt; …   </span><br><span class="line">D -&gt; …         </span><br><span class="line"><span class="comment">//每个非终结符的函数</span></span><br><span class="line"><span class="built_in">parse_X</span>()&#123;</span><br><span class="line">    token = <span class="built_in">nextToken</span>();</span><br><span class="line">    <span class="keyword">if</span>(token==a)&#123;</span><br><span class="line">        move token;</span><br><span class="line">        <span class="built_in">parse_B</span>();</span><br><span class="line">        <span class="keyword">if</span>(token==c)&#123;</span><br><span class="line">            move token;</span><br><span class="line">            <span class="built_in">parse_D</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">error</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(token==b)&#123;</span><br><span class="line">        move token;</span><br><span class="line">        <span class="built_in">parse_D</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">error</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">当产生式的多个选择中含有公因子，前看符号就无法指导分支选择了，因此需要提取左公因子，方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; aB1</span><br><span class="line">|aB2</span><br><span class="line">|aB3</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 提取左公因子</span></span><br><span class="line">A -&gt; aA<span class="string">&#x27;</span></span><br><span class="line"><span class="string">A&#x27;</span>-&gt;B1|B2|B3|...</span><br></pre></td></tr></table></figure><p style="text-indent:2em">另一个可能出现的问题是，当产生式为一个递归式时，将无法调用产生式右部非终结符的分析函数，因此需要将左递归消除，方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; Aa|B</span><br><span class="line"><span class="comment"># 消除左递归</span></span><br><span class="line">A -&gt; BA<span class="string">&#x27;#推导结束的时候，一定有一个B在开始的位置上</span></span><br><span class="line"><span class="string">A&#x27;</span>-&gt; aA<span class="string">&#x27;|ε#B之后有多个a</span></span><br></pre></td></tr></table></figure><p style="text-indent:2em">有些情况，使用以上方法并不能消除掉左递归，也就无法通过一个前看符号预测正确的产生式。<b>一个上下文无关文法不一定有对应的无回朔文法，是否存在对应的无回朔文法是不可判定的。</b></p><h3 id="2-3-LL-1-分析算法"><a href="#2-3-LL-1-分析算法" class="headerlink" title="2.3 LL(1)分析算法"></a>2.3 LL(1)分析算法</h3><p style="text-indent:2em">LL(1)分析算法是另一种自顶向下分析算法。LL(1)表示从左向右分析，使用最左推导，采用一个前看符号。该算法的基本思想是使用分析表来指导产生式规则的选择，因此被称为是一种<b>表驱动</b>的分析算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">tokens[];</span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//栈中一开始只有开始符号</span></span><br><span class="line">stack=[s];</span><br><span class="line"><span class="keyword">while</span>(stack!=[])</span><br><span class="line">    <span class="keyword">if</span>(stack[top] is a terminal t)&#123;</span><br><span class="line">        <span class="comment">//匹配成功</span></span><br><span class="line">        <span class="keyword">if</span>(t==tokens[i++]) <span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//匹配失败，要把刚刚入栈的元素出栈，换回原来的非终结符</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">backtrack</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(stack[top] is a nonterminal T)&#123;</span><br><span class="line">        <span class="comment">//非终结符出栈，换为产生式中的成分，从右往左入栈</span></span><br><span class="line">        <span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">push</span>(the next right hand side of T)</span><br><span class="line">        <span class="comment">//↓ 使用分析表确定将哪个具体的产生式入栈</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">从每个产生式S开始推导，最终产生的句子可能有多种开头，分析表就是基于这些开头进行前看分析的。这些开头的集合称为<font color="red">FIRST_S(p)集</font>，这个集合也一般被称作<font color="red">SELECT集</font>。而产生式的开头可能是什么非终结符，又是由产生式开头的非终结符N决定的。非终结符N开始推导得出的句子开头的所有可能终结符集合为<font color="red">FIRST(N)集</font>。</p><p style="text-indent:2em">FIRST(N)集的获取，只要对N的产生式的开头的非终结符进行替换，直到替换到终结符就可以了，所有最终替换到的终结符的集合就是FIRST(N)集。但是要考虑到开头的非终结符最终可能为空串，那样的话，整个非终结符N的开头就不是由开头的非终结符产生的了。例如N->XY，而X->ε|a，那FIRST(N)就不仅仅是{a}，还要考虑Y最终可以替换为什么终结符。因此还需要考虑哪些非终结符最终能产生空串，这些非终结符的集合称为<font color="red">NULLABLE集</font>。</p><p style="text-indent:2em">一个非终结符X属于NULLABLE集合由以下两种情况：</p><ul><li>X-&gt;ε|…</li><li>X-&gt;Y1Y2…Yn，Y1-Yn都属于NULLABLE集</li></ul><p style="text-indent:2em">NULLABLE集的产生过程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//伪代码描述</span><br><span class="line">NULLABLE=&#123;&#125;;</span><br><span class="line">while (NULLABLE IS STILL CHANGING)&#123;</span><br><span class="line">    foreach(产生式：X-&gt;β)</span><br><span class="line">        if(β==epsilon)</span><br><span class="line">            NULLABLE ∪= &#123;X&#125;</span><br><span class="line">    if(β==Y1Y2...Yn)&#123;</span><br><span class="line">            if(Y1,Y2,...Yn∈NULLABLE)</span><br><span class="line">                NULLABLE ∪= &#123;X&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">//进一步伪代码描述</span><br><span class="line">NULLABLE=&#123;&#125;;</span><br><span class="line">while (上一轮结束，NULLABLE集还在变化)&#123;</span><br><span class="line">    foreach(遍历每一条产生式：X-&gt;β)</span><br><span class="line">        if(β为空串)X添加到NULLABLE集当中;</span><br><span class="line">    if(β为Y1Y2...Yn)&#123;</span><br><span class="line">            if(Y1,Y2,...Yn都在NULLABLE中，都可以推导到空串)</span><br><span class="line">                X添加到NULLABLE集中;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">考虑了空串的FIRST(N)集算法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//伪代码描述</span><br><span class="line">foreach (N)</span><br><span class="line">    FIRST(N)=&#123;&#125;</span><br><span class="line">while(set is changing)&#123;</span><br><span class="line">    foreach(N-&gt;X1X2...Xn)&#123;/*对每个产生式更新FIRST(N)*/</span><br><span class="line">        foreach(Xi)&#123;</span><br><span class="line">    if(Xi==a)&#123;/*终结符并入集合*/</span><br><span class="line">                FIRST(N) ∪= &#123;a&#125;</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            if(Xi==M..)&#123;/*非终结符要确认是不是在NULLABLE中*/</span><br><span class="line">                FIRST(N) ∪= FIRST(M)</span><br><span class="line">                if(M not in NULLABLE) break</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">考虑一个产生式的第一个符号，存在这样一种情况，s->N1N2，N1N2可以为空串，这时就没办法知道什么时候使用产生式s了，为了知道什么时候使用产生式s，需要知道非终结符N后面会跟什么符号，N后面会出现的符号集合称为<font color="red">FOLLOW(N)集。</font></p><p style="text-indent:2em">FOLLOW(N)集的算法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//伪代码描述</span><br><span class="line">while(有任何非终结符的FOLLOW集还发生变化)&#123;</span><br><span class="line">    for(每个产生式N-&gt;β1...βn)&#123;</span><br><span class="line">        tail = FOLLOW(N);</span><br><span class="line">        for(i=n;i&gt;0;i--)&#123;</span><br><span class="line">            if(βi==a) tail = a;</span><br><span class="line">            if(βi==M)&#123;</span><br><span class="line">                FOLLOW(M) ∪= tail;</span><br><span class="line">                /*M可以为空串，则M前面出现的非终结符的FOLLOW集包含FIRST(M)，也包含M后面可能出现的终结符，因此这里是并*/</span><br><span class="line">                if(M in NULLABLE) tail ∪= FIRST(M);</span><br><span class="line">                else tail = FIRST(M);</span><br><span class="line">                /*如果M不可以为空串，那么M前面的非终结符的FOLLOW集只有FIRST(M)，不能有M后面的东西了*/</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">计算FOLLOW集是一个遍历产生式，对每个非终结符出现的情况，向非终结符的FOLLOW集添加元素的过程。</p><p style="text-indent:2em">有了NULLABLE，FIRST，FOLLOW集，就可以求产生式的FIRST_S集(SELECT集)了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">calculate_first_s(p:N-&gt;b1b2...bn)&#123;</span><br><span class="line">    for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(bi==a)&#123;</span><br><span class="line">            FIRST_S(p) ∪= &#123;a&#125;;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(bi==M)&#123;</span><br><span class="line">            FIRST_S(p) ∪= FIRST(M)-ε;</span><br><span class="line">            if(M not in NULLABLE) return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /*整个产生式的元素都可以走到空串*/</span><br><span class="line">    FIRST_S(p) ∪= FOLLOW(N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">需要注意，<font color="red">SELECT集即FIRST_S集中不含有空串</font>。有了FIRST_S集(SELECT集)，分析表的填写就很容易了，例如产生式p1，p2都是N的产生式，就在分析表上N的一行上，哪个终结符在FIRST_S(p1)/SELECT(p1)当中就在哪一列填写产生p1，p2同理。</p><h2 id="3-自底向上分析"><a href="#3-自底向上分析" class="headerlink" title="3.自底向上分析"></a>3.自底向上分析</h2><p style="text-indent:2em">自底向上分析是另一种语法分析的方式，与自底向下的推导不同，自底向上是一个规约的过程。自底向上分析中最重要的是LR分析算法，即移进-规约算法。使用这种分析方法，对记号流进行规约时，使用一个<b><font color="red"> · </font></b>将已经读入的和未读入的输入分开。用一个栈表示读入的记号，读入的记号入栈，称为<font color="”blue“">移进</font>，栈顶的一些元素匹配产生式，将这些元素出栈，产生式左部入栈， 称为<font color="blue">规约</font>。</p><p style="text-indent:2em">什么时候进行移进，什么时候进行规约，实际上也是通过预先构造的分析表完成的。分析表为以下形式：</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221101215423962.png" style="zoom:80%;"></p><p style="text-indent:2em">其中的$表示结束，表示可以接收，结束语法分析。通常将需要分析的文法进行拓展，补充一条产生式。例如一个文法由S开始，在这个文法中加入一条产生式S'->S$，其他产生式不变，然后再进行语法分析。这个新的文法也被称为是原文法的<b>增广文法</b>。分析时使用两个栈，一个状态栈，一个记号栈，根据上面的分析表进行移进和规约。状态栈栈顶根据记号栈栈顶进行状态变化。</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221101215556978.png" style="zoom:80%;"></p><p style="text-indent:2em">重点就在于构建分析表，考虑不采用前看符号的自顶向下分析，即LR(0)算法中，分析表的构建。</p><h3 id="3-1-LR-0"><a href="#3-1-LR-0" class="headerlink" title="3.1 LR(0)"></a>3.1 LR(0)</h3><p style="text-indent:2em">LR(0)分析算法中分析表的构造分为两个步骤：</p><ul><li>构造DFA</li><li>根据DFA生成LR(0)分析表</li></ul><p style="text-indent:2em">构造的DFA形式如下，每一个产生式被称作一个<b>项目</b>，每一个状态是状态集或者称为<b>项目集</b>。可以看出通过终结符产生的状态是移进的过程，通过非终结符产生的状态是规约。<font color="blue">遇到了非终结符，就将遇到的非终结符的产生式加入到状态中。</font>这一步也被称为求项集的闭包。</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221102000502457.png" style="zoom:80%;"></p><p style="text-indent:2em">根据DFA构造分析表的过程比较简单，注意移进，规约，转移这三个动作就可以了。在分析表中，用<b><font color="red">sn</font></b>表示移进，<b><font color="red">rn</font></b>表示规约，<b><font color="red">gn</font></b>表示转移。</p><h3 id="3-2-SLR分析算法"><a href="#3-2-SLR分析算法" class="headerlink" title="3.2 SLR分析算法"></a>3.2 SLR分析算法</h3><p style="text-indent:2em">LR(0)分析算法有两个缺点。第一个缺点是延迟了错误发现的时机，当已经读入的记号可以规约时，就进行规约，哪怕后续的记号是错误的，也先把读入的全部规约后才发现后续的错误；另一个缺点是可能存在冲突，例如有产生式S->T和S->T+，既可以移进也可以规约，无法一步作出正确的选择。为了解决LR(0)分析算法的问题，在LR(0)的基础上，修改规约表项的生成，就是<b>SLR分析算法。</b></p><p style="text-indent:2em">SLR分析算法相比于LR(0)的修改之处为：生成分析表时，若某状态包含A->α·，只对<font color="red">FOLLOW(A)</font>中的输入记号添加对产生式A->α的规约操作。因此对于上面在LR(0)中已经见到过的分析表，使用SLR分析算法构建的表如下：</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221102105130932.png" style="zoom: 50%;"></p><p style="text-indent:2em">如果最终产生的分析表没有冲突项，那么就说这个文法是<font color="red">SLR文法</font>。可能的冲突有两种：<b>移进-规约冲突；规约-规约冲突</b>。在分析表中，体现为一个状态在接收到一个符号后，既可以移进又可以规约，或有两个不同的规约方法。</p><h3 id="3-3-LR-1-分析算法"><a href="#3-3-LR-1-分析算法" class="headerlink" title="3.3 LR(1)分析算法"></a>3.3 LR(1)分析算法</h3><p style="text-indent:2em">在SLR分析算法中，最终得到的分析表仍然可能存在冲突，因为进行规约时，对于非终结符A，只要后面出现了FOLLOW(A)的元素就进行规约。分析表的作用就是为了选择正确的产生式，但是FOLLOW(A)对于确认在哪个产生式中发生了规约是不够精确的。因此考虑采用前看符号，确认产生式的选择，即采用<b>LR(1)</b>分析算法。</p><p style="text-indent:2em">LR(1)中定义项目为[X ➝α•β, a]，其含义是：- 已读入α- 剩余的输入能够匹配βa；若β=ε，可以用该条产生式归约（α归约成X）</p><p style="text-indent:2em">LR(1)分析算法其他和LR(0)相同，仅状态集的产生和归约表项的产生不同。</p><ul><li><p>状态集(项目集)的产生：对项目为[X ➝ α •Y β, a]，添加[Y -&gt; • γ,b]到项目集(状态集)，其中b属于FIRST_S(βa)</p></li><li><p>归约表项的产生：对包含项目[X ➝ α β •, a]的状态，对输入a产生该产生式的归约项rn</p></li></ul><p style="text-indent:2em">下面是一个LR(1)中产生项集闭包的例子，可以看到第一条产生式中遇到非终结符S，而第一条产生式S后面只有$，因此下面添加S的产生式到项集时，前看符号是FIRST_S($)={$}；第二条产生式遇到了L，L后面是=R，该条产生式的前看符号是$，因此下面添加L的产生式到项集时，前看符号是FIRST_S(=R$)={=}。</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221107152240619.png" style="zoom:80%;"></p><p style="text-indent:2em">最后总结一下自底向上分析的步骤：</p><ul><li>向原文法添加产生式S’-&gt;S$，产生增广文法</li><li>使用DFA构造法产生状态转移过程，每个状态是一个项集</li><li>根据DFA生成分析表</li><li>利用状态栈和记号栈，使用分析表进行自底向上分析</li></ul><h2 id="4-语法制导翻译"><a href="#4-语法制导翻译" class="headerlink" title="4.语法制导翻译"></a>4.语法制导翻译</h2><p style="text-indent:2em">语法分析结束后，需要进行语义分析和中间代码生成，这两步可以合称为语义翻译，语义翻译可以在语法分析时一并完成，因此语法分析，语义分析，中间代码生成可以合称为语法制导翻译阶段。</p><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p style="text-indent:2em">以上所述的语法分析的过程中，最终将给定的句子按照给定的文法构建了一颗语法分析树，在这个过程中也判断了句子是否是合法的。但是仅仅完成以上的工作还不够，语法分析还需要产生抽象语法树，并完成类型检查，目标代码生成，中间代码生成等工作。这些后续的工作，可以通过<b>语法制导翻译</b>完成。</p><p style="text-indent:2em">语法制导翻译(SDT)是语法分析指导下的翻译，用于生成抽象语法树，语义分析以及生成中间代码。翻译的方法是在语法分析时，给产生式附加一个动作。翻译动作包括：</p><ul><li>生成动作：生成抽象语法树，生成中间或目标代码</li><li>语义动作：赋予类型、检查类型</li></ul><p style="text-indent:2em">语法分析在使用产生式时，插入翻译的动作.</p><p style="text-indent:2em">在自底向上分析中，体现为分析时多了一个动作栈：</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221116141730596.png" alt="image-20221116141730596" style="zoom:67%;"></p><p style="text-indent:2em">进行语法分析时，相应的动作也入栈执行。</p><h3 id="4-2-抽象语法树"><a href="#4-2-抽象语法树" class="headerlink" title="4.2 抽象语法树"></a>4.2 抽象语法树</h3><p style="text-indent:2em">在语法分析树中，保留了使用产生式推导的过程，这些信息在后续的语义分析和代码生成中不需要，占用额外空间。因此将语法分析树中对后续工作没有用的节点取去掉，，仅保留必要的信息，得到的就是抽象语法树。语法分析树存储的是具体的语法信息，而抽象语法树只需要保留<b>程序构造的动作和执行对象</b>。以3+4*5为例，对应的抽象语法树如下：</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221120110215577.png" alt="image-20221120110215577" style="zoom:50%;"></p><p style="text-indent:2em">以下是一个简单的抽象语法树的数据结构定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">kind</span> &#123;E_INT,E_ADD,E_TIMES&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Exp</span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">kind</span> kind;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// *的抽象语法树节点 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Exp_Times</span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">kind</span> kind;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Exp</span> *left;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Exp</span> *right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 整型的抽象语法树节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Exp_Int</span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">kind</span> kind;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// +的抽象语法树节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Exp_Add</span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">kind</span> kind;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Exp</span> *left;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Exp</span> *right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">语法分析中，通常采用自底向上的方法，例如语法分析器生成工具Bison就是对LALR文法进行自底向上分析。采用自底向上的方法，抽象语法树应该是从子节点开始建立的。最先建立的是终结符对应的叶子节点，此后每次使用产生式进行规约时，就建立一个新的节点，并将产生式中成分的节点设置为新节点的子节点。相关的函数和调用大致为以下的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产生一个终结符的叶子节点，创建节点并赋相应的值</span></span><br><span class="line"><span class="function">Exp_int *<span class="title">Exp_Int_new</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Exp_Int</span> *p = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(p));</span><br><span class="line">    p-&gt;kind = E_INT;</span><br><span class="line">    p-&gt;n = n;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加一个加法节点</span></span><br><span class="line"><span class="function">Exp_Add *<span class="title">Exp_Add_new</span><span class="params">(Exp *left,  Exp *right)</span></span>&#123;</span><br><span class="line">    Exp_Add *p = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(p));</span><br><span class="line">    p-&gt;kind = E_ADD;</span><br><span class="line">    p-&gt;left = left;</span><br><span class="line">    p-&gt;right = right;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//语法分析时调用动作函数</span></span><br><span class="line">E -&gt; n&#123;e=<span class="built_in">Exp_Int_new</span>(n)&#125;</span><br><span class="line">     |  E+E&#123;e=<span class="built_in">Exp_Add_new</span>(e1,e2)&#125;</span><br><span class="line">     |  E*E&#123;e=<span class="built_in">Exp_Times_new</span>(e1,e2)&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">以上的抽象语法树节点相当简化，实际上应该包含更多信息，如文件，行号，列号等，因为程序被转换为抽象语法树后，源代码就被丢弃了，必须保留足够的信息，使后续过程能够准确的报错。</p><h3 id="4-3-语法制导翻译理论"><a href="#4-3-语法制导翻译理论" class="headerlink" title="4.3 语法制导翻译理论"></a>4.3 语法制导翻译理论</h3><p style="text-indent:2em">语法制导翻译是建立在<font color="red">语法制导定义SDD</font>基础上的。SDD是一种上下文无关文法，每个文法符号具备一个<b>属性</b>(对于一个结点X，用X.a表示其属性)，每个产生式有一个<b>语义动作</b>。一些输出等动作称为副作用，如果SDD中没有副作用，则这种SDD被称为<b>属性文法</b>。一个SDD包含了语法分析与语法制导翻译的过程。但不是所有的语法制导翻译都可以在语法分析中完成(即动作能完成的工作是有限的)。SDD被分为两类：</p><ul><li><p>S属性的SDD：只存在自底向上的属性依赖关系，每个属性都是综合属性。</p><ul><li>综合属性：节点的综合属性只能通过子节点或者节点本身的属性来定义。</li></ul><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20230216212111467.png" alt="image-20230216212111467" style="zoom:80%;"></p></li><li><p>L属性的SDD：只存在自底向上，自顶向下，自左向右的属性依赖关系，每个属性都是继承属性。</p><ul><li><p>继承属性：节点的继承属性由父节点，节点本身或兄弟节点的属性来定义。</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20230216212150014.png" alt="image-20230216212150014" style="zoom:80%;"></p></li></ul></li></ul><p style="text-indent:2em">对于S属性的SDD，只要在使用产生式把右部规约为左部时执行翻译动作就可以了，这也是上面构造语法分析树的方式。而对于L属性的SDD，由于是继承关系，可以考虑采用递归下降的语法分析，对非终结符N的产生式成分调用子分析函数进行分析时(此处可回顾递归下降分析的分析函数)，<font color="blue">N的继承属性是子函数的参数，综合属性是子函数的返回值</font>，并且左边的子函数先执行，所以左依赖的属性值先计算，按照这个顺序完成翻译动作。</p><p style="text-indent:2em">自底向上分析也可以完成L属性的SDD的语法制导翻译，此处不讨论，在龙书中5.5.4节有介绍。</p><p style="text-indent:2em">S属性的语法制导翻译是一个自底向上的过程，子节点总是属性值已知，父节点的值由子节点的属性值决定，例如计算式3+5*4,3和5和4为子节点，5*4构成父节点factor，其属性值为20，然后3和factor再构成父节点expression，值为3+20，这个计算式的代码也可以按照这个过程生成。中科大配套实验的第四个实验就是这样自底向上生成代码，计算抽象语法树的结点属性值的。通常情况下是先建立好语法分析树，然后进行深度优先遍历语法分析树，计算节点的属性值，完成语义分析，代码生成。</p><h3 id="4-4语法制导翻译方案-模式"><a href="#4-4语法制导翻译方案-模式" class="headerlink" title="4.4语法制导翻译方案(模式)"></a>4.4语法制导翻译方案(模式)</h3><p style="text-indent:2em">语法制导翻译的方案(模式)就是在SDD基础上进行语法制导翻译的具体实现，可以看作是对SDD的实现细节的具体说明。翻译方案是在产生式右部嵌入了<font color="red">程序片段</font>的文法，其中的程序片段称为语义动作。按照管理，语义动作放在{}内。例如:</p><p>D → T {L.inh = T.type} L<br>T → int {T.type = int}</p><p>T → real {T.type = real}</p><p style="text-indent:2em">语义动作的位置决定了动作的执行时间。</p><p style="text-indent:2em">对于S属性的SDD，将每个语义动作放在产生式的最后<font color="blue">(只有子结点都分析完毕，才可以计算父节点的综合属性)</font>。将L属性的SDD转换为SDT，需要将计算非终结符A的继承属性的动作插入到产生式右部A出现之前的位置，将综合属性的动作放到产生式右部的最右端。</p><p style="text-indent:2em">对以上的语义动作放置位置进行举例：对于产生式P → T X = E和E → E + E，处理到E结点时，调用子节点E1和E2的处理函数，E1和E2的值计算完毕后，才可以计算E的值，所以语义动作必须放在最后。而E的类型取决于前面的声明，是一个继承属性，因此在调用E的处理函数之前，就要告知E的类型，这样之后才能确定E1和E2进行什么类型的加法运算(生成什么加法指令)，并进行语义检查(例如检查E1和E2是否为同一个类型，是否需要转换)。因此其翻译模式如下：</p><p>P → T X = {E.type = X.type} E</p><p>E → E + E {E.val = E1.val + E2.val}</p><h1 id="第四章-语义分析"><a href="#第四章-语义分析" class="headerlink" title="第四章 语义分析"></a>第四章 语义分析</h1><p style="text-indent:2em">语义分析也称为类型检查，上下文相关分析，主要负责检查程序的上下文相关的属性，例如变量使用前要声明，函数调用要与声明一致等。</p><h2 id="1-语义规则"><a href="#1-语义规则" class="headerlink" title="1.语义规则"></a>1.语义规则</h2><p style="text-indent:2em">通常来说，程序设计语言都采用自然语言来表达程序语言的语义，语义规则与具体语言相关，编译器的实现者必须对语言的语义规定有全面的理解。</p><h2 id="2-符号表"><a href="#2-符号表" class="headerlink" title="2.符号表"></a>2.符号表</h2><p style="text-indent:2em">对于上下文相关的属性，必须进行记录才能保证程序能够运行，例如变量的声明必须有所记录，语义检查也是通过这些记录完成好呢个的。程序中的变量相关信息记录在<b>符号表</b>当中，包含变量的类型，作用域，访问控制信息，符号表的使用伴随了编译的全过程。</p><p style="text-indent:2em">符号表实现时，比较复杂的是考虑作用域的情况，不同作用域可以使用一个链表来记录：</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221224173753951.png" alt="image-20221224173753951" style="zoom: 67%;"></p><p style="text-indent:2em">也可以符号表栈，进入一个作用域就插入新的符号表，退出则删除栈顶符号表。</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221224173931283.png" alt="image-20221224173931283" style="zoom:67%;"></p><p style="text-indent:2em">语义分析中包含的其他问题还有类型相容等。现代的编译器中的语义分析模块，除了做语义分析外，还要负责生成中间代码或目标代码。因此，语义分析模块往往是编译器中最庞大也最复杂的模块。接下来就介绍代码生成的部分。</p><h1 id="第五章-代码生成"><a href="#第五章-代码生成" class="headerlink" title="第五章 代码生成"></a>第五章 代码生成</h1><p style="text-indent:2em">生成了抽象语法树，前端的工作就结束了。后端的工作是将输入的抽象语法树翻译生成目标代码。即代码生成。</p><p style="text-indent:2em">代码生成是将源程序翻译成目标机器上的代码的过程，主要完成两个任务，同时要保证等价和效率。</p><ul><li>给源程序的数据分配存储资源<ul><li>数据：全局变量，局部变量，动态分配等。</li><li>存储资源：寄存器，内存。</li></ul></li><li>给源程序的代码选择指令<ul><li>源程序的代码：表达式，语句，函数等。</li><li>机器指令：算术运算，比较，跳转等。</li></ul></li></ul><p style="text-indent:2em">代码生成技术与指令集有关，主要研究两种不同的指令集上的代码生成技术：栈计算机，寄存器计算机。</p><h2 id="1-栈式计算机的代码生成技术"><a href="#1-栈式计算机的代码生成技术" class="headerlink" title="1.栈式计算机的代码生成技术"></a>1.栈式计算机的代码生成技术</h2><p style="text-indent:2em">栈式计算机现在已经基本淘汰了，研究其代码生成技术的原因是其代码生成比较简单，且现在仍然有许多栈式的虚拟机。</p><p style="text-indent:2em">栈式计算机的结构和指令集如下：</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221116155344350.png" alt="image-20221116155344350" style="zoom:50%;"></p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221116155737804.png" alt="image-20221116155737804" style="zoom:67%;"></p><p style="text-indent:2em">栈式计算机只支持一种数据类型int，给变量x分配内存的伪指令是：.int x。其他的指令执行的操作如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">push NUM</span><br><span class="line">    top++;</span><br><span class="line">stack[top] = NUM;</span><br><span class="line">load x</span><br><span class="line">    top++;</span><br><span class="line">stack[top] = x;</span><br><span class="line">store x</span><br><span class="line">    x = stack[top];</span><br><span class="line">top--;</span><br><span class="line">add </span><br><span class="line">    temp = stack[top<span class="number">-1</span>] + stack[top];</span><br><span class="line">top = top<span class="number">-2</span>;</span><br><span class="line">push temp;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">语法如下：</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221116162402189.png" alt="image-20221116162402189" style="zoom:50%;"></p><p style="text-indent:2em">每个非终结符都有一个代码生成函数，在代码生成时，表达式对应的值总是在栈顶。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Gen_E</span>(E e)&#123;</span><br><span class="line">    <span class="keyword">switch</span> (e)</span><br><span class="line">        <span class="keyword">case</span> n: </span><br><span class="line">    <span class="built_in">emit</span>(<span class="string">&quot;push n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> id: </span><br><span class="line">    <span class="built_in">emit</span>(<span class="string">&quot;load id&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">            <span class="built_in">emit</span>(<span class="string">&quot;push 1&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> e1+e2:</span><br><span class="line">            <span class="built_in">Gen_E</span>(e1);</span><br><span class="line">            <span class="built_in">Gen_E</span>(e2);</span><br><span class="line">            <span class="built_in">emit</span>(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Gen_T</span>(T t)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(t)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">    <span class="built_in">emit</span>(<span class="string">&quot;.int&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">    <span class="built_in">emit</span>(<span class="string">&quot;.int&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Gen_S</span>(S s)&#123;</span><br><span class="line">    <span class="keyword">switch</span> (s)</span><br><span class="line">        <span class="keyword">case</span> id=e:</span><br><span class="line">    <span class="built_in">Gen_E</span>(e);</span><br><span class="line">    <span class="built_in">emit</span>(<span class="string">&quot;store id&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Gen_D</span>(T id; D)&#123;</span><br><span class="line">    <span class="built_in">Gen_T</span>(T);</span><br><span class="line">    <span class="built_in">emit</span>(<span class="string">&quot; id&quot;</span>);</span><br><span class="line">    <span class="built_in">Gen_D</span>(D);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Gen_P</span>(D S)&#123;</span><br><span class="line">    <span class="built_in">Gen_D</span>(D);</span><br><span class="line">    <span class="built_in">Gen_S</span>(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">一个代码生成的示例如下：</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221116163942938.png" alt="image-20221116163942938" style="zoom:50%;"></p><h2 id="2-寄存器计算机的代码生成技术"><a href="#2-寄存器计算机的代码生成技术" class="headerlink" title="2.寄存器计算机的代码生成技术"></a>2.寄存器计算机的代码生成技术</h2><p style="text-indent:2em">寄存器计算机是目前最流行的机器体系结构。寄存器计算机中寄存器代替了栈式计算机的栈，在寄存器存放部分变量和中间结果。在考虑代码生成技术时，假定有无限多个寄存器。代码生成的过程和栈式计算机相似。只是目标指令不同，入栈出栈都转变为了寄存器分配，然后存值。</p><p style="text-indent:2em">以下是一个简单寄存器计算机的指令集：</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221116164716744.png" alt="image-20221116164716744" style="zoom:67%;"></p><p style="text-indent:2em">文法仍然为上述介绍栈式计算机时的文法，每一个非终结符的函数变为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Gen_E</span>(E e)&#123;</span><br><span class="line">    <span class="keyword">switch</span> (e)</span><br><span class="line">        <span class="keyword">case</span> n: </span><br><span class="line">    r = <span class="built_in">getNewReg</span>();</span><br><span class="line">    <span class="built_in">emit</span>(<span class="string">&quot;movn n,r&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">case</span> id: </span><br><span class="line">    r = <span class="built_in">getNewReg</span>();</span><br><span class="line">    <span class="built_in">emit</span>(<span class="string">&quot;mov id,r&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">            r = <span class="built_in">getNewReg</span>();</span><br><span class="line">    <span class="built_in">emit</span>(<span class="string">&quot;movn 1,r&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">case</span> e1+e2:</span><br><span class="line">            r1 = <span class="built_in">Gen_E</span>(e1);</span><br><span class="line">            r2 = <span class="built_in">Gen_E</span>(e2);</span><br><span class="line">    r3 = <span class="built_in">getNewReg</span>();</span><br><span class="line">            <span class="built_in">emit</span>(<span class="string">&quot;add r1,r2,r3&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Gen_T</span>(T t)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(t)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">    <span class="built_in">emit</span>(<span class="string">&quot;.int&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">    <span class="built_in">emit</span>(<span class="string">&quot;.int&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Gen_S</span>(S s)&#123;</span><br><span class="line">    <span class="keyword">switch</span> (s)</span><br><span class="line">        <span class="keyword">case</span> id=e:</span><br><span class="line">    r = <span class="built_in">Gen_E</span>(e);</span><br><span class="line">    <span class="built_in">emit</span>(<span class="string">&quot;store r,id&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Gen_D</span>(T id; D)&#123;</span><br><span class="line">    <span class="built_in">Gen_T</span>(T);</span><br><span class="line">    <span class="built_in">emit</span>(<span class="string">&quot; id&quot;</span>);</span><br><span class="line">    <span class="built_in">Gen_D</span>(D);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Gen_P</span>(D S)&#123;</span><br><span class="line">    <span class="built_in">Gen_D</span>(D);</span><br><span class="line">    <span class="built_in">Gen_S</span>(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">一个代码生成的示例如下：</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221116165933101.png" alt="image-20221116165933101" style="zoom:50%;"></p><h1 id="第六章-中间表示"><a href="#第六章-中间表示" class="headerlink" title="第六章 中间表示"></a>第六章 中间表示</h1><p style="text-indent:2em">在上一章中介绍了代码生成，即从抽象语法树生成目标代码的过程。实际在编译过程中，抽象语法树通常不直接生成目标代码，而是先生成一些中间表示，再通过中间表示，生成不同目标机器上的目标代码。中间表示的作用是提供一个中间层，抽象语法树只需要生成中间表示，而不需要根据具体的机器生成目标代码，由后端在后续过程中将中间表示进行优化，并转换为目标代码。基本思想是<b>与目标机器无关，且对于多种源语言通用</b>。</p><p style="text-indent:2em">一般编译器有多阶段的中间表示，高层中间表示接近源语言，便于进行语义分析和冗余检查；低层中间表示接近目标语言，便于优化和翻译。常用的中间表示有：</p><ul><li>图IR：树和有向无环图DAG</li><li>线性IR：三地址码</li><li>混合IR：控制流图CFG，静态单赋值形式SSA</li></ul><p style="text-indent:2em">下面分别介绍这几种中间表示。</p><h2 id="1-有向无环图DAG"><a href="#1-有向无环图DAG" class="headerlink" title="1.有向无环图DAG"></a>1.有向无环图DAG</h2><p style="text-indent:2em">有向无环图DAG是抽象语法树AST的进一步抽象，解决抽象语法树存储开销大，不便于优化的问题。</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221121220337305.png" style="zoom:50%;"></p><p style="text-indent:2em">使用有向无环图DAG的一般用途为：</p><ul><li>减少内存占用：减小AST的内存开销</li><li>后端代码优化：查找冗余，减少翻译出的机器指令</li></ul><p style="text-indent:2em">DAG在生成时，会检查节点是否已经存在，如果需要的节点已经生成，就直接进行引用。手动构造一个DAG的步骤如下：</p><ul><li>将操作数不重复的排成一排</li><li>标出表达式中运算符生效的顺序</li><li>按顺序加入运算符 结果保存在操作数最大层数的上一层</li><li>检查同层运算符是否能够合并</li></ul><p style="text-indent:2em">其中合并可以直接在加入运算符时进行。</p><h2 id="2-三地址代码"><a href="#2-三地址代码" class="headerlink" title="2.三地址代码"></a>2.三地址代码</h2><p style="text-indent:2em">三地址代码是一种每个指令最多有三个操作数，一个运算符的代码。基本思想是：</p><ul><li>给每个中间变量和计算结果命名，没有复合表达式</li><li>只有最基本的控制流，只有goto和call指令</li><li>是指令集的抽象</li></ul><p style="text-indent:2em">以下是一个三地址代码的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源代码</span></span><br><span class="line">a = <span class="number">3</span> + <span class="number">4</span> * <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt; y)</span><br><span class="line">  z = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  z = <span class="number">7</span>;</span><br><span class="line"><span class="comment">//三地址码</span></span><br><span class="line">t1 = <span class="number">4</span> * <span class="number">5</span>;</span><br><span class="line">a = <span class="number">3</span> + t1;</span><br><span class="line"><span class="keyword">if</span> (x &lt; y) <span class="keyword">goto</span> L_1;</span><br><span class="line"><span class="keyword">goto</span> L_2; </span><br><span class="line">L_1:</span><br><span class="line">z = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">goto</span> L_3;</span><br><span class="line">L_2:</span><br><span class="line">z = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">goto</span> L_3:</span><br></pre></td></tr></table></figure><p style="text-indent:2em">使用三地址码的好处是：</p><ul><li>类似寄存器计算机的指令，便于代码生成</li><li>代码紧凑，空间占用少</li><li>形式灵活，表达清晰，且每个中间变量和计算结果命名，便于控制名字和值的复用</li></ul><p style="text-indent:2em">三地址码的主要不足在于程序的控制流信息是隐式的，因为控制流被简化了，因此通过三地址代码难以理解源程序的控制流结构。</p><p style="text-indent:2em">三地址码的生成过程和第五章代码生成中的生成方式很相似。也可以使用语法制导定义SDD直接在语法分析时生成，直接跳过抽象语法树的生成。</p><h2 id="3-控制流图CFG"><a href="#3-控制流图CFG" class="headerlink" title="3.控制流图CFG"></a>3.控制流图CFG</h2><p style="text-indent:2em">控制流图是一个有向图G=(V,E)。其中每个节点V是一个<b>基本块</b>，E是基本块之间的边，表示跳转关系。每个基本块只能从第一条语句进入，从最后一条语句离开。主要的用途为：</p><ul><li>控制流分析：分析程序的内部结构，如是否存在循环。并可以通过分析修改或优化程序，例如删除死基本块。</li><li>数据流分析：例如一个变量可能的取值。</li></ul><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221130102049747.png" alt="image-20221130102049747" style="zoom:50%;"></p><p style="text-indent:2em">控制流图可以由三地址码生成。而控制流图的操作可以使用图论中的各种算法实现。</p><p style="text-indent:2em">控制流图的缺点在于没有显式的数据流信息。不能通过数据流对程序进行优化。</p><h2 id="4-静态单赋值形式SSA"><a href="#4-静态单赋值形式SSA" class="headerlink" title="4.静态单赋值形式SSA"></a>4.静态单赋值形式SSA</h2><p style="text-indent:2em">静态单赋值形式在数据流图的基础上添加了数据流信息，基本思想是：</p><ul><li>每个变量只定义一次。</li><li>使用数据时必须指向一个特定的变量。</li></ul><p style="text-indent:2em">主要的用途就是基于数据流和控制流进行优化。由于在数据流图的基础上显式添加了数据流，主要是在数据流的基础上进行优化：</p><ul><li>删除冗余赋值</li><li>常量传播</li></ul><h1 id="第七章-代码优化"><a href="#第七章-代码优化" class="headerlink" title="第七章 代码优化"></a>第七章 代码优化</h1><p style="text-indent:2em">代码优化是一个在保持语义的基础上进行代码变换的过程。可以按照不同的阶段分为：</p><ul><li>前期优化<ul><li>在抽象语法树上进行</li><li>常量折叠、代数优化、不可达代码删除等</li></ul></li><li>中期优化<ul><li>在中间表示上进行</li><li>常量传播、拷贝传播、死代码删除、公共子表达式删除等</li></ul></li><li>后期优化<ul><li>在后端(汇编代码级)进行</li><li>寄存器分配、指令调度、窥孔优化等</li></ul></li></ul><h2 id="1-前期优化"><a href="#1-前期优化" class="headerlink" title="1.前期优化"></a>1.前期优化</h2><p style="text-indent:2em">前期优化包括<b>常量折叠，代数优化，不可达代码删除</b>。在<b>抽象语法树</b>上进行。</p><p style="text-indent:2em">常量折叠是对程序中表达式的常量计算进行优化。因为一些表达式的值在编译过程中就可以得到，例如a=3+5，可以直接优化为a=8。在语法树或者中间表示上，这种优化是容易实现的，且通常实现为公共子函数，可以被其他优化调用。但在优化过程中必须遵守语言的语义，例如<b>考虑异常或溢出</b>，例如x=4294967294+1，如果x为unsigned int，则值正常+1，如果x是int，结果为-1。</p><p style="text-indent:2em">代数优化是对表达式计算的化简，利用的是代数系统的性质。例如a=1*b = a*b，a+1024+b-1024 = a+b。进行代数化简，也要注意遵守语言的语义，考虑溢出或异常。</p><p style="text-indent:2em">不可达代码删除的基本思想是删除程序中不会执行的代码。这种优化也可以中期在控制流图上完成。</p><h2 id="2-中期优化"><a href="#2-中期优化" class="headerlink" title="2.中期优化"></a>2.中期优化</h2><p style="text-indent:2em">前期优化可简化中后端处理，但是优化能力有限，进行如不可达代码删除这样的优化很不方便。在<b>中间表示</b>位置可以进行进一步的优化。优化的方式则依赖于具体所使用的中间表示。本部分介绍基于控制流图的中期优化。</p><p style="text-indent:2em">中期优化一般分为两步。第一步是<b>程序分析</b>，通过控制流分析，数据流分析，依赖分析等得到被优化程序的静态保守信息(对动态运行行为的保守估计)。第二步是<b>程序重写</b>，基于程序分析的信息对程序进行重写。</p><p style="text-indent:2em">本章主要介绍的是程序分析的两种方法：<font color="red">到达定义分析</font>和<font color="red">活性分析。</font></p><h3 id="2-1-到达定义分析"><a href="#2-1-到达定义分析" class="headerlink" title="2.1 到达定义分析"></a>2.1 到达定义分析</h3><p style="text-indent:2em">到达定义分析主要分析的是<b>对每个变量的使用点，有哪些定义可以到达。</b>其中<b>定义指的是对变量的赋值，使用点是对变量值的读取</b>。</p><p style="text-indent:2em">使用集合来表示到达定义分析的结果，分析每一个语句对到达定义的改变。设每一个语句都有一个<font color="red">in集</font>，表示到达该语句时，有哪些语句的定义有效，每一个语句还有一个<font color="red">out集</font>，表示经过该语句后，还有哪些语句的定义是有效的。</p><p style="text-indent:2em">为了求解in和out集，每个语句还有一个gen集和一个kill集，分别表示该语句产生了一个语句定义，该语句使哪些语句的定义无效。</p><p style="text-indent:2em">假设每条语句编号i，对变量x定义，则到达定义的计算为：</p><ul><li>gen = {i}</li><li><p>kill = defs[x] - {i}</p><ul><li>defs[x]表示所有定义x的语句</li></ul></li><li><p>in[i] = 所有到达i的语句的out集</p></li><li>out[i] = gen[i] ∪ (in[i] - kill[i])，即经过该语句有效的定义语句，是<strong>当前语句</strong>加上<strong>到达该语句有效的定义语句</strong>再减去<strong>当前语句使之无效的那些语句</strong>。</li></ul><p style="text-indent:2em">由于后面的定义需要包含前面的有效定义，即out[i]依赖于in[i]，对于语句in和out集的计算应该从前往后进行，即从第一条语句开始，计算in和out集的方程被称为<font color="red">前向数据流方程</font>。</p><p style="text-indent:2em">以下是一个控制流图的到达定义分析示例，由于in集取决于来源语句的out集，而来源语句的out集可能还没有计算结束，因此要反复计算in和out集，直到集合不发生改变。</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221130155232481.png" alt="image-20221130155232481" style="zoom:99%;"></p><h3 id="2-2-活性分析"><a href="#2-2-活性分析" class="headerlink" title="2.2 活性分析"></a>2.2 活性分析</h3><p style="text-indent:2em">到达定义分析分析的是对变量的使用点，有哪些定义可以到达。另一种常用的程序分析方法是活性分析，分析的是在程序的每个语句，有哪些变量正在处于使用状态。活性分析主要用于寄存器分配，在中间代码生成时，通常假设有无限多个寄存器，从而简化代码生成，最终产生目标代码，必须将无限的虚拟寄存器分配到机器的有限的寄存器当中。进行活性分析，可以确定哪些变量可以共用一个寄存器。</p><p style="text-indent:2em">活性分析需要确定变量在哪些语句是活跃的，活跃的这些语句就是变量的活跃区间。变量活跃的定义如下：</p><ul><li><p>如果变量x在程序点p(含)之后<strong>被使用</strong>，则x在p点是<strong>活跃的</strong>。(显然，如果变量x在点p被有效定义，在点p也是活跃的)</p></li><li><p>否则，如果变量x在程序点p(含)之后<strong>未被使用</strong>，则x在p点是<strong>死的</strong>。(如果变量x在点p被定义，在后面却没有被使用，这个定义实质是无效的，x在点p不是活跃的。)</p></li></ul><p style="text-indent:2em">根据以上的变量活跃的定义，变量活跃，只需要重点关注使用情况，而不需要关注定义情况。并且在分析时，还应该将一些无效的定义语句将被排除在变量活跃区间以外。例如下面的例子：</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221207143830663.png" alt="image-20221207143830663" style="zoom:67%;"></p><p style="text-indent:2em">在语句3和语句4都有对变量c的定义，根据变量活跃的定义，语句3开始就是c的活跃区间，但语句3的定义是无效的，c的活跃区间里不应该有语句3。在求活跃区间时避免这种情况的方式是：从后往前求活跃区间。下面描述一下求解过程。</p><p style="text-indent:2em">类似到达定义分析，设每个语句都有一个in集和一个out集，分别表示<font color="red">到该语句仍然活跃的活跃变量，在该语句之后的还保持活跃的活跃变量</font>。还使用两个辅助的集合use集和def集，分别表示该语句使用了哪些变量，定义了哪些变量。假设语句编号i，这是个集合的计算如下：</p><ul><li>use = {x|x在语句i中出现}</li><li>def = {x|x由语句i定义}</li><li>out[i]：所有从该语句离开，所到达的语句的in集合的并集</li><li>in[i] = use[i] ∪ (out[i] - def[i])</li></ul><p style="text-indent:2em">为了解决上面已经提到的无效定义问题，应该从后往前计算，即in[i]依赖于out[i]，所以从最后的语句开始进行分析，且先计算out集，再计算in集。计算in和out集的方程被称为<font color="red">后向数据流方程</font>。</p><p style="text-indent:2em">对于上图中的程序，求出的in和out集如下：</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221207224109858.png" alt="image-20221207224109858" style="zoom:50%;"></p><p style="text-indent:2em">以下是一个控制流图的活性分析示例，由于out集取决于从当前语句离开所到达语句的in集，而对应语句的out集可能还没有计算结束，因此要反复计算in和out集，直到集合不发生改变。由于要反复进行计算，尽管应该按照从后往前的顺序计算，但实际上从前往后或从后往前都可以，因为整个集合不改变时才停止计算，不会遗漏。</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221207215323478.png" alt="image-20221207215323478" style="zoom: 67%;"></p><p style="text-indent:2em">以上已经给出了求in和out集的方法，求in和out集的目的是求变量的活跃区间。因此此时再来分析以下这两个集合，in表示到该语句仍然活跃的活跃变量，out表示在该语句之后的还保持活跃的活跃变量，所以只要根据变量是否在该语句的in集或out集当中，就可以划分出变量的活跃区间了。</p><h3 id="2-3-优化方法"><a href="#2-3-优化方法" class="headerlink" title="2.3 优化方法"></a>2.3 优化方法</h3><p style="text-indent:2em">中期优化一般分为两步。第一步是<b>程序分析</b>，通过控制流分析，主要的两种方法就是到达定义分析和活性分析。第二步是<b>程序重写</b>，基于程序分析的信息对程序进行重写。接下来就用例子展现程序重写的方法：常量传播，拷贝传播，死代码删除。</p><p>常量传播优化</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221207223634425.png" alt="image-20221207223634425" style="zoom:50%;"></p><p>拷贝传播优化：</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221207223723027.png" alt="image-20221207223723027" style="zoom:50%;"></p><p>死代码删除</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221207223815656.png" alt="image-20221207223815656" style="zoom:50%;"></p><p style="text-indent:2em">其中的死代码删除和前期优化提到过的不可达代码删除是有区别的。不可达代码不会被执行，而死代码是可以执行，但没有意义的代码。</p><h2 id="3-后期优化"><a href="#3-后期优化" class="headerlink" title="3.后期优化"></a>3.后期优化</h2><p style="text-indent:2em">后期优化在生成代码后，在汇编代码级进行优化。后期优化与目标机器相关，和寄存器数量，指令集等都有关系。后期优化的方法有寄存器分配，指令调度，窥孔优化等。这里重点介绍寄存器分配。</p><p style="text-indent:2em">在代码生成时，为了简化代码生成的过程，假设寄存器有无限个，真实的目标机器的寄存器数量是有限的，不同机器的寄存器数量也不一样，例如RISC机器通常有32个寄存器。因此在生成代码后，要进行寄存器分配，重写代码，将使用的多个变量分配到少数物理寄存器中，保证使用的寄存器数量不超过机器的真实寄存器数量。以下是一个寄存器分配的例子：</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221214152905641.png" alt="image-20221214152905641" style="zoom:50%;"></p><p style="text-indent:2em">寄存器分配的主要思路就是让不同时活跃的变量共用一个寄存器，从而减少寄存器数量。一种简单的寄存器分配算法是遇到一个变量就使用一个当前不活跃变量所使用的寄存器，如果分配失败，就把某个变量放回内存，重用他的寄存器。这种方式分配效率很低，程序性能可能很差。在1980年，IBM研究员尝试了使用<b>图着色算法</b>进行寄存器分配，这种方法分配更简单，效果也更好。</p><p style="text-indent:2em">图着色算法分配寄存器的步骤如下：</p><ul><li>计算活性分析</li><li>画出寄存器冲突图(RIG)</li><li>对RIG着色分配寄存器</li><li>将无法分配寄存器的变量溢出到内存</li></ul><p style="text-indent:2em">下面以一个完整的例子说明图着色算法分配寄存器的过程。</p><p><strong>活性分析</strong></p><p style="text-indent:2em">对以下控制流图所示的程序进行活性分析，结果标在图中。</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221214153727676.png" alt="image-20221214153727676" style="zoom:50%;"></p><p><strong>画出寄存器冲突图</strong></p><p style="text-indent:2em">寄存器冲突图是一个无向图，每个节点是一个变量，如果两个变量有同时活跃的情况，添加一条边连接两个变量对应的节点。如果两个变量没有边连接，说明他们可以使用同一个寄存器。</p><p style="text-indent:2em">以上程序的寄存器冲突图如下：</p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221214154125726.png" alt="image-20221214154125726" style="zoom: 50%;"></p><p><strong>对RIG进行图着色分配寄存器</strong></p><p style="text-indent:2em">给每个节点着色，相当于为每个变量分配寄存器。如果一个图可以被k种颜色着色，两个连接的节点颜色不相同，该图为k可着色图。k可着色图的特点是，从图中删除一个边小于k的点，如果删除后的图是k可着色的，那么原图也一定是k可着色的，因为这个删除的点连接的边数小于k，总能找到一种不一样的颜色。根据这个特点，可以使用启发式算法对RIG进行图着色，将着色算法分为两部分：</p><ul><li>删除点<ul><li>选择一个邻居数量小于k个的节点t(暂时假设总能找到)，从RIG中删除t和它所有的边</li><li>把t放在栈顶</li><li>重复上述步骤直到RIG中没有节点</li></ul></li><li>着色<ul><li>从栈顶弹出1个节点</li><li>给该节点选择1种与其邻居都不同的颜色</li><li>重复上述步骤直到栈为空</li></ul></li></ul><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221214160553489.png" alt="image-20221214160553489" style="zoom:50%;"></p><p><img src="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221214161041523.png" alt="image-20221214161041523" style="zoom:50%;"></p><p><strong>将无法分配寄存器的变量溢出</strong></p><p style="text-indent:2em">如果使用以上的着色算法无法找到邻居数量小于k个的节点，就需要溢出变量，将其存放在内存里。方式是选择一个邻居大于等于k的节点f照常入栈，然后进行着色，直到出栈节点为溢出的节点f，先尝试对其进行着色，如果无法着色，就在每次使用节点前插入load指令，在每次定义节点后插入store指令，然后重新计算活性分析，再重新画出RIG图，进行寄存器分配。</p><p style="text-indent:2em">找到可行的图着色方案，可能需要多次溢出，溢出哪个变量很关键，也很难确定，可能的启发式算法有：</p><ul><li>选择与其他变量冲突最多的变量</li><li>选择使用较少的变量</li><li>避免溢出循环内部的变量</li></ul></名词></形容词></名词></名词短语></名词短语></形容词></名词短语></动词短语></名词短语></句子></p>]]></content>
      
      
      <categories>
          
          <category> cs基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题记录V1</title>
      <link href="/2022/09/04/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95V1/"/>
      <url>/2022/09/04/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95V1/</url>
      
        <content type="html"><![CDATA[<p style="text-indent:2em">此前在leetcode按类别刷了一些题，不过时间久了就又忘记了，也没有稳固好自己的算法基础。恰好这学期有算法设计与分析课程，空余时间也比较多，打算好好的刷一些题并好好记录。刷题还是打算按类别刷，记录主要是备注题目情况，重点题也会记录些思路和理解。</p><span id="more"></span><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="1-盛最多水的容器"><a href="#1-盛最多水的容器" class="headerlink" title="1.盛最多水的容器"></a>1.<a herf="https://leetcode.cn/problems/container-with-most-water/">盛最多水的容器</a></h2><p style="text-indent:2em">想得到是双指针，最开始想不清两个指针到底怎么移动。实际上移动时是按照排除当前柱子进行的，两个柱子里面短的柱子如果不变，就不可能有更大的结果了，所以要从短的一边移动，尝试扩大容积。## 2.<a herf="https://leetcode.cn/problems/3sum-closest/">最接近的三数之和</a></p><p style="text-indent:2em">和三数之和是同一道题。一个数遍历，另外两个数用双指针。</p><h2 id="3-下一个排列"><a href="#3-下一个排列" class="headerlink" title="*3.下一个排列"></a>*3.<a herf="https://leetcode.cn/problems/next-permutation/">下一个排列</a></h2><p style="text-indent:2em">想不到怎样从当前排列转换到下一个排列。题解中的从后向前寻找第一个升序对是关键，找的是最后一个可以调整为更大的数字(先升序，此后均为降序)，再把这个数字换为其后大于该数中最小的，并对此后的数字重新排序，得到的就是下一个排列。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i,j,len,tmp;</span><br><span class="line">        len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        j = len<span class="number">-1</span>, i = j<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;=nums[j])&#123;</span><br><span class="line">                i--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=len<span class="number">-1</span>;k&gt;=j;k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[k]&gt;nums[i])&#123;</span><br><span class="line">                    tmp = nums[k];</span><br><span class="line">                    nums[k] = nums[i];</span><br><span class="line">                    nums[i] = tmp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>()+j,nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>## 4.<a herf="https://leetcode.cn/problems/rotate-list/">旋转链表</a></p><p style="text-indent:2em">被各种边界卡了很多遍，但总算是自己完成了。链表需要注意的情况有：</p><ul><li>链表为空。</li><li>长度小于需要的长度(循环/成环)。</li><li>移动步数相关问题先取余，让步数小于长度。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head||k==<span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyhead-&gt;next = head;</span><br><span class="line">        ListNode *p1,*p2,*p3;</span><br><span class="line">        p1 = p2 = dummyhead;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1-&gt;next)&#123;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = dummyhead;</span><br><span class="line">        k = k%len;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">while</span>(k)&#123;</span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">if</span>(p2-&gt;next!=<span class="literal">NULL</span>) p2 = p2-&gt;next; </span><br><span class="line">            <span class="keyword">else</span> p2 = dummyhead-&gt;next;</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">while</span>(p2-&gt;next&amp;&amp;p1-&gt;next)&#123;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1==dummyhead) <span class="keyword">return</span> head;</span><br><span class="line">        p3 = p1-&gt;next;</span><br><span class="line">        p2-&gt;next = dummyhead-&gt;next;</span><br><span class="line">        p1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> p3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-颜色分类"><a href="#5-颜色分类" class="headerlink" title="5.颜色分类"></a>5.<a herf="https://leetcode.cn/problems/sort-colors/">颜色分类</a></h2><p style="text-indent:2em">直接写排序了。实际应该用双指针交换0和2。## 6.<a herf="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">删除排序链表中的重复元素</a></p><p style="text-indent:2em">重复的直接继续遍历到不重复就可以了。本题卡的问题是因为链表操作不熟练。## 7.<a herf="https://leetcode.cn/problems/compare-version-numbers/">分割版本号</a></p><p style="text-indent:2em">    字符串分隔不算难，不过要用双指针达到下面这个优秀题解的简洁优雅还是很值得学习：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">compareVersion</span><span class="params">(string version1, string version2)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>, j = <span class="number">0</span>, num1 = <span class="number">0</span>, num2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len1 = version1.<span class="built_in">length</span>(),len2 = version2.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">while</span>(i&lt;len1 || j&lt;len2)&#123;</span><br><span class="line">        num1 = <span class="number">0</span>, num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;len1 &amp;&amp; version1[i]!=<span class="string">&#x27;.&#x27;</span>) num1 = num1*<span class="number">10</span> + version1[i++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;len2 &amp;&amp; version2[j]!=<span class="string">&#x27;.&#x27;</span>) num2 = num2*<span class="number">10</span> + version2[j++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(num1&gt;num2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num1&lt;num2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        i++,j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>## 8.<a herf="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">两数之和</a></p><p style="text-indent:2em">双指针做的第一个题就是这个题，不知道为什么这里是两数之和II，而且还是中等题。## *9.<a herf="https://leetcode.cn/problems/linked-list-cycle-ii/">环形链表</a></p><p style="text-indent:2em">快慢指针经典题，最好还是多做几次，尤其是分三段abc，对距离和步数的推导。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow,*fast;</span><br><span class="line">        slow = fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">                fast = head;</span><br><span class="line">                <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>## 10.<a herf="https://leetcode.cn/problems/reorder-list/">重排链表</a></p><p style="text-indent:2em">链表操作还是不熟练。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *prev = <span class="literal">nullptr</span>;   </span><br><span class="line">        ListNode *cur = head;   </span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;  </span><br><span class="line">            ListNode* nextTemp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow,*fast,*p1,*p2,*reordered;</span><br><span class="line">        reordered =head;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        slow = head, fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next&amp;&amp;fast-&gt;next-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        fast = <span class="built_in">reverseList</span>(fast);</span><br><span class="line">        p1 = head-&gt;next;</span><br><span class="line">        p2 = fast;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1&amp;&amp;p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                reordered-&gt;next = p1;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                reordered-&gt;next = p2;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = !flag;</span><br><span class="line">            reordered = reordered-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1) reordered-&gt;next = p1;</span><br><span class="line">        <span class="keyword">if</span>(p2) reordered-&gt;next = p2;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="11-排序链表"><a href="#11-排序链表" class="headerlink" title="*11.排序链表"></a>*11.<a herf="https://leetcode.cn/problems/sort-list/">排序链表</a></h2><p style="text-indent:2em">递归归并排序：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        ListNode *dummyhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *p1 = dummyhead;</span><br><span class="line">        <span class="keyword">while</span>(l1&amp;&amp;l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)&#123;</span><br><span class="line">                p1-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p1-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p1-&gt;next = l1?l1:l2;</span><br><span class="line">        <span class="keyword">return</span> dummyhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow,*fast;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> ||head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        slow = head, fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next&amp;&amp;fast-&gt;next-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        slow = <span class="built_in">sortList</span>(head);</span><br><span class="line">        fast = <span class="built_in">sortList</span>(fast);</span><br><span class="line">        head =  <span class="built_in">merge</span>(slow,fast);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p style="text-indent:2em">非递归的归并排序待完成。## 12.<a herf="https://leetcode.cn/problems/rotate-array/">轮转数组</a></p><p style="text-indent:2em">原地完成，每次移动i+k，自己的写法是循环移动，三次反转的想不到。</p><h2 id="13-寻找重复数"><a href="#13-寻找重复数" class="headerlink" title="-13.寻找重复数"></a>-13.<a herf="https://leetcode.cn/problems/find-the-duplicate-number/">寻找重复数</a></h2><p style="text-indent:2em">太抽象了，根本想不到是环形链表。</p><h2 id="14-压缩字符串"><a href="#14-压缩字符串" class="headerlink" title="14.压缩字符串"></a>14.<a herf="https://leetcode.cn/problems/string-compression/">压缩字符串</a></h2><p style="text-indent:2em">没什么问题，就是把计数写进去的方式太笨了，还好计数是在2000内。不过笨办法的好处是比把数字写进去然后再反转要快。</p><h2 id="15-环形数组"><a href="#15-环形数组" class="headerlink" title="*15.环形数组"></a>*15.<a herf="https://leetcode.cn/problems/circular-array-loop/">环形数组</a></h2><p style="text-indent:2em">有了13题，这里很快就能想出来是快慢指针遍历环形链表的思路了，但是不太明白没有符合条件的环(方向不一致和单循环的情况外)什么情况，不知道为什么单次遍历是按照方向是否相同为终止条件的。</p><h2 id="16-供暖器"><a href="#16-供暖器" class="headerlink" title="16.供暖器"></a>16.<a herf="https://leetcode.cn/problems/heaters/">供暖器</a></h2><p style="text-indent:2em">当成模拟去做了，没想到本质。</p><h2 id="17-重拍链表"><a href="#17-重拍链表" class="headerlink" title="17.重拍链表"></a>17.<a herf="https://leetcode.cn/problems/LGjMqU/">重拍链表</a></h2><p style="text-indent:2em">重排链表，再来一次！</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="1-pow-x-n"><a href="#1-pow-x-n" class="headerlink" title="1.pow(x,n)"></a>1.<a herf="https://leetcode.cn/problems/powx-n/">pow(x,n)</a></h2><p style="text-indent:2em">快速幂，注意负指数。</p><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.<a herf="https://leetcode.cn/problems/add-two-numbers/">两数相加</a></h2><h2 id="3-为运算表达式设计优先级"><a href="#3-为运算表达式设计优先级" class="headerlink" title="**3.为运算表达式设计优先级"></a>**3.<a herf="https://leetcode.cn/problems/different-ways-to-add-parentheses/"><a href="https://leetcode.cn/problems/different-ways-to-add-parentheses/">为运算表达式设计优先级</a></a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(string expression)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; left,right;</span><br><span class="line">        <span class="type">int</span> len = expression.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(len==<span class="number">2</span>) res.<span class="built_in">push_back</span>((expression[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+(expression[<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">            <span class="keyword">else</span> res.<span class="built_in">push_back</span>(expression[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(expression[i]==<span class="string">&#x27;+&#x27;</span>||expression[i]==<span class="string">&#x27;-&#x27;</span>||expression[i]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                left = <span class="built_in">diffWaysToCompute</span>(expression.<span class="built_in">substr</span>(<span class="number">0</span>,i));</span><br><span class="line">                right = <span class="built_in">diffWaysToCompute</span>(expression.<span class="built_in">substr</span>(i+<span class="number">1</span>,len-i<span class="number">-1</span>));</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;left.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;right.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(expression[i]==<span class="string">&#x27;+&#x27;</span>) res.<span class="built_in">push_back</span>(left[j]+right[k]);</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(expression[i]==<span class="string">&#x27;-&#x27;</span>) res.<span class="built_in">push_back</span>(left[j]-right[k]);</span><br><span class="line">                        <span class="keyword">else</span> res.<span class="built_in">push_back</span>(left[j]*right[k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-消除游戏"><a href="#4-消除游戏" class="headerlink" title="*4.消除游戏"></a>*4.<a herf="https://leetcode.cn/problems/elimination-game/">消除游戏</a></h2><h2 id="5-字符串解码"><a href="#5-字符串解码" class="headerlink" title="5.字符串解码"></a>5.<a herf="https://leetcode.cn/problems/decode-string/">字符串解码</a></h2><p style="text-indent:2em">没有问题</p><h2 id="6-第K个语法符号"><a href="#6-第K个语法符号" class="headerlink" title="6.第K个语法符号"></a>6.<a herf="https://leetcode.cn/problems/k-th-symbol-in-grammar/"><a href="https://leetcode.cn/problems/k-th-symbol-in-grammar/">第K个语法符号</a></a></h2><p style="text-indent:2em">这道题和上一题的出现一定是在挽救我消失的信心(然后明天的题继续锤我)。</p><h2 id="7-找出第-N-个二进制字符串中的第-K-位"><a href="#7-找出第-N-个二进制字符串中的第-K-位" class="headerlink" title="7.找出第 N 个二进制字符串中的第 K 位"></a>7.<a herf="https://leetcode.cn/problems/find-kth-bit-in-nth-binary-string/"><a href="https://leetcode.cn/problems/find-kth-bit-in-nth-binary-string/">找出第 N 个二进制字符串中的第 K 位</a></a></h2><p style="text-indent:2em">和字符串解码一样。</p><h2 id="8-找出最后的赢家"><a href="#8-找出最后的赢家" class="headerlink" title="**8.找出最后的赢家"></a>**8.<a herf="https://leetcode.cn/problems/find-the-winner-of-the-circular-game/">找出最后的赢家</a></h2><p style="text-indent:2em">约瑟夫环，递归/链表模拟。对于下标的+1还没理解。</p><h2 id="9-二叉搜索树的后续遍历"><a href="#9-二叉搜索树的后续遍历" class="headerlink" title="**9.二叉搜索树的后续遍历"></a>**9.<a herf="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">二叉搜索树的后续遍历</a></h2><p style="text-indent:2em">重点是理解二叉搜索树后续遍历的结果序列的特点。另外本题的递归是从树的整体开始，左节点右节点递归检查。</p><h1 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h1><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="1-不同路径"><a href="#1-不同路径" class="headerlink" title="1.不同路径"></a>1.<a herf="https://leetcode.cn/problems/unique-paths/">不同路径</a></h2><h2 id="2-整数拆分"><a href="#2-整数拆分" class="headerlink" title="*2.整数拆分"></a>*2.<a herf="https://leetcode.cn/problems/integer-break/">整数拆分</a></h2><h2 id="3-不同的二叉搜索树"><a href="#3-不同的二叉搜索树" class="headerlink" title="*3.不同的二叉搜索树"></a>*3.<a herf="https://leetcode.cn/problems/unique-binary-search-trees/">不同的二叉搜索树</a></h2><h2 id="4-0-1背包"><a href="#4-0-1背包" class="headerlink" title="*4.0/1背包"></a>*4.0/1背包</h2><p style="text-indent:2em">二维dp数组的0/1背包如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;weight,vector&lt;<span class="type">int</span>&gt; &amp;value,<span class="type">int</span> bag_weight)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = weight.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//dp表示到第i号物品，重量为j的最大价值</span></span><br><span class="line">    <span class="type">int</span> dp[n][bg_weight+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//dp初始化，当j&gt;=weight[0]，dp[0][j]=value[0]</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=weight[<span class="number">0</span>];j&lt;=bag_weight;j++) dp[<span class="number">0</span>][j]=value[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//更新dp数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=bag_weight;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;weight[i]) dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-weight[i]]+value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n<span class="number">-1</span>][bag_weight]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">二维背包中，第一维物品i要不是直接将上一层拷贝到当前层，要不就是根据上一层的情况更新当前层，这一维是可以去掉的，只要不停更新当前层就可以了。因此0/1背包可以使用一位数组解决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;weight,vector&lt;<span class="type">int</span>&gt; &amp;value,<span class="type">int</span> bag_weight)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = weight.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//dp表示重量为j的背包的最大价值</span></span><br><span class="line">    <span class="type">int</span> dp[bag_weight+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//dp初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="comment">//更新dp</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=bag_weight;j&gt;=weight[i];j--)&#123;</span><br><span class="line">            <span class="comment">//反向遍历，防止一个物品多次放入背包</span></span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-weight[i]]+value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-分割等和子集"><a href="#5-分割等和子集" class="headerlink" title="5.分割等和子集"></a>5.<a herf="https://leetcode.cn/problems/partition-equal-subset-sum/">分割等和子集</a></h2><h2 id="6-最后一块石头的重量"><a href="#6-最后一块石头的重量" class="headerlink" title="6.最后一块石头的重量"></a>6.<a herf="https://leetcode.cn/problems/last-stone-weight-ii/">最后一块石头的重量</a></h2><p style="text-indent:2em">和上题一样，难点在于能不能想到这个问题可以转化为背包问题，对于本题还有一个问题是怎么就等价于两堆石头碰撞，暂时还没能理解。</p><h2 id="7-目标和"><a href="#7-目标和" class="headerlink" title="7.目标和"></a>7.<a herf="https://leetcode.cn/problems/target-sum/">目标和</a></h2><h2 id="8-1和0"><a href="#8-1和0" class="headerlink" title="*8.1和0"></a>*8.<a herf="https://leetcode.cn/problems/ones-and-zeroes/">1和0</a></h2><p style="text-indent:2em">总感觉滚动数组比多维数组更容易想到。到这道题基本上不用套01背包的模版，可以靠题意正常做出来了，只有内层循环反向遍历还是要注意。</p><h2 id="9-零钱兑换II"><a href="#9-零钱兑换II" class="headerlink" title="*9.零钱兑换II"></a>*9.<a herf="https://leetcode.cn/problems/coin-change-2/">零钱兑换II</a></h2><p style="text-indent:2em">完全背包，计算方法数的典型例子。但是零钱兑换是一个组合问题，即1和5，5和1是同一个组合，因此要采用先遍历面值的方式，因为这样在面额为1的遍历中计算dp[6]时，还没有dp[5]中还没有包含一张5的情况。而对于排列问题，就需要采用先遍历容量，内层遍历价值的方式，这样计算dp[6]时，dp[5]里面已经有一张5的情况了，因此1和5，5和1各算作了一种情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dp[amount+<span class="number">1</span>];            <span class="comment">//dp[i]表示总金额i可以有多少种凑成方法</span></span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));     <span class="comment">//初始化，dp[0]=1;</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=coins[i];j&lt;=amount;j++) dp[j]+=dp[j-coins[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="10-组合总和IV"><a href="#10-组合总和IV" class="headerlink" title="10.组合总和IV"></a>10.<a herf="https://leetcode.cn/problems/combination-sum-iv/">组合总和IV</a></h2><p style="text-indent:2em">上一题的组合情况。</p><h2 id="11-零钱兑换"><a href="#11-零钱兑换" class="headerlink" title="11.零钱兑换"></a>11.<a herf="https://leetcode.cn/problems/coin-change/">零钱兑换</a></h2><p style="text-indent:2em">求最少的情况是不需要考虑遍历顺序的，因为总会取最小值。</p><h2 id="12-完全平方和"><a href="#12-完全平方和" class="headerlink" title="12.完全平方和"></a>12.<a herf="https://leetcode.cn/problems/perfect-squares/">完全平方和</a></h2><p style="text-indent:2em">同上。</p><h2 id="13-字符串拆分"><a href="#13-字符串拆分" class="headerlink" title="13.字符串拆分"></a>13.<a herf="https://leetcode.cn/problems/word-break/">字符串拆分</a></h2><p style="text-indent:2em">这题和前面几题不一样，物品变成字符串了，内部的遍历处理不一样，需要注意。</p><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="1-最小花费-彩色绳子"><a href="#1-最小花费-彩色绳子" class="headerlink" title="1.最小花费-彩色绳子"></a>1.<a herf="https://leetcode.cn/problems/minimum-time-to-make-rope-colorful/">最小花费-彩色绳子</a></h2>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统概论笔记</title>
      <link href="/2022/09/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/09/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p style="text-indent:2em">数据库系统概论(王珊 萨师煊 编著)笔记。</p><h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="1-数据库系统概述"><a href="#1-数据库系统概述" class="headerlink" title="1.数据库系统概述"></a>1.数据库系统概述</h2><h3 id="1-1数据库的4个基本概念"><a href="#1-1数据库的4个基本概念" class="headerlink" title="1.1数据库的4个基本概念"></a>1.1数据库的4个基本概念</h3><ul><li>数据：描述事物的符号记录称为数据。数据的含义称为数据的语义，数据与其语义是不可分的。</li><li>数据库：<strong>长期存储在计算机内、有组织的、可共享的</strong>大量数据的集合。数据库中的数据按一定的数据模型组织、描述和存储，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享。</li><li>数据库管理系统(DBMS)：科学组织和存储数据，高效获取和维护数据。主要有以下功能：<ul><li>数据定义功能</li><li>数据组织、存储和管理</li><li>数据操纵功能</li><li>数据库的事务管理和运行管理</li><li>数据库的建立和维护功能</li><li>其他功能</li></ul></li><li>数据库系统(DBS)：由数据库、数据库管理系统、应用程序和数据库管理员组成的存储、管理、处理和维护数据的系统。</li></ul><span id="more"></span><h3 id="1-2数据管理技术的产生和发展"><a href="#1-2数据管理技术的产生和发展" class="headerlink" title="1.2数据管理技术的产生和发展"></a>1.2数据管理技术的产生和发展</h3><ul><li>人工管理阶段-&gt;文件系统阶段-&gt;数据库系统阶段。</li><li>从文件系统到数据库系统标志着数据管理技术的飞跃。</li></ul><h3 id="1-3数据库系统的特点"><a href="#1-3数据库系统的特点" class="headerlink" title="1.3数据库系统的特点"></a>1.3数据库系统的特点</h3><ul><li>数据结构化：数据库系统实现整体数据的结构化。数据库中的数据不仅针对一个应用，而是面向整个组织或企业。</li><li>数据的共享性高，冗余性低且易扩充。</li><li>数据独立性高：数据独立性包括物理独立性和逻辑独立性。<ul><li>物理独立性是指用户的应用程序与数据库中的物理存储是相互独立的。</li><li>逻辑独立性是指用户的应用程序与数据库的逻辑结构是相互独立的。</li></ul></li><li>数据由数据库管理系统统一管理和控制：数据库的共享是并发的，为了保证数据一致性，数据库管理系统还必须提供以下几方面的数据控制功能：<ul><li>数据的安全性保护：防止不合法使用造成的数据泄密和破坏。</li><li>数据的完整性检查：控制数据的正确性，有效性和相容性。</li><li>并发控制</li><li>数据库恢复</li></ul></li></ul><h2 id="2-数据模型"><a href="#2-数据模型" class="headerlink" title="2.数据模型"></a>2.数据模型</h2><p style="text-indent:2em">数据模型是数据库系统的核心和基础。包含两类，第一类是概念模型，第二类是逻辑模型和物理模型。</p><ul><li>概念模型：从用户的观点对信息和数据建模，主要用于数据库设计。</li><li>逻辑模型：从计算机系统的观点对数据建模，主要用于数据库管理系统的实现。</li><li>物理模型：描述数据在系统内部的表示方式和存取方法。</li></ul><h3 id="2-1-概念模型"><a href="#2-1-概念模型" class="headerlink" title="2.1 概念模型"></a>2.1 概念模型</h3><ul><li>概念模型：对信息建模。概念模型是认识抽象到数据库管理系统支持的数据模型的一个中间层次。以下是概念模型中的一些术语：<ul><li>实体：客观存在并可相互区别的实物称为实体。</li><li>属性：实体所具有的某一特性。</li><li>码(key)：唯一标识实体的属性集称为码。</li><li>实体型：用实体名和属性名集合来抽象和刻画同类实体。例如：学生(学号，姓名，性别，院系)。</li><li>实体集：同一类型实体的集合称为实体集。</li><li>联系：实体之间的联系通常是指不同实体集之间的联系。有一对一，一对多和多对多等多种类型。</li></ul></li><li>概念模型的一种表示方法：实体-联系方法(E-R方法)，见第7章。</li></ul><h3 id="2-2-数据模型的组成要素"><a href="#2-2-数据模型的组成要素" class="headerlink" title="*2.2 数据模型的组成要素"></a>*2.2 数据模型的组成要素</h3><ul><li>数据结构：描述数据库的组成对象以及对象之间的联系。</li><li>数据操作：对数据库中各种对象的实例允许执行的操作的合集，包括操作及有关的操作规则。</li><li>完整性约束：一组完整性规则。</li></ul><h3 id="2-3-常用的数据模型"><a href="#2-3-常用的数据模型" class="headerlink" title="2.3 常用的数据模型"></a>2.3 常用的数据模型</h3><p><strong>层次模型</strong></p><ul><li>数据库中满足下面两个条件的基本层次联系的集合为层次模型：<ul><li>有且只有一个结点没有双亲结点，称为根结点。</li><li>根以外的其他结点只有一个双亲结点。</li></ul></li><li>数据操纵主要为查询，插入，删除，更新。操作要满足层次模型的完整性约束条件。</li><li>层次模型的优点：<ul><li>数据结构简单清晰。</li><li>查询效率高(因为联系用有向边表示)。</li><li>提供了良好的完整性支持。</li></ul></li><li>层次模型的缺点：<ul><li>现实中很多联系是非层次性的。</li><li>一个结点有多个双亲结点，就只能引入冗余数据，应用程序编写复杂。</li><li>查询子女结点必须通过双亲结点。</li><li>结构严密，层次命令趋于程序化。</li></ul></li></ul><p><strong>网状模型</strong></p><ul><li>数据库中满足下面两个条件的基本层次联系的集合为网状模型：<ul><li>允许一个以上的结点无双亲。</li><li>一个结点可以有多于一个的双亲。</li></ul></li><li>具体的网状数据库系统对数据操纵都加了一些限制，提供了一定的完整性约束。</li><li>网状模型的优点：<ul><li>能够更为直接的描述现实世界。</li><li>具有良好的性能，存储效率较高。</li></ul></li><li>网状模型的缺点：<ul><li>结构比较复杂，不利于最终用户掌握。</li><li>DDL，DML复杂，并且要嵌入一种高级语言中，不容易掌握和使用。</li><li>记录之间的联系通过存取路径实现，访问数据时必须选择适当的存取路径，用户必须了解系统结构的细节。</li></ul></li></ul><p><strong>关系模型</strong></p><p style="text-indent:2em">关系模型由一组关系组成，每个关系的数据结构是一张规范化的二维表。</p><ul><li>关系模型的术语：<ul><li>关系：对应一张表</li><li>元组：表中的一行</li><li>属性：列</li><li>码：唯一确定一个元组</li><li>域：属性的取值范围</li><li>分量：元组中的一个属性值</li><li>关系模式：对关系的描述一般为：关系名（属性1，属性2…）</li></ul></li><li>关系模型要求关系必须是规范化的，每一个分量必须是一个不可分的数据项。</li><li>关系模型的优点：<ul><li>建立在严格数学概念上。</li><li>概念单一，结构简单清晰。</li><li>关系模型存取路径透明，有更高的数据独立性，更好的安全保密性。</li></ul></li></ul><p style="text-indent:2em">其他相关内容见第二章。</p><h2 id="3-数据库系统的结构-三级模式结构"><a href="#3-数据库系统的结构-三级模式结构" class="headerlink" title="*3.数据库系统的结构(三级模式结构)"></a>*3.数据库系统的结构(三级模式结构)</h2><ul><li>模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。数据库管理系统提供模式数据定义语言(DDL)来严格定义模式。</li><li>外模式：数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</li><li>内模式：数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。</li><li>为了实现以上三个抽象层次的联系和转换，数据库管理系统在三级模式之间提供了两层映像：外模式/模式映像和模式/内模式映像。<ul><li>外模式/模式映像：定义了外模式与模式之间的对应关系。</li><li>模式/内模式映像：定义了数据全局逻辑结构和存储结构之间的关系。</li></ul></li><li>数据库模式即全局逻辑结构是数据库的中心与关键，独立于数据库的其他层次。</li><li>当模式改变时，修改映像使外模式不变，这保证了<b>数据与程序的逻辑独立性</b>。当存储结构(内模式)改变时，修改映像使模式保持不变，这保证了<b>数据与程序的物理独立性</b>。</li></ul><h1 id="第二章-关系数据库"><a href="#第二章-关系数据库" class="headerlink" title="第二章 关系数据库"></a>第二章 关系数据库</h1><h2 id="1-关系数据结构及形式化定义"><a href="#1-关系数据结构及形式化定义" class="headerlink" title="1.关系数据结构及形式化定义"></a>1.关系数据结构及形式化定义</h2><h3 id="1-1关系"><a href="#1-1关系" class="headerlink" title="1.1关系"></a>1.1关系</h3><p style="text-indent:2em">以下是集合论角度下关系数据结构的形式化定义。- 域：一组具有相同数据类型的值的集合。- 笛卡尔积：域上的一种集合运算。  - 笛卡尔积中的每一个元素叫做一个n元组，元组中每个值叫做一个分量。  - 一个域允许的不同取值个数称为这个域的基数。- 域D1，D2，D3......的子集叫做在域D1，D2...上的关系，表示为R(D1，D2，...，D3)，R表示关系的名字，n是关系的目或度。n=1时为单元关系，n=2时为二元关系。- **若关系中的某一属性组的值能唯一标识一个元组，而其子集不能，则该属性组为候选码。**- 若一个关系有多个候选码，则选定其中一个为主码。- <font color="red">候选码</font>的诸属性称为主属性。其他属性为非主属性。- 最极端的情况下，所有属性为关系模式的候选码，称为全码。- 关系可以有三种类型：基本关系，查询表和视图表。- 基本关系具有以下六条性质：  - 列是同质的。  - 不同的列可出自同一个域。  - 列可交换。  - 元组候选码不能取相同值。  - 行可交换。  - 分量必须是原子的，每一个分量必须是不可分的数据项。### 1.2关系模式</p><p style="text-indent:2em">关系的描述称为关系模式。可以形式化表示为R(U，D，DOM，F)。通常简记为R(U)。关系模式是型，关系是值；关系模式是静态的，关系是动态的，变化的；关系是关系模式在某一时刻的状态或内容。关系和关系模式常统称为关系，根据上下文进行区分。</p><ul><li>R：关系名</li><li>U：属性名集合</li><li>DOM：属性来自的域</li><li>F：属性间数据的依赖关系集合</li></ul><h2 id="2-关系操作"><a href="#2-关系操作" class="headerlink" title="2.关系操作"></a>2.关系操作</h2><h3 id="2-1基本的关系操作"><a href="#2-1基本的关系操作" class="headerlink" title="2.1基本的关系操作"></a>2.1基本的关系操作</h3><p style="text-indent:2em">五种基本的关系操作：<font color="red">选择、投影、并、差、笛卡尔积</font>。其他操作如连接，除，交可用基本操作定义和导出。</p><h3 id="2-2关系数据语言分类"><a href="#2-2关系数据语言分类" class="headerlink" title="2.2关系数据语言分类"></a>2.2关系数据语言分类</h3><ul><li>关系代数语言(ISBL)</li><li>关系演算语言<ul><li>元组关系演算语言(ALPHA)</li><li>域关系演算语言(QBE)</li></ul></li><li>具有关系代数和关系演算双重特点的语言(SQL)</li></ul><h2 id="3-关系的完整性"><a href="#3-关系的完整性" class="headerlink" title="3.关系的完整性"></a>3.关系的完整性</h2><ul><li>实体完整性：主属性不能取空值</li><li>参照完整性：F是基本关系的一个或一组属性，但不是R的码，Ks是基本关系S的主码，如果F与Ks对应，F是R的外码，并称R为参照关系，S为被参照关系。R和S不一定不同。<ul><li>一个关系的属性为另一个关系的主码，则这个属性是这个关系的外码，这个关系为参照关系。</li><li>参照完整性规则：外码的取值或者为空，或者为被参照关系的某个元组的主码值。</li></ul></li><li>用户定义的完整性</li></ul><h2 id="4-关系代数"><a href="#4-关系代数" class="headerlink" title="4.关系代数"></a>4.关系代数</h2><p style="text-indent:2em">练习：</p><p>​        <a href="https://blog.csdn.net/qq_45978890/article/details/114177921">https://blog.csdn.net/qq_45978890/article/details/114177921</a></p><h1 id="第三章-关系数据库标准语言SQL"><a href="#第三章-关系数据库标准语言SQL" class="headerlink" title="第三章 关系数据库标准语言SQL"></a>第三章 关系数据库标准语言SQL</h1><h2 id="1-数据定义"><a href="#1-数据定义" class="headerlink" title="1.数据定义"></a>1.数据定义</h2><div class="table-container"><table><thead><tr><th>操作对象</th><th>创建</th><th>删除</th><th>修改</th></tr></thead><tbody><tr><td>模式</td><td>CREATE SCHEMA</td><td>DROP SCHEMA</td><td></td></tr><tr><td>表</td><td>CREATE TABLE</td><td>DROP TABLE</td><td>ALTER TABLE</td></tr><tr><td>视图</td><td>CREATE VIEW</td><td>DROP VIEW</td><td></td></tr><tr><td>索引</td><td>CREATE INDEX</td><td>DROP INDEX</td><td>ALTER INDEX</td></tr></tbody></table></div><h3 id="1-1模式定义和删除"><a href="#1-1模式定义和删除" class="headerlink" title="1.1模式定义和删除"></a>1.1模式定义和删除</h3><p style="text-indent:2em">模式定义语句如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SCHEMA <span class="operator">&lt;</span>模式名<span class="operator">&gt;</span> <span class="keyword">AUTHORIZATION</span> <span class="operator">&lt;</span>用户名<span class="operator">&gt;</span> [<span class="operator">&lt;</span>表定义子句<span class="operator">&gt;</span><span class="operator">|</span><span class="operator">&lt;</span>视图定义子句<span class="operator">&gt;</span><span class="operator">|</span><span class="operator">&lt;</span>授权定义子句<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure></p><p style="text-indent:2em">删除模式语句如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> SCHEMA <span class="operator">&lt;</span>模式名<span class="operator">&gt;</span><span class="operator">&lt;</span>CASCADE<span class="operator">|</span>RESTRICT<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>### 1.2基本表的定义和修改**表的定义**</p><p style="text-indent:2em">定义基本表：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>[列级完整性约束条件])</span><br></pre></td></tr></table></figure></p><p style="text-indent:2em">例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*建立一个学生表*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student(</span><br><span class="line">Sno <span class="type">CHAR</span>(<span class="number">9</span>)<span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    Sname <span class="type">CHAR</span>(<span class="number">20</span>)<span class="keyword">UNIQUE</span>,</span><br><span class="line">    Ssex <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">    Sage <span class="type">SMALLINT</span>,</span><br><span class="line">    Sdept <span class="type">CHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">/*建立一个课程表*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Course(</span><br><span class="line">Cno <span class="type">CHAR</span>(<span class="number">4</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    Cname <span class="type">CHAR</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    Cpno <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">    Ccredit <span class="type">SMALLINT</span>,</span><br><span class="line">    <span class="comment">/*表级完整性约束条件*/</span></span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (Cpno) <span class="keyword">REFERENCES</span> Course(Cno)</span><br><span class="line">);</span><br><span class="line"><span class="comment">/*建立学生选课表SC*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC(</span><br><span class="line">Sno <span class="type">CHAR</span>(<span class="number">9</span>),</span><br><span class="line">    Cno <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">    Grade <span class="type">SMALLINT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(Sno,Cno),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY(Sno) <span class="keyword">REFERENCES</span> Student(Sno),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY(Cno) <span class="keyword">REFERENCES</span> Cource(Cno)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p style="text-indent:2em">表中的每一个属性都来自一个域，域的概念用数据类型实现，以下是常用的几种数据类型：| 数据类型                      | 含义                         || ----------------------------- | ---------------------------- || CHAR(N),CHARACTER(N)          | 定长字符串                   || VARCHAR(N),CHARACTERVARING(N) | 最大长度为n的字符串          || CLOB                          | 字符串大对象                 || BLOB                          | 二进制大对象                 || INT,INTEGER                   | 长整数                       || SMALLINT                      | 短整数                       || BIGINT                        | 大整数                       || NUMERIC(P,D)                  | 定点数，p位数，小数点后有d位 || DECIMAL(P,D),DEC(P,D)         | 同上                         || REAL                          | 单精度浮点                   || DOUBLE PRECISION              | 双精度浮点                   || FLOAT(N)                      | 可选精度浮点                 || BOOLEAN                       | 逻辑布尔量                   || DATE                          | 日期，YYYY-MM-DD             || TIME                          | 时间，HH:MM:SS               || TIMESTAMP                     | 时间戳类型                   || INTERVAL                      | 时间间隔类型                 |</p><p style="text-indent:2em">每一个表都属于一种模式，使用以下方法可以定义基本表所属的模式：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TEST.Student(...);</span><br></pre></td></tr></table></figure>**表的修改**</p><p style="text-indent:2em">修改基本表的格式为：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span><span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">ADD</span>[<span class="keyword">COLUMN</span>]<span class="operator">&lt;</span>新列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>[完整性约束]]</span><br><span class="line">[<span class="keyword">ADD</span><span class="operator">&lt;</span>表级完整性约束<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">DROP</span> [<span class="keyword">COLUMN</span>]<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>[CASCADE<span class="operator">|</span>RESTRICT]]</span><br><span class="line">[<span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span><span class="operator">&lt;</span>完整性约束名<span class="operator">&gt;</span>[RESTRICT<span class="operator">|</span>CASCADE]]</span><br><span class="line">[<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span><span class="operator">&lt;</span>列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure></p><p style="text-indent:2em">例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student <span class="keyword">ADD</span> S_entrance <span class="type">DATE</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> Sage <span class="type">INT</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Course <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span>(Cname);</span><br></pre></td></tr></table></figure>### 1.3建立索引</p><p style="text-indent:2em">建立索引是加快查询速度的有效手段。建立索引的一般格式为：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>][CLUSTER] INDEX<span class="operator">&lt;</span>索引名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>[<span class="operator">&lt;</span>次序<span class="operator">&gt;</span>][,<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>[次序]]...)</span><br></pre></td></tr></table></figure>- UNIQUE表示索引的每一个索引值只对应唯一的数据记录。- CLUSTER表示聚簇索引。- 次序可选为ASC升序或DESC降序，默认为升序ASC<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX Stusno <span class="keyword">ON</span> Student(Sno);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX Cousno <span class="keyword">ON</span> Cource(Cno);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX SCno <span class="keyword">ON</span> SC(Sno <span class="keyword">ASC</span>,Cno <span class="keyword">DESC</span>);</span><br></pre></td></tr></table></figure>## 2.数据查询</p><p style="text-indent:2em">基本查询格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br></pre></td></tr></table></figure><h3 id="2-1-单表查询"><a href="#2-1-单表查询" class="headerlink" title="2.1 单表查询"></a>2.1 单表查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#基本列查询</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">#去除重复元素</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">#查询满足条件的元组</span><br><span class="line"><span class="keyword">WHERE</span> ... <span class="keyword">BETWEEN</span> ... <span class="keyword">AND</span> ...;</span><br><span class="line"><span class="keyword">WHERE</span> ... <span class="keyword">IN</span> ();</span><br><span class="line"><span class="keyword">WHERE</span> ... <span class="keyword">LIKE</span> <span class="string">&#x27;_*_A%&#x27;</span> <span class="keyword">ESCAPE</span> <span class="string">&#x27;*&#x27;</span>;#_表示单字符，<span class="operator">%</span>表示任意长度字符，<span class="keyword">ESCAPE</span>表示换码字符</span><br><span class="line"><span class="keyword">WHERE</span> ... <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line">#<span class="keyword">ORDER</span> <span class="keyword">BY</span>子句</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ... <span class="keyword">DESC</span><span class="operator">/</span><span class="keyword">ASC</span></span><br><span class="line">#限制条数</span><br><span class="line">LIMIT <span class="number">0</span>,<span class="number">2</span></span><br><span class="line"></span><br><span class="line">#聚集函数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> STUDENT;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> SNO)</span><br><span class="line"><span class="keyword">FROM</span> SC;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(GRADE)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> CNO<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(GRADE)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> CNO<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">聚集函数遇到空值时除COUNT(*)外，都直接跳过空值。</span></span><br><span class="line"><span class="comment">WHERE语句不可以用聚集函数作为条件表达式，聚集函数只能用于SELECT和GROUP BY中的HAVING子句</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#<span class="keyword">GROUP</span> <span class="keyword">BY</span>子句</span><br><span class="line"><span class="keyword">SELECT</span> CNO,<span class="built_in">COUNT</span>(SNO)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> CNO;</span><br><span class="line"><span class="keyword">SELECT</span> SNO</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> SNO</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">3</span>;</span><br><span class="line"><span class="keyword">SELECT</span> SNO,<span class="built_in">AVG</span>(GRADE)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> SNO</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(GRADE<span class="operator">&gt;=</span><span class="number">90</span>);</span><br></pre></td></tr></table></figure><h3 id="2-2-连接查询"><a href="#2-2-连接查询" class="headerlink" title="2.2 连接查询"></a>2.2 连接查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 连接</span><br><span class="line"><span class="keyword">SELECT</span> student.sno,sname</span><br><span class="line"><span class="keyword">FROM</span> student,sc</span><br><span class="line"><span class="keyword">WHERE</span> student.sno<span class="operator">=</span>sc.sno <span class="keyword">AND</span></span><br><span class="line">sc.cno<span class="operator">=</span><span class="string">&#x27;2&#x27;</span> <span class="keyword">AND</span> sc.grade<span class="operator">&gt;</span><span class="number">90</span>;</span><br><span class="line"># 自然连接(把目标列中重复的属性去掉)，方式同上</span><br><span class="line"># 自身连接，需要为表起别名</span><br><span class="line"><span class="keyword">SELECT</span> first.cno,seconde.cpno</span><br><span class="line"><span class="keyword">FROM</span> course <span class="keyword">first</span>,course <span class="keyword">second</span></span><br><span class="line"><span class="keyword">WHERE</span> first.cpno<span class="operator">=</span>second.cno;</span><br><span class="line"># 外连接，把表中的悬浮元组保存在结果关系中</span><br><span class="line"><span class="keyword">SELECT</span> student.sno,sname,ssex,sage,sdept,cno,grade</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> sc <span class="keyword">ON</span> (student.sno<span class="operator">=</span>sc.sno)</span><br><span class="line"># 多表连接和以上类似</span><br></pre></td></tr></table></figure><h3 id="2-3-嵌套查询"><a href="#2-3-嵌套查询" class="headerlink" title="2.3 嵌套查询"></a>2.3 嵌套查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># 不相关子查询</span><br><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> dept <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line">        <span class="keyword">SELECT</span> dept </span><br><span class="line">        <span class="keyword">FROM</span> student</span><br><span class="line">        <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;刘晨&#x27;</span></span><br><span class="line">    );</span><br><span class="line"># 相关子查询</span><br><span class="line"><span class="keyword">SELECT</span> sno,cno</span><br><span class="line"><span class="keyword">FROM</span> SC x</span><br><span class="line"><span class="keyword">WHERE</span> Grade <span class="operator">&gt;=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(Grade)</span><br><span class="line">               <span class="keyword">FROM</span> SC y</span><br><span class="line">    <span class="keyword">WHERE</span> y.sno<span class="operator">=</span>x.sno</span><br><span class="line">               );</span><br><span class="line"># <span class="keyword">ANY</span>(<span class="keyword">SOME</span>)<span class="operator">/</span><span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> name,age</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> age<span class="operator">&lt;</span><span class="keyword">ALL</span></span><br><span class="line">(</span><br><span class="line">        <span class="keyword">SELECT</span> age</span><br><span class="line">        <span class="keyword">FROM</span> student</span><br><span class="line">        <span class="keyword">WHERE</span> dept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">AND</span> dept<span class="operator">!=</span><span class="string">&#x27;CS&#x27;</span>;</span><br><span class="line"># EXIST</span><br><span class="line"><span class="keyword">SELECT</span> name </span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">        <span class="keyword">FROM</span> SC</span><br><span class="line">        <span class="keyword">WHERE</span> sno<span class="operator">=</span>student.sno <span class="keyword">AND</span> cno<span class="operator">=</span><span class="string">&#x27;1&#x27;</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h3 id="2-4-集合查询"><a href="#2-4-集合查询" class="headerlink" title="2.4 集合查询"></a>2.4 集合查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> dept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span> (<span class="keyword">UNION</span> <span class="keyword">ALL</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> age<span class="operator">&lt;=</span><span class="number">19</span>;</span><br><span class="line"># <span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> dept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> age<span class="operator">&lt;=</span><span class="number">19</span>;</span><br><span class="line"># <span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> dept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> age<span class="operator">&lt;=</span><span class="number">19</span>;</span><br></pre></td></tr></table></figure><h2 id="3-数据更新"><a href="#3-数据更新" class="headerlink" title="3.数据更新"></a>3.数据更新</h2><h3 id="3-1-插入"><a href="#3-1-插入" class="headerlink" title="3.1 插入"></a>3.1 插入</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 插入元组</span><br><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> student(sno,sname,ssex,sdept,sage)#可以不指出属性名，但<span class="keyword">VALUE</span>要保持顺序</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;201215128&#x27;</span>,<span class="string">&#x27;陈东&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;IS&#x27;</span>,<span class="number">18</span>);  #未给出的列将自动赋空值</span><br><span class="line"># 插入子查询结果</span><br><span class="line">CREAT <span class="keyword">TABLE</span> DEPT_AGE</span><br><span class="line">(SDEPT <span class="type">CHAR</span>(<span class="number">15</span>)</span><br><span class="line">     AVG_AGE <span class="type">SMALLINT</span>);</span><br><span class="line"><span class="keyword">INSERT</span> DEPT_AGE(SDEPT,AVG_AGE)</span><br><span class="line"><span class="keyword">SELECT</span> SDEPT,<span class="built_in">AVG</span>(SAGE)</span><br><span class="line"><span class="keyword">FROM</span> STUDENT</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> SDEPT;</span><br></pre></td></tr></table></figure><h3 id="3-2-修改数据"><a href="#3-2-修改数据" class="headerlink" title="3.2 修改数据"></a>3.2 修改数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 修改一个元组的值</span><br><span class="line"><span class="keyword">UPDATE</span> student</span><br><span class="line"><span class="keyword">SET</span> sage<span class="operator">=</span><span class="number">22</span></span><br><span class="line"><span class="keyword">WHERE</span> sno<span class="operator">=</span><span class="string">&#x27;201215121&#x27;</span>;</span><br><span class="line"># 修改多个元组的值</span><br><span class="line"><span class="keyword">UPDATE</span> student</span><br><span class="line"><span class="keyword">SET</span> sage<span class="operator">=</span>sage<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line"># 带子查询的修改语句</span><br><span class="line"><span class="keyword">UPDATE</span> SC</span><br><span class="line"><span class="keyword">SET</span> grade<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">WHERE</span> sno <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> sno</span><br><span class="line">     <span class="keyword">FROM</span> student</span><br><span class="line">     <span class="keyword">WHERE</span> sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="3-3-删除数据"><a href="#3-3-删除数据" class="headerlink" title="3.3 删除数据"></a>3.3 删除数据</h3><p style="text-indent:2em">使用DELETE语句进行删除，方式与修改数据的方式相同。</p><h2 id="4-空值的处理"><a href="#4-空值的处理" class="headerlink" title="4.空值的处理"></a>4.空值的处理</h2><p style="text-indent:2em">空值是‘不知道’，‘不确定’，‘不存在’的值。在插入元组时，未指定的属性将为空。空值通过IS NULL和IS NOT NULL来判断。属性定义中有NOT NULL约束条件的不能取空值，加了UNIQUE限制的属性不能取空值，码属性不能取空值。空值与另一个值的算数运算结果为空值，与另一个值的比较运算结果为UNKNOWN。在查询语句中，只有使WHERE和HAVING子句中的选择条件为<b>TRUE</b>的元组才被选出作为结果。</p><h2 id="5-视图"><a href="#5-视图" class="headerlink" title="5.视图"></a>5.视图</h2><h3 id="5-1-定义与删除视图"><a href="#5-1-定义与删除视图" class="headerlink" title="5.1 定义与删除视图"></a>5.1 定义与删除视图</h3><p style="text-indent:2em">CREAT VIEW命令用于建立视图。该语句将视图的定义存入数据字典，并不执行其中的SELECT语句，只在对视图查询时，才按视图的定义从基本表中将数据查出。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 建立视图，省略属性列名</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_Student</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> sno,sname,sage</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> sdept<span class="operator">=</span><span class="string">&#x27;IS&#x27;</span>;</span><br><span class="line"># 建立视图，并要求进行修改和插入操作时仍保证该视图满足<span class="keyword">SELECT</span>的条件</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_Student</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> sno,sname,sage</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> sdept<span class="operator">=</span><span class="string">&#x27;IS&#x27;</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION</span><br></pre></td></tr></table></figure><p style="text-indent:2em">若视图从单个基本表导出，只去掉了某些行列，保留了主码，则称这类视图为<b>行列子集视图</b>。</p><p style="text-indent:2em">视图不仅可以建立在一个或多个表上，也可以建立在一个或多个定义好的视图上。还可以用带有聚集函数和GROUP BY的子句查询来定义视图，这种视图称为分组视图。</p><p style="text-indent:2em">删除视图使用DROP VIEW语句。删除后视图的定义将从数据字典中删除。如果基本表删除了，视图将无法使用，但定义还在数据字典中，需要使用DROP VIEW删除。</p><h3 id="5-2-查询视图"><a href="#5-2-查询视图" class="headerlink" title="5.2 查询视图"></a>5.2 查询视图</h3><p style="text-indent:2em">视图定义后就可以像基本表一样查询了。如果查询的视图存在，则从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询，再执行修正的查询，这一转换过程称为视图消解。</p><h3 id="5-3-更新视图"><a href="#5-3-更新视图" class="headerlink" title="5.3 更新视图"></a>5.3 更新视图</h3><p style="text-indent:2em">视图的更新与查询类似，最终要转换为对基本表的更新，也需要进行视图消解。需要注意的是，有些事图是不可更新的，还有一些视图则是不允许更新的。</p><h1 id="第四章-数据库安全性"><a href="#第四章-数据库安全性" class="headerlink" title="第四章 数据库安全性"></a>第四章 数据库安全性</h1><p style="text-indent:2em">数据库安全性是指防止用户对数据库的不合法使用导致的数据泄露，更改或破坏。</p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p style="text-indent:2em">不安全因素：</p><ul><li>非授权用户对数据库的恶意存取和破坏</li><li>重要或敏感的数据被泄露</li><li>安全环境的脆弱性</li></ul><p style="text-indent:2em">安全标准：</p><ul><li>TCSEC</li><li>CC</li></ul><h2 id="2-数据库安全性控制"><a href="#2-数据库安全性控制" class="headerlink" title="2.数据库安全性控制"></a>2.数据库安全性控制</h2><h3 id="2-1-用户身份鉴别"><a href="#2-1-用户身份鉴别" class="headerlink" title="2.1 用户身份鉴别"></a>2.1 用户身份鉴别</h3><p style="text-indent:2em">常用的用户身份鉴别方法：</p><ul><li>静态口令鉴别</li><li>动态口令鉴别</li><li>生物特征鉴别</li><li>智能卡鉴别</li></ul><h3 id="2-2-存取控制"><a href="#2-2-存取控制" class="headerlink" title="2.2 存取控制"></a>2.2 存取控制</h3><p style="text-indent:2em">存取控制机制主要包括<b>定义用户权限</b>和<b>合法权限检查两部分</b>。两类根据数据库安全等级所支持的存取控制为：</p><ul><li>自主存取控制DAC(C1级安全)</li><li>强制存取控制MAC(B1级安全)</li></ul><h3 id="2-3-自主存取控制方法"><a href="#2-3-自主存取控制方法" class="headerlink" title="2.3 自主存取控制方法"></a>2.3 自主存取控制方法</h3><p style="text-indent:2em">自主存取控制方法中，用户对于不同的数据库对象有不同的存取权限，不同用户对同一对象也有不同的权限，用户还可以将自己的存取权限转授给他人。</p><p style="text-indent:2em">自主存取控制主要通过GRANT语句和REVOKE语句实现。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">GRANT</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> STUDENT</span><br><span class="line"><span class="keyword">TO</span> U1</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;# 该用户可以以同样方式授权其他用户</span><br><span class="line"># <span class="keyword">REVOKE</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> STUDENT</span><br><span class="line"><span class="keyword">FROM</span> U1;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">对数据库模式的授权在创建用户时实现，数据库用户有三种权限：CONNECT,RESOURCE,DB。</p><p style="text-indent:2em">数据库还支持对一组与数据库操作相关的权限命名，称为角色。使用CREATE ROLE语句创建，授权和收回权限的方式与对用户的操作相同。</p><p style="text-indent:2em">自主存取控制的缺点是可能存在数据无意识的泄露。因为数据本身并无安全性标记。</p><h3 id="2-4-强制存取控制方法"><a href="#2-4-强制存取控制方法" class="headerlink" title="2.4 强制存取控制方法"></a>2.4 强制存取控制方法</h3><p style="text-indent:2em">强制存取控制方法中，数据库管理系统所管理的全部实体被分为主体和客体。主体包括用户及用户进程，客体包括文件，基本表等。数据库系统为每个主体或客体的实例创建一个敏感度标记。每个数据库对象被标以一定的密级，每一个用户被授予某一个级别的许可证。对于任意一个对象，只有具有合法许可证的用户才可以存取。主体对客体的存取必须遵循以下规则：</p><ul><li>主体许可证级别大于或等于客体密级时，才能读取客体</li><li>主体许可证级别小于或等于客体密级时，才能写客体</li></ul><p style="text-indent:2em">第二条是为了防止恶意降低密级进行数据泄露。</p><h2 id="3-视图机制"><a href="#3-视图机制" class="headerlink" title="3.视图机制"></a>3.视图机制</h2><p style="text-indent:2em">视图由一个或多个基本表导出，是虚表，在数据库中只保存定义。视图可以像基本表一样进行查询和删除，但更改受限制。视图机制可以限制数据对象，把保密数据对无权存取的用户隐藏起来，提供一定程度的安全保护。使用视图可以简化用户的操作；能够使用户以多种角度看待同一数据；对重构数据库提供了一定的逻辑独立性；可以更清晰地表达查询。</p><h2 id="4-审计机制"><a href="#4-审计机制" class="headerlink" title="4.审计机制"></a>4.审计机制</h2><p style="text-indent:2em">审计功能把用户对数据库的所有操作记录下来放入审计日志，审计员可以通过审计日志监控数据库行为，找到非法存取数据的人，时间和内容等。审计机制提供了一种事后安全检查的机制。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AUDIT <span class="keyword">ALTER</span>,<span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">ON</span> SC;</span><br><span class="line">NOAUDIT <span class="keyword">ALTER</span>,<span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">ON</span> SC;</span><br></pre></td></tr></table></figure><h2 id="5-数据加密"><a href="#5-数据加密" class="headerlink" title="5.数据加密"></a>5.数据加密</h2><p style="text-indent:2em">数据加密能有效防止数据库数据在存储和传输中失密。数据加密主要包括存储加密和传输加密。</p><h2 id="6-其他安全性保护"><a href="#6-其他安全性保护" class="headerlink" title="6.其他安全性保护"></a>6.其他安全性保护</h2><p style="text-indent:2em">其他安全性保护包括推理控制，数据库应用中的隐蔽信道和数据隐私保护等技术。</p><h1 id="第五章-数据库完整性"><a href="#第五章-数据库完整性" class="headerlink" title="第五章 数据库完整性"></a>第五章 数据库完整性</h1><p style="text-indent:2em">数据库完整性是指数据的正确性和相容性。为维护数据库的完整性，数据库管理系统必须能够实现以下功能：</p><ul><li>提供定义完整性约束的机制</li><li>提供完整性检查</li><li>进行违约处理</li></ul><h2 id="1-实体完整性"><a href="#1-实体完整性" class="headerlink" title="1.实体完整性"></a>1.实体完整性</h2><p style="text-indent:2em">实体完整性定义：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 列级定义</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">(Sno <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">PRIMARY</span> KEY</span><br><span class="line">    );</span><br><span class="line"># 表级定义</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">(Sno <span class="type">CHAR</span>(<span class="number">9</span>),</span><br><span class="line">     Sname <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">     <span class="keyword">PRIMARY</span> KEY(Sno,Sname)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p style="text-indent:2em">完整性检查中，检查主码值是否唯一，主码的属性是否为空，不唯一或有属性为空就拒绝插入或修改。</p><h2 id="2-参照完整性"><a href="#2-参照完整性" class="headerlink" title="2.参照完整性"></a>2.参照完整性</h2><p style="text-indent:2em">用FOREIGN KEY定义哪些为外码，REFERENCES指明外码参照哪些表的主码。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">(Sno <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     Cno <span class="type">CHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     GRADE <span class="type">SMALLINT</span>,</span><br><span class="line">     PRIMARYKEY(Sno,Cno),</span><br><span class="line">     <span class="keyword">FOREIGN</span> KEY(Sno) <span class="keyword">REFERENCES</span> Student(Sno),</span><br><span class="line">     <span class="keyword">FOREIGN</span> KEY(Cno) <span class="keyword">REFERENCES</span> Cources(Cno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p style="text-indent:2em">破坏参照完整性发生时，系统可以拒绝执行；级联操作(删除或更改所有导致不一致的元组);设置为空值（将导致不一致的元组的属性设为空值）。默认为拒绝执行，可显式进行说明：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">(Sno <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     Cno <span class="type">CHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     GRADE <span class="type">SMALLINT</span>,</span><br><span class="line">     PRIMARYKEY(Sno,Cno),</span><br><span class="line">     <span class="keyword">FOREIGN</span> KEY(Sno) <span class="keyword">REFERENCES</span> Student(Sno)</span><br><span class="line">     <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE</span><br><span class="line">     <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE,</span><br><span class="line">     <span class="keyword">FOREIGN</span> KEY(Cno) <span class="keyword">REFERENCES</span> Cources(Cno)</span><br><span class="line">     <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION</span><br><span class="line">     <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="3-用户定义的完整性"><a href="#3-用户定义的完整性" class="headerlink" title="3.用户定义的完整性"></a>3.用户定义的完整性</h2><p style="text-indent:2em">用户定义属性上的约束条件包括：</p><ul><li>列值非空NOT NULL</li><li>列值唯一UNIQUE</li><li>检查列值是否满足一个条件CHECK</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 属性上的约束条件</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">(Sno <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     Cno <span class="type">CHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     GRADE <span class="type">SMALLINT</span> <span class="keyword">CHECK</span> (GRADE<span class="operator">&gt;=</span><span class="number">0</span> <span class="keyword">AND</span> GRADE<span class="operator">&lt;=</span><span class="number">100</span>),</span><br><span class="line">     PRIMARYKEY(Sno,Cno),</span><br><span class="line">     <span class="keyword">FOREIGN</span> KEY(Sno) <span class="keyword">REFERENCES</span> Student(Sno),</span><br><span class="line">     <span class="keyword">FOREIGN</span> KEY(Cno) <span class="keyword">REFERENCES</span> Cources(Cno)</span><br><span class="line">);</span><br><span class="line"># 元组上的约束条件</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">(Sno <span class="type">CHAR</span>(<span class="number">9</span>),</span><br><span class="line">     Sname <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     Ssex <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">     Sage <span class="type">SMALLINT</span>,</span><br><span class="line">     <span class="keyword">PRIMARY</span> KEY(Sno),</span><br><span class="line">     <span class="keyword">CHECK</span>(Ssex<span class="operator">=</span>‘女’ <span class="keyword">OR</span> Sname <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">&#x27;Ms.%&#x27;</span>)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h2 id="4-完整性约束命名"><a href="#4-完整性约束命名" class="headerlink" title="4.完整性约束命名"></a>4.完整性约束命名</h2><p style="text-indent:2em">为了方便灵活地增加，删除完整性约束条件，可以对完整性约束进行命名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> STUDENT</span><br><span class="line">(Sno <span class="type">CHAR</span>(<span class="number">9</span>),</span><br><span class="line">     Sname <span class="type">CHAR</span>(<span class="number">20</span>)</span><br><span class="line">     <span class="keyword">CONSTRAINT</span> C1 <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     Sage <span class="type">SMALLINT</span></span><br><span class="line">     <span class="keyword">CONSTRAINT</span> C2 <span class="keyword">CHECK</span>(Sage<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">AND</span> Sage<span class="operator">&lt;</span><span class="number">100</span>),</span><br><span class="line">     Ssex <span class="type">CHAR</span>(<span class="number">2</span>)</span><br><span class="line">     <span class="keyword">CONSTRAINT</span> C4 <span class="keyword">CHECK</span> (Ssex <span class="keyword">IN</span> (<span class="string">&#x27;male&#x27;</span>,<span class="string">&#x27;female&#x27;</span>)),</span><br><span class="line">     <span class="keyword">CONSTRAINT</span> StudentKey <span class="keyword">PRIMARY</span> KEY(Sno)</span><br><span class="line">    );</span><br><span class="line"># <span class="keyword">ALTER</span> CONSTRAINTS</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> C1;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> C2 <span class="keyword">CHECK</span>(Sno<span class="operator">&gt;</span><span class="string">&#x27;000000000&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="5-断言"><a href="#5-断言" class="headerlink" title="5.断言"></a>5.断言</h2><p style="text-indent:2em">断言是更具一般性的约束，可以定义涉及多个表或聚集操作的比较复杂的完整性约束。使用CREATE ASSERTION语句来创建断言，且每个断言都有一个名字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 限制数据库课程最多<span class="number">60</span>名学生选修</span><br><span class="line"><span class="keyword">CREATE</span> ASSERTION ASSE_SC_DB_NUM</span><br><span class="line"><span class="keyword">CHECK</span> (<span class="number">60</span><span class="operator">&gt;=</span>(</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line">                <span class="keyword">FROM</span> Course,SC</span><br><span class="line">                <span class="keyword">WHERE</span> SC.CNO<span class="operator">=</span>COURSE.CNO <span class="keyword">AND</span> COURSE.CNAME<span class="operator">=</span>‘数据库’</span><br><span class="line">    )</span><br><span class="line">          );</span><br><span class="line"># 限制每个学期每门课程最多<span class="number">60</span>名学生选修</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SC <span class="keyword">ADD</span> TERM <span class="type">DATE</span>;</span><br><span class="line"><span class="keyword">CREATE</span> ASSERTION ASSE_SC_CNUM2</span><br><span class="line"><span class="keyword">CHECK</span>(</span><br><span class="line">        <span class="number">60</span><span class="operator">&gt;=</span><span class="keyword">ALL</span>(<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> SC <span class="keyword">GROUP</span> <span class="keyword">BY</span> Cno,TERM)</span><br><span class="line">    );</span><br><span class="line"># 删除断言</span><br><span class="line"><span class="keyword">DROP</span> ASSERTION 断言名</span><br></pre></td></tr></table></figure><p style="text-indent:2em">需要注意的是，如果断言很复杂，则系统在检测和维护断言上的开销较高，使用断言时需要注意。</p><h2 id="6-触发器"><a href="#6-触发器" class="headerlink" title="6.触发器"></a>6.触发器</h2><p style="text-indent:2em">触发器是用户定义在关系表上的一类由时间驱动的特殊过程。定义后，触发器将被保存在数据库服务器中，任何用户对表的增、删、查、改操作均由服务器自动激活相应的触发器。触发器类似约束，但更加灵活，可以实施更为复杂的检查和操作。关于触发器有以下几点：</p><ul><li>表的拥有者才可以创建触发器，而且可创建的触发器数量有限。</li><li>触发器只能定义在基本表上，不能定义在视图上。</li><li>触发事件可以是UPDATE/INSERT等的组合，AFTER/BEFORE是触发的时机。</li><li>触发器按照触发间隔可分为行级触发器FOR EACH ROW和语句级触发器FOR EACH STATEMENT。</li><li>触发器被激活时，只有当触发条件为真时才执行。</li></ul><p style="text-indent:2em">触发器的一般格式为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名</span><br><span class="line">BEFORE<span class="operator">|</span>AFTER 触发事件 <span class="keyword">ON</span> 表名</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span><span class="operator">|</span><span class="keyword">OLD</span> <span class="type">ROW</span> <span class="keyword">AS</span> 变量</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span><span class="operator">|</span>STATEMENT</span><br><span class="line"><span class="keyword">WHEN</span> 触发条件 触发动作体</span><br></pre></td></tr></table></figure><p style="text-indent:2em">以下是触发器的几个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 将<span class="keyword">INSERT</span>语句增加的元组数记录到insertlog中</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Student_Count</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> Student</span><br><span class="line"><span class="keyword">REFERENCING</span></span><br><span class="line"><span class="keyword">NEW</span> <span class="keyword">TABLE</span> <span class="keyword">AS</span> DELTA</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> STATEMENT</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> StudentInsertLog(Numbers)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> DELTA;</span><br><span class="line"># 将分数增加<span class="number">10</span><span class="operator">%</span>的操作添加到一个另一个表SC_U</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> SC_T</span><br><span class="line">AFTER <span class="keyword">UPDATE</span> <span class="keyword">OF</span> Grade <span class="keyword">ON</span> SC</span><br><span class="line"><span class="keyword">REFERENCING</span></span><br><span class="line">OLDROW <span class="keyword">AS</span> OldTuple</span><br><span class="line">NEWROW <span class="keyword">AS</span> NewTuple</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (NewTuple.Grade<span class="operator">&gt;=</span><span class="number">1.1</span><span class="operator">*</span>OldTuple.Grade)</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC_U (Sno,Cno,OldGrade,NewGrade)</span><br><span class="line"><span class="keyword">VALUES</span>(OldTuple.Sno,OldTuple.Cno,ldTuple.Grade,NewTuple.Grade);</span><br><span class="line"># 教授的工资不低于<span class="number">4000</span>，低于<span class="number">4000</span>则改为<span class="number">4000</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Insert_Or_Update_Sal</span><br><span class="line">BEFORE <span class="keyword">INSERT</span> <span class="keyword">OR</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> Teacher</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">row</span> <span class="keyword">AS</span> newtuple</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">IF(newtuple.Job<span class="operator">=</span>‘教授’) <span class="keyword">AND</span> newtuple.Sal<span class="operator">&lt;</span><span class="number">4000</span>)</span><br><span class="line"><span class="keyword">THEN</span> newtuple.Sal:<span class="operator">=</span><span class="number">4000</span>;</span><br><span class="line"><span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">一个表上可能有多个触发器，触发器激活时执行顺序是BEFORE触发器、激活触发器的SQL语句，该表上的AFTER触发器。对于同一个表上的多个触发器，遵循涉嫌创建谁先执行的原则，有的数据库管理系统按照触发器名字排序执行。</p><p style="text-indent:2em">删除触发器的语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROP <span class="keyword">TRIGGER</span> 触发器名 <span class="keyword">ON</span> 表名</span><br></pre></td></tr></table></figure><h1 id="第六章-关系数据理论"><a href="#第六章-关系数据理论" class="headerlink" title="第六章 关系数据理论"></a>第六章 关系数据理论</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h2><p style="text-indent:2em">本章主要的内容为如何构造一个好的数据库模式，即应该构造几个关系模式，每个关系由哪些属性组成等。</p><p style="text-indent:2em">作为一个二维表，关系要满足的最基本的要求是每个分量必须是不可分的数据项。满足该条件的关系模式就属于<b>第一范式1NF</b>。</p><p style="text-indent:2em">数据依赖是关系内部属性与属性之间的约束关系，体现数据间的相关联系。数据依赖中最重要的是函数依赖和多值依赖。函数依赖是最为普遍的，但是如果函数依赖存在不好的性质，就会导致插入异常，删除异常，冗余等许多问题。</p><p style="text-indent:2em">函数依赖的一个例子：F={Sno->Sdept，Sdept->Mname，(Sno，Cno)->Grade}。</p><h2 id="2-规范化"><a href="#2-规范化" class="headerlink" title="2.规范化"></a>2.规范化</h2><h3 id="2-1-函数依赖"><a href="#2-1-函数依赖" class="headerlink" title="2.1 函数依赖"></a>2.1 函数依赖</h3><p style="text-indent:2em">函数依赖包括非平凡的函数依赖，平凡的函数依赖(X->X)。若X->Y，X称为函数的决定属性组，也称为决定因素。通常我们只讨论非平凡的函数依赖。</p><p style="text-indent:2em">函数依赖还可以分为完全函数依赖和部分函数依赖。对于完全函数依赖X->Y，Y不依赖于X的真子集，只有选取完整的X，才能选定唯一的Y，例如(Sno，Cno)->Grade。而不完全依赖是指X->Y，X的真子集和Y也能形成依赖关系，即X的真子集就可以确定唯一的Y，例如(Sno，Cno)->Sdept。</p><h3 id="2-2-码"><a href="#2-2-码" class="headerlink" title="2.2 码"></a>2.2 码</h3><p style="text-indent:2em">设K为关系R<U,F>中的属性或属性组，若U完全依赖于K，则K为R的候选码。若候选码多于一个，则其中一个被选定为主码。任何一个候选码中的属性为主属性，否则为非主属性或非码属性。</U,F></p><p style="text-indent:2em">关系R中的属性或属性组X非R的码，为另一个关系模式的码，则X是R的外码。</p><h3 id="2-3-范式"><a href="#2-3-范式" class="headerlink" title="2.3 范式"></a>2.3 范式</h3><p style="text-indent:2em">关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式。一个低一级范式的关系模式通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫做规范化。</p><h3 id="2-4-2NF"><a href="#2-4-2NF" class="headerlink" title="2.4 2NF"></a>2.4 2NF</h3><p style="text-indent:2em">若R为第一范式，且每一个非主属性完全函数依赖于任何一个候选码，则R为第二范式。第二范式保证了关系中的每一个属性，都是可以通过另一个候选码属性确定的，即关系中不存在和候选码无关的属性，这确保了表中只含有与候选码相关的一类信息。</p><h3 id="2-5-3NF"><a href="#2-5-3NF" class="headerlink" title="2.5 3NF"></a>2.5 3NF</h3><p style="text-indent:2em">若R中不存在码X，属性组Y及非主属性Z，使得X->Y,Y->Z成立，Y不完全依赖于X，则关系R满足第三范式。这条范式是指关系中不存在传递依赖，每一个属性都是和主码直接相关的。</p><p style="text-indent:2em">第三范式可以简单表述为：每一个非主属性既不传递依赖于码，也不部分依赖于码。</p><h3 id="2-6-BCNF-修正的第三范式"><a href="#2-6-BCNF-修正的第三范式" class="headerlink" title="2.6 BCNF(修正的第三范式)"></a>2.6 BCNF(修正的第三范式)</h3><p style="text-indent:2em">BCNF在第三范式的基础上，增加了要求：每一个决定因素都包含码。即所有属性都只完全函数依赖于码，不依赖于非码的一组属性。</p><h3 id="2-7-4NF"><a href="#2-7-4NF" class="headerlink" title="2.7 4NF"></a>2.7 4NF</h3><p style="text-indent:2em">4NF消除了属性之间的非平凡且非函数依赖的多值依赖。</p><h2 id="3-Armstrong公理系统"><a href="#3-Armstrong公理系统" class="headerlink" title="3.Armstrong公理系统"></a>3.Armstrong公理系统</h2><p style="text-indent:2em">Armstrong公理系统是讨论函数依赖的一个完备的公理系统，对于关系模式R<U，F>，有以下推理规则：</U，F></p><ul><li>自反律：若Y⊆X⊆U，则X→Y为F所蕴含。</li><li><p>传递律：若X→Y，Y→Z，则X→Z为F所蕴含。</p></li><li><p>增广律：若X→Y，Z⊆U，则XZ→YZ为F所蕴含。</p></li></ul><p style="text-indent:2em">在讨论函数依赖时，需要求出Armstrong公理能推导出的所有函数依赖的集合。因此引入以下定义：</p><ul><li>设F为属性集U上的一组函数依赖，$X_F^+$={A|X→A能由F根据Armstrong公理系统导出}，称其为属性集X关于函数依赖集F的闭包。</li></ul><p style="text-indent:2em">如果函数依赖集F满足一些条件，则F为一个最小依赖集。下面直接给出<font color="red">求解最小依赖集的方法</font>：</p><ul><li>使F中函数依赖的右部仅有一个属性(分解)</li><li>去掉冗余的函数依赖(先去掉X→Y，求X的闭包，若含Y，则X→Y可以去掉，否则保留)</li><li>去掉函数依赖左部冗余的属性(XY→A，求X的闭包，若含A，则X→A，Y可以去掉)</li></ul><h1 id="第七章-数据库设计"><a href="#第七章-数据库设计" class="headerlink" title="第七章 数据库设计"></a>第七章 数据库设计</h1><h2 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1.概述"></a>1.概述</h2><p style="text-indent:2em">数据库设计是指对于一个给定的应用环境，构造优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效存储和管理数据，满足用户应用需求。特点是重视技术、管理、基础数据的收集和整理；结构(数据)设计和行为(处理)设计相结合。数据库设计的基本步骤如下：</p><ul><li>需求分析：通过调查分析，获得用户对数据库的信息要求，处理要求，安全性与完整性要求。</li><li>概念结构设计：产生独立于数据库管理系统的概念模式(E-R图)。</li><li>逻辑结构设计：将E-R图转换为数据模型，如关系模型。并按照用户处理和安全的要求建立必要的视图。</li><li>物理结构设计：根据数据库管理系统特点和处理的需要，进行物理存储安排，建立索引，形成数据库内模式。</li><li>数据库实施</li><li>数据库运行和维护</li></ul><h2 id="2-需求分析"><a href="#2-需求分析" class="headerlink" title="2.需求分析"></a>2.需求分析</h2><ul><li>数据字典：数据字典是通过详细的数据收集和分析后的主要成果。是关于数据库中数据的描述，是元数据。在需求分析阶段建立，在设计过程中不断修改和完善。数据字典通常包含数据流，数据项，数据结构，数据存储和处理过程等。</li></ul><h2 id="3-概念结构设计"><a href="#3-概念结构设计" class="headerlink" title="3.概念结构设计"></a>3.概念结构设计</h2><p style="text-indent:2em">将需求分析得到的用户需求抽象为概念模型的过程就是概念结构设计。概念模型通常用E-R模型来表示和描述。</p><h3 id="3-1-E-R模型"><a href="#3-1-E-R模型" class="headerlink" title="3.1 E-R模型"></a>3.1 E-R模型</h3><p style="text-indent:2em">E-R模型由实体，属性，实体之间的联系等构成。实体型之间的联系包括一对一联系，一对多联系，多对多联系等，多个实体型之间也可以存在联系，单个实体型内也可以存在联系。这些实体与实体之间的联系用E-R图来表示。在E-R图中，对于实体，属性，联系的表示方法如下：</p><ul><li>实体型用矩形表示</li><li>属性用椭圆表示</li><li>联系用菱形表示</li></ul><p style="text-indent:2em">由于一个实体可能存在多个属性，为了表述清晰，可以不把属性在E-R图中画出，而是直接写出，例如：</p><p style="text-indent:2em">实体：</p><p style="text-indent:2em">实体名1(属性1，属性2，属性3...)</p><p style="text-indent:2em">然后再给出E-R图。</p><h3 id="3-2-概念结构设计"><a href="#3-2-概念结构设计" class="headerlink" title="3.2 概念结构设计"></a>3.2 概念结构设计</h3><p style="text-indent:2em">概念结构设计的第一步是对数据进行分类，确定实体，属性，联系。实体与属性划分时，能看作属性的尽量看作属性，并按照两条准则：</p><ul><li>属性不能和其他实体具有联系：例如人事管理系统中，如果职称与工资，补贴无关，就可以视作职工的属性。否则看作一个实体对待更合适。</li><li>作为属性，不能有再需要描述的性质。</li></ul><p style="text-indent:2em">概念结构设计时，通常自顶向下确定需求，自底向上设计概念结构。首先设计各子系统的分E-R图，然后再集成起来，得到全局E-R图。集成过程一般有两步：</p><ul><li>合并：解决各分E-R图之间的冲突，合并分E-R图产生初步E-R图，冲突有以下几种：<ul><li>属性冲突：域或取值单位冲突</li><li>命名冲突</li><li>结构冲突：同一对象有不同的抽象(在不同子系统分别看作实体，属性)，实体间的联系在不同系统中不同，同一实体有不同的属性等。</li></ul></li><li>消除不必要的冗余，设计基本E-R图</li></ul><h2 id="4-逻辑结构设计"><a href="#4-逻辑结构设计" class="headerlink" title="4.逻辑结构设计"></a>4.逻辑结构设计</h2><p style="text-indent:2em">逻辑结构设计的任务是把概念结构设计的基本E-R图转变为与选定数据库管理系统对应的数据模型的逻辑结构。下面以关系模型为例介绍转换过程。</p><p style="text-indent:2em">将E-R图转换为关系模型的逻辑结构。关系模型是一组关系模式的集合，转换实际上就是将E-R图转换为一些关系模式。其中，实体可以直接转换为关系模式，而联系则有以下情况：</p><ul><li>1;1联系可以转换为一个关系模式，也可以与任意一端的关系模式合并。</li><li>1:n联系可以转换为一个关系模式，或与n端关系模式合并。</li><li>m:n或多个实体间的联系可以转换为一个关系模式。</li><li>具有相同码的关系模式可以合并。</li></ul><p style="text-indent:2em">完成转换后，可以对得到的数据模型进行优化，具体的方法是合并与分解，以规范化理论为依据，但不一定要规范化到程度很高，要考虑使用情况。</p><p style="text-indent:2em">得到了全局的逻辑模型后，还应该根据局部应用的需求，为用户设计外模式，外模式使用应符合用户习惯的别名，且应该为不同用户设计不同的外模式，并简化用户对系统的使用。</p><h2 id="5-物理结构设计"><a href="#5-物理结构设计" class="headerlink" title="5.物理结构设计"></a>5.物理结构设计</h2><p style="text-indent:2em">物理结构设计的任务是为给定的逻辑数据模型选取一个最适合应用要求的物理结构。物理设计分为两步：</p><ul><li>确定数据库的物理结构，在关系数据库中主要指存取方法和存储结构</li><li>对物理结构进行评价，重点评价时间和空间效率</li></ul><p style="text-indent:2em">下面简要介绍关系型数据库的物理设计。</p><h3 id="5-1-存取方法选择"><a href="#5-1-存取方法选择" class="headerlink" title="5.1 存取方法选择"></a>5.1 存取方法选择</h3><p style="text-indent:2em">存取方法是快速存取数据库中数据的技术。数据库管理系统一般提供多种存取方法。常用的存取方法为索引方法和聚簇方法。</p><ul><li>B+树索引存取方法：对属性列或属性组建立索引。如果一个属性或属性组经常被查询，连接或作为聚集函数的参数，可以考虑建立索引。维护索引要付出代价，因此索引不是越多越好。</li><li>HASH索引存取方法：如果一个关系的属性主要出现在等值连接条件或等值比较选择条件中，并且关系大小不变，或数据库提供了动态HASH存取方法，则可以选择HASH存取方法。</li><li>聚簇存取方法：将某个属性上有连续或相同值的元组放在连续物理块中称为聚簇。该属性称为<strong>聚簇码</strong>。聚簇可以大大提高按聚簇码查询的效率，但开销也很大，一个关系只能使用一个聚簇码。应该尽量使用稳定的聚簇码，应用应该主要通过聚簇码进行连接或访问，否则聚簇码值总是改变，维护的开销会很大。</li></ul><h3 id="5-2-确定数据库的存储结构"><a href="#5-2-确定数据库的存储结构" class="headerlink" title="5.2 确定数据库的存储结构"></a>5.2 确定数据库的存储结构</h3><p style="text-indent:2em">数据库的存储结构主要指数据的存放位置，包括确定关系，索引，聚簇，日志，备份等的存储安排或存储结构。确定数据的存放位置，应该将数据的易变部分和稳定部分，经常存取和存取频率低的部分分开存放，提高I/O效率，也可以将日志文件和数据库对象放在不同的磁盘上，或是将较大的表放在两个磁盘上，有许多方法可以让存储结构和存放位置有利于数据库的性能。</p><p style="text-indent:2em">关系型数据库管理系统一般都提供了一些系统配置变量和存储分配参数，管理人员可以通过参数对数据库进行物理优化。系统配置变量有很多，例如并发用户数，同时打开的数据库对象数，缓冲区参数，物理块的大小，锁的数目等。</p><h2 id="6-数据库的实施和维护"><a href="#6-数据库的实施和维护" class="headerlink" title="6.数据库的实施和维护"></a>6.数据库的实施和维护</h2><p style="text-indent:2em">数据库设计完成后，就要进行数据库的实施，并且组织数据入库，然后就可以使用数据库应用了。数据库应用程序设计应该和数据库设计同时进行，当数据库设计完成后，就可以载入数据，进行应用程序的调试。数据库试运行时，先从小批量数据调试开始，再逐步增加数据；且开始时数据库系统可能还不稳定，操作人员还不熟悉，要做好数据库的转储和恢复，以免破坏数据库。</p><p style="text-indent:2em">数据库试运行合格后，就可以投入正式运行了，在运行阶段，维护工作主要包括数据库的转储和恢复，数据库的安全性和完整性控制，数据库性能的监督、分析和改造，数据库的重组织与重构造。这里就不一一介绍了。</p><h1 id="第八章-数据库编程"><a href="#第八章-数据库编程" class="headerlink" title="第八章 数据库编程"></a>第八章 数据库编程</h1><p style="text-indent:2em">本章主要介绍的内容是关于数据库编程的，包括嵌入式SQL，过程化SQL，存储过程以及函数。由于不同的数据库实际提供了不同的应用接口，不一定兼容嵌入式SQL，而存储过程以及函数主要在实验中学习，故本章内容不再介绍。</p><h1 id="第九章-关系查询处理和查询优化"><a href="#第九章-关系查询处理和查询优化" class="headerlink" title="第九章 关系查询处理和查询优化"></a>第九章 关系查询处理和查询优化</h1><p style="text-indent:2em">本章介绍关系数据库的<b>查询处理</b>和<b>查询优化</b>技术。首先介绍关系数据库管理系统的查询处理步骤，然后介绍查询优化技术。查询优化一般可分为<b>代数优化</b>和<b>物理优化</b>。代数优化是对关系代数表达式的优化，物理优化则是通过存取路径和底层操作算法的选择进行优化。</p><h2 id="1-关系数据库系统的查询处理"><a href="#1-关系数据库系统的查询处理" class="headerlink" title="1.关系数据库系统的查询处理"></a>1.关系数据库系统的查询处理</h2><p style="text-indent:2em">关系数据库管理系统的查询处理可以分为四个阶段：</p><ul><li>查询分析：对语句进行词法分析和语法分析，并进行检查。</li><li>查询检查：对语句进行语义检查，检查数据字典中是否有语句中的数据对象，用户是否有存取权限，是否是对视图的查询(需要进行消解)，是否违反完整性约束。检查通过后将语句转化为内部表示，即等价的<strong>关系代数表达式</strong>，并用查询树表示。</li><li>查询优化：对查询进行优化。一般包括代数优化和物理优化，代数优化是对关系代数表达式的优化，物理优化则是通过存取路径和底层操作算法的选择进行优化。</li><li>查询执行：由代码生成器生成执行查询的代码，执行后返回结果。</li></ul><h2 id="2-实现查询操作的算法示例"><a href="#2-实现查询操作的算法示例" class="headerlink" title="2.实现查询操作的算法示例"></a>2.实现查询操作的算法示例</h2><h3 id="2-1-选择操作的实现"><a href="#2-1-选择操作的实现" class="headerlink" title="2.1 选择操作的实现"></a>2.1 选择操作的实现</h3><p style="text-indent:2em">简单的选择操作的实现方法如下：</p><ul><li>简单全表扫描算法：按照次序读出物理块到内存并逐个元组扫描。</li><li>索引扫描算法：如果选择条件的属性存在索引，首先通过索引找到满足条件的元组指针，再通过元组指针找到元组。如果有多个选择条件并且都有索引，例如Sdept=CS AND Sage&gt;20，则可以求索引元组指针交集，也可以取出满足一个条件的所有元组，再选出符合第二个条件的。</li></ul><p style="text-indent:2em">当选择率较低时，索引扫描算法优于全表扫描算法，但选择率较高，或者要查找的元组均匀分布在表中的情况下，全表扫描可能性能更好，因为扫描索引也有开销，对每一个索引码，从B+树根节点到叶子节点的每个节点都要执行一次I/O。</p><h3 id="2-2-连接操作的实现"><a href="#2-2-连接操作的实现" class="headerlink" title="2.2 连接操作的实现"></a>2.2 连接操作的实现</h3><p style="text-indent:2em">连接操作是查询处理最常用也最耗时的操作之一，连接操作的一些算法实现如下：</p><ul><li>嵌套循环算法：对外层循环的元组，检查内层循环的每一个元组，在连接属性上是否相等。</li><li>排序-合并算法：先对两表按连接属性排序，取一个表A中的第一个元组，扫描另一个表B中具有相同连接属性的元组并连接，直到遇到了不相同的第一个元组，再返回表A取下一个元组，重复这个过程。对于大表，尽管没有排序时要先进行排序，执行时间仍然会比嵌套循环更少。</li><li>索引连接算法：若在表A已经建立了连接属性的索引，对表B的每一个元组，由连接属性值通过表A的索引查找相应的元组，找到后进行连接。</li><li>hash join算法：hash join也是处理等值连接的算法。它把连接属性作为hash码，用同一个hash函数把两表中的元组散列到hash表中。第一步划分阶段，创建hash表，对包含较少元组的表处理，把元组分散到hash表的桶中；第二步试探阶段，对另一个表进行一遍处理，把元组也按同一个hash函数散列，找到适当的hash桶，并将匹配的元组连接起来。</li></ul><h2 id="3-关系数据库系统的查询优化"><a href="#3-关系数据库系统的查询优化" class="headerlink" title="3.关系数据库系统的查询优化"></a>3.关系数据库系统的查询优化</h2><h3 id="3-1-代数优化"><a href="#3-1-代数优化" class="headerlink" title="3.1 代数优化"></a>3.1 代数优化</h3><p style="text-indent:2em">代数优化是基于关系代数等价变换规则的优化方法。关系代数的等价变换规则是一组基本的结合律，串接定律，交换律等。此处直接介绍查询树的启发式优化算法。在查询处理的第二步，查询检查后，会产生查询树，通常使用启发式算法对查询树进行优化，典型的启发式规则有：</p><ul><li>选择运算尽可能先做：减少计算中间结果。(<strong>最重要的规则</strong>，可以大大减少中间结果的大小)</li><li>投影运算和选择运算同时进行：扫描关系时同时完成。</li><li>投影和前或后的双目运算结合：没有必要为了去掉字段扫描关系。</li><li>把一些选择和笛卡尔积结合为连接运算：连接运算要比笛卡尔积节省很多时间。</li><li>找出公共子表达式：如果子表达式的结果重复出现且不太大，可以将该结果存入中间文件。当查询视图时，视图的定义就是公共子表达式。</li></ul><p style="text-indent:2em">以下是一个代数优化的例子：</p><p style="text-indent:2em">对学生-课程数据库，查询信息系学生选修了的所有课程名称。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Cname</span><br><span class="line"><span class="keyword">FROM</span> Student,Course,SC</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno<span class="operator">=</span>SC.Sno </span><br><span class="line"><span class="keyword">AND</span> SC.Cno<span class="operator">=</span>Course.Cno </span><br><span class="line"><span class="keyword">AND</span> Student.Sdept<span class="operator">=</span>’<span class="keyword">IS</span>’;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">试画出用关系代数表示的语法树，并用关系代数表达式优化算法对原始的语法树进行优化处理，画出优化后的标准语法树。</p><p><img src="/2022/09/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%94%E8%AE%B0/image-20221215104442115.png" alt="image-20221215104442115" style="zoom:50%;"></p><p><img src="/2022/09/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%94%E8%AE%B0/image-20221215104459965.png" alt="image-20221215104459965" style="zoom:50%;"></p><p><img src="/2022/09/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%94%E8%AE%B0/image-20221215105503438.png" alt="image-20221215105503438" style="zoom: 80%;"></p><h3 id="3-2-物理优化"><a href="#3-2-物理优化" class="headerlink" title="3.2 物理优化"></a>3.2 物理优化</h3><p style="text-indent:2em">代数优化改变查询语句中操作的次序和组合，但不涉及底层操作路径。对每一种操作，可以有多种算法，多条存取路径，物理优化就是从多种算法和多条路径中选择高效合理的操作和算法进行查询。选择的方法可以是：</p><ul><li>基于规则的启发式优化</li><li>基于代价估算的优化</li><li>两者结合的优化</li></ul><p><strong>基于启发式规则的存取路径选择优化</strong></p><p style="text-indent:2em">对于选择操作，小关系直接使用全表顺序扫描，即使存在索引；大关系则使用以下启发式规则：</p><ul><li>选择条件为主码=值，选择主码索引</li><li>选择条件为非主属性=值，并且存在索引，估算查询结果的元组数目，如果比例较小，例如&lt;10%，可以使用索引扫描，否则还是采用全表顺序扫描</li><li>对于选择条件是属性的非等值查询或范围查询，同上，需要估算结果元组数目</li><li>对于AND连接的合取选择条件，如果有涉及这些属性的组合索引，优先采用组合索引扫描，某些列上有一般索引，也可以用索引扫描方法</li><li>对于OR连接的析取选择条件，一般使用全表顺序扫描</li></ul><h1 id="第十章-数据库恢复技术"><a href="#第十章-数据库恢复技术" class="headerlink" title="第十章 数据库恢复技术"></a>第十章 数据库恢复技术</h1><h2 id="1-事务的基本概念"><a href="#1-事务的基本概念" class="headerlink" title="1.事务的基本概念"></a>1.事务的基本概念</h2><p style="text-indent:2em">事务是用户定义的一个操作序列，这些操作只能全做或全不做，是不可分割的工作单位。事务开始与结束可以由用户显式控制，如果没有控制，数据库系统会自动划分事务。事务通常以BEGIN TRANSACTION开始，以COMMIT或ROLLBACK结束。COMMIT表示提交，将所有对数据库的更新写到磁盘上的物理数据库中。ROLLBACK表示回滚，当出现某些故障，事务不能继续执行，就撤销所有已完成的操作，回到事务开始时的状态。</p><p style="text-indent:2em">事务具有4个特性，原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)，这四个特性被称为事务的ACID特性。</p><ul><li>原子性：事务是数据库工作的逻辑单位，只能全做或全不做。</li><li>一致性：事务必须使数据库从一个一致性状态到另一个一致性状态。</li><li>隔离性：一个事务的执行不能被其他事务干扰。</li><li>持久性：一个事务一旦提交，对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不对其结果有影响。</li></ul><h2 id="2-数据库恢复概述"><a href="#2-数据库恢复概述" class="headerlink" title="2.数据库恢复概述"></a>2.数据库恢复概述</h2><p style="text-indent:2em">数据库管理系统必须具有把数据库从错误状态恢复到某一已知的正确状态的功能，这就是数据库的恢复。</p><h2 id="3-故障的种类"><a href="#3-故障的种类" class="headerlink" title="3.故障的种类"></a>3.故障的种类</h2><p style="text-indent:2em">数据库系统中可能发生的故障，大致可分为以下几类：</p><ul><li>事务内部的故障：事务内部的故障有些是事务程序本身可以发现的，有些是非预期的，不能由事务程序处理。事务故障表示事务没有达到预期终点，因此恢复程序要强行回滚该事务，撤销该事务已作出的对数据库的修改，这类恢复操作称为<strong>事务撤销</strong>。</li><li>系统故障：系统故障是造成系统停止运转的任何事件，使得系统要重新启动。恢复子系统必须在系统重新启动时进行事务撤销。系统故障时还可能有已完成的事务没有写到物理数据库中，还需要<strong>重做</strong>所有已提交的事务。</li><li>介质故障：外存故障，磁盘损坏，磁头碰撞等。这类故障发生概率小，但破坏最大。</li><li>计算机病毒：人为的故障或破坏。</li></ul><p style="text-indent:2em">各类故障对数据库的影响有两种可能，一是数据库本身被破坏，二是数据库没有被破坏，但数据可能不正确。恢复的基本原理是采用<b>冗余</b>。</p><h2 id="4-恢复的实现技术"><a href="#4-恢复的实现技术" class="headerlink" title="4.恢复的实现技术"></a>4.恢复的实现技术</h2><h3 id="4-1-数据转储"><a href="#4-1-数据转储" class="headerlink" title="4.1 数据转储"></a>4.1 数据转储</h3><p style="text-indent:2em">数据转储是数据库恢复的基本技术。转储即定期将整个数据库复制到存储介质上保存，作为后备副本。数据库遭到破坏后，可以装入后背副本，将数据库恢复到转储时的状态。为了将数据库恢复到故障发生时的状态，还需要重新运行转储以后的所有更新事务。</p><p style="text-indent:2em">转储可分为静态转储和动态转储。</p><ul><li>静态转储：在系统无运行事务时进行转储。</li><li>动态转储：转储期间允许对数据库进行存取和修改。此方式转储和事务可以并发执行，但不能保证转储结束的后备副本正确有效，还需要使用日志文件记录转储期间各事务对数据库的修改。</li></ul><p style="text-indent:2em">转储还可分为海量转储和增量转储。</p><ul><li>海量转储：每次转储全部数据库。</li><li>增量转储：每次只转储上一次转储后更新过的数据。</li></ul><p style="text-indent:2em">根据转储时期，转储内容，转储可分为静态海量转储，静态增量转储，动态海量转储，动态增量转储。</p><h3 id="4-2-登记日志文件"><a href="#4-2-登记日志文件" class="headerlink" title="4.2 登记日志文件"></a>4.2 登记日志文件</h3><p style="text-indent:2em">日志文件是用来记录事务对数据库的更新操作的文件。日志文件主要有两种格式，<b>以记录为单位的日志文件</b>和<b>以数据块为单位的日志文件</b>。对以记录为单位的日志文件，记录需要登记事务的开始和结束标记，以及所有更新操作，每一个开始和结束标记，更新操作都有一个日志记录，日志记录包含事务标识，操作对象，类型，修改前后的值等。</p><p style="text-indent:2em">日志文件的主要作用是：</p><ul><li>事务故障恢复和系统故障恢复必须用日志文件。</li><li>动态转储必须建立日志文件，和后备副本结合恢复数据库。</li><li>静态转储也可以建立日志文件，和后备副本结合恢复数据库到故障前某一刻的状态。</li></ul><p style="text-indent:2em">为保证数据库是可恢复的，登记日志文件时必须遵守两条原则：</p><ul><li>登记的次序严格按照并发事务执行的时间次序。</li><li>必须先写日志文件，后写数据库。</li></ul><h2 id="5-恢复策略"><a href="#5-恢复策略" class="headerlink" title="5.恢复策略"></a>5.恢复策略</h2><p style="text-indent:2em">不同故障使用不同的故障恢复方法和策略。</p><p style="text-indent:2em">事务故障的恢复由系统利用日志文件自动完成，撤销该事务对数据库进行的修改。方式是反向扫描日志文件，找到该事务的更新操作，就进行逆操作，直到读到事务的开始标记。</p><p style="text-indent:2em">系统故障的恢复由系统在重新启动时自动完成，不需要用户干预。方式是正向扫描日志文件，找出故障发生前已经提交的事务(存在BEGIN TRANSACTION 和 COMMIT记录)，将其事务标识加入REDO重做队列，将未完成的事务的事务标识记入UNDO撤销队列，然后撤销撤销队列中的事务，重做重做队列中的事务。</p><p style="text-indent:2em">介质故障的恢复首先要装入最新的数据库后备副本，使数据库恢复到最近一次转储的一致性状态。对于动态转储的数据库副本，还需要装入转储开始时刻的日志文件副本，进行REDO和UNDO，才能将数据库恢复到一致状态。然后装入转储结束时刻的日志文件副本，重做已经完成的事务，就可以恢复数据库了。</p><h2 id="6-具有检查点的恢复技术"><a href="#6-具有检查点的恢复技术" class="headerlink" title="6.具有检查点的恢复技术"></a>6.具有检查点的恢复技术</h2><p style="text-indent:2em">利用日志对数据库恢复时，需要检查所有日志记录，耗费大量时间，还可能将很多已经将更新写入数据库的事务进行了重做，浪费了大量时间。为了解决这些问题，产生了具有检查点的恢复技术。这类技术在日志文件中添加<b>检查点记录</b>，增加了一个<b>重新开始文件</b>，让恢复子系统动态维护日志。</p><p style="text-indent:2em">检查点记录的内容包括：</p><ul><li>建立检查点时刻正在执行的事务清单。</li><li>这些事务最近一个日志记录的地址。</li></ul><p style="text-indent:2em">重新开始文件则记录了各个检查点记录在日志文件中的地址。通过不断记录检查点，就可以只对检查点到故障发生时的事务进行处理，解决上述浪费时间的问题。系统使用检查点恢复的步骤是：</p><ul><li>从重新开始文件找到最后一个检查点记录在日志文件中的地址，在日志文件中找到最后一个检查点记录。</li><li>由检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST，并建立REDO-LIST和UNDO-LIST事务队列，将所有ACTIVE-LIST中的事务先添加到UNDO-LIST。</li><li>从检查点开始正向扫描日志文件，将完成的事务从UNDO-LIST转移到REDO-LIST。</li><li>重做REDO-LIST中的事务，撤销UNDO-LIST中的事务。</li></ul><h2 id="7-数据库镜像"><a href="#7-数据库镜像" class="headerlink" title="7.数据库镜像"></a>7.数据库镜像</h2><p style="text-indent:2em">随着存储介质的价格下降，为了应对介质故障，并避免周期性转储的负担，许多数据库管理系统提供了数据库镜像功能，自动将数据库或其中的关键数据复制到另一个磁盘，并自动保证一致性。数据库镜像也可以用于并发操作，让数据被修改时，其他用户可以读镜像数据库的数据，而不用等待。数据库镜像一般只对关键数据和日志文件进行镜像。</p><h1 id="第十一章-并发控制"><a href="#第十一章-并发控制" class="headerlink" title="第十一章 并发控制"></a>第十一章 并发控制</h1><h2 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1.概述"></a>1.概述</h2><p style="text-indent:2em">数据库是一个共享资源，供多个用户使用，同一个时刻并发运行的事务数很多。事务不是严格按照一个一个完成的串行顺序执行的，而是并行执行的，并行事务轮流交叉运行。在单处理器上，并行事务并不是真正并行运行的，但减少了处理器空闲时间，提高了系统效率。</p><p style="text-indent:2em">事务是并发控制的基本单位，保证事务的ACID特性是事务处理的重要任务。为了保证事务的隔离性和一致性，数据库系统需要对并发操作进行正确调度。并发操作带来的数据不一致性有以下三种：</p><ul><li>丢失修改：两个事务读入同一数据并修改，其中一个事务的修改丢失。</li><li>不可重复读：一个事务读取数据，另一个事务执行了更新操作(修改，删除，插入)，当读取数据的事务重新读取数据时，无法重现前一次读的结果。</li><li>读脏数据：一个事务修改某一数据，紧接着另一事务读取该数据，修改数据的事务接下来因为某些原因被撤销，读取数据的事务读到的数据为脏数据，与数据库的数据不一致。</li></ul><p style="text-indent:2em">并发控制机制就是使用正确的调度使一个用户的事务不受另一个用户的干扰，避免数据的不一致性。</p><p style="text-indent:2em">并发控制的主要技术有封锁，时间戳，乐观控制法和多版本并发控制等。</p><h2 id="2-封锁"><a href="#2-封锁" class="headerlink" title="2.封锁"></a>2.封锁</h2><p style="text-indent:2em">数据库对数据对象使用两种类型的基本封锁保证数据一致性。</p><ul><li>排他锁(X锁/写锁)：事务T对数据对象A加上排他锁，则只允许T读取修改A，其他事务不能对A加任何锁，直到T释放该锁。</li><li>共享锁(S锁/读锁)：事务T对数据对象A加上共享锁，T只能读取A，其他事务可以对A加共享锁，不可以加排他锁，直到T释放该锁。</li></ul><h2 id="3-封锁协议"><a href="#3-封锁协议" class="headerlink" title="3.封锁协议"></a>3.封锁协议</h2><p style="text-indent:2em">对数据加锁时，要约定一些规则，这些规则称为封锁协议。</p><div class="table-container"><table><thead><tr><th>封锁协议</th><th>一致性保证</th><th>协议</th></tr></thead><tbody><tr><td>一级封锁协议</td><td>不丢失修改</td><td>事务T在修改数据之前必须加X锁，事务结束释放该锁。</td></tr><tr><td>二级封锁协议</td><td>不丢失修改，不读脏数据</td><td>在一级封锁协议基础上，事务T在读取数据之前必须<br>加S锁，<br><strong>读完</strong>后释放S锁</td></tr><tr><td>三级封锁协议</td><td>不丢失修改，不读脏数据，可重复读</td><td>在一级封锁协议基础上，事务T在读取数据之前必须<br>加S锁，<br><strong>事务结束</strong>后释放S锁</td></tr></tbody></table></div><h2 id="4-活锁和死锁"><a href="#4-活锁和死锁" class="headerlink" title="4.活锁和死锁"></a>4.活锁和死锁</h2><p style="text-indent:2em">和操作系统并发控制一样，封锁会引起活锁和死锁等问题。</p><p style="text-indent:2em">活锁是指一个事务等待锁，但是由于许多事务都在等待锁，而每次一个事务释放锁时，总是将锁交给其他等待锁的事务，导致这个事务永远等待锁的情况。避免活锁的方法是使用先来先服务的策略，按照次序让事务获取锁。</p><p style="text-indent:2em">死锁的情况是两个事务封锁了两个数据对象，而这两个事务又都需要使用对方当前上锁的数据对象，导致互相等待。在数据库中，解决死锁的问题有两类方法，一类是预防死锁，另一类是允许死锁发生，定期诊断并解除死锁。死锁的预防存在很大的困难，因此数据库普遍采用诊断并解除死锁的方法。</p><ul><li><p>死锁的预防：</p><ul><li>一次封锁法：每个事务必须一次将所有要使用的数据全部加锁，否则不能执行。这个方法能有效防止死锁，但一开始就封锁了所有数据，降低了并发度，而且如果要在一开始就封锁所有可能使用的数据对象，只能扩大封锁范围，进一步降低了并发度。</li><li>顺序封锁法：预先对数据对象规定一个封锁顺序，按顺序封锁。这种方法的问题为：事务中的数据对象很多且会变化，很难维护一个封锁顺序；封锁请求可以随事务执行动态决定，难以确定所有的封锁对象及顺序。</li></ul></li><li><p>死锁的诊断</p><ul><li>超时法：如果事务等待时间超过规定时限，就认为发生超时。这种方法时限的确定困难，时限短可能误判死锁，时限长则死锁不能及时发现。</li><li>等待图法：用事务等待图表示所有事务的等待情况。并发控制系统周期生成事务等待图，通过检测是否存在回路判断是否出现了死锁。</li></ul></li><li>死锁的解除：数据库通常采用的方法是选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有的锁，使其他事务可以正常运行。</li></ul><h2 id="5-并发调度的可串行性"><a href="#5-并发调度的可串行性" class="headerlink" title="5.并发调度的可串行性"></a>5.并发调度的可串行性</h2><p style="text-indent:2em">多个事务的并发执行是正确的，当且仅当其<b>结果与按某一次序串行的执行这些事务的结果相同</b>，成这种调度策略为<b>可串行化调度</b>。</p><p style="text-indent:2em">可串行性是并发事务正确调度的准则。一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。</p><p style="text-indent:2em">接下来介绍判断可串行化调度的<b>充分条件</b>，首先介绍冲突操作。</p><ul><li>冲突操作：不同的事务对同一个数据的读写操作和写写操作。例如：Ri(x)与Wj(x)，i≠j。</li></ul><p style="text-indent:2em">两事务的冲突操作或同一事务的两个操作一旦交换顺序，结果就会不同，因此考虑可串行化的调度时，不能交换冲突操作或同一事务的两个操作的顺序。一个调度在保证冲突操作次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度，如果新的调度是串行的，则原调度为<b>冲突可串行化的调度</b>。若一个调度是冲突可串行化的调度，则一定是可串行化的调度。需要注意冲突可串行化是可串行化调度的充分条件，不是必要条件。</p><p>例：</p><p style="text-indent:2em">有三个事务的一个调度r3(B)r1(A)w3(B)r2(B)r2(A)w2(B)r1(B)w1(A)，该调度是否为冲突可串行化的调度?</p><p style="text-indent:2em">该调度是冲突可串行化的调度。</p><p style="text-indent:2em">交换r1(A)和w3(B)，得到r3(B)w3(B)r1(A)r2(B)r2(A)w2(B)r1(B)w1(A)</p><p style="text-indent:2em">交换r1(A)和w2(B)，得到r3(B)w3(B)w2(B)r2(B)r2(A)r1(A)r1(B)w1(A)</p><p style="text-indent:2em">r3(B)w3(B)w2(B)r2(B)r2(A)r1(A)r1(B)w1(A)等价于一个串行调度T3T2T1，因此原调度为冲突可串行化的调度。</p><h2 id="6-两段锁协议"><a href="#6-两段锁协议" class="headerlink" title="6.两段锁协议"></a>6.两段锁协议</h2><p style="text-indent:2em">为了保证并发调度的正确性，数据库管理系统需要保证调度是可串行化的。目前数据库管理系统普遍采用<b>两段锁协议</b>实现并发调度的可串行性，从而保证调度的可串行性。</p><p style="text-indent:2em">两段锁指两个阶段对数据项加锁和解锁：</p><ul><li>对任何数据进行读，写操作之前，首先要申请并获得对数据的封锁</li><li>在释放一个封锁之后，事务不再申请和获得任何其他封锁</li></ul><p style="text-indent:2em">两段锁的两段的含义是，事务分为两个阶段，第一阶段获得锁，称为扩展阶段，该阶段只能获得锁，不能释放锁；第二阶段是释放锁，称为收缩阶段，该阶段只能释放锁，不能获得锁。</p><p style="text-indent:2em">若并发执行的所有事务都遵守两段锁协议，则这些事务的任何并发调度策略都是可串行化的。不过事务遵守两段锁协议也只是可串行化调度的充分条件，不是必要条件。需要注意，两段锁协议中，第一阶段没有要求一次对所有使用的数据对象加锁，因此不是一次封锁法，是可能产生死锁的。</p><p style="text-indent:2em">最后比较一下两段锁协议与三级封锁协议，这两种协议的目的不同，两段锁协议的目的是保证并发调度的正确性，而三级封锁协议的目的是保证数据的一致性。遵守三级封锁协议一定遵守两段锁协议。</p><h2 id="7-封锁的粒度"><a href="#7-封锁的粒度" class="headerlink" title="7.封锁的粒度"></a>7.封锁的粒度</h2><h3 id="7-1-多粒度封锁"><a href="#7-1-多粒度封锁" class="headerlink" title="7.1 多粒度封锁"></a>7.1 多粒度封锁</h3><p style="text-indent:2em">封锁对象的大小称为封锁粒度。封锁对象可以是逻辑单元(关系，索引，属性)，也可以是物理单元(页)。封锁粒度越大，并发度越小，系统开销越小。为了平衡开销与并发度，一个系统中应该同时支持多种封锁粒度供不同的事务选择，这种封锁称为<b>多粒度封锁</b>。需要封锁时，考虑封锁开销和并发度两个因素，适当选择合适的封锁粒度。例如处理一个关系的大量元组可以以关系为封锁粒度，处理少量元组的事务可以以元组为封锁粒度，处理多个关系的大量元组的事务可以以数据库为封锁粒度。</p><p style="text-indent:2em">多粒度封锁情况可以用多粒度树表示，多粒度树根节点是数据库，表示最大的数据粒度，叶子节点表示最小的数据粒度。多粒度封锁的协议允许多粒度树找那个的每个节点独立加锁，并且一个节点加锁，其后代子节点也被加同样的锁。因此多粒度封锁中的数据可能以两种方式封锁：</p><ul><li>显式封锁：直接加到数据对象的锁</li><li>隐式封锁：由于上级节点加锁导致当前节点加锁</li></ul><p style="text-indent:2em">显式封锁和隐式封锁的效果是一样的。在对数据对象加锁时，要检查有无显式封锁冲突，还要检查上级节点，检查是否与隐式封锁冲突，也要检查下级节点，判断下级节点的显式封锁是否与当前加锁带来的隐式封锁冲突，这样的检查效率很低，因此引入了一种新型锁提高效率，称为<b>意向锁</b>。</p><h3 id="7-2-意向锁"><a href="#7-2-意向锁" class="headerlink" title="7.2 意向锁"></a>7.2 意向锁</h3><p style="text-indent:2em">意向锁的含义是：如果对一个节点加意向锁，说明其下层后代节点正在被加锁；对任一节点加锁时，必须先对其上层节点加意向锁。以下是三种常见用的意向锁：</p><ul><li>IS锁：对一个数据对象加IS锁，表示其下层节点要加S锁。</li><li>IX锁：对一个数据对象加IX锁，表示其下层节点要加X锁。</li><li>SIX锁：对一个数据对象加IX锁，表示对其加S锁，再加IX锁。例如事务对某个表加SIX锁，表示事务要读整个表，同时更新个别元组。</li></ul><p style="text-indent:2em">数据锁的相容矩阵如下：</p><div class="table-container"><table><thead><tr><th>T1/T2</th><th>S</th><th>X</th><th>IS</th><th>IX</th><th>SIX</th></tr></thead><tbody><tr><td>S</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>N</td></tr><tr><td>X</td><td>N</td><td>N</td><td>N</td><td>N</td><td>N</td></tr><tr><td>IS</td><td>Y</td><td>N</td><td>Y</td><td><font color="red">Y</font></td><td><font color="red">Y</font></td></tr><tr><td>IX</td><td>N</td><td>N</td><td><font color="red">Y</font></td><td><font color="red">Y</font></td><td>N</td></tr><tr><td>SIX</td><td>N</td><td>N</td><td><font color="red">Y</font></td><td>N</td><td>N</td></tr></tbody></table></div><p style="text-indent:2em">有了意向锁之后，就可以只检查当前数据是否有不相容的锁，上层节点是否有不相容的锁，不需要检查下层后代节点是否有不相容的锁。</p>]]></content>
      
      
      <categories>
          
          <category> cs基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习笔记</title>
      <link href="/2022/08/30/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/08/30/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p style="text-indent:2em">git学习笔记。学习视频：<a herf="https://www.bilibili.com/video/BV1MU4y1Y7h5?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&vd_source=463e5b3e4b18e5453477b57388c2e427">黑马程序员git教程</a></p><span id="more"></span><h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一.概述"></a>一.概述</h1><h2 id="1-版本控制器的方式"><a href="#1-版本控制器的方式" class="headerlink" title="1.版本控制器的方式"></a>1.版本控制器的方式</h2><ul><li>集中式版本控制工具：版本库集中存放在中央服务器，team里每个人work时从中央服务器下载代码，必须联网才能工作，局域网或互联网。个人修改后然后提交到中央版本库。（例：SVN）</li><li>分布式版本控制工具：没有“中央服务器”，每个人的电脑上都是一个完整的版本库，工作时，不需要联网。多人协作只需要各自的修改推送给对方，就能互相看到对方的修改。（git）</li></ul><h2 id="2-git工作流程"><a href="#2-git工作流程" class="headerlink" title="2.git工作流程"></a>2.git工作流程</h2><img src="/2022/08/30/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" class><ul><li>clone（克隆）: 从远程仓库中克隆代码到本地仓库。</li><li>checkout （检出）:从本地仓库中检出一个仓库分支然后进行修订。</li><li>add（添加）: 在提交前先将代码提交到暂存区。</li><li>commit（提交）: 提交到本地仓库。本地仓库中保存修改的各个历史版本。</li><li>fetch (抓取) ： 从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。</li><li>pull (拉取) ： 从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于fetch+merge。</li><li>push（推送） : 修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库。</li></ul><h1 id="二-git常用命令"><a href="#二-git常用命令" class="headerlink" title="二.git常用命令"></a>二.git常用命令</h1><h2 id="1-获取本地仓库"><a href="#1-获取本地仓库" class="headerlink" title="1.获取本地仓库"></a>1.获取本地仓库</h2><ul><li>创建空目录作为本地仓库。</li><li>git init创建本地仓库，创建完成后文件夹下可看到隐藏的git目录。</li></ul><h2 id="2-基础操作指令"><a href="#2-基础操作指令" class="headerlink" title="2.基础操作指令"></a>2.基础操作指令</h2><p style="text-indent:2em">git工作目录下对于文件的修改(增加、删除、更新)会存在几个状态，这些修改的状态会随着我们执行git 的命令而发生变化。</p><img src="/2022/08/30/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%8A%B6%E6%80%81.jpg" class><ul><li>git add 工作区-&gt;暂存区（git add .所有文件添加到暂存区）。</li><li>git commit 暂存区-&gt;本地仓库（-m进行注释）。</li><li>git status 查看状态。</li><li>git log 查看提交日志。<ul><li>—all 显示所有分支。</li><li>—pretty=oneline 显示一行信息。</li><li>—abbrev-commit 使得输出的commited更简短。</li><li>—graph 以图的形式显示。</li></ul></li><li>git reset —hard commitID 版本回退。</li><li>git reflog 查看已经删除的记录。</li><li>添加文件至忽略列表：创建.gitignore文件，将不需要仓库管理的文件名保存到该文件中。</li></ul><h2 id="3-git分支"><a href="#3-git分支" class="headerlink" title="3.git分支"></a>3.git分支</h2><p style="text-indent:2em">几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离 开来进行重大的Bug修改、开发新的功能，以免影响开发主线。</p><ul><li>git branch 查看分支。</li><li>git branch 分支名 创建新分支。</li><li>git checkout 分支名 切换分支 （-b 创建并切换到新分支）。</li><li>git merge 分支名称 分支合并。</li><li>git brach -d b1删除分支时，做各种检查；-D则不做任何检查，强制删除。</li><li>解决冲突：<ul><li>处理文件中冲突的地方。</li><li>. 将解决完冲突的文件加入暂存区(add)，提交到仓库(commit)。</li></ul></li><li>开发中分支使用原则与流程<ul><li>master （生产） 分支。</li><li>develop（开发）分支：从master创建的分支，一般作为开发部门的主要开发分支。</li><li>feature/xxxx分支：从develop创建的分支，一般是同期并行开发，但不同期上线时创建的分支，分支上的研发任务完成后合并到develop分支。</li><li>hotfix/xxxx分支：从master派生的分支，一般作为线上bug修复使用，修复完成后需要合并到master、test、 develop分支。</li></ul></li></ul><h1 id="三-git远程仓库"><a href="#三-git远程仓库" class="headerlink" title="三.git远程仓库"></a>三.git远程仓库</h1><h2 id="1-配置公钥"><a href="#1-配置公钥" class="headerlink" title="1.配置公钥"></a>1.配置公钥</h2><ul><li>生产公钥：ssh-keygen -t rsa</li><li>获取公钥：cat ~/.ssh/id_rsa.pub</li><li>验证是否配置成功：ssh -T url</li></ul><h2 id="2-远程仓库操作"><a href="#2-远程仓库操作" class="headerlink" title="2.远程仓库操作"></a>2.远程仓库操作</h2><ul><li>添加远程仓库：git remote add &lt;远端名称&gt; &lt;仓库路径&gt;，远端名称默认为origin</li><li>查看远程仓库：git remote</li><li>推送到远程仓库：git push [-f] [—set-upstream] [远端名称] [本地分支名][:远端分支名] 。例如：git push origin master:master<ul><li>远程分支名和本地分支名相同可只写本地分支名。</li><li>push 失败时，先尝试<font color="red">git pull —rebase origin master</font>，再重新push。</li><li>-f 表示强制覆盖。</li><li>—set-upstream 推送到远端的同时并且建立起和远端分支的关联关系。</li><li>如果当前分支已经和远端分支关联，则可以省略分支名和远端名。</li></ul></li><li>从远程仓库克隆：git clone &lt;仓库路径&gt;  [本地目录]，本地目录可以省略。</li><li>从远程仓库中抓取：git fetch [remote name] [branch name]<ul><li>抓取指令就是将仓库里的更新都抓取到本地，不会进行合并。</li><li>如果不指定远端名称和分支名，则抓取所有分支。</li></ul></li><li>拉取：git pull [remote name] [branch name]<ul><li>拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge 。</li><li>如果不指定远端名称和分支名，则抓取所有并更新当前分支。</li></ul></li><li>解决合并冲突：拉取到本地解决冲突后，再推送到远程仓库。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记</title>
      <link href="/2022/08/30/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/08/30/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p style="text-indent:2em">《算法笔记》的笔记。</p><span id="more"></span><h1 id="第一章-C-C-基础"><a href="#第一章-C-C-基础" class="headerlink" title="第一章 C/C++基础"></a>第一章 C/C++基础</h1><h2 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1.基本数据类型"></a>1.基本数据类型</h2><ul><li><p>10^9以内使用int，以上则使用long long</p></li><li><p>如果long long赋大于2^32-1的初值，需要在初值后面加上LL。例如：long long bignum = 123456789012345LL</p></li><li>尽量不使用宏定义来做除了定义常量以外的事（存在陷阱）。定义常量推荐const写法。</li></ul><h2 id="2-顺序结构"><a href="#2-顺序结构" class="headerlink" title="2.顺序结构"></a>2.顺序结构</h2><ul><li>scanf的几种格式符：%d，%lld，%f，%lf（double），%c，%s。</li><li>printf的格式符，double、float均为%f。</li><li>%md不足m位右对齐（空格补齐），%0md用0补齐，%mf保留m位小数输出。</li><li>常用math函数：fabs()，floor()，ceil()，pow()，sqrt()，log()，asin()，sin()，round()。</li><li>如果数组大小较大（大概10^6级别），则需要定义在主函数外。主函数内申请的局部变量使用系统栈，允许的空间较小，全局变量来自静态存储区，允许申请的空间较大。</li><li>memset(数组名，值，sizeof(数组名))，按字节赋值。用来赋<font color="red">0,1</font>不容易出错。如果赋其他数字，使用fill函数。</li><li>gets(数组名)用于输入一行字符串，以\n为结束，因此gets一行的字符串后，<font color="red">需要getchar()接收换行符</font>。</li><li>常用字符数组函数：<ul><li>strlen(数组)</li><li>strcmp(数组1，数组2)</li><li>strcpy(数组1，数组2)，数组2复制到数组1</li><li>strcat(数组1，数组2)，数组2接到数组1后面</li></ul></li><li>sscanf(str,”%d”,&amp;n)，从左至右</li><li>sprintf(str,”%d”,n)，从右至左</li></ul><h1 id="第二章-简单模拟"><a href="#第二章-简单模拟" class="headerlink" title="第二章 简单模拟"></a>第二章 简单模拟</h1><h2 id="1-日期差值"><a href="#1-日期差值" class="headerlink" title="1.日期差值"></a>1.日期差值</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> month[<span class="number">13</span>][<span class="number">2</span>]=&#123;</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">28</span>,<span class="number">29</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,</span><br><span class="line">    &#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isleap</span><span class="params">(<span class="type">int</span> year)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (year%<span class="number">4</span> == <span class="number">0</span> &amp;&amp; year%<span class="number">100</span> != <span class="number">0</span>) || (year%<span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> time1,y1,m1,d1;</span><br><span class="line">    <span class="type">int</span> time2,y2,m2,d2;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;time1,&amp;time2) != EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(time1&gt;time2)&#123;</span><br><span class="line">            <span class="type">int</span> temp = time1;</span><br><span class="line">            time1 = time2;</span><br><span class="line">            time2 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        y1 = time1/<span class="number">10000</span>, m1 = time1%<span class="number">10000</span>/<span class="number">100</span>, d1 = time1%<span class="number">100</span>;</span><br><span class="line">        y2 = time2/<span class="number">10000</span>, m2 = time2%<span class="number">10000</span>/<span class="number">100</span>, d2 = time2%<span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(y1&lt;y2 || d1&lt;d2 || m1&lt;m2)&#123;</span><br><span class="line">            d1++;</span><br><span class="line">            <span class="keyword">if</span>(d1 == month[m1][<span class="built_in">isleapyear</span>(y1)+<span class="number">1</span>])&#123;</span><br><span class="line">                m1++;</span><br><span class="line">                d1 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(m1 == <span class="number">13</span>)&#123;</span><br><span class="line">                y1++;</span><br><span class="line">                m1 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-进制转换"><a href="#2-进制转换" class="headerlink" title="2.进制转换"></a>2.进制转换</h2><p style="text-indent:2em">D进制的A+B<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,d,sum;</span><br><span class="line">    <span class="type">int</span> ans[<span class="number">40</span>],num=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;d);</span><br><span class="line">    sum = a+b;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        ans[num++] = sum%d;</span><br><span class="line">        sum/=d;</span><br><span class="line">    &#125;<span class="keyword">while</span>(sum!=<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=num<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>## 3.字符串处理# 第三章 算法初步## 1.排序### 1.1选择排序</p><p style="text-indent:2em">进行n次操作，每次选出待排序部分中最小的元素，与A[i]进行交换。复杂度为O(n^2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> k=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[k]&gt;A[j])&#123;</span><br><span class="line">                k=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> temp = A[k];</span><br><span class="line">        A[k] = A[i];</span><br><span class="line">        A[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2直接插入排序"><a href="#1-2直接插入排序" class="headerlink" title="1.2直接插入排序"></a>1.2直接插入排序</h3><p style="text-indent:2em">直接插入排序是将带插入部分一个个插入初始已有序部分中的过程，具体做法为从后往前枚举已有序部分来确定插入位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> temp = A[i],j=i;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">1</span> &amp;&amp; temp&lt;A[j<span class="number">-1</span>])&#123;<span class="comment">//注意j的取值</span></span><br><span class="line">            A[j] = A[j<span class="number">-1</span>];<span class="comment">//后移一位</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        A[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3冒泡排序"><a href="#1-3冒泡排序" class="headerlink" title="1.3冒泡排序"></a>1.3冒泡排序</h3><p style="text-indent:2em">每次将最大的数移动到最右侧，移动n-1次完成排序。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;<span class="comment">//n-1次排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n-i;j++)&#123;<span class="comment">//将最大的数移动至最右侧</span></span><br><span class="line">            <span class="keyword">if</span>(A[j]&gt;A[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> temp = A[j];</span><br><span class="line">                A[j+<span class="number">1</span>] = temp;</span><br><span class="line">                A[j] = A[j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p style="text-indent:2em">归并排序与快速排序在双指针一节中。## 2.散列### 2.1散列的定义及整数散列</p><p style="text-indent:2em">将元素通过一个函数转换为整数，使得该整数可以尽量唯一的代表这个元素。其中把这个转换函数称为散列函数H，对于一个元素key，转换的结果为整数H(key)。</p><p style="text-indent:2em">对于key为整数的情况来说，常用的散列函数有直接定址法（H(key)=key或H(key)=a*key+b），平方取中法（取key平方的中间若干位作为数组下标，很少使用），除留取余法（H(key)=key%mod）。</p><p style="text-indent:2em">使用除留取余法时，可以把很大的数转换为小于mod的整数，数组TSize要大于mod。可能有key1和key2的H(key1)=H(key2)的冲突情况，这种情况有以下三种解决方法：</p><ul><li>线性探查法：当H(key)被占用，检查H(key+1)是否被占用，不断检查直到找到可用的位置。使用这种方式可能导致扎堆。</li><li>平方探查法：当H(key)被占用，检查H(key)+1，H(key)-1，H(key)+2^2，H(key)-2^2……。如果H(key)+k^2超过了表长，就对表长取模，如果H(key)-k^2<0，就将(H(key)-k^2)%TSize+TSize)%TSize作为结果。也可以只使用正向的平方探查，如果在表长范围内没有找到位置，当k>=TSize时，也一定无法找到位置。</0，就将(H(key)-k^2)%TSize+TSize)%TSize作为结果。也可以只使用正向的平方探查，如果在表长范围内没有找到位置，当k></li><li>链地址法：将所有的H(key)相同的key链接成一条单链表。</li></ul><h3 id="2-2字符串hash"><a href="#2-2字符串hash" class="headerlink" title="*2.2字符串hash"></a>*2.2字符串hash</h3><p style="text-indent:2em">字符串hash是将一个字符串映射为一个整数，使得该整数可以尽可能的唯一的代表字符串S。映射方式是将大小写字母映射到0-51，然后按照进制转换的方式将其转换为十进制数。如果字符串中有数字，可以增大进制为62，或者可以将末尾的确定个数的数字直接拼接上去。</p><p style="text-indent:2em">给出N个字符（有恰好三位大写字母组成），再给出M个查询字符串，问每个查询字符串在N个字符串中出现的次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="type">int</span> hashtable[<span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span>+<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> s[<span class="number">1000</span>][<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hashfunc</span><span class="params">(<span class="type">char</span> s[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        id = id*<span class="number">26</span> + (s[i]-<span class="string">&#x27;A&#x27;</span>);<span class="comment">//进制转换</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]);</span><br><span class="line">        <span class="type">int</span> id = <span class="built_in">hashfunc</span>(s[i]);</span><br><span class="line">        hashtable[id++];</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">char</span> temp[<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,temp);</span><br><span class="line">        <span class="type">int</span> id = <span class="built_in">hashfunc</span>(temp,<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,hashtable[id]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-递归"><a href="#3-递归" class="headerlink" title="3.递归"></a>3.递归</h2><h3 id="3-1分治"><a href="#3-1分治" class="headerlink" title="3.1分治"></a>3.1分治</h3><p style="text-indent:2em">分治法将原问题划分成若干个规模较小而结构与原问题相同或相似的子问题，然后分别解决这些子问题，最后合并子问题的解，即可得到原问题的解。分治法分解出的子问题应当是相互独立，没有交叉的。分治法作为一种算法思想，既可以使用递归的方法实现，也可以通过非递归的方法实现。</p><h3 id="3-2递归"><a href="#3-2递归" class="headerlink" title="*3.2递归"></a>*3.2递归</h3><p style="text-indent:2em">递归是实现分治的一种方式。递归的核心在于解决以下两个问题：- 递归边界- 递归式</p><p style="text-indent:2em">以下是递归解决的全排列问题。本题也体现了回朔的思想。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">示例</span></span><br><span class="line"><span class="comment">输入：nums = [1,2,3]</span></span><br><span class="line"><span class="comment">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span></span><br><span class="line"><span class="comment">-------------------------------------------------------------------------------------------------*/</span> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; used;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traceback</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()==nums.<span class="built_in">size</span>())&#123;<span class="comment">//边界</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">traceback</span>(nums);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123; </span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        used.<span class="built_in">resize</span>(len,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">traceback</span>(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p style="text-indent:2em"><a herf="https://leetcode.cn/problems/n-queens/">n皇后问题</a>也是一个全排列问题，递归解法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; used;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traceback</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>()==n)&#123;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//对角线检查</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">abs</span>(path[i]-path[j])==<span class="built_in">abs</span>(i-j))</span><br><span class="line">                        flag =<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">                res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//全排列</span></span><br><span class="line">            <span class="keyword">if</span>(used[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">traceback</span>(n);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; NQueens;</span><br><span class="line">        used.<span class="built_in">resize</span>(n,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">traceback</span>(n);</span><br><span class="line">        <span class="comment">//字符形式表示每行</span></span><br><span class="line">        string row = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">            row += <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x = res.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x;i++)&#123;           <span class="comment">//res[i]为nqueens的一种全排列     </span></span><br><span class="line">            vector&lt;string&gt; temp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                row[res[i][j]<span class="number">-1</span>] = <span class="string">&#x27;Q&#x27;</span>;<span class="comment">//把每一行中的queen位置置为Q</span></span><br><span class="line">                temp.<span class="built_in">push_back</span>(row);</span><br><span class="line">                row[res[i][j]<span class="number">-1</span>] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            NQueens.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NQueens;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-贪心"><a href="#4-贪心" class="headerlink" title="4.贪心"></a>4.贪心</h2><h3 id="4-1简单贪心"><a href="#4-1简单贪心" class="headerlink" title="4.1简单贪心"></a>4.1简单贪心</h3><p style="text-indent:2em">贪心法是求解一类最优化问题的方法，总是考虑当前状态下局部最优的策略，使全局的结果达到最优。策略最优的证明通常使用反证法和数学归纳法，一般情况下，只要举不出反例就可以尝试使用贪心法求解问题。</p><h3 id="4-2区间贪心"><a href="#4-2区间贪心" class="headerlink" title="*4.2区间贪心"></a>*4.2区间贪心</h3><p style="text-indent:2em">区间不相交问题是另一个经典的贪心问题。给出N个开区间，从中选择尽可能多的开区间，使得这些开区间两两没有交集。这道题的关键在于总是选择较小的区间，一个区间的左边界总是小于右边界，如果区间尽可能小，那么左边界应尽可能大，右边界尽可能小。因此解决该问题有两种方式，一种是按右边界排序，优先选择右边界小的，而且要从最小的右边界开始选起；另一种是按左边界排序，优先选择左边界大的，从最大的左边界开始选起。这两种方式需要注意的是<font color="red">选择的顺序</font>，按右边界排序就要从右边界最小的开始选，相当于从左往右选，尽量选择给右边能留出更大空间的区间；按左边界排序就要从左边界最大的开始选，相当于从右往左选，尽量选择给左边留出更大空间的区间。</p><p style="text-indent:2em"><a herf="https://leetcode.cn/problems/non-overlapping-intervals/">无重叠区间</a>就是上述的区间贪心问题，以下是从左向右选区间，按右边界排序的解法：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</span></span><br><span class="line"><span class="comment">-------------------------------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">interval</span>&#123;</span><br><span class="line">        <span class="type">int</span> left,right;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(interval a,interval b)</span></span>&#123;<span class="comment">//按右边界从小到大排序</span></span><br><span class="line">        <span class="keyword">if</span>(a.right==b.right)</span><br><span class="line">            <span class="keyword">return</span> a.left&lt;b.left;</span><br><span class="line">        <span class="keyword">return</span> a.right&lt;b.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> num=intervals.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;interval&gt; _intervals;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">interval</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            temp.left = intervals[i][<span class="number">0</span>];</span><br><span class="line">            temp.right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            _intervals.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(_intervals.<span class="built_in">begin</span>(),_intervals.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        temp = _intervals[<span class="number">0</span>];        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;num;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.right&lt;=_intervals[i].left)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                temp.right = _intervals[i].right;<span class="comment">//更新已选的最大右边界</span></span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num-ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p style="text-indent:2em">类似的题还有<a herf="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">最少的箭射气球</a>、<a herf="https://leetcode.cn/problems/merge-intervals/">合并区间</a>。这两个题也体现了贪心的思想，但是与区间不相交问题不同，这两个问题是尽可能让区间相交合并，因此在处理上和上题不同。例如最少的箭这道题，一种方式就是按左边界从小到大排序，从左往右选，尽量使相交区间更多，这和上题的顺序不同。在解决这类问题时，要仔细考虑<font color="red">按哪个边界排序，从哪一侧开始遍历</font>。## *5.二分法### 5.1二分查找</p><p style="text-indent:2em">二分查找是基于有序序列的查找算法，该算法从整体区间开始，每次测试当前区间的中间位置，通过判断中间元素与查找元素的大小进行进一步查找。二分查找的高效在于每次去除当前区间中的一半元素，时间复杂度只有<b>O(logn)</b>。以下是最基本的二分查找：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(A[mid]==x) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[mid]&gt;x)&#123;</span><br><span class="line">            right = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">以上的这个查找，是在闭区间[left,right]进行的，最终终止的条件是left&gtright，这是因为left=right的情况要检查最终的唯一位置是否为符合要求的元素。如果是在[left,right)区间进行查找，没有left=right的情况，终止条件就是left&ltright了。</p><p style="text-indent:2em">当问题转变为寻找有序序列中第一个满足条件的元素的位置时，终止条件又不同了。如果是闭区间，终止条件将变为left&ltright，当left=right时就已经找到唯一的位置，且不需要像查找元素一样，判断该元素是否符合要求了，直接返回位置就可以了。类似的，如果是(left,right]这样的区间，终止条件为left+1&ltright，当left+1=right，就找到唯一位置了。以下是解决有序序列的第一个满足某条件的元素的位置的固定解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[left,right]</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> left ,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;<span class="comment">//这里是判断是否找到了唯一位置</span></span><br><span class="line">        mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(条件成立)&#123;</span><br><span class="line">            <span class="comment">//这里满足条件，mid需要保留(可能mid是要找的位置)，所以下面right=mid</span></span><br><span class="line">            right = mid;<span class="comment">//左区间查找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//不满足条件，不需要mid了</span></span><br><span class="line">            left = mid+<span class="number">1</span>;<span class="comment">//右区间查找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;<span class="comment">//上面取到了left=right</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//(left,right]</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> left ,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">        mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(条件成立)&#123;</span><br><span class="line">            right = mid;<span class="comment">//左区间查找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//这里不满足条件也要把左区间的mid留着，因为区间左开，保留mid就相当于左边从left+1开始</span></span><br><span class="line">            left = mid;<span class="comment">//右区间查找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;<span class="comment">//left+1=right，左开，因此要返回right</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">还有一点需要注意的是，mid=(left+right)/2可能发生溢出，因此常常用<b>mid=left+(left-right)/2</b>这条语句代替。下面是<a herf="https://leetcode.cn/problems/search-insert-position/">搜索插入位置</a>的解，其中可以注意到，最后返回的是right+1，这是因为查找时取到了left=right，最后判断结束后，可能产生right=mid-1或left=mid+1，再结合可能插入的几种情况(在整个数组前，中，后)，最终返回right+1。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right = nums.<span class="built_in">size</span>()<span class="number">-1</span>,mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                right = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p style="text-indent:2em">通过以上几题可以看出，while循环的终止条件，循环中最后对left和right的处理，最后返回的位置，都是要根据具体情况考虑的。直接记忆很可能出错，还是需要进行推导。</p><h3 id="5-2二分法拓展"><a href="#5-2二分法拓展" class="headerlink" title="5.2二分法拓展"></a>5.2二分法拓展</h3><p style="text-indent:2em">除了二分查找外，二分法也经常应用于其他问题。最经典的例子是求根号2的近似值，这个问题是一类问题的代表：在给定区间上有单调函数f(x)，求方程f(x)=0的根，用逐步逼近的方式求解答案。### 5.3快速幂</p><p style="text-indent:2em">研究一个以下问题：给定三个正整数a、b、m，求a^b%m。其中a&lt10^9，b&lt10^18，1&ltm&lt10^9。</p><p style="text-indent:2em">这个问题，使用循环是无法处理的，因为数量级非常大，必须采用其他的做法，即快速幂。快速幂基于二分的思想，如下：- 如果b是奇数，a^b = a * a^(b-1)- 如果b是偶数，a^b=a^(b/2) * a^(b/2) </p><p style="text-indent:2em">b是奇数的情况总是可以转换为b是偶数的情况，b是偶数的情况总是可以转化为b/2的情况。以下是快速幂的迭代写法，递归写法同理：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function">LL <span class="title">binaryPow</span><span class="params">(LL a, LL b, LL m)</span></span>&#123;</span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            ans = ans*a%m;</span><br><span class="line">        &#125;</span><br><span class="line">        a=a*a%m;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>## 6.双指针### 6.1双指针</p><p style="text-indent:2em">双指针是利用问题本身与序列的特性，使用两个下标(或指针)对序列进行扫描，以较低的复杂度解决问题。双指针是一种重要的编程技巧。以下是双指针的一个例子：给定一个递增的整数序列和正整数M，求序列中两个位置a，b的数使他们的和为M，输出所有方案。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]+a[j]==m)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,i,j);</span><br><span class="line">        i++;</span><br><span class="line">    j--;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[i]+a[j]&lt;m) i++;</span><br><span class="line">    <span class="keyword">else</span> j--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">以上的解决方式充分利用了序列递增的性质。这种遍历方式不仅常用于数组，也应用于链表的相关问题。</p><h3 id="6-2归并排序"><a href="#6-2归并排序" class="headerlink" title="6.2归并排序"></a>6.2归并排序</h3><p style="text-indent:2em">归并排序是一种基于归并思想的排序方法。对于两路归并排序，原理是将序列两两分组，组内单独排序，再将这些组两两归并，组内再单独排序，直到只剩下一个组为止。以下是递归实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> L1, <span class="type">int</span> R1, <span class="type">int</span> L2, <span class="type">int</span> R2)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = L1, j = L2;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>,temp[maxn];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=R1&amp;&amp;j&lt;=R2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[j])&#123;</span><br><span class="line">            temp[index++] = A[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> temp[index++] = A[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=R1) temp[index++] = A[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=R2) temp[index++] = A[j++];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">        A[L1+i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(A,left,mid);</span><br><span class="line">        <span class="built_in">mergeSort</span>(A,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="built_in">merge</span>(A,left,mid,mid+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">非递归实现的思路是在for循环中进行排序，实现如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(num&lt;n)&#123;<span class="comment">//num是分组元素数/2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i+=num*<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">int</span> left1 = i,right1 = i+num<span class="number">-1</span>,left2=i+num,right2=i+<span class="number">2</span>*num<span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">merge</span>(A,left1,right1,left2,right2);</span><br><span class="line">        &#125;</span><br><span class="line">        num*=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>### 6.3快速排序<p style="text-indent:2em">快速排序是排序算法中平均时间复杂度为O(nlogn)的一种算法。快速排序的思路是：1. 调整序列中的元素，使当前序列最左端的元素在调整后满足左侧所有元素均不超过该元素，右侧所有元素均大于该元素。2. 对该元素的左侧和右侧分别递归进行1的调整，直到当前调整区间的长度不超过1。</p><p style="text-indent:2em">首先实现步骤1，保证左侧元素小于第一个元素，右侧元素大于第一个元素。实现方式是把右边比该元素小的换到左边，再把左边元素大的换到右边，交替进行，当left与right重合时，调整完毕。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = A[left];</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; A[right]&gt;temp) right--;</span><br><span class="line">        A[left] = A[right];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; A[left]&lt;temp) left++;</span><br><span class="line">        A[right] = A[left];</span><br><span class="line">    &#125;</span><br><span class="line">    A[left] = temp;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p style="text-indent:2em">实现1后，快速排序只需要递归完成：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="built_in">Partition</span>(A,left,right);</span><br><span class="line">        <span class="built_in">quickSort</span>(A,left,pos<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(A,pos+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p style="text-indent:2em">快速排序在序列中元素的排列比较随机时效率最高，但是当序列中元素接近有序时，会达到最坏的时间复杂度O(n^2)，产生这种情况的原因在于没有把当前区间划分为两个长度接近的自区间。解决方法是随机选择基准(放在中间的元素)，这样对任意输入数据的期望时间复杂度都能达到O(nlogn)。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">randPartition</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = (<span class="built_in">round</span>(<span class="number">1.0</span>*<span class="built_in">rand</span>()/RAND_MAX*(right-left)+left));</span><br><span class="line">    <span class="built_in">swap</span>(A[p],A[left]);</span><br><span class="line">    <span class="comment">//原Partition的划分过程，不需要任何改变......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure># 第四章 数学问题## 1.简单数学</p><p style="text-indent:2em"><a herf="https://pintia.cn/problem-sets/994805260223102976/problems/994805302786899968">PAT B1019 数字黑洞</a>。这个题其实感觉不算数学问题，只是简单模拟。## 2.最大公约数与最小公倍数**最大公约数**</p><p style="text-indent:2em">求解最大公约数常使用辗转相除法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b) <span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        t = a%b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最小公倍数</strong></p><p style="text-indent:2em">在求得最大公约数的基础上求最小公倍数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a,b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a/(<span class="built_in">gcd</span>(a,b))*b;<span class="comment">//注意避免a*b溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-分数"><a href="#3-分数" class="headerlink" title="3.分数"></a>3.分数</h2><p><strong>分数的表示及化简</strong></p><p style="text-indent:2em">分数可以用结构体表示为假分数，注意由于分子分母的乘除法可能超出int范围，常使用long long型的分子分母。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">fraction</span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> up,down;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">fraction <span class="title">reduction</span><span class="params">(fraction result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(result.down&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        result.up = -result.up;</span><br><span class="line">        reult.down = -result.down;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result.up == <span class="number">0</span>) result.down = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> d = <span class="built_in">gcd</span>(result.up,result.down);</span><br><span class="line">        result.up /= d;</span><br><span class="line">        result.down /= d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分数输出</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">showresult</span><span class="params">(fraction r)</span></span>&#123;</span><br><span class="line">    r = <span class="built_in">reduction</span>(r);</span><br><span class="line">    <span class="keyword">if</span>(r.down == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,r.up);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(r.up)&gt;r.down) <span class="built_in">printf</span>(<span class="string">&quot;%d %d/%d\n&quot;</span>,r.up/r.down,<span class="built_in">abs</span>(r.up)%r.down,r.down);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d/%d\n&quot;</span>,r.up,r.down);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-素数"><a href="#4-素数" class="headerlink" title="4.素数"></a>4.素数</h2><p style="text-indent:2em">素数是除了1和本身以外，不能被其他数整除的一类数。1既不是合数也不是素数。以下是关于素数的两个问题：如何判断给定的正整数是否是素数；如何较快的求出1-n以内的素数。</p><p style="text-indent:2em">先看如何判断一个数是否是素数的问题。假设k是数n的约数，那么n/k也是n的约数，有n*n/k=n，这两个约数一个大于等于根号n，一个小于等于根号n。因此寻找约数只需要在根号n范围内寻找就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isprime</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> sqr = (<span class="type">int</span>)<span class="built_in">sqrt</span>(n*<span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; sqr;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">能够判断素数，求素数表只要一个数一个数判断就可以了，但是这样判断时间复杂度为O(n*根号n)，对于10^5以上时就很慢了。有更高效的算法能够加快求素数表，以下是比较容易理解的埃氏筛法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> manx = <span class="number">101</span>;</span><br><span class="line"><span class="type">int</span> prime[maxn], pnum = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> p[maxn] = &#123;<span class="number">0</span>&#125;;<span class="comment">//表示是否被排除掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_prime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i&lt;maxn;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i] = <span class="literal">false</span>)&#123;</span><br><span class="line">            prime[pnum++] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + i;j &lt; maxn;j += i)&#123;</span><br><span class="line">                p[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-质因子分解"><a href="#5-质因子分解" class="headerlink" title="5.质因子分解"></a>5.质因子分解</h2><p style="text-indent:2em">能够求出质数表，质因子分解只需要一个一个判断是否是因子，不断除去因子就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="comment">//判断素数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> sqr = <span class="built_in">sqrt</span>(<span class="number">1.0</span>*n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;sqr;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求素数表</span></span><br><span class="line"><span class="type">int</span> prime[maxn], pnum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findPrime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; maxn;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isPrime</span>(i)) prime[pnum++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//质因子</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">factor</span> &#123;</span><br><span class="line">    <span class="type">int</span> x,cnt;</span><br><span class="line">&#125;fac[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//质因子分解</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">findPrime</span>();</span><br><span class="line">    <span class="type">int</span> n, num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;l=1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d=&quot;</span>,n);</span><br><span class="line">        <span class="type">int</span> sqr = <span class="built_in">sqrt</span>(n*<span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; pnum&amp;&amp;prime[i] &lt;= sqr;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%prime[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                fac[num].x = i;</span><br><span class="line">                fac[num].cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(n%prime[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    fac[num].cnt++;</span><br><span class="line">                    n /= prime[i];</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n!=<span class="number">1</span>)&#123;</span><br><span class="line">            fac[num].x = n;</span><br><span class="line">            fac[num].cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; num;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,fac[i].x);</span><br><span class="line">            <span class="keyword">if</span>(fac[i].cnt &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;^%d&quot;</span>,fac[i].cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-大整数运算"><a href="#6-大整数运算" class="headerlink" title="6.大整数运算"></a>6.大整数运算</h2><p style="text-indent:2em">对于超出存储精度范围的整数，可以用数组来存储每一位。将整数的高位存储在数组的高位，整数的低位存储在数组的低位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">bign</span>&#123;</span><br><span class="line">    <span class="type">int</span> d[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">bign</span>()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in">sizeof</span>(d));</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">读入时注意高位存在数组高位，这样从低位开始遍历比较顺。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bign <span class="title">change</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;</span><br><span class="line">    bign a;</span><br><span class="line">    a.len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;a.len;i++)&#123;</span><br><span class="line">        bign.d[i] = str[len-i<span class="number">-1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="text-indent:2em">四则运算基本上就是按照运算法则一位一位进行运算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加法</span></span><br><span class="line"><span class="function">bign <span class="title">add</span><span class="params">(bign a,bign b)</span></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;a.len||i&lt;b.len;i++)&#123;</span><br><span class="line">        <span class="type">int</span> temp = a.d[i] + b.d[i] + carry;</span><br><span class="line">        c.d[c.len++] = temp%<span class="number">10</span>;</span><br><span class="line">        carry = temp/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry != <span class="number">0</span>)&#123;</span><br><span class="line">        c.d[c.len++] = carry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//减法</span></span><br><span class="line"><span class="function">bign <span class="title">sub</span><span class="params">(bign a, bign b)</span></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;a.len||i&lt;b.len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.d[i] &lt; b.d[i])&#123;</span><br><span class="line">            a.d[i+<span class="number">1</span>]--;</span><br><span class="line">            a.d[i] += <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c.d[c.len++] = a.d[i] - b.d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.len<span class="number">-1</span>&gt;=<span class="number">1</span>&amp;&amp;c.d[len<span class="number">-1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">        c.len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//乘法</span></span><br><span class="line"><span class="function">bign <span class="title">multi</span><span class="params">(bign a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;a.len;i++)&#123;</span><br><span class="line">        <span class="type">int</span> temp = a.d[i]*b + carry;</span><br><span class="line">        c.[i] = temp%<span class="number">10</span>;</span><br><span class="line">        carry = temp/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(carry!=<span class="number">0</span>)&#123;</span><br><span class="line">        c.d[len++] = carry%<span class="number">10</span>;</span><br><span class="line">        carry/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//除法，r为余数</span></span><br><span class="line"><span class="function">bign <span class="title">divide</span><span class="params">(bign a,<span class="type">int</span> b,&amp;r)</span></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    c.len = a.len;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        r = r*<span class="number">10</span> + a.d[i];</span><br><span class="line">        <span class="keyword">if</span>(r&lt;b) c.d[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            c.d[i] = r/b;</span><br><span class="line">            r = r%b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.len<span class="number">-1</span>&gt;=<span class="number">1</span> &amp;&amp; c.d[c.len<span class="number">-1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">        c.len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第五章-C-标准模版库-STL"><a href="#第五章-C-标准模版库-STL" class="headerlink" title="第五章 C++标准模版库(STL)"></a>第五章 C++标准模版库(STL)</h1><h2 id="1-vector常见用法"><a href="#1-vector常见用法" class="headerlink" title="1.vector常见用法"></a>1.vector常见用法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line">vector&lt;<span class="keyword">typename</span>&gt; name;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">typename</span>&gt; &gt; name;</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line">vector&lt;<span class="keyword">typename</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*(it+i));<span class="comment">//只有vector和string才有这种写法</span></span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it = vi.<span class="built_in">begin</span>();it!=vi.<span class="built_in">end</span>();it++) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*it);<span class="comment">//不支持it&lt;vi.end()</span></span><br><span class="line"><span class="comment">//常用函数</span></span><br><span class="line"><span class="built_in">push_back</span>();</span><br><span class="line"><span class="built_in">pop_back</span>();</span><br><span class="line"><span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">insert</span>(it,x);</span><br><span class="line"><span class="built_in">erase</span>(it);</span><br><span class="line"><span class="built_in">erase</span>(first,last);</span><br></pre></td></tr></table></figure><h2 id="2-set"><a href="#2-set" class="headerlink" title="2.set"></a>2.set</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line">set&lt;<span class="keyword">typename</span>&gt; name;</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line">set&lt;<span class="keyword">typename</span>&gt;::iterator it;</span><br><span class="line"><span class="comment">//常用函数</span></span><br><span class="line"><span class="built_in">insert</span>(x);</span><br><span class="line"><span class="built_in">find</span>(value);</span><br><span class="line"><span class="built_in">erase</span>(it);</span><br><span class="line"><span class="built_in">erase</span>(first,last);</span><br><span class="line"><span class="built_in">erase</span>(value);</span><br><span class="line"><span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure><h2 id="3-string"><a href="#3-string" class="headerlink" title="3.string"></a>3.string</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器和vector一样，以下是常用函数</span></span><br><span class="line"><span class="built_in">insert</span>(pos,string);</span><br><span class="line"><span class="built_in">insert</span>(it,it1,it2);</span><br><span class="line"><span class="built_in">erase</span>(it);</span><br><span class="line"><span class="built_in">erase</span>(first,last);</span><br><span class="line"><span class="built_in">erase</span>(pos,length);</span><br><span class="line"><span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">substr</span>(pos,len);</span><br><span class="line"><span class="built_in">find</span>(str);</span><br><span class="line"><span class="built_in">find</span>(str,pos);<span class="comment">//未找到返回string::npos</span></span><br><span class="line"><span class="built_in">replace</span>(pos,len,str);</span><br><span class="line"><span class="built_in">replace</span>(it1,it2,str);</span><br></pre></td></tr></table></figure><h2 id="4-map"><a href="#4-map" class="headerlink" title="4.map"></a>4.map</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line">map&lt;typename1,typename2&gt; name;</span><br><span class="line">map[key];</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="keyword">for</span>(map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;::iterator it=mp.<span class="built_in">begin</span>();it!=mp.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c %d\n&quot;</span>,it-&gt;first,it-&gt;second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常用函数</span></span><br><span class="line"><span class="built_in">find</span>(key);</span><br><span class="line"><span class="built_in">erase</span>(it);</span><br><span class="line"><span class="built_in">erase</span>(key);</span><br><span class="line"><span class="built_in">erase</span>(first,last);</span><br><span class="line"><span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure><h2 id="5-queue"><a href="#5-queue" class="headerlink" title="5.queue"></a>5.queue</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用函数</span></span><br><span class="line"><span class="built_in">push</span>();</span><br><span class="line"><span class="built_in">front</span>();</span><br><span class="line"><span class="built_in">back</span>();</span><br><span class="line"><span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">empty</span>();</span><br><span class="line"><span class="built_in">size</span>();</span><br></pre></td></tr></table></figure><h2 id="6-priority-queue"><a href="#6-priority-queue" class="headerlink" title="6.priority_queue"></a>6.priority_queue</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用函数</span></span><br><span class="line"><span class="built_in">push</span>();</span><br><span class="line"><span class="built_in">top</span>();</span><br><span class="line"><span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">empty</span>();</span><br><span class="line"><span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//基本数据类型优先级的设置</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//结构体的优先级设置</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fruit</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> price;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (fruit f1, fruit f2)&#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price&lt;f2.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;fruit&gt; q;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(fruit f1,fruit f2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f1.price&gt;f2.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;fruit, vector&lt;fruit&gt;, cmp&gt; q;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络微课笔记</title>
      <link href="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p style="text-indent:2em">在打算开始学习计算机网络时，找到了湖科大一位老师的<a herf="https://www.bilibili.com/video/BV1c4411d7jb?vd_source=463e5b3e4b18e5453477b57388c2e427">计算机网络微课堂</a>课程。这门课程配图要点明确，讲解清晰，且课程也比较简短。因此学习本课程并记录了笔记。</p><span id="more"></span><h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><h3 id="1-因特网概述"><a href="#1-因特网概述" class="headerlink" title="1.因特网概述"></a>1.因特网概述</h3><h3 id="1-1-网络、互联网和因特网"><a href="#1-1-网络、互联网和因特网" class="headerlink" title="1.1 网络、互联网和因特网"></a>1.1 网络、互联网和因特网</h3><ul><li>网络由若干结点和连接这些结点的<strong>链路</strong>组成</li><li>多个网络可以通过路由器互连起来，构成覆盖范围更大的网络，即互联网，因此互联网是<strong>“网络的网络”</strong></li><li>因特网是世界上最大的互连网络</li></ul><blockquote><p>internet：通用名词，泛指多个计算机网络互连而成的网络，在这些网络之间的通信协议可以是任意的</p><p>Internet：专指全球最大的，由众多网络互连而成的计算机网络，采用TCP/IP协议族作为通信规则</p></blockquote><h4 id="1-2-因特网发展的三个阶段"><a href="#1-2-因特网发展的三个阶段" class="headerlink" title="1.2 因特网发展的三个阶段"></a>1.2 因特网发展的三个阶段</h4><ul><li>从单个网络ARPANET向互联网发展</li><li>逐步建成三级结构的因特网(NSFNET)</li><li>逐步形成了多层次ISP结构的因特网</li></ul><blockquote><p>ISP：因特网服务提供者，提供IP地址，有了IP地址就可以接入因特网。常见的ISP包括中国电信，中国移动等。</p></blockquote><p>ISP三层结构：</p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/ISP三层结构.jpg" style="zoom:70%;"></p><h4 id="1-3-因特网的标准化工作"><a href="#1-3-因特网的标准化工作" class="headerlink" title="1.3 因特网的标准化工作"></a>1.3 因特网的标准化工作</h4><ul><li>面向公众</li><li>因特网协会ISOC对因特网进行全面管理</li></ul><h4 id="1-4-因特网的组成"><a href="#1-4-因特网的组成" class="headerlink" title="1.4 因特网的组成"></a>1.4 因特网的组成</h4><ul><li>边缘部分：由所有连接在因特网的<strong>主机</strong>组成，用户直接使用，用来进行通信和资源共享</li><li>核心部分：由大量网络和连接这些网络的<strong>路由器</strong>组成，为边缘部分提供服务</li></ul><h3 id="2-三种交换方式"><a href="#2-三种交换方式" class="headerlink" title="2.三种交换方式"></a>2.三种交换方式</h3><h4 id="2-1-电路交换"><a href="#2-1-电路交换" class="headerlink" title="2.1 电路交换"></a>2.1 电路交换</h4><ul><li>电话交换机接通电话线的方式称为电路交换</li><li>交换：按照某种方式动态分配传输线路的资源</li><li>三个步骤：建立连接-通话-释放连接</li></ul><h4 id="2-2-分组交换"><a href="#2-2-分组交换" class="headerlink" title="2.2 分组交换"></a>2.2 分组交换</h4><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/分组交换.jpg" style="zoom:35%;"></p><h4 id="2-3-报文交换"><a href="#2-3-报文交换" class="headerlink" title="2.3 报文交换"></a>2.3 报文交换</h4><ul><li>与分组交换类似，交换结点采用存储转发方式，但对报文的大小没有限制，主要用于早期的电报通信网</li></ul><h4 id="2-4-三种交换方式的对比"><a href="#2-4-三种交换方式的对比" class="headerlink" title="2.4 三种交换方式的对比"></a>2.4 三种交换方式的对比</h4><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/三种交换的对比.jpg" style="zoom: 33%;"></p><div class="table-container"><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>电路交换</td><td>通信时延小<br>有序传输<br>没有冲突<br>使用范围广<br>实时性强<br><br>控制简单</td><td>建立连接时间长<br>线路独占，使用效率低<br>灵活性差(故障后需要重新建立连接)<br>难以规格化(数据直达，不同规格终端难以通信)</td></tr><tr><td>报文交换</td><td>无需建立连接<br>动态分配线路<br>提高线路可靠性(某条路径故障，选择另一条路径)<br>提高线路利用率<br>提供多目标服务</td><td>引起转发时延<br>需要较大的存储缓存空间<br>需要额外信息量(目标地址等)</td></tr><tr><td>分组交换</td><td>无需建立连接<br>线路利用率高<br>简化存储管理(相对于报文交换，分组长度固定)<br>加速传输(分组的转发和存储可同时进行)<br>减少出错概率和重发数据量</td><td>引起转发时延<br>需要传输额外数据<br><br>失序，丢失，重复分组等问题<br>虚电路存在呼叫建立，数据传输和虚电路释放三个过程</td></tr></tbody></table></div><h3 id="3-计算机网络的定义和分类"><a href="#3-计算机网络的定义和分类" class="headerlink" title="3.计算机网络的定义和分类"></a>3.计算机网络的定义和分类</h3><h4 id="3-1-计算机网络的定义"><a href="#3-1-计算机网络的定义" class="headerlink" title="3.1 计算机网络的定义"></a>3.1 计算机网络的定义</h4><ul><li>最简单的定义：<strong>互连</strong>的，<strong>自洽</strong>的计算机的<strong>集合</strong></li><li>较好的定义：通用的，可编程的硬件互连而成，可用来传送多种不同类型的数据能支持广泛的和日益增长的应用</li></ul><h4 id="3-2-分类"><a href="#3-2-分类" class="headerlink" title="3.2 分类"></a>3.2 分类</h4><ul><li>按交换技术分类：电路交换/报文交换/分组交换</li><li>按使用者分类：公用网/专用网</li><li>按传输介质分类：有线/无线网络</li><li>按覆盖范围分类：广域网WAN/城域网MAN/局域网LAN/个域网PAN</li><li>按拓扑结构分类：总线型/星型/环形/网状型</li></ul><h3 id="4-计算机网络的性能指标"><a href="#4-计算机网络的性能指标" class="headerlink" title="4.计算机网络的性能指标"></a>4.计算机网络的性能指标</h3><h4 id="4-1-速率"><a href="#4-1-速率" class="headerlink" title="4.1 速率"></a>4.1 速率</h4><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/%E9%80%9F%E7%8E%87.jpg" class><h4 id="4-2-带宽"><a href="#4-2-带宽" class="headerlink" title="4.2 带宽"></a>4.2 带宽</h4><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/%E5%B8%A6%E5%AE%BD.jpg" class><h4 id="4-3-吞吐量"><a href="#4-3-吞吐量" class="headerlink" title="4.3 吞吐量"></a>4.3 吞吐量</h4><ul><li>吞吐量表示单位时间内通过某个网络(或信道、接口)的数据量。</li><li>吞吐量受网络的带宽或额定速率的限制</li></ul><h4 id="4-4-时延"><a href="#4-4-时延" class="headerlink" title="4.4 时延"></a>4.4 时延</h4><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/时延.jpg" style="zoom:33%;"></p><h4 id="4-5-时延带宽积"><a href="#4-5-时延带宽积" class="headerlink" title="4.5 时延带宽积"></a>4.5 时延带宽积</h4><ul><li>传播时延和带宽的乘积：即连续发送数据时，第一个字节到达终点时，发送端已经发送了时延带宽积的字节</li></ul><h4 id="4-6-往返时间RTT"><a href="#4-6-往返时间RTT" class="headerlink" title="4.6 往返时间RTT"></a>4.6 往返时间RTT</h4><ul><li>双向交互所需的时间</li></ul><h4 id="4-7-利用率"><a href="#4-7-利用率" class="headerlink" title="4.7 利用率"></a>4.7 利用率</h4><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/%E5%88%A9%E7%94%A8%E7%8E%87.jpg" class><h4 id="4-8-丢包率"><a href="#4-8-丢包率" class="headerlink" title="4.8 丢包率"></a>4.8 丢包率</h4><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/%E4%B8%A2%E5%8C%85%E7%8E%87.jpg" class><p><strong>8个性能指标总结如下：</strong></p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/前4个性能指标.jpg" style="zoom:90%;"></p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/4%E4%B8%AA%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87.jpg" class><h3 id="5-计算机网络体系结构"><a href="#5-计算机网络体系结构" class="headerlink" title="5.计算机网络体系结构"></a>5.计算机网络体系结构</h3><h4 id="5-1-常见结构"><a href="#5-1-常见结构" class="headerlink" title="5.1 常见结构"></a>5.1 常见结构</h4><p><strong>OSI参考模型</strong></p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/OSI.jpg" style="zoom:50%;"></p><p><strong>TCP</strong>/<strong>IP协议模型</strong></p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/TCPip%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.jpg" class><p><strong>原理体系结构</strong></p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/原理体系结构.jpg" style="zoom:50%;"></p><h4 id="5-2-分层必要性"><a href="#5-2-分层必要性" class="headerlink" title="5.2 分层必要性"></a>5.2 分层必要性</h4><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/原理体系结构分层.jpg" style="zoom:80%;"></p><h4 id="5-3-分层思想举例"><a href="#5-3-分层思想举例" class="headerlink" title="5.3 分层思想举例"></a>5.3 分层思想举例</h4><h4 id="5-4-专用术语"><a href="#5-4-专用术语" class="headerlink" title="5.4 专用术语"></a>5.4 专用术语</h4><ul><li>实体：任何可发送或接收信息的硬件或软件进程</li><li>对等实体：通信双方的相同层次</li><li>协议：逻辑通信的规则集合</li><li>协议三要素：语法（格式），语义，同步</li><li>服务访问点：同一系统中相邻两层的实体交换信息的逻辑接口</li><li>协议数据单元PDU：对等层次之间传送的数据包</li><li>服务数据单元SDU：统一系统内，层与层之间交换的数据包</li></ul><h2 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h2><h3 id="1-物理层协议的主要任务"><a href="#1-物理层协议的主要任务" class="headerlink" title="1.物理层协议的主要任务"></a>1.物理层协议的主要任务</h3><ul><li>考虑怎样才能在连接各种计算机的传输媒体上传输数据比特流</li></ul><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/物理层主要任务.jpg" style="zoom:50%;"></p><h3 id="2-传输媒体"><a href="#2-传输媒体" class="headerlink" title="2.传输媒体"></a>2.传输媒体</h3><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/物理层传输媒体.jpg" style="zoom:40%;"></p><p><strong>双绞线</strong>：</p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/双绞线.jpg" style="zoom:50%;"></p><p><strong>光纤</strong>：</p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/光纤.jpg" style="zoom:50%;"></p><p><strong>微波</strong>：</p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/微波.jpg" style="zoom:80%;"></p><h3 id="3-传输方式"><a href="#3-传输方式" class="headerlink" title="3.传输方式"></a>3.传输方式</h3><ul><li>串行传输/并行传输</li><li>同步传输/异步传输</li><li>单工/半双工/全双工通信</li></ul><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/传输方式-同步异步.jpg" style="zoom:60%;"></p><h3 id="4-编码与调制"><a href="#4-编码与调制" class="headerlink" title="4.编码与调制"></a>4.编码与调制</h3><p><strong>编码</strong></p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/编码与调制1.jpg" style="zoom:50%;"></p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/编码与调制-常用编码.jpg" style="zoom:50%;"></p><p><strong>调制</strong></p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/调制1.jpg" style="zoom:50%;"></p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/调制2.jpg" style="zoom:50%;"></p><h3 id="5-信道的极限容量"><a href="#5-信道的极限容量" class="headerlink" title="5.信道的极限容量"></a>5.信道的极限容量</h3><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/信道极限容量.jpg" style="zoom:80%;"></p><h2 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/数据链路概述.jpg" style="zoom:80%;"></p><p><strong>三个重要问题</strong>：</p><ul><li>封装成帧</li><li>差错检测</li><li>可靠传输</li></ul><h3 id="2-封装成帧"><a href="#2-封装成帧" class="headerlink" title="2.封装成帧"></a>2.封装成帧</h3><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/封装成帧.jpg" style="zoom:80%;"></p><ul><li>字节填充：在数据部分出现的帧定界符前添加转义字节</li><li>比特填充：在数据部分每5个1后添加一个0（帧尾为6个1，即修改成和帧尾不同）</li></ul><h3 id="3-差错检测"><a href="#3-差错检测" class="headerlink" title="3.差错检测"></a>3.差错检测</h3><ul><li>奇偶校验：漏检率高，一般不采用</li><li>循环校验CRC：</li></ul><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/CRC.jpg" style="zoom:80%;"></p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/CRC生成多项式.jpg" style="zoom:80%;"></p><p><strong>例</strong>：</p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/CRC例题.jpg" style="zoom:80%;"></p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/差错检测补.jpg" style="zoom:80%;"></p><h3 id="4-可靠传输"><a href="#4-可靠传输" class="headerlink" title="4.可靠传输"></a>4.可靠传输</h3><p style="text-indent:2em">一般情况下，有线链路的误码率比较低，为了减小开销，不要求数据链路层向上层提供可靠传输服务；无线链路易受干扰，误码率较高，因此要求数据链路层必须向上层提供可靠传输</p><p style="text-indent:2em">比特差错只是传输差错的一种，传输差错还包括分组丢失，分组时序，分组重复。</p><h3 id="5-可靠传输的实现机制"><a href="#5-可靠传输的实现机制" class="headerlink" title="5.可靠传输的实现机制"></a>5.可靠传输的实现机制</h3><p><strong>停止-等待协议SW</strong></p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/停止等待协议.jpg" style="zoom:80%;"></p><p><strong>回退N帧协议GBN</strong></p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/GBN.jpg" style="zoom:80%;"></p><p><strong>选择重传协议SR</strong></p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/SR.jpg" style="zoom:80%;"></p><h3 id="6-点对点PPP协议"><a href="#6-点对点PPP协议" class="headerlink" title="6.点对点PPP协议"></a>6.点对点PPP协议</h3><ul><li>点对点协议PPP是目前使用最广泛的点对点数据链路层协议</li></ul><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/PPP.jpg" style="zoom:100%;"></p><h3 id="7-媒体接入控制"><a href="#7-媒体接入控制" class="headerlink" title="7.媒体接入控制"></a>7.媒体接入控制</h3><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/MAC.jpg" style="zoom:80%;"></p><h4 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a><strong>静态划分信道</strong></h4><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/静态划分信道.jpg" style="zoom:80%;"></p><h4 id="随机接入"><a href="#随机接入" class="headerlink" title="随机接入"></a>随机接入</h4><p><strong>CSMA/CD协议：</strong></p><p>现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA/CD协议</p><ul><li>CSMA/CD协议的工作原理<ul><li>多址接入MA：多个主机连接在一条总线上，竞争使用总线</li><li>载波监听CS：发送帧前先检测总线，总线空闲96比特时间则发送，否则持续检测是否空闲</li><li>碰撞检测CD：边发送边检测碰撞，若检测到碰撞则停止发送，退避一段随机时间后重新发送</li></ul></li><li>使用CSMA/CD协议的以太网争用期(碰撞窗口)<ul><li>发送帧的主机最多经过以太网端到端往返传播时延2t时间，就可检测到碰撞，这个时间称为争用期</li><li>争用期内没有检测到碰撞则确定不会发生碰撞</li><li>以太网规定2t取值为512比特时间</li></ul></li><li>使用CSMA/CD协议的以太网的最小帧长和最大帧长<ul><li>最小帧长 = 争用期*信道带宽(10Mbps的以太网，最小帧长为64字节)</li><li>最小帧长保证了主机可在帧发送完成前检测到该帧是否发生了碰撞</li><li>为了防止主机长时间占用总线，以太网的帧长有限制(V2的MAC帧最大长度为1518字节)</li></ul></li><li>CSMA/CD协议使用的截断二进制指数退避算法<ul><li>随机退避时间 = 争用期2t * 随机数r，r从离散整数集合{0,1…,(2^k-1)}中随机取一个，k = Min[重传次数，10]</li><li>重传16次仍不成功时，表示同时又太多主机打算发送数据，此时丢弃该帧并向高层报告</li></ul></li><li>以太网的信道利用率<ul><li>以太网端到端的距离受到限制</li><li>以太网帧的长度应尽量长些</li></ul></li></ul><script type="math/tex; mode=display">Smax↑ = \frac{1}{1+a↓}\\a↓ = \frac{t↓}{T0↑}</script><p><strong>CSMA/CA(碰撞避免)协议：</strong></p><ul><li>802.11无线局域网在MAC层使用CSMA/CA协议，尽量减小碰撞发送的概率。不能使用CSMA/CD协议的原因是在无线局域网中无法实现碰撞检测(隐蔽站问题)。在使用CSMA/CA协议的同时，还使用停止等待协议来实现可靠传输。</li></ul><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/隐蔽站问题.jpg" style="zoom:40%;"></p><ul><li>为了尽可能避免碰撞，CSMA/CA协议的退避算法不同，且信道从忙态转为空闲时，都要执行退避算法。<ul><li>站点为退避计时器设置一个随机退避时间，减小到零开始发送数据</li><li>退避计时器未减小到零时信道转为忙状态，就冻结退避计时器，重新等待信道空闲，再经过DIFS后，启动退避计时器</li></ul></li></ul><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/退避冻结.jpg" style="zoom:80%;"></p><ul><li>802.11标准规定，所有的站在完成发送后，必须再等待一段帧间间隔(IFS)时间才能发送下一帧。帧间间隔的长短取决于该站要发送的帧的优先级。<ul><li>SIFS：短帧间间隔，分隔开属于一次对话的各帧(ACK，C)</li><li>DCF：比SIFS长的多，用来发送数据帧和管理帧</li></ul></li></ul><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/CSMACA.jpg" style="zoom:60%;"></p><ul><li>在802.11无线局域网的MAC帧首部中有一个持续期字段，用于填入本帧结束后还要占用信道多久时间，其他站点通过该字段实现虚拟载波监听</li><li>802.11标准允许要发送数据的站点对信道进行预约，先发送请求发送RTS帧，收到响应允许发送CTS帧后，发送数据帧。RTS和CTS帧很短，碰撞概率和开销很小，因此付出很小的代价进行信道预约是值得的。</li></ul><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/RTS.jpg" style="zoom:80%;"></p><h3 id="8-MAC地址，IP地址与ARP协议"><a href="#8-MAC地址，IP地址与ARP协议" class="headerlink" title="8.MAC地址，IP地址与ARP协议"></a>8.MAC地址，IP地址与ARP协议</h3><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><ul><li>多个主机连接在同一个广播信道上，每个主机必须有一个唯一的标识，即一个数据链路层地址</li><li>在每个主机发送的帧中必须携带标识发送主机和接收主机的地址，这类地址用于媒体接入控制(MAC)，因此这类地址被称为<font color="blue">MAC地址</font>(也被称为硬件地址或物理地址)。尽管可能被称为物理地址，<font color="red">MAC地址不属于物理层</font>。</li><li>一般情况下，用户主机包含两个网络适配器：有线局域网适配器(有线网卡),h和无线局域网适配器(无线网卡)。每个网络适配器都有一个全球唯一的MAC地址，而交换机和路由器往往拥有更多的网络接口，拥有更多的MAC地址。<font color="red">MAC地址是对网络上各接口的唯一标识，而不是对网络上设备的唯一标识</font>。</li></ul><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/MAC格式.jpg" style="zoom:80%;"></p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/MAC地址类型.jpg" style="zoom:80%;"></p><h4 id="IP地址-网络层"><a href="#IP地址-网络层" class="headerlink" title="IP地址(网络层)"></a>IP地址(网络层)</h4><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/IP地址.jpg" style="zoom:80%;"></p><h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><ul><li>地址解析协议ARP将IP地址解析为MAC地址。</li><li>源主机在自己的<font color="red">ARP高速缓存表</font>中查找目的主机的IP地址对应的MAC地址，若未找到则发送<font color="red">ARP请求(封装在广播MAC帧中)</font>。</li><li>目的主机收到ARP请求后，将源主机的IP地址与MAC地址存入ARP高速缓存表中，然后给源主机发送<font color="red">ARP响应</font>(包含目的主机的IP地址和MAC地址)。</li><li>ARP的作用范围：<font color="red">逐段链路或逐个网络</font>。</li><li>除ARP请求和响应外，ARP还有其他类型的报文(如检测IP地址冲突的无故ARP)。</li><li>ARP没有安全验证机制，存在ARP欺骗(攻击)问题。</li></ul><h3 id="9-集线器与交换机"><a href="#9-集线器与交换机" class="headerlink" title="9.集线器与交换机"></a>9.集线器与交换机</h3><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/集线器与交换机.jpg" style="zoom:80%;"></p><h3 id="10-以太网交换机自学习和转发帧的流程"><a href="#10-以太网交换机自学习和转发帧的流程" class="headerlink" title="10.以太网交换机自学习和转发帧的流程"></a>10.以太网交换机自学习和转发帧的流程</h3><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/交换机自学习.jpg" style="zoom:80%;"></p><h3 id="11-以太网交换机的生成树协议STP"><a href="#11-以太网交换机的生成树协议STP" class="headerlink" title="11.以太网交换机的生成树协议STP"></a>11.以太网交换机的生成树协议STP</h3><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/STP.jpg" style="zoom:80%;"></p><h3 id="12-虚拟局域网VLAN"><a href="#12-虚拟局域网VLAN" class="headerlink" title="12.虚拟局域网VLAN"></a>12.虚拟局域网VLAN</h3><h4 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a>虚拟局域网VLAN</h4><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/VLAN.jpg" style="zoom:80%;"></p><h4 id="虚拟局域网VLAN的实现"><a href="#虚拟局域网VLAN的实现" class="headerlink" title="虚拟局域网VLAN的实现"></a>虚拟局域网VLAN的实现</h4><p><strong>IEEE 802.1Q帧</strong></p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/VLAN1Q.jpg" style="zoom:80%;"></p><p><strong>交换机的端口</strong></p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/ACCESS.jpg" style="zoom:80%;"></p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/TRUNK.jpg" style="zoom:80%;"></p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/HYBRID.jpg" style="zoom:80%;"></p><h2 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h3><ul><li>网络层的主要任务是实现网络互连，实现数据包在各网络间的传输</li><li>要实现网络层任务，需要解决以下问题：<ul><li>网络层向运输层提供怎样的服务(可靠/不可靠传输)</li><li>网络层寻址问题</li><li>路由选择问题</li></ul></li></ul><h3 id="2-网络层提供的两种服务"><a href="#2-网络层提供的两种服务" class="headerlink" title="2.网络层提供的两种服务"></a>2.网络层提供的两种服务</h3><ul><li>面向连接的虚电路服务<ul><li>可靠通信由网络来保证</li><li>必须建立网络层的连接，即<font color="red">虚电路VC</font></li><li>通信双方沿着已建立的虚电路发送分组</li><li>目的主机的地址仅在连接建立时使用，之后每个分组的首部只需要携带虚电路的编号</li><li>通信结束后需要释放虚电路</li><li>很多广域分组交换网都使用面向连接的虚电路服务(曾经的X.25和已经逐渐过时的帧中继FR，异步传输模式ATM等)</li></ul></li><li>无连接的数据报服务<ul><li>可靠通信由用户主机来保证</li><li>不需要建立网络层连接</li><li>每个分组可走不同路径</li><li>首部必须携带目的主机的完整地址</li><li>传输分组可能误码，丢失，重复和失序，网络本身不提供端到端的可靠服务</li></ul></li></ul><h3 id="3-IPV4地址"><a href="#3-IPV4地址" class="headerlink" title="3.IPV4地址"></a>3.IPV4地址</h3><h4 id="分类编址的IPV4地址"><a href="#分类编址的IPV4地址" class="headerlink" title="分类编址的IPV4地址"></a>分类编址的IPV4地址</h4><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/分类编址的IP.jpg" style="zoom:100%;"></p><h4 id="划分子网的IPV4地址"><a href="#划分子网的IPV4地址" class="headerlink" title="划分子网的IPV4地址"></a>划分子网的IPV4地址</h4><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/划分子网的IP.jpg" style="zoom:80%;"></p><h4 id="无分类编址的IPV4地址"><a href="#无分类编址的IPV4地址" class="headerlink" title="无分类编址的IPV4地址"></a>无分类编址的IPV4地址</h4><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/无分类编址IPV4.jpg" style="zoom:80%;"></p><h4 id="IPV4地址的应用规划"><a href="#IPV4地址的应用规划" class="headerlink" title="IPV4地址的应用规划"></a>IPV4地址的应用规划</h4><p><strong>定长子网掩码</strong>FLSM</p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/定长子网掩码.jpg" style="zoom:80%;"></p><p><strong>变长子网掩码</strong>VLSM</p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/变长子网掩码.jpg" style="zoom:80%;"></p><h3 id="4-IP数据报的发送与转发"><a href="#4-IP数据报的发送与转发" class="headerlink" title="4.IP数据报的发送与转发"></a>4.IP数据报的发送与转发</h3><ul><li><p>主机发送IP数据报：判断目的主机是否与自己在同一个网络(将目的IP与子网掩码相与)，进行直接交付或通过<font color="red">默认网关</font>(路由器)间接交付</p></li><li><p>路由器转发IP数据报：检查IP数据报首部是否出错，无错则根据目的地址在路由表中查找匹配的条目进行转发</p></li></ul><h3 id="5-静态路由配置"><a href="#5-静态路由配置" class="headerlink" title="5.静态路由配置"></a>5.静态路由配置</h3><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/静态路由配置.jpg" style="zoom:80%;"></p><h3 id="6-路由选择协议"><a href="#6-路由选择协议" class="headerlink" title="6.路由选择协议"></a>6.路由选择协议</h3><ul><li>静态路由选择：人工配置，不能适应网络状态变化，一般只在小规模网络中采用</li><li>动态路由选择：路由器通过路由选择协议自动获取路由信息，能适应网络状态变化，适用于大规模网络</li></ul><p><strong>常见的路由选择协议</strong></p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/常见路由协议.jpg" style="zoom:80%;"></p><h4 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h4><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/RIP.jpg" style="zoom:100%;"></p><h4 id="开放最短路径优先OSPF"><a href="#开放最短路径优先OSPF" class="headerlink" title="开放最短路径优先OSPF"></a>开放最短路径优先OSPF</h4><ul><li>开放最短路径优先OSPF是公开的使用最短路径算法SPF的协议，算法保证<font color="red">不会产生路由环路</font></li><li>OSPF<font color="red">基于链路状态</font>。链路状态指路由器和哪些路由器相邻，以及相应链路的<font color="red">代价</font>(费用，距离，时延，带宽等，由网络管理人员决定)</li><li>OSPF相邻路由器之间通过交换<font color="red">问候(Hello)分组</font>，建立和维护邻居关系</li></ul><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/OSPF邻居.jpg" style="zoom:100%;"></p><ul><li>使用OSPF的每个路由器都会产生<font color="red">链路状态通告LSA</font>，LSA包括：直连网络的链路状态信息；邻居路由器的链路状态信息</li><li>LSA被封装在<font color="red">链路状态更新分组LSU</font>中，采用洪泛法发送</li><li>使用OSPF的每个路由器都有一个<font color="red">链路状态数据库LSDB</font>，用于存储LSA</li><li>通过各路由器洪范发送封装LSA的LSU分组，各路由器的LSDB最终状态将达到一致</li><li>使用OSPF的各路由器基于LSDB进行最短路径优先SPF计算，构建出各自到达其他路由器的最短路径，即各自的路由表</li><li><p>OSPF有以下五种分组类型</p><ul><li>问候分组：发现和维护邻居路由器的可达性</li><li>数据库描述分组：向邻居路由器给出自己的链路状态数据库中的所有链路状态项目的摘要信息</li><li>链路状态请求分组：向邻居路由器请求发送某些链路状态项目的详细信息</li><li>链路状态更新分组：路由器使用这种分组将其链路状态进行洪泛发送，即用洪泛法对全网更新链路状态</li><li>链路状态确认分组：对链路状态更新分组的确认分组</li></ul></li><li><p>OSPF在多点接入网络应用：</p></li></ul><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/OSPF多点接入.jpg" style="zoom:100%;"></p><ul><li>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域</li></ul><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/OSPF区域.jpg" style="zoom:100%;"></p><h4 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h4><ul><li>外部网关协议EGP在不同自治系统之间选择一条能够到达目的网络且比较好的路由，由于个自治系统度量路由的代价不同，无法用代价衡量最佳路由，因此EGP不一定要找到一条最佳路由</li><li>配置BGP时，每个自治系统的管理员选择至少一个路由作为该自治系统的<font color="red">BGP发言人</font></li><li>不同自治系统的BGP发言人要交换路由信息，必须先建立<font color="red">TCP连接</font>，端口号为179<ul><li>在此TCP连接上交换BGP报文以建立<font color="red">BGP会话</font></li><li>利用BGP会话交换路由信息(增加撤销路由，报告出错情况等)</li><li>使用TCP连接交换路由信息的两个BGP发言人，彼此称为对方的<font color="red">临站/对等站</font></li></ul></li><li>BGP发言人交换<font color="red">网络可达性的信息</font>(到达某个网络要经过的一系列自治系统)</li><li>BGP发言人交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的好的路由</li><li>BGP-4有以下四种报文<ul><li>OPEN报文：与相邻的另一个BGP发言人建立关系，使通信初始化</li><li>UPDATE报文：用来通告某一路由的信息，以及列出要撤销的多条路由</li><li>KEEPALIVE保活报文：用来周期性证实临站的连通性</li><li>NOTIFICATION报文：用来发送检测到的差错</li></ul></li></ul><h3 id="7-IPv4数据报的首部格式"><a href="#7-IPv4数据报的首部格式" class="headerlink" title="7.IPv4数据报的首部格式"></a>7.IPv4数据报的首部格式</h3><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/IP数据报首部格式.jpg" style="zoom:100%;"></p><ul><li>版本：表示IP协议的版本</li><li>首部长度：4字节，表示IP数据报首部的长度，该字段的取值以4字节为单位，最小取值为5，表示只有20字节固定部分，最大取值为15，表示IP数据报首部包含20字节固定部分和最大40字节可变部分</li><li>可选字段：用于支持排错，测量，安全等，由于长度不定增加了路由器处理IP数据报的开销，实际上很少使用</li><li>填充：填充保证IP数据报首部为4字节的整数倍</li><li>区分服务字段：用数值提供不同等级的服务质量，一般情况下都不使用该字段</li><li>总长度字段：表示IP数据报总长度(首部+数据载荷)</li><li>标识，标志，片偏移用于IP数据报分片。当IP数据报长度超过帧的数据载荷的最大长度(最大传输单元MTU)，无法封装，需要分片<ul><li>标识：同一个数据报的各分片数据报有相同标识。IP软件维持计数器，每产生一个数据报，计数加1，并将该值赋给标识字段</li><li>标志：3bit<ul><li>DF位：1表示允许分片</li><li>MF位：1表示还有分片，0表示这是最后一个分片</li><li>保留位：必须为0</li></ul></li><li>片偏移：以8个字节为单位。指出分片数据报的数据载荷部分偏移其原数据报的位置</li></ul></li><li>生存时间TTL：最初以秒为单位，最大生存周期为255秒，在路由器转发时减去在本路由器上耗费的时间。现在以跳数为单位，路由器转发时-1。</li><li>协议字段：指明数据部分是何种协议数据单元<ul><li>1：ICMP报文</li><li>6：TCP报文</li></ul></li><li>首部检验和：使用因特网检验和检测首部在传输过程中是否出现差错。由于IP层不提供可靠传输服务，因此IPv6中，路由器不再计算首部校验和。</li></ul><h3 id="8-网际控制报文协议ICMP"><a href="#8-网际控制报文协议ICMP" class="headerlink" title="8.网际控制报文协议ICMP"></a>8.网际控制报文协议ICMP</h3><ul><li>为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了网际控制报文协议ICMP</li><li>主机或路由器使用ICMP来发送<font color="red">差错报告报文和询问报文</font>。</li><li><font color="red">ICMP数据报封装在IP数据报</font>中发送</li><li><strong>ICMP差错报文</strong>共有以下五种：<ul><li>终点不可达：当路由器或主机不能交付数据报时，就向源点发送终点不可达报文。具体可再根据ICMP的代码字段细分为目的网络不可达、目的主机不可达、目的协议不可达、目的端口不可达、目的网络未知等13种错误。</li><li>源点抑制：当路由器或主机由于拥塞而丢弃数据报时，向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢</li><li>时间超过：当路由器收到一个目的IP地址不是自己的IP数据报，会将其生存时间TTL-1，若为0则丢弃该IP数据报，并向源点发送时间超过报文。另外，终点在预规定时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，也会发送时间超过报文。</li><li>参数问题：当路由器或目的主机收到IP数据报后，若首部检验和字段发现首部在传输过程中出现了误码，就丢弃该数据报，并向源点发送参数问题报文。</li><li>改变路由(重定向)：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器(可通过的更好路由)。</li></ul></li><li>以下情况不应发送ICMP差错报告报文<ul><li>对ICMP差错报告报文不再发送ICMP差错报告报文</li><li>对第一个分片的数据报片的后续数据报片不再发送ICMP差错报告报文</li><li>对具有多播地址的数据报都不发送ICMP差错报告报文</li><li>对具有特殊地址的数据报(如127.0.0.0或0.0.0.0)的数据包不发送ICMP差错报告报文</li></ul></li><li><strong>ICMP询问报文</strong>有以下两种：<ul><li>回送请求和回答：ICMP回送请求报文是由主机或路由器向一个特定目的主机发送的询问。收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。这种询问报文用来测试目的站是否可达及了解有关状态。</li><li>时间戳请求和回答：请求某个主机或路由器回答当前的日期和时间。这种报文用来进行时钟同步和测量时间。</li></ul></li><li>ICMP应用举例：<ul><li>分组网间探测PING<ul><li>用来测试主机或路由器间的连通性</li><li>应用层直接使用网际层的ICMP(没有通过运输层的TCP或UDP)</li><li>使用ICMP回送请求和回答报文</li></ul></li><li>跟踪路由traceroute<ul><li>用来测试IP数据报从源主机到达目的主机要经过哪些路由器</li><li>Windows：tracert命令；应用层直接使用网际层ICMP；使用了ICMP回送请求和回答报文</li><li>UNIX：traceroute命令；在运输层使用UDP协议；仅使用ICMP差错报告报文</li></ul></li></ul></li></ul><h3 id="9-虚拟专用网VPN与网络地址转换NAT"><a href="#9-虚拟专用网VPN与网络地址转换NAT" class="headerlink" title="9.虚拟专用网VPN与网络地址转换NAT"></a>9.虚拟专用网VPN与网络地址转换NAT</h3><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/VPN&NAT.jpg" style="zoom:100%;"></p><h2 id="第五章-运输层"><a href="#第五章-运输层" class="headerlink" title="第五章 运输层"></a>第五章 运输层</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1.概述"></a>1.概述</h3><ul><li>物理层、数据链路层以及网络层共同解决了将主机通过异构网络互联起来的问题，实现了<strong>主机到主机的通信</strong></li><li>实际上在计算机网络中进行通信的真正实体是位于<strong>通信两端主机中的进程</strong></li><li><strong>为运行在不同主机上的应用进程提供直接的通信服务是运输层的任务</strong>，运输层协议又称为端到端协议</li><li>根据应用需求的不同，运输层为应用层提供了两种不同的运输协议：<font color="red">面向连接的TCP</font>和<font color="red">无连接的UDP</font>&gt;，这两种协议是运输层讨论的主要内容</li></ul><h3 id="2-运输层端口号、复用与分用的概念"><a href="#2-运输层端口号、复用与分用的概念" class="headerlink" title="2.运输层端口号、复用与分用的概念"></a>2.运输层端口号、复用与分用的概念</h3><ul><li>运行在计算机上的进程使用进程标识符PID来标志，但不同操作系统使用不同格式的进程标识符。为了使运行不同操作系统的计算机的应用进程之间能够进行网络通信，必须使用统一的方法对TCP/IP体系的应用进程进行标识</li><li>TCP/IP体系的运输层使用<font color="red">端口号</font>区分应用层的不同应用进程<ul><li>端口号16bit表示，取值范围0-65535<ul><li>熟知端口号：0-1023，用于TCP/IP体系中最重要的应用协议，例如FTP使用21/20，HTTP使用80DNS使用53</li><li>登记端口号：1024-49151，没有熟知端口号的应用程序使用，必须在IANA按规定登记</li><li>短暂端口号：49152-65335.留给客户进程选择暂时使用。当服务器进程收到用户进程的报文时，就知道客户进程使用的动态端口号。通信结束后该端口号可供其他客户进程使用</li></ul></li><li>端口号只有本地意义，即端口号只是为了标识本计算机应用层中的各进程，不同计算机中的相同端口号是没有联系的</li></ul></li><li>发送方的复用和接收方的分用</li></ul><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/复用分用.jpg" style="zoom:100%;"></p><ul><li>TCP/IP体系的应用层常用协议所使用的运输层熟知端口号</li></ul><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/熟知端口号.jpg" style="zoom:100%;"></p><h3 id="3-UDP和TCP"><a href="#3-UDP和TCP" class="headerlink" title="3.UDP和TCP"></a>3.UDP和TCP</h3><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/UDP与TCP.jpg" style="zoom:100%;"></p><h3 id="4-TCP的流量控制"><a href="#4-TCP的流量控制" class="headerlink" title="4.TCP的流量控制"></a>4.TCP的流量控制</h3><ul><li>流量控制的目的是让发送方的发送频率不要太快，要让接收方来得及接收</li><li>利用<font color="red">滑动窗口</font>机制可以方便地在TCP连接上实现对发送方的流量控制<ul><li>TCP接收方利用自己的接收窗口的大小来限制发送方发送窗口的大小</li><li>TCP接收方接收数据后回发TCP确认报文段(ACK=1)，并在TCP报文段首部的确认号字段(ack)进行累计确认</li><li>TCP发送方收到接收方的<font color="red">零窗口通知</font>后，应启动持续计时器(避免更改窗口的小的报文丢失，导致发送窗口保持为0，接收窗口等待的死锁情况)，持续计时器超时后，向接收方发送<font color="red">零窗口探测报文</font>(该报文也有计时器)</li></ul></li></ul><h3 id="5-TCP的拥塞控制"><a href="#5-TCP的拥塞控制" class="headerlink" title="5.TCP的拥塞控制"></a>5.TCP的拥塞控制</h3><ul><li>在某段时间，若对网络中某一资源(带宽，交换结点中的缓存和处理机等)的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况就叫做拥塞</li><li>若出现拥塞而不进行控制，整个网络的吞吐量将随输入地负荷的增大而下降</li></ul><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/拥塞.jpg" style="zoom:100%;"></p><ul><li>发送方维护一个叫做<font color="red">拥塞窗口cwnd</font>的状态变量，其值取决于网络的拥塞程度，并动态变化<ul><li>拥塞窗口cwnd的维护原则：只要没有出现拥塞，拥塞窗口就增大一些，只要网络出现拥塞，拥塞窗口就减小</li><li>判断出现网络拥塞的依据：没有按时收到应当到达的确认报文(即发生<font color red>超时重传</font>)</li></ul></li><li>发送方将拥塞窗口作为发送窗口swnd，即swnd=cwnd</li><li>维护一个慢开始门限<font color="red">ssthresh</font>状态变量<ul><li>当cwnd&lt;ssthresh，使用慢开始算法</li><li>当cwnd&gt;ssthresh，停止使用慢开始算法，使用拥塞避免算法</li><li>当cwnd=ssthresh，可使用慢开始算法或拥塞避免算法</li></ul></li></ul><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/慢开始.jpg" style="zoom:100%;"></p><ul><li>快重传：发送方尽快进行重传，而不是等超时重传计时器超时再重传<ul><li>要求接收方不等待自己发送数据时才确认，而是立即发送确认</li><li>收到了失序的报文段后对已收到的报文段<font color="red">重复确认</font></li><li>发送方收到3各连续的重复确认，就将相应的报文段立即重传，不等待超时重传计时器超时再重传</li><li>个别报文丢失不会导致超时重传，就不会误认为出现了拥塞，快重传可以让整个网络的吞吐量提高约20%</li></ul></li></ul><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/快重传.jpg" style="zoom:100%;"></p><ul><li>发送方接收3个重复确认，知道只是丢失了个别报文段，于是不启动慢开始，而执行<font color="red">快恢复算法</font><ul><li>发送方将慢开始门限ssrhresh和拥塞窗口cwnd值调整为当前窗口的一半，开始执行拥塞避免算法</li><li>也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd增大3，原因是有3个数据报文段已离开网络，不停留在接收方的接受缓存中，可适当扩大窗口</li></ul></li></ul><h3 id="6-TCP超时重传时间的选择"><a href="#6-TCP超时重传时间的选择" class="headerlink" title="6.TCP超时重传时间的选择"></a>6.TCP超时重传时间的选择</h3><ul><li><p>超时重传时间RTO应略大于往返时间RTT</p></li><li><p>不能直接使用某次测量得到的RTT样本来计算超时重传时间RTO</p></li><li><p>利用每次测量得到的RTT样本，计算加权平均<font color="red">往返时间RTTs</font>（又称为平滑的往返时间），超时重传时间RTO应略大于加权平均往返时间</p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/RTO.jpg" style="zoom:50%;"></p></li><li><p>往返时间RTT测量是复杂的，为了解决超时重传无法测准往返时间RTT的问题，使用Karn算法：计算加权平均往返时间RTTs时，<font color="red">只要报文段重传了，就不采用其往返时间RTT样本</font>。不重新计算RTTs和RTO。但是在报文段时延增大且保持时，这会导致超时重传时间无法更新，导致报文段反复重传。</p></li><li>对Karn算法的修正：<font color="red">报文段每重传一次，就把超时重传时间RTO增大一些</font>。典型的做法是将新RTO的值取为旧RTO值的2倍。</li></ul><h3 id="7-TCP可靠传输的实现"><a href="#7-TCP可靠传输的实现" class="headerlink" title="7.TCP可靠传输的实现"></a>7.TCP可靠传输的实现</h3><ul><li>TCP基于<font color="red">以字节为单位的滑动窗口</font>来实现可靠传输</li></ul><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/TCP可靠传输.jpg" style="zoom:100%;"></p><ul><li>发送方的发送窗口并不总是和接收方的接收窗口一样大<ul><li>网络传送窗口值需要经历一定时间的时间滞后，而且这个时间是不确定的</li><li>发送方还可能根据网络当时的拥塞情况适当减小自己的发送窗口尺寸</li></ul></li><li>对于不按序到达的数据如何处理，TCP无明确规定<ul><li>若直接丢弃不按序到达的数据，接收窗口的管理会比较简单，但不利于网络资源利用</li><li>TCP通常对不按序到达的数据临时存放在接收窗口中，等到字节流中锁缺少的字节收到后，再<font color="red">按序交付上层的应用进程</font></li></ul></li><li>TCP要求接受方必须有<font color="red">累计确认和捎带确认机制</font>，减小传输开销。接收方可以在合适时发送确认，也可以在自己有数据要发送时把确认信息捎带上。<ul><li>接收方不应过分推迟发送确认，否则会导致发送方不必要的超时重传。TCP标准规定，确认推迟的时间不应超过0.5s。若收到一连串具有最大长度的报文段，必须每隔一个报文段就发送一个确认。</li><li>捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。</li></ul></li><li>TCP的通信是全双工通信。通信中的每一方都有自己的发送和接收窗口。</li></ul><h3 id="8-TCP的运输连接管理"><a href="#8-TCP的运输连接管理" class="headerlink" title="8.TCP的运输连接管理"></a>8.TCP的运输连接管理</h3><h4 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h4><ul><li>TCP的连接建立要解决以下三个问题<ul><li>使TCP双方能够确知对方的存在。</li><li>使TCP双方能够协商一些参数(如最大窗口值，是否使用窗口扩大选项和时间戳选项以及服务质量等)。</li><li>使TCP双方能够对运输实体资源(如缓存发小、连接表中的项目等)进行分配。</li></ul></li><li>TCP使用三报文握手建立连接<ul><li>TCP标准规定，SYN=1的报文段不能携带数据，消耗一个序号。</li><li>普通的确认报文段如果不携带数据，则不消耗序号。</li></ul></li></ul><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/TCP建立连接.jpg" style="zoom:100%;"></p><h4 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h4><ul><li>TCP通过四报文释放连接</li></ul><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/释放连接.jpg" style="zoom:100%;"></p><ul><li>TCP服务器每收到一次TCP客户进程的数据，就重新设置并启动<font color="red">保活计时器。</font></li><li>若保活计时器定时周期内未收到TCP客户进程发来的数据，则当保活计时器到时后，TCP服务器进程就向TCP客户进程发送一个探测报文段，以后每隔75s发送一次。若一连发送10个探测报文段后仍无TCP客户进程的响应，TCP服务器进程就认为TCP客户进程所在主机出了故障，关闭连接。</li></ul><h3 id="9-TCP报文段的首部格式"><a href="#9-TCP报文段的首部格式" class="headerlink" title="9.TCP报文段的首部格式"></a>9.TCP报文段的首部格式</h3><ul><li>为了实现可靠传输，TCP采用了<font color="red">面向字节流</font>的方式。</li><li>但TCP在发送数据时，是从发送缓存中取出一部分或全部字节并给其添加一个首部使之称为TCP报文段后进行发送。<ul><li>一个TCP报文段由首部和数据载荷两部分构成</li><li>TCP的全部功能都体现在它首部中各字段的作用</li></ul></li></ul><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/TCP首部.jpg" style="zoom:100%;"></p><ul><li>源端口：16bit，写入源端口号，用来标识发送该TCP报文段的应用进程。</li><li>目的端口：16bit，写入目的端口号，用来标识接收该TCP报文段的应用进程。</li><li>序号：32bit，指出本TCP报文段数据载荷的第一个字节的序号。</li><li>确认号：32bit，指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认。</li><li>确认标志位ACK：取值为1时确认号字段才有效，取值为0时确认号字段无效。TCP规定，连接建立后所有传送的TCP报文ACK均置1。</li><li>数据偏移：4bit，以4字节为单位。用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远。这个字段实际上是只出了TCP报文段的首部长度。取值为20-60。</li><li>保留：6bit，保留，目前置为0。</li><li>窗口：16bit，字节为单位，指出<font color="red">发送本报文段的一方的接收窗口</font>。</li><li>校验和：16bit，检查范围包括TCP报文段的首部和数据载荷两部分。在计算校验和时，要在TCP报文段的前面加上12字节的伪首部。</li><li>同步标志位SYN：在TCP连接建立时用来同步序号。</li><li>终止标志位FIN：用来释放TCP连接。</li><li>复位标志位RST：用来复位TCP连接。当RST=1时，表明TCP连接出现了异常，必须释放连接，然后再重新建立连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个TCP连接。</li><li>推送标志位PSH：接收方的TCP收到该标志位为1的报文段会<font color="red">尽快上交应用进程</font>，而不必等到接受缓存都填满后再向上交付。</li><li>紧急标志位URG：取值为1时紧急指针字段有效。取值为0时紧急指针字段无效。</li><li>紧急指针：占16bit，以字节为单位，用来指明紧急数据的长度。</li></ul><blockquote><p>​        当发送方有紧急数据时，可将紧急数据插队到发送缓存的最前面，并立即封装到一个TCP报文段中进行发送。紧急指针会指出本报文段数据再和部分包含了多长的紧急数据，紧急数据之后是普通数据。</p></blockquote><ul><li>扩展首部<ul><li>最大报文段长度MSS选项：TCP报文段数据载荷部分的最大长度。</li><li>窗口扩大选项：为了扩大窗口(提高吞吐率)。</li><li>时间戳选项：用来计算往返时间RTT；处理序号超范围的情况，又称为防止序号绕回PAWS。</li><li>选择确认选项</li></ul></li><li>填充：保证报文段首部能被4整除</li></ul><h2 id="第六章-应用层"><a href="#第六章-应用层" class="headerlink" title="第六章 应用层"></a>第六章 应用层</h2><h3 id="1-客户-服务器方式-C-S方式-和对等方式-P2P方式"><a href="#1-客户-服务器方式-C-S方式-和对等方式-P2P方式" class="headerlink" title="1.客户/服务器方式(C/S方式)和对等方式(P2P方式)"></a>1.客户/服务器方式(C/S方式)和对等方式(P2P方式)</h3><h4 id="客户-服务器方式"><a href="#客户-服务器方式" class="headerlink" title="客户/服务器方式"></a>客户/服务器方式</h4><ul><li>客户和服务器是指通信中所涉及的两个应用进程</li><li>客户/服务器方式所描述的是进程之间服务和被服务的关系</li><li>客户是服务请求方，服务器是服务提供方</li><li>服务器总是处于运行状态，并等待客户的服务请求。服务器具有固定端口号(例如HTTP服务器的默认端口号为80)。而运行服务器的主机也具有固定的IP地址。</li><li>C/S方式是因特网上传统的，同时也是最成熟的方式。很多我们熟悉的网络应用采用的都是C/S方式。包括万维网WWW、电子邮件、文件传输FTP等。</li><li>基于C/S方式的应用服务器通常是服务集中型的，即应用服务集中在网络中比客户机少的多的服务器计算机上<ul><li>由于一台服务器要为多个客户机提供服务，在C/S应用中，常会出现服务器计算机跟不上众多客户机请求的情况。</li><li>为此，在C/S应用中，常用计算机群集(或服务器场)构建一个强大的虚拟服务器。</li></ul></li></ul><h4 id="对等方式P2P"><a href="#对等方式P2P" class="headerlink" title="对等方式P2P"></a>对等方式P2P</h4><ul><li>P2P方式中，没有固定的服务请求者和服务提供者，分布在网络边缘各端系统中的应用进程是对等的，被称为对等方。对等方相互之间直接通信，每个对等方既是服务的请求者，又是服务的提供者。</li><li>目前因特网流行的P2P应用主要包括P2P文件共享、即时通信、P2P流媒体、分布式存储等。</li><li>基于P2P的应用是服务分散型的，因为服务分散在大量对等计算机中，不是服务提供商所有，而是为个人控制的桌面计算机和笔记本电脑。</li><li>P2P的特性是<font color="red">可扩展性</font>。因为系统每增加一个对等方，不仅增加的是服务的请求者，同时也增加了服务的提供者，系统性能不会因规模的增大而降低。</li><li>P2P方式具有成本上的优势。通常不需要庞大的服务器设施和服务器带宽。</li></ul><h3 id="2-动态主机配置协议DHCP"><a href="#2-动态主机配置协议DHCP" class="headerlink" title="2.动态主机配置协议DHCP"></a>2.动态主机配置协议DHCP</h3><ul><li>动态主机配置协议DHCP提供了一种机制，称为即插即用连网。这种机制允许一台计算机加入新网络时可自动获取IP地址等网络配置信息而不用手工参与。</li><li>DHCP报文在运输层使用<font color="red">UDP协议封装</font><ul><li>DHCP客户使用的UDP端口号为68</li><li>DHCP服务器使用的UDP端口号为67</li></ul></li><li>DHCP客户在未获取到IP地址使用地址<font color="red">0.0.0.0</font></li><li>在每一个网络上都设置一个DHCP服务器会使DHCP服务器的数量太多。因此每个网络至少有一个<font color="red">DHCP中继代理(通常是一台路由器)</font>，它配置了DHCP服务器的IP地址信息，作为各网络中计算机与DHCP服务器的桥梁。</li></ul><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/DHCP.jpg" style="zoom:100%;"></p><h3 id="3-域名系统DNS"><a href="#3-域名系统DNS" class="headerlink" title="3.域名系统DNS"></a>3.域名系统DNS</h3><ul><li>因特网采用层次树状结构的域名结构</li><li>域名结构由若干个分量组成，分量之间用点隔开<ul><li>每一级域名都有英文字母和数字组成，不超过63个字符，不区分大小写字母。</li><li>级别最低的域名写在最左边，而级别最高的顶级域名写在最右边。</li><li>完整的域名不超过255个字符。</li></ul></li><li>域名系统不规定一个域名需要包含多少个下级域名，也不规定每一级的域名代表什么意思。</li><li>各级域名由上一级的域名管理机构管理，而最高的顶级域名由因特网名称与数字地址分配机构ICANN进行管理。</li><li>顶级域名TLD分为以下三类：<ul><li>国家顶级域名nTLD：采用ISO3166的规定。如cn表示中国，us表示美国等</li><li>通用顶级域名gTLD：com(公司企业)，net(网络服务机构)，org(非盈利性组织)，int(国际组织)，edu(美国教育机构)，gov(美国政府部门)，mil(美国军事部门)。</li><li>反向域arpa：用于反向域名解析，即IP地址反向解析为域名</li></ul></li><li>在国家顶级域名下注册的二级域名由该国自行确定</li><li>我国将二级域名划分为以下两类：<ul><li>类别域名：ac科研机构，com企业，edu教育机构，gov政府部门，net提供网络服务的机构，mil军事机构，org非盈利性组织。</li><li>行政区域名：共34个，适用于我国各省，自治区，直辖市。</li></ul></li><li>域名和IP地址的映射关系必须保存在域名服务器中，供所有其他应用查询。DNS使用<font color="red">分布在各地的域名服务器</font>来实现域名到IP地址的转换。</li><li>域名服务器可以划分为以下四种不同的类型<ul><li>根域名服务器：<br>根域名服务器是最高层次的域名服务器，知道所有的顶级域名服务器的域名及IP地址。因特网共有13个不同IP地址的根域名服务器。每台服务器都是分布在各地的计算机构成的<font color="red">服务器集群</font>。当本地域名服务器向根域名服务器发出查询请求时，路由器就把查询请求报文转发到离这个DNS客户最近的一个根域名服务器，加快DNS查询过程。<font color="red">根域名服务器通常并不直接对域名进行解析，而是返回该域名所述顶级域名的顶级域名服务器的IP地址。</font></li><li>顶级域名服务器：<br>这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。当收到DNS查询请求时就给出相应的回答(可能是最后的结果，也可能是下一级权限域名服务器的IP地址)。</li><li>权限域名服务器<br>这些域名服务器负责管理某个区的域名，每一个主机的域名都必须在某个权限域名服务器注册登记。因此权限域名服务器知道其管辖的域名与IP地址的映射关系。权限域名服务器还知道其下级域名服务器的地址。</li><li>本地域名服务器<br>本地域名服务器不属于上述的域名服务器的等级结构。当一个主机发出DNS请求报文时，这个报文就首先被送外该主机的本地域名服务器。<font color="red">本地域名服务器起着代理的作用，会将该报文转发到上述的域名服务器的等级结构中</font>。每一个因特网服务提供者ISP，都可以拥有一个本地域名服务器，有时也被称为<font color="red">默认域名服务器</font>。本地域名服务器离用户较近，一般不超过几个路由器，也有可能就在同一个局域网中。</li></ul></li><li>域名解析的过程</li></ul><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/域名解析.jpg" style="zoom:100%;"></p><ul><li>为了提高DNS查询效率，减轻根域名服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器中广泛使用了<font color="red">高速缓存</font>。高速缓存用来存放最近查询过的域名以及从何处取得域名映射信息的记录。</li><li>为保持高速缓存中的内容正确。域名服务器为<font color="red">每项内容设置计时器并删除超过合理时间的项</font>。</li><li>用户主机中同样存在高速缓存，只在从缓存中找不到域名时才向域名服务器查询。</li><li>DNS报文使用运输层的UDP协议进行封装，端口号为<font color="red">53</font>。</li></ul><h3 id="4-文件传送协议FTP"><a href="#4-文件传送协议FTP" class="headerlink" title="4.文件传送协议FTP"></a>4.文件传送协议FTP</h3><ul><li>文件传送FTP是因特网上使用的最广泛的文件传送协议<ul><li>FTP提供交互式的访问，允许客户指明文件的类型与格式（如指明是否使用ASCII码），并允许文件具有存取权限（如访问文件的用户必须经过授权，并输入有效的口令）。</li><li>FTP屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件。</li></ul></li><li>FTP的常见用途是在计算机之间传输文件，尤其是用于批量传输文件。也常用于将构成网站内容的大量文件批量上传到他们的Web服务器。</li><li>FTP的基本工作原理<ul><li>有数据要传输时，FTP客户通过命令通道告知FTP服务器来与自己的另一个临时端口建立TCP连接，建立数据通道。</li><li>建立数据通道时，FTP服务器主动连接FTP客户称为主动模式，FTP服务器被动等待FTP客户端建立连接称为被动模式。</li></ul></li></ul><h3 id="5-电子邮件"><a href="#5-电子邮件" class="headerlink" title="5.电子邮件"></a>5.电子邮件</h3><ul><li>电子邮件是因特网上最早流行的一种应用。</li><li>电子邮件采用客户/服务器方式</li><li>电子邮件系统的三个主要组成：<font color="red">用户代理，邮件服务器，电子邮件需要的协议</font><ul><li>用户代理是用户与电子邮件系统的接口</li><li>邮件服务器是电子邮件系统的基础设施。因特网上所有的ISP都有邮件服务器，其功能是发送和接收邮件，同时负责维护用户的邮箱。</li><li>协议包括邮件发送协议（例如SMTP）和邮件读取协议（例如POP3，IMAP）。</li></ul></li><li>简单邮件传送协议SMTP</li></ul><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/SMTP.jpg" style="zoom:100%;"></p><ul><li><p>电子邮件有信封和内容两部分，内容由首部和主题两部分构成。</p></li><li><p>SMTP协议只能传送ASCII码文本数据，不能传送可执行文件或其他二进制对象，也不能传送多媒体邮件和许多非英语国家的文字。</p></li><li>为解决SMTP传送非ASCII码文本的问题，提出了<font color="red">多用途因特网邮件扩展MIME</font>。<ul><li>增加了5个新的邮件首部字段，提供了有关邮件主体的信息。</li><li>定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。</li><li>定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。</li></ul></li><li>实际上MIME不仅仅用于SMTP，也用于同样面向ASCII字符的HTTP。</li><li>常用的邮件读取协议有以下两个<ul><li><font color="red">邮局协议POP</font>：因特网正式标准。简单但功能有限，用户只能以下载并删除方式或下载并保留方式从邮件服务器下载邮件到用户方服务器。不允许用户在邮件服务器上管理自己的邮件。（例如创建文件夹，对邮件进行分类管理等）。</li><li><font color="red">因特网邮件访问协议IMAP</font>：因特网建议标准。用户在自己的计算机上就可以操控邮件服务器中的邮箱，就像在本地操控一样，因此IMAP是一个联机协议。</li><li>POP3和IMAP4都采用基于TCP连接的客户/服务器方式。POP3使用熟知端口110，IMAP4使用熟知端口143。</li></ul></li><li>基于万维网的电子邮件<ul><li>通过浏览器登录（提供用户名和口令）邮件服务器万维网就可以撰写收发和管理电子邮件。方式与IMAP类似，但不需要安装专门的用户代理程序。</li><li>邮件服务器提供方便的邮件管理功能，用户可以在邮件服务器上管理和处理自己的邮件。</li></ul></li></ul><h3 id="6-万维网"><a href="#6-万维网" class="headerlink" title="6.万维网"></a>6.万维网</h3><ul><li>万维网WWW是一个大规模的、联机的信息储藏所，是运行在因特网上的一个分布式应用。</li><li>浏览器最重要的部分是<font color="red">渲染引擎</font>，也就是浏览器内核，负责对网页内容进行解析和显示。</li><li>万维网使用<font color="red">统一资源定位符URL</font>来指明因特网上任何种类资源的位置。其一般形式为：&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;</li><li>万维网文档<ul><li>超文本标记语言HTML，使用多种标签来描述网页的结构和内容。</li><li>层叠样式表CSS，从审美角度来描述网页的样式。</li><li>脚本语言JavaScript，控制网页的行为。</li></ul></li><li><font color="red">超文本传输协议HTTP</font>定义了浏览器（万维网客户进程）怎样向万维网服务器请万维网文档，以及万维网服务器怎样把万维网文档传送给浏览器。<ul><li>HTTP/1.0采用<font color="red">非持续连接方式</font>。每次浏览器要请求一个文件都要与服务器建立TCP连接（80端口），当收到响应后就立即关闭连接。</li><li>HTTP/1.1采用<font color="red">持续连接方式</font>。万维网服务器在发送相应后仍然保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。还可采用<font color="red">流水线方式</font>，即浏览器收到HTTP的相应报文之前就能够连续发送多个请求报文。</li></ul></li><li>HTTP有两类报文：请求报文和响应报文。报文中的每一个字段都是一些ASCII码串，并且每个字段的长度都是不确定的。</li><li>Cookie提供了一种机制使得万维网服务器能够记住用户，而无需用户主动提供标识信息。<font color="red">Cookie是一种对无状态的HTTP进行状态化的技术</font>。</li><li><p>在万维网中还可以使用缓存机制以提高万维网的效率。万维网缓存又称为<font color="red">Web缓存</font>，可位于客户机，也可位于中间系统上，位于中间系统的Web缓存又称为代理服务器。</p></li><li><p>HTTP的报文格式</p><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/HTTP.jpg" style="zoom:100%;"></p></li><li><p>Cookie</p></li></ul><p><img src="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BE%AE%E8%AF%BE%E7%AC%94%E8%AE%B0/cookie.jpg" style="zoom:100%;"></p>]]></content>
      
      
      <categories>
          
          <category> cs基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数模转换实验</title>
      <link href="/2021/10/30/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%AA%8C/"/>
      <url>/2021/10/30/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="D级任务"><a href="#D级任务" class="headerlink" title="D级任务"></a><div align="center">D级任务</div></h1><h2 id="一-实验任务"><a href="#一-实验任务" class="headerlink" title="一.实验任务"></a>一.实验任务</h2><p style="text-indent:2em">对74194进行仿真验证，掌握Quartus仿真的基本原则和常规步骤，记录移位寄存器的数据读写，并描述仿真波形，分析结果。</p><span id="more"></span><h2 id="二-实验过程"><a href="#二-实验过程" class="headerlink" title="二.实验过程"></a>二.实验过程</h2><h3 id="1-电路连接"><a href="#1-电路连接" class="headerlink" title="1.电路连接"></a>1.电路连接</h3><img src="/2021/10/30/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%AA%8C/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1.png" class><h3 id="2-功能仿真"><a href="#2-功能仿真" class="headerlink" title="2.功能仿真"></a>2.功能仿真</h3><p style="text-indent:2em">仿真结果如图所示：</p><img src="/2021/10/30/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%AA%8C/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2.png" class><h3 id="3-波形分析"><a href="#3-波形分析" class="headerlink" title="3.波形分析"></a>3.波形分析</h3><p style="text-indent:2em">50ns：s=11，并行置位，qabcd=abcd=1010</p><p style="text-indent:2em">125ns：clrn=0，低电平有效，异步清零，qabcd=0</p><p style="text-indent:2em">250ns：s=01，串行右移，sr=1，qabcd=1000</p><p style="text-indent:2em">350ns：s=01，串行右移，sr=0，qabcd=0100</p><p style="text-indent:2em">450ns：s=10，串行左移，sl=1，qabcd=1001</p><p style="text-indent:2em">550ns，s=10，串行左移，sl=0，qabcd=0010</p><p style="text-indent:2em">此后s=00，ckrn=1，qabcd保持为0010</p><h2 id="三-实验结果"><a href="#三-实验结果" class="headerlink" title="三.实验结果"></a>三.实验结果</h2><p style="text-indent:2em">经功能仿真验证，74149的工作与表中相同。</p><img src="/2021/10/30/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%AA%8C/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A3.png" class><h1 id="C级任务"><a href="#C级任务" class="headerlink" title="C级任务"></a><div align="center">C级任务</div></h1><h2 id="一-实验任务-1"><a href="#一-实验任务-1" class="headerlink" title="一.实验任务"></a>一.实验任务</h2><p style="text-indent:2em">在DAC0832电路中依据导线命名循迹跨页跨层查到FPGA操作DAC0832的有关控制信号输入端管脚PIN号、数据输入端的管脚PIN号和DAC输出端测量点位置。</p><h2 id="二-实验过程-1"><a href="#二-实验过程-1" class="headerlink" title="二.实验过程"></a>二.实验过程</h2><h3 id="1-电路图"><a href="#1-电路图" class="headerlink" title="1.电路图"></a>1.电路图</h3><p style="text-indent:2em">DAC0832电路如下图所示：</p><img src="/2021/10/30/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%AA%8C/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A4.png" class><h3 id="2-控制信号输入端管脚PIN号"><a href="#2-控制信号输入端管脚PIN号" class="headerlink" title="2.控制信号输入端管脚PIN号"></a>2.控制信号输入端管脚PIN号</h3><p style="text-indent:2em">输入控制信号为CS和WR1，这两个输入信号由DAC_CS控制，因此只需要找到DAC_CS的输入端管脚。在顶层原理图找到cs，wr1，跨层查找电路，找到输入端管脚号为Pin11.</p><p><img src="/2021/10/30/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%AA%8C/数模转换实验报告5-16574389752276.png" style="zoom:60%;"></p><p><img src="/2021/10/30/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%AA%8C/数模转换实验报告6.png" style="zoom:80%;"></p><h3 id="3-数据输入端管脚号"><a href="#3-数据输入端管脚号" class="headerlink" title="3.数据输入端管脚号"></a>3.数据输入端管脚号</h3><p style="text-indent:2em">数据输入信号共8个，对应序号为4-7、13-16。</p>                                                       <img src="/2021/10/30/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%AA%8C/数模转换实验报告7.png" style="zoom:50%;"><img src="/2021/10/30/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%AA%8C/数模转换实验报告8.png" style="zoom:60%;"><img src="/2021/10/30/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%AA%8C/数模转换实验报告9.png" style="zoom:60%;"><p style="text-indent:2em">根据顶层图得到输入端的引脚号为：PIN_205-208、PIN_213-216。</p><h3 id="4-DAC输出端测量点位置"><a href="#4-DAC输出端测量点位置" class="headerlink" title="4.DAC输出端测量点位置"></a>4.DAC输出端测量点位置</h3><p style="text-indent:2em">输出由U12输出1，U11输出9决定，可以找到测量点应在DA位置。</p><p><img src="/2021/10/30/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%AA%8C/数模转换实验报告10.png" style="zoom:60%;"></p><p><img src="/2021/10/30/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%AA%8C/数模转换实验报告11.png" style="zoom:60%;"></p><h1 id="B级任务"><a href="#B级任务" class="headerlink" title=" B级任务"></a><div align="center"> B级任务</div></h1><h2 id="一-实验任务-2"><a href="#一-实验任务-2" class="headerlink" title="一.实验任务"></a>一.实验任务</h2><p style="text-indent:2em">Proteus中，建工程绘制电路，使用仪器测出数字编码信号转换后的模拟电压值.列表记录并画出“编码-电压”转换函数图。</p><h2 id="二-实验过程-2"><a href="#二-实验过程-2" class="headerlink" title="二.实验过程"></a>二.实验过程</h2><h3 id="1-电路绘制"><a href="#1-电路绘制" class="headerlink" title="1.电路绘制"></a>1.电路绘制</h3><p><img src="/2021/10/30/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%AA%8C/数模转换实验报告12.png" style="zoom:60%;"></p><h3 id="2-编码-电压”转换函数图"><a href="#2-编码-电压”转换函数图" class="headerlink" title="2.编码-电压”转换函数图"></a>2.编码-电压”转换函数图</h3><p><img src="/2021/10/30/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%AA%8C/数模转换实验报告13.png" style="zoom:60%;"></p><p style="text-indent:2em">函数可近似为y=0.02x+d，d是一个极小的截距。</p><h1 id="A级任务"><a href="#A级任务" class="headerlink" title="A级任务"></a><div align="center">A级任务</div></h1><h2 id="一-实验任务-3"><a href="#一-实验任务-3" class="headerlink" title="一.实验任务"></a>一.实验任务</h2><p style="text-indent:2em">VHDL编写波形发生器并仿真验证。</p><h2 id="二-实验过程-3"><a href="#二-实验过程-3" class="headerlink" title="二.实验过程"></a>二.实验过程</h2><p style="text-indent:2em">本任务DDS及.mif文件的生成均参考网络资源，只进行了波形验证。</p><p style="text-indent:2em">波形设置:</p><p><img src="/2021/10/30/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%AA%8C/数模转换实验报告14.png" style="zoom:50%;"></p><p><img src="/2021/10/30/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%AA%8C/数模转换实验报告15.png" style="zoom: 50%;"></p><p><img src="/2021/10/30/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%AA%8C/数模转换实验报告16.png" style="zoom: 80%;"></p><p style="text-indent:2em">正弦波周期64us，与mif文件中的数据对应。</p><h1 id="实验总结"><a href="#实验总结" class="headerlink" title="**实验总结**"></a><div align="center">**实验总结**</div></h1><ul><li>熟悉了功能仿真验证的方法</li><li>了解74149芯片的功能及使用方法</li><li>了解了更多关于数模转换的方法知识</li><li>学习了Proteus的使用方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> cs基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HNU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello!</title>
      <link href="/2021/10/30/hello/"/>
      <url>/2021/10/30/hello/</url>
      
        <content type="html"><![CDATA[<div align="center">欢迎来到我的博客！</div>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
