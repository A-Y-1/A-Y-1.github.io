<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据库系统概论笔记 | 橙的Blog</title><meta name="author" content="橙"><meta name="copyright" content="橙"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据库系统概论(王珊 萨师煊 编著)笔记。  第一章 绪论1.数据库系统概述1.1数据库的4个基本概念 数据：描述事物的符号记录称为数据。数据的含义称为数据的语义，数据与其语义是不可分的。 数据库：长期存储在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和存储，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享。 数据库管理系统(DBMS)：科学">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库系统概论笔记">
<meta property="og:url" content="https://a-y-1.github.io/2022/09/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="橙的Blog">
<meta property="og:description" content="数据库系统概论(王珊 萨师煊 编著)笔记。  第一章 绪论1.数据库系统概述1.1数据库的4个基本概念 数据：描述事物的符号记录称为数据。数据的含义称为数据的语义，数据与其语义是不可分的。 数据库：长期存储在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和存储，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享。 数据库管理系统(DBMS)：科学">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://a-y-1.github.io/cover/db.jpg">
<meta property="article:published_time" content="2022-09-03T11:01:29.000Z">
<meta property="article:modified_time" content="2023-09-26T02:30:44.928Z">
<meta property="article:author" content="橙">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://a-y-1.github.io/cover/db.jpg"><link rel="shortcut icon" href="/img/orange.png"><link rel="canonical" href="https://a-y-1.github.io/2022/09/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据库系统概论笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-09-26 10:30:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/a0.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/../cover/0105.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="橙的Blog"><span class="site-name">橙的Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据库系统概论笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-03T11:01:29.000Z" title="发表于 2022-09-03 19:01:29">2022-09-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-26T02:30:44.928Z" title="更新于 2023-09-26 10:30:44">2023-09-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据库系统概论笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p style="text-indent:2em">数据库系统概论(王珊 萨师煊 编著)笔记。</p>

<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="1-数据库系统概述"><a href="#1-数据库系统概述" class="headerlink" title="1.数据库系统概述"></a>1.数据库系统概述</h2><h3 id="1-1数据库的4个基本概念"><a href="#1-1数据库的4个基本概念" class="headerlink" title="1.1数据库的4个基本概念"></a>1.1数据库的4个基本概念</h3><ul>
<li>数据：描述事物的符号记录称为数据。数据的含义称为数据的语义，数据与其语义是不可分的。</li>
<li>数据库：<strong>长期存储在计算机内、有组织的、可共享的</strong>大量数据的集合。数据库中的数据按一定的数据模型组织、描述和存储，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享。</li>
<li>数据库管理系统(DBMS)：科学组织和存储数据，高效获取和维护数据。主要有以下功能：<ul>
<li>数据定义功能</li>
<li>数据组织、存储和管理</li>
<li>数据操纵功能</li>
<li>数据库的事务管理和运行管理</li>
<li>数据库的建立和维护功能</li>
<li>其他功能</li>
</ul>
</li>
<li>数据库系统(DBS)：由数据库、数据库管理系统、应用程序和数据库管理员组成的存储、管理、处理和维护数据的系统。</li>
</ul>
<span id="more"></span>
<h3 id="1-2数据管理技术的产生和发展"><a href="#1-2数据管理技术的产生和发展" class="headerlink" title="1.2数据管理技术的产生和发展"></a>1.2数据管理技术的产生和发展</h3><ul>
<li>人工管理阶段-&gt;文件系统阶段-&gt;数据库系统阶段。</li>
<li>从文件系统到数据库系统标志着数据管理技术的飞跃。</li>
</ul>
<h3 id="1-3数据库系统的特点"><a href="#1-3数据库系统的特点" class="headerlink" title="1.3数据库系统的特点"></a>1.3数据库系统的特点</h3><ul>
<li>数据结构化：数据库系统实现整体数据的结构化。数据库中的数据不仅针对一个应用，而是面向整个组织或企业。</li>
<li>数据的共享性高，冗余性低且易扩充。</li>
<li>数据独立性高：数据独立性包括物理独立性和逻辑独立性。<ul>
<li>物理独立性是指用户的应用程序与数据库中的物理存储是相互独立的。</li>
<li>逻辑独立性是指用户的应用程序与数据库的逻辑结构是相互独立的。</li>
</ul>
</li>
<li>数据由数据库管理系统统一管理和控制：数据库的共享是并发的，为了保证数据一致性，数据库管理系统还必须提供以下几方面的数据控制功能：<ul>
<li>数据的安全性保护：防止不合法使用造成的数据泄密和破坏。</li>
<li>数据的完整性检查：控制数据的正确性，有效性和相容性。</li>
<li>并发控制</li>
<li>数据库恢复</li>
</ul>
</li>
</ul>
<h2 id="2-数据模型"><a href="#2-数据模型" class="headerlink" title="2.数据模型"></a>2.数据模型</h2><p style="text-indent:2em">数据模型是数据库系统的核心和基础。包含两类，第一类是概念模型，第二类是逻辑模型和物理模型。</p>

<ul>
<li>概念模型：从用户的观点对信息和数据建模，主要用于数据库设计。</li>
<li>逻辑模型：从计算机系统的观点对数据建模，主要用于数据库管理系统的实现。</li>
<li>物理模型：描述数据在系统内部的表示方式和存取方法。</li>
</ul>
<h3 id="2-1-概念模型"><a href="#2-1-概念模型" class="headerlink" title="2.1 概念模型"></a>2.1 概念模型</h3><ul>
<li>概念模型：对信息建模。概念模型是认识抽象到数据库管理系统支持的数据模型的一个中间层次。以下是概念模型中的一些术语：<ul>
<li>实体：客观存在并可相互区别的实物称为实体。</li>
<li>属性：实体所具有的某一特性。</li>
<li>码(key)：唯一标识实体的属性集称为码。</li>
<li>实体型：用实体名和属性名集合来抽象和刻画同类实体。例如：学生(学号，姓名，性别，院系)。</li>
<li>实体集：同一类型实体的集合称为实体集。</li>
<li>联系：实体之间的联系通常是指不同实体集之间的联系。有一对一，一对多和多对多等多种类型。</li>
</ul>
</li>
<li>概念模型的一种表示方法：实体-联系方法(E-R方法)，见第7章。</li>
</ul>
<h3 id="2-2-数据模型的组成要素"><a href="#2-2-数据模型的组成要素" class="headerlink" title="*2.2 数据模型的组成要素"></a>*2.2 数据模型的组成要素</h3><ul>
<li>数据结构：描述数据库的组成对象以及对象之间的联系。</li>
<li>数据操作：对数据库中各种对象的实例允许执行的操作的合集，包括操作及有关的操作规则。</li>
<li>完整性约束：一组完整性规则。</li>
</ul>
<h3 id="2-3-常用的数据模型"><a href="#2-3-常用的数据模型" class="headerlink" title="2.3 常用的数据模型"></a>2.3 常用的数据模型</h3><p><strong>层次模型</strong></p>
<ul>
<li>数据库中满足下面两个条件的基本层次联系的集合为层次模型：<ul>
<li>有且只有一个结点没有双亲结点，称为根结点。</li>
<li>根以外的其他结点只有一个双亲结点。</li>
</ul>
</li>
<li>数据操纵主要为查询，插入，删除，更新。操作要满足层次模型的完整性约束条件。</li>
<li>层次模型的优点：<ul>
<li>数据结构简单清晰。</li>
<li>查询效率高(因为联系用有向边表示)。</li>
<li>提供了良好的完整性支持。</li>
</ul>
</li>
<li>层次模型的缺点：<ul>
<li>现实中很多联系是非层次性的。</li>
<li>一个结点有多个双亲结点，就只能引入冗余数据，应用程序编写复杂。</li>
<li>查询子女结点必须通过双亲结点。</li>
<li>结构严密，层次命令趋于程序化。</li>
</ul>
</li>
</ul>
<p><strong>网状模型</strong></p>
<ul>
<li>数据库中满足下面两个条件的基本层次联系的集合为网状模型：<ul>
<li>允许一个以上的结点无双亲。</li>
<li>一个结点可以有多于一个的双亲。</li>
</ul>
</li>
<li>具体的网状数据库系统对数据操纵都加了一些限制，提供了一定的完整性约束。</li>
<li>网状模型的优点：<ul>
<li>能够更为直接的描述现实世界。</li>
<li>具有良好的性能，存储效率较高。</li>
</ul>
</li>
<li>网状模型的缺点：<ul>
<li>结构比较复杂，不利于最终用户掌握。</li>
<li>DDL，DML复杂，并且要嵌入一种高级语言中，不容易掌握和使用。</li>
<li>记录之间的联系通过存取路径实现，访问数据时必须选择适当的存取路径，用户必须了解系统结构的细节。</li>
</ul>
</li>
</ul>
<p><strong>关系模型</strong></p>
<p style="text-indent:2em">关系模型由一组关系组成，每个关系的数据结构是一张规范化的二维表。</p>

<ul>
<li>关系模型的术语：<ul>
<li>关系：对应一张表</li>
<li>元组：表中的一行</li>
<li>属性：列</li>
<li>码：唯一确定一个元组</li>
<li>域：属性的取值范围</li>
<li>分量：元组中的一个属性值</li>
<li>关系模式：对关系的描述一般为：关系名（属性1，属性2…）</li>
</ul>
</li>
<li>关系模型要求关系必须是规范化的，每一个分量必须是一个不可分的数据项。</li>
<li>关系模型的优点：<ul>
<li>建立在严格数学概念上。</li>
<li>概念单一，结构简单清晰。</li>
<li>关系模型存取路径透明，有更高的数据独立性，更好的安全保密性。</li>
</ul>
</li>
</ul>
<p style="text-indent:2em">其他相关内容见第二章。</p>


<h2 id="3-数据库系统的结构-三级模式结构"><a href="#3-数据库系统的结构-三级模式结构" class="headerlink" title="*3.数据库系统的结构(三级模式结构)"></a>*3.数据库系统的结构(三级模式结构)</h2><ul>
<li>模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。数据库管理系统提供模式数据定义语言(DDL)来严格定义模式。</li>
<li>外模式：数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</li>
<li>内模式：数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。</li>
<li>为了实现以上三个抽象层次的联系和转换，数据库管理系统在三级模式之间提供了两层映像：外模式/模式映像和模式/内模式映像。<ul>
<li>外模式/模式映像：定义了外模式与模式之间的对应关系。</li>
<li>模式/内模式映像：定义了数据全局逻辑结构和存储结构之间的关系。</li>
</ul>
</li>
<li>数据库模式即全局逻辑结构是数据库的中心与关键，独立于数据库的其他层次。</li>
<li>当模式改变时，修改映像使外模式不变，这保证了<b>数据与程序的逻辑独立性</b>。当存储结构(内模式)改变时，修改映像使模式保持不变，这保证了<b>数据与程序的物理独立性</b>。</li>
</ul>
<h1 id="第二章-关系数据库"><a href="#第二章-关系数据库" class="headerlink" title="第二章 关系数据库"></a>第二章 关系数据库</h1><h2 id="1-关系数据结构及形式化定义"><a href="#1-关系数据结构及形式化定义" class="headerlink" title="1.关系数据结构及形式化定义"></a>1.关系数据结构及形式化定义</h2><h3 id="1-1关系"><a href="#1-1关系" class="headerlink" title="1.1关系"></a>1.1关系</h3><p style="text-indent:2em">以下是集合论角度下关系数据结构的形式化定义。

- 域：一组具有相同数据类型的值的集合。
- 笛卡尔积：域上的一种集合运算。
  - 笛卡尔积中的每一个元素叫做一个n元组，元组中每个值叫做一个分量。
  - 一个域允许的不同取值个数称为这个域的基数。
- 域D1，D2，D3......的子集叫做在域D1，D2...上的关系，表示为R(D1，D2，...，D3)，R表示关系的名字，n是关系的目或度。n=1时为单元关系，n=2时为二元关系。
- **若关系中的某一属性组的值能唯一标识一个元组，而其子集不能，则该属性组为候选码。**
- 若一个关系有多个候选码，则选定其中一个为主码。
- <font color="red">候选码</font>的诸属性称为主属性。其他属性为非主属性。
- 最极端的情况下，所有属性为关系模式的候选码，称为全码。
- 关系可以有三种类型：基本关系，查询表和视图表。
- 基本关系具有以下六条性质：
  - 列是同质的。
  - 不同的列可出自同一个域。
  - 列可交换。
  - 元组候选码不能取相同值。
  - 行可交换。
  - 分量必须是原子的，每一个分量必须是不可分的数据项。

### 1.2关系模式

</p><p style="text-indent:2em">关系的描述称为关系模式。可以形式化表示为R(U，D，DOM，F)。通常简记为R(U)。关系模式是型，关系是值；关系模式是静态的，关系是动态的，变化的；关系是关系模式在某一时刻的状态或内容。关系和关系模式常统称为关系，根据上下文进行区分。</p>

<ul>
<li>R：关系名</li>
<li>U：属性名集合</li>
<li>DOM：属性来自的域</li>
<li>F：属性间数据的依赖关系集合</li>
</ul>
<h2 id="2-关系操作"><a href="#2-关系操作" class="headerlink" title="2.关系操作"></a>2.关系操作</h2><h3 id="2-1基本的关系操作"><a href="#2-1基本的关系操作" class="headerlink" title="2.1基本的关系操作"></a>2.1基本的关系操作</h3><p style="text-indent:2em">五种基本的关系操作：<font color="red">选择、投影、并、差、笛卡尔积</font>。其他操作如连接，除，交可用基本操作定义和导出。</p>

<h3 id="2-2关系数据语言分类"><a href="#2-2关系数据语言分类" class="headerlink" title="2.2关系数据语言分类"></a>2.2关系数据语言分类</h3><ul>
<li>关系代数语言(ISBL)</li>
<li>关系演算语言<ul>
<li>元组关系演算语言(ALPHA)</li>
<li>域关系演算语言(QBE)</li>
</ul>
</li>
<li>具有关系代数和关系演算双重特点的语言(SQL)</li>
</ul>
<h2 id="3-关系的完整性"><a href="#3-关系的完整性" class="headerlink" title="3.关系的完整性"></a>3.关系的完整性</h2><ul>
<li>实体完整性：主属性不能取空值</li>
<li>参照完整性：F是基本关系的一个或一组属性，但不是R的码，Ks是基本关系S的主码，如果F与Ks对应，F是R的外码，并称R为参照关系，S为被参照关系。R和S不一定不同。<ul>
<li>一个关系的属性为另一个关系的主码，则这个属性是这个关系的外码，这个关系为参照关系。</li>
<li>参照完整性规则：外码的取值或者为空，或者为被参照关系的某个元组的主码值。</li>
</ul>
</li>
<li>用户定义的完整性</li>
</ul>
<h2 id="4-关系代数"><a href="#4-关系代数" class="headerlink" title="4.关系代数"></a>4.关系代数</h2><p style="text-indent:2em">练习：</p>

<p>​        <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45978890/article/details/114177921">https://blog.csdn.net/qq_45978890/article/details/114177921</a></p>
<h1 id="第三章-关系数据库标准语言SQL"><a href="#第三章-关系数据库标准语言SQL" class="headerlink" title="第三章 关系数据库标准语言SQL"></a>第三章 关系数据库标准语言SQL</h1><h2 id="1-数据定义"><a href="#1-数据定义" class="headerlink" title="1.数据定义"></a>1.数据定义</h2><div class="table-container">
<table>
<thead>
<tr>
<th>操作对象</th>
<th>创建</th>
<th>删除</th>
<th>修改</th>
</tr>
</thead>
<tbody>
<tr>
<td>模式</td>
<td>CREATE SCHEMA</td>
<td>DROP SCHEMA</td>
<td></td>
</tr>
<tr>
<td>表</td>
<td>CREATE TABLE</td>
<td>DROP TABLE</td>
<td>ALTER TABLE</td>
</tr>
<tr>
<td>视图</td>
<td>CREATE VIEW</td>
<td>DROP VIEW</td>
<td></td>
</tr>
<tr>
<td>索引</td>
<td>CREATE INDEX</td>
<td>DROP INDEX</td>
<td>ALTER INDEX</td>
</tr>
</tbody>
</table>
</div>
<h3 id="1-1模式定义和删除"><a href="#1-1模式定义和删除" class="headerlink" title="1.1模式定义和删除"></a>1.1模式定义和删除</h3><p style="text-indent:2em">模式定义语句如下：

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SCHEMA <span class="operator">&lt;</span>模式名<span class="operator">&gt;</span> <span class="keyword">AUTHORIZATION</span> <span class="operator">&lt;</span>用户名<span class="operator">&gt;</span> [<span class="operator">&lt;</span>表定义子句<span class="operator">&gt;</span><span class="operator">|</span><span class="operator">&lt;</span>视图定义子句<span class="operator">&gt;</span><span class="operator">|</span><span class="operator">&lt;</span>授权定义子句<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure>

</p><p style="text-indent:2em">删除模式语句如下：

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> SCHEMA <span class="operator">&lt;</span>模式名<span class="operator">&gt;</span><span class="operator">&lt;</span>CASCADE<span class="operator">|</span>RESTRICT<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

### 1.2基本表的定义和修改

**表的定义**

</p><p style="text-indent:2em">定义基本表：

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>[列级完整性约束条件])</span><br></pre></td></tr></table></figure>

</p><p style="text-indent:2em">例：

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*建立一个学生表*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student(</span><br><span class="line">	Sno <span class="type">CHAR</span>(<span class="number">9</span>)<span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    Sname <span class="type">CHAR</span>(<span class="number">20</span>)<span class="keyword">UNIQUE</span>,</span><br><span class="line">    Ssex <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">    Sage <span class="type">SMALLINT</span>,</span><br><span class="line">    Sdept <span class="type">CHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">/*建立一个课程表*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Course(</span><br><span class="line">	Cno <span class="type">CHAR</span>(<span class="number">4</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    Cname <span class="type">CHAR</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    Cpno <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">    Ccredit <span class="type">SMALLINT</span>,</span><br><span class="line">    <span class="comment">/*表级完整性约束条件*/</span></span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (Cpno) <span class="keyword">REFERENCES</span> Course(Cno)</span><br><span class="line">);</span><br><span class="line"><span class="comment">/*建立学生选课表SC*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC(</span><br><span class="line">	Sno <span class="type">CHAR</span>(<span class="number">9</span>),</span><br><span class="line">    Cno <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">    Grade <span class="type">SMALLINT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(Sno,Cno),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY(Sno) <span class="keyword">REFERENCES</span> Student(Sno),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY(Cno) <span class="keyword">REFERENCES</span> Cource(Cno)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</p><p style="text-indent:2em">表中的每一个属性都来自一个域，域的概念用数据类型实现，以下是常用的几种数据类型：

| 数据类型                      | 含义                         |
| ----------------------------- | ---------------------------- |
| CHAR(N),CHARACTER(N)          | 定长字符串                   |
| VARCHAR(N),CHARACTERVARING(N) | 最大长度为n的字符串          |
| CLOB                          | 字符串大对象                 |
| BLOB                          | 二进制大对象                 |
| INT,INTEGER                   | 长整数                       |
| SMALLINT                      | 短整数                       |
| BIGINT                        | 大整数                       |
| NUMERIC(P,D)                  | 定点数，p位数，小数点后有d位 |
| DECIMAL(P,D),DEC(P,D)         | 同上                         |
| REAL                          | 单精度浮点                   |
| DOUBLE PRECISION              | 双精度浮点                   |
| FLOAT(N)                      | 可选精度浮点                 |
| BOOLEAN                       | 逻辑布尔量                   |
| DATE                          | 日期，YYYY-MM-DD             |
| TIME                          | 时间，HH:MM:SS               |
| TIMESTAMP                     | 时间戳类型                   |
| INTERVAL                      | 时间间隔类型                 |

</p><p style="text-indent:2em">每一个表都属于一种模式，使用以下方法可以定义基本表所属的模式：

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TEST.Student(...);</span><br></pre></td></tr></table></figure>

**表的修改**

</p><p style="text-indent:2em">修改基本表的格式为：

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span><span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">ADD</span>[<span class="keyword">COLUMN</span>]<span class="operator">&lt;</span>新列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>[完整性约束]]</span><br><span class="line">[<span class="keyword">ADD</span><span class="operator">&lt;</span>表级完整性约束<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">DROP</span> [<span class="keyword">COLUMN</span>]<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>[CASCADE<span class="operator">|</span>RESTRICT]]</span><br><span class="line">[<span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span><span class="operator">&lt;</span>完整性约束名<span class="operator">&gt;</span>[RESTRICT<span class="operator">|</span>CASCADE]]</span><br><span class="line">[<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span><span class="operator">&lt;</span>列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure>

</p><p style="text-indent:2em">例：

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student <span class="keyword">ADD</span> S_entrance <span class="type">DATE</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> Sage <span class="type">INT</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Course <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span>(Cname);</span><br></pre></td></tr></table></figure>

### 1.3建立索引

</p><p style="text-indent:2em">建立索引是加快查询速度的有效手段。建立索引的一般格式为：

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>][CLUSTER] INDEX<span class="operator">&lt;</span>索引名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>[<span class="operator">&lt;</span>次序<span class="operator">&gt;</span>][,<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>[次序]]...)</span><br></pre></td></tr></table></figure>

- UNIQUE表示索引的每一个索引值只对应唯一的数据记录。
- CLUSTER表示聚簇索引。
- 次序可选为ASC升序或DESC降序，默认为升序ASC

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX Stusno <span class="keyword">ON</span> Student(Sno);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX Cousno <span class="keyword">ON</span> Cource(Cno);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX SCno <span class="keyword">ON</span> SC(Sno <span class="keyword">ASC</span>,Cno <span class="keyword">DESC</span>);</span><br></pre></td></tr></table></figure>

## 2.数据查询

</p><p style="text-indent:2em">基本查询格式如下：</p>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br></pre></td></tr></table></figure>
<h3 id="2-1-单表查询"><a href="#2-1-单表查询" class="headerlink" title="2.1 单表查询"></a>2.1 单表查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#基本列查询</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">#去除重复元素</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">#查询满足条件的元组</span><br><span class="line"><span class="keyword">WHERE</span> ... <span class="keyword">BETWEEN</span> ... <span class="keyword">AND</span> ...;</span><br><span class="line"><span class="keyword">WHERE</span> ... <span class="keyword">IN</span> ();</span><br><span class="line"><span class="keyword">WHERE</span> ... <span class="keyword">LIKE</span> <span class="string">&#x27;_*_A%&#x27;</span> <span class="keyword">ESCAPE</span> <span class="string">&#x27;*&#x27;</span>;			#_表示单字符，<span class="operator">%</span>表示任意长度字符，<span class="keyword">ESCAPE</span>表示换码字符</span><br><span class="line"><span class="keyword">WHERE</span> ... <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line">#<span class="keyword">ORDER</span> <span class="keyword">BY</span>子句</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ... <span class="keyword">DESC</span><span class="operator">/</span><span class="keyword">ASC</span></span><br><span class="line">#限制条数</span><br><span class="line">LIMIT <span class="number">0</span>,<span class="number">2</span></span><br><span class="line"></span><br><span class="line">#聚集函数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> STUDENT;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> SNO)</span><br><span class="line"><span class="keyword">FROM</span> SC;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(GRADE)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> CNO<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(GRADE)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> CNO<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	聚集函数遇到空值时除COUNT(*)外，都直接跳过空值。</span></span><br><span class="line"><span class="comment">	WHERE语句不可以用聚集函数作为条件表达式，聚集函数只能用于SELECT和GROUP BY中的HAVING子句</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#<span class="keyword">GROUP</span> <span class="keyword">BY</span>子句</span><br><span class="line"><span class="keyword">SELECT</span> CNO,<span class="built_in">COUNT</span>(SNO)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> CNO;</span><br><span class="line"><span class="keyword">SELECT</span> SNO</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> SNO</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">3</span>;</span><br><span class="line"><span class="keyword">SELECT</span> SNO,<span class="built_in">AVG</span>(GRADE)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> SNO</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(GRADE<span class="operator">&gt;=</span><span class="number">90</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2-2-连接查询"><a href="#2-2-连接查询" class="headerlink" title="2.2 连接查询"></a>2.2 连接查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 连接</span><br><span class="line"><span class="keyword">SELECT</span> student.sno,sname</span><br><span class="line"><span class="keyword">FROM</span> student,sc</span><br><span class="line"><span class="keyword">WHERE</span> student.sno<span class="operator">=</span>sc.sno <span class="keyword">AND</span></span><br><span class="line">	sc.cno<span class="operator">=</span><span class="string">&#x27;2&#x27;</span> <span class="keyword">AND</span> sc.grade<span class="operator">&gt;</span><span class="number">90</span>;</span><br><span class="line"># 自然连接(把目标列中重复的属性去掉)，方式同上</span><br><span class="line"># 自身连接，需要为表起别名</span><br><span class="line"><span class="keyword">SELECT</span> first.cno,seconde.cpno</span><br><span class="line"><span class="keyword">FROM</span> course <span class="keyword">first</span>,course <span class="keyword">second</span></span><br><span class="line"><span class="keyword">WHERE</span> first.cpno<span class="operator">=</span>second.cno;</span><br><span class="line"># 外连接，把表中的悬浮元组保存在结果关系中</span><br><span class="line"><span class="keyword">SELECT</span> student.sno,sname,ssex,sage,sdept,cno,grade</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> sc <span class="keyword">ON</span> (student.sno<span class="operator">=</span>sc.sno)</span><br><span class="line"># 多表连接和以上类似</span><br></pre></td></tr></table></figure>
<h3 id="2-3-嵌套查询"><a href="#2-3-嵌套查询" class="headerlink" title="2.3 嵌套查询"></a>2.3 嵌套查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># 不相关子查询</span><br><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> dept <span class="keyword">IN</span></span><br><span class="line">	(</span><br><span class="line">        <span class="keyword">SELECT</span> dept </span><br><span class="line">        <span class="keyword">FROM</span> student</span><br><span class="line">        <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;刘晨&#x27;</span></span><br><span class="line">    );</span><br><span class="line"># 相关子查询</span><br><span class="line"><span class="keyword">SELECT</span> sno,cno</span><br><span class="line"><span class="keyword">FROM</span> SC x</span><br><span class="line"><span class="keyword">WHERE</span> Grade <span class="operator">&gt;=</span> (</span><br><span class="line">    			<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(Grade)</span><br><span class="line">               	<span class="keyword">FROM</span> SC y</span><br><span class="line">    			<span class="keyword">WHERE</span> y.sno<span class="operator">=</span>x.sno</span><br><span class="line">               );</span><br><span class="line"># <span class="keyword">ANY</span>(<span class="keyword">SOME</span>)<span class="operator">/</span><span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> name,age</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> age<span class="operator">&lt;</span><span class="keyword">ALL</span></span><br><span class="line">	(</span><br><span class="line">        <span class="keyword">SELECT</span> age</span><br><span class="line">        <span class="keyword">FROM</span> student</span><br><span class="line">        <span class="keyword">WHERE</span> dept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">AND</span> dept<span class="operator">!=</span><span class="string">&#x27;CS&#x27;</span>;</span><br><span class="line"># EXIST</span><br><span class="line"><span class="keyword">SELECT</span> name </span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">	(</span><br><span class="line">    	<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">        <span class="keyword">FROM</span> SC</span><br><span class="line">        <span class="keyword">WHERE</span> sno<span class="operator">=</span>student.sno <span class="keyword">AND</span> cno<span class="operator">=</span><span class="string">&#x27;1&#x27;</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<h3 id="2-4-集合查询"><a href="#2-4-集合查询" class="headerlink" title="2.4 集合查询"></a>2.4 集合查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> dept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span> (<span class="keyword">UNION</span> <span class="keyword">ALL</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> age<span class="operator">&lt;=</span><span class="number">19</span>;</span><br><span class="line"># <span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> dept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> age<span class="operator">&lt;=</span><span class="number">19</span>;</span><br><span class="line"># <span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> dept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> age<span class="operator">&lt;=</span><span class="number">19</span>;</span><br></pre></td></tr></table></figure>
<h2 id="3-数据更新"><a href="#3-数据更新" class="headerlink" title="3.数据更新"></a>3.数据更新</h2><h3 id="3-1-插入"><a href="#3-1-插入" class="headerlink" title="3.1 插入"></a>3.1 插入</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 插入元组</span><br><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> student(sno,sname,ssex,sdept,sage)				#可以不指出属性名，但<span class="keyword">VALUE</span>要保持顺序</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;201215128&#x27;</span>,<span class="string">&#x27;陈东&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;IS&#x27;</span>,<span class="number">18</span>);			  #未给出的列将自动赋空值</span><br><span class="line"># 插入子查询结果</span><br><span class="line">CREAT <span class="keyword">TABLE</span> DEPT_AGE</span><br><span class="line">	(SDEPT <span class="type">CHAR</span>(<span class="number">15</span>)</span><br><span class="line">     AVG_AGE <span class="type">SMALLINT</span>);</span><br><span class="line"><span class="keyword">INSERT</span> DEPT_AGE(SDEPT,AVG_AGE)</span><br><span class="line"><span class="keyword">SELECT</span> SDEPT,<span class="built_in">AVG</span>(SAGE)</span><br><span class="line"><span class="keyword">FROM</span> STUDENT</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> SDEPT;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-修改数据"><a href="#3-2-修改数据" class="headerlink" title="3.2 修改数据"></a>3.2 修改数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 修改一个元组的值</span><br><span class="line"><span class="keyword">UPDATE</span> student</span><br><span class="line"><span class="keyword">SET</span> sage<span class="operator">=</span><span class="number">22</span></span><br><span class="line"><span class="keyword">WHERE</span> sno<span class="operator">=</span><span class="string">&#x27;201215121&#x27;</span>;</span><br><span class="line"># 修改多个元组的值</span><br><span class="line"><span class="keyword">UPDATE</span> student</span><br><span class="line"><span class="keyword">SET</span> sage<span class="operator">=</span>sage<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line"># 带子查询的修改语句</span><br><span class="line"><span class="keyword">UPDATE</span> SC</span><br><span class="line"><span class="keyword">SET</span> grade<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">WHERE</span> sno <span class="keyword">IN</span></span><br><span class="line">	(<span class="keyword">SELECT</span> sno</span><br><span class="line">     <span class="keyword">FROM</span> student</span><br><span class="line">     <span class="keyword">WHERE</span> sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="3-3-删除数据"><a href="#3-3-删除数据" class="headerlink" title="3.3 删除数据"></a>3.3 删除数据</h3><p style="text-indent:2em">使用DELETE语句进行删除，方式与修改数据的方式相同。</p>

<h2 id="4-空值的处理"><a href="#4-空值的处理" class="headerlink" title="4.空值的处理"></a>4.空值的处理</h2><p style="text-indent:2em">空值是‘不知道’，‘不确定’，‘不存在’的值。在插入元组时，未指定的属性将为空。空值通过IS NULL和IS NOT NULL来判断。属性定义中有NOT NULL约束条件的不能取空值，加了UNIQUE限制的属性不能取空值，码属性不能取空值。空值与另一个值的算数运算结果为空值，与另一个值的比较运算结果为UNKNOWN。在查询语句中，只有使WHERE和HAVING子句中的选择条件为<b>TRUE</b>的元组才被选出作为结果。</p>

<h2 id="5-视图"><a href="#5-视图" class="headerlink" title="5.视图"></a>5.视图</h2><h3 id="5-1-定义与删除视图"><a href="#5-1-定义与删除视图" class="headerlink" title="5.1 定义与删除视图"></a>5.1 定义与删除视图</h3><p style="text-indent:2em">CREAT VIEW命令用于建立视图。该语句将视图的定义存入数据字典，并不执行其中的SELECT语句，只在对视图查询时，才按视图的定义从基本表中将数据查出。</p>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 建立视图，省略属性列名</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_Student</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> sno,sname,sage</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> sdept<span class="operator">=</span><span class="string">&#x27;IS&#x27;</span>;</span><br><span class="line"># 建立视图，并要求进行修改和插入操作时仍保证该视图满足<span class="keyword">SELECT</span>的条件</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_Student</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> sno,sname,sage</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> sdept<span class="operator">=</span><span class="string">&#x27;IS&#x27;</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION</span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">若视图从单个基本表导出，只去掉了某些行列，保留了主码，则称这类视图为<b>行列子集视图</b>。</p>

<p style="text-indent:2em">视图不仅可以建立在一个或多个表上，也可以建立在一个或多个定义好的视图上。还可以用带有聚集函数和GROUP BY的子句查询来定义视图，这种视图称为分组视图。</p>

<p style="text-indent:2em">删除视图使用DROP VIEW语句。删除后视图的定义将从数据字典中删除。如果基本表删除了，视图将无法使用，但定义还在数据字典中，需要使用DROP VIEW删除。</p>

<h3 id="5-2-查询视图"><a href="#5-2-查询视图" class="headerlink" title="5.2 查询视图"></a>5.2 查询视图</h3><p style="text-indent:2em">视图定义后就可以像基本表一样查询了。如果查询的视图存在，则从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询，再执行修正的查询，这一转换过程称为视图消解。</p>

<h3 id="5-3-更新视图"><a href="#5-3-更新视图" class="headerlink" title="5.3 更新视图"></a>5.3 更新视图</h3><p style="text-indent:2em">视图的更新与查询类似，最终要转换为对基本表的更新，也需要进行视图消解。需要注意的是，有些事图是不可更新的，还有一些视图则是不允许更新的。</p>

<h1 id="第四章-数据库安全性"><a href="#第四章-数据库安全性" class="headerlink" title="第四章 数据库安全性"></a>第四章 数据库安全性</h1><p style="text-indent:2em">数据库安全性是指防止用户对数据库的不合法使用导致的数据泄露，更改或破坏。</p>

<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p style="text-indent:2em">不安全因素：</p>

<ul>
<li>非授权用户对数据库的恶意存取和破坏</li>
<li>重要或敏感的数据被泄露</li>
<li>安全环境的脆弱性</li>
</ul>
<p style="text-indent:2em">安全标准：</p>

<ul>
<li>TCSEC</li>
<li>CC</li>
</ul>
<h2 id="2-数据库安全性控制"><a href="#2-数据库安全性控制" class="headerlink" title="2.数据库安全性控制"></a>2.数据库安全性控制</h2><h3 id="2-1-用户身份鉴别"><a href="#2-1-用户身份鉴别" class="headerlink" title="2.1 用户身份鉴别"></a>2.1 用户身份鉴别</h3><p style="text-indent:2em">常用的用户身份鉴别方法：</p>

<ul>
<li>静态口令鉴别</li>
<li>动态口令鉴别</li>
<li>生物特征鉴别</li>
<li>智能卡鉴别</li>
</ul>
<h3 id="2-2-存取控制"><a href="#2-2-存取控制" class="headerlink" title="2.2 存取控制"></a>2.2 存取控制</h3><p style="text-indent:2em">存取控制机制主要包括<b>定义用户权限</b>和<b>合法权限检查两部分</b>。两类根据数据库安全等级所支持的存取控制为：</p>

<ul>
<li>自主存取控制DAC(C1级安全)</li>
<li>强制存取控制MAC(B1级安全)</li>
</ul>
<h3 id="2-3-自主存取控制方法"><a href="#2-3-自主存取控制方法" class="headerlink" title="2.3 自主存取控制方法"></a>2.3 自主存取控制方法</h3><p style="text-indent:2em">自主存取控制方法中，用户对于不同的数据库对象有不同的存取权限，不同用户对同一对象也有不同的权限，用户还可以将自己的存取权限转授给他人。</p>

<p style="text-indent:2em">自主存取控制主要通过GRANT语句和REVOKE语句实现。</p>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">GRANT</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> STUDENT</span><br><span class="line"><span class="keyword">TO</span> U1</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;	# 该用户可以以同样方式授权其他用户</span><br><span class="line"># <span class="keyword">REVOKE</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> STUDENT</span><br><span class="line"><span class="keyword">FROM</span> U1;</span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">对数据库模式的授权在创建用户时实现，数据库用户有三种权限：CONNECT,RESOURCE,DB。</p>

<p style="text-indent:2em">数据库还支持对一组与数据库操作相关的权限命名，称为角色。使用CREATE ROLE语句创建，授权和收回权限的方式与对用户的操作相同。</p>

<p style="text-indent:2em">自主存取控制的缺点是可能存在数据无意识的泄露。因为数据本身并无安全性标记。</p>

<h3 id="2-4-强制存取控制方法"><a href="#2-4-强制存取控制方法" class="headerlink" title="2.4 强制存取控制方法"></a>2.4 强制存取控制方法</h3><p style="text-indent:2em">强制存取控制方法中，数据库管理系统所管理的全部实体被分为主体和客体。主体包括用户及用户进程，客体包括文件，基本表等。数据库系统为每个主体或客体的实例创建一个敏感度标记。每个数据库对象被标以一定的密级，每一个用户被授予某一个级别的许可证。对于任意一个对象，只有具有合法许可证的用户才可以存取。主体对客体的存取必须遵循以下规则：</p>

<ul>
<li>主体许可证级别大于或等于客体密级时，才能读取客体</li>
<li>主体许可证级别小于或等于客体密级时，才能写客体</li>
</ul>
<p style="text-indent:2em">第二条是为了防止恶意降低密级进行数据泄露。</p>

<h2 id="3-视图机制"><a href="#3-视图机制" class="headerlink" title="3.视图机制"></a>3.视图机制</h2><p style="text-indent:2em">视图由一个或多个基本表导出，是虚表，在数据库中只保存定义。视图可以像基本表一样进行查询和删除，但更改受限制。视图机制可以限制数据对象，把保密数据对无权存取的用户隐藏起来，提供一定程度的安全保护。使用视图可以简化用户的操作；能够使用户以多种角度看待同一数据；对重构数据库提供了一定的逻辑独立性；可以更清晰地表达查询。</p>

<h2 id="4-审计机制"><a href="#4-审计机制" class="headerlink" title="4.审计机制"></a>4.审计机制</h2><p style="text-indent:2em">审计功能把用户对数据库的所有操作记录下来放入审计日志，审计员可以通过审计日志监控数据库行为，找到非法存取数据的人，时间和内容等。审计机制提供了一种事后安全检查的机制。</p>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AUDIT <span class="keyword">ALTER</span>,<span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">ON</span> SC;</span><br><span class="line">NOAUDIT <span class="keyword">ALTER</span>,<span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">ON</span> SC;</span><br></pre></td></tr></table></figure>
<h2 id="5-数据加密"><a href="#5-数据加密" class="headerlink" title="5.数据加密"></a>5.数据加密</h2><p style="text-indent:2em">数据加密能有效防止数据库数据在存储和传输中失密。数据加密主要包括存储加密和传输加密。</p>

<h2 id="6-其他安全性保护"><a href="#6-其他安全性保护" class="headerlink" title="6.其他安全性保护"></a>6.其他安全性保护</h2><p style="text-indent:2em">其他安全性保护包括推理控制，数据库应用中的隐蔽信道和数据隐私保护等技术。</p>

<h1 id="第五章-数据库完整性"><a href="#第五章-数据库完整性" class="headerlink" title="第五章 数据库完整性"></a>第五章 数据库完整性</h1><p style="text-indent:2em">数据库完整性是指数据的正确性和相容性。为维护数据库的完整性，数据库管理系统必须能够实现以下功能：</p>

<ul>
<li>提供定义完整性约束的机制</li>
<li>提供完整性检查</li>
<li>进行违约处理</li>
</ul>
<h2 id="1-实体完整性"><a href="#1-实体完整性" class="headerlink" title="1.实体完整性"></a>1.实体完整性</h2><p style="text-indent:2em">实体完整性定义：</p>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 列级定义</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">	(Sno <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">PRIMARY</span> KEY</span><br><span class="line">    );</span><br><span class="line"># 表级定义</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">	(Sno <span class="type">CHAR</span>(<span class="number">9</span>),</span><br><span class="line">     Sname <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">     <span class="keyword">PRIMARY</span> KEY(Sno,Sname)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">完整性检查中，检查主码值是否唯一，主码的属性是否为空，不唯一或有属性为空就拒绝插入或修改。</p>

<h2 id="2-参照完整性"><a href="#2-参照完整性" class="headerlink" title="2.参照完整性"></a>2.参照完整性</h2><p style="text-indent:2em">用FOREIGN KEY定义哪些为外码，REFERENCES指明外码参照哪些表的主码。</p>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">	(Sno <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     Cno <span class="type">CHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     GRADE <span class="type">SMALLINT</span>,</span><br><span class="line">     PRIMARYKEY(Sno,Cno),</span><br><span class="line">     <span class="keyword">FOREIGN</span> KEY(Sno) <span class="keyword">REFERENCES</span> Student(Sno),</span><br><span class="line">     <span class="keyword">FOREIGN</span> KEY(Cno) <span class="keyword">REFERENCES</span> Cources(Cno)</span><br><span class="line">	);</span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">破坏参照完整性发生时，系统可以拒绝执行；级联操作(删除或更改所有导致不一致的元组);设置为空值（将导致不一致的元组的属性设为空值）。默认为拒绝执行，可显式进行说明：</p>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">	(Sno <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     Cno <span class="type">CHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     GRADE <span class="type">SMALLINT</span>,</span><br><span class="line">     PRIMARYKEY(Sno,Cno),</span><br><span class="line">     <span class="keyword">FOREIGN</span> KEY(Sno) <span class="keyword">REFERENCES</span> Student(Sno)</span><br><span class="line">     	<span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE</span><br><span class="line">     	<span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE,</span><br><span class="line">     <span class="keyword">FOREIGN</span> KEY(Cno) <span class="keyword">REFERENCES</span> Cources(Cno)</span><br><span class="line">     	<span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION</span><br><span class="line">     	<span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE</span><br><span class="line">	);</span><br></pre></td></tr></table></figure>
<h2 id="3-用户定义的完整性"><a href="#3-用户定义的完整性" class="headerlink" title="3.用户定义的完整性"></a>3.用户定义的完整性</h2><p style="text-indent:2em">用户定义属性上的约束条件包括：</p>

<ul>
<li>列值非空NOT NULL</li>
<li>列值唯一UNIQUE</li>
<li>检查列值是否满足一个条件CHECK</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 属性上的约束条件</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">	(Sno <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     Cno <span class="type">CHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     GRADE <span class="type">SMALLINT</span> <span class="keyword">CHECK</span> (GRADE<span class="operator">&gt;=</span><span class="number">0</span> <span class="keyword">AND</span> GRADE<span class="operator">&lt;=</span><span class="number">100</span>),</span><br><span class="line">     PRIMARYKEY(Sno,Cno),</span><br><span class="line">     <span class="keyword">FOREIGN</span> KEY(Sno) <span class="keyword">REFERENCES</span> Student(Sno),</span><br><span class="line">     <span class="keyword">FOREIGN</span> KEY(Cno) <span class="keyword">REFERENCES</span> Cources(Cno)</span><br><span class="line">	);</span><br><span class="line"># 元组上的约束条件</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">	(Sno <span class="type">CHAR</span>(<span class="number">9</span>),</span><br><span class="line">     Sname <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     Ssex <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">     Sage <span class="type">SMALLINT</span>,</span><br><span class="line">     <span class="keyword">PRIMARY</span> KEY(Sno),</span><br><span class="line">     <span class="keyword">CHECK</span>(Ssex<span class="operator">=</span>‘女’ <span class="keyword">OR</span> Sname <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">&#x27;Ms.%&#x27;</span>)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<h2 id="4-完整性约束命名"><a href="#4-完整性约束命名" class="headerlink" title="4.完整性约束命名"></a>4.完整性约束命名</h2><p style="text-indent:2em">为了方便灵活地增加，删除完整性约束条件，可以对完整性约束进行命名。</p>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> STUDENT</span><br><span class="line">	(Sno <span class="type">CHAR</span>(<span class="number">9</span>),</span><br><span class="line">     Sname <span class="type">CHAR</span>(<span class="number">20</span>)</span><br><span class="line">     <span class="keyword">CONSTRAINT</span> C1 <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     Sage <span class="type">SMALLINT</span></span><br><span class="line">     <span class="keyword">CONSTRAINT</span> C2 <span class="keyword">CHECK</span>(Sage<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">AND</span> Sage<span class="operator">&lt;</span><span class="number">100</span>),</span><br><span class="line">     Ssex <span class="type">CHAR</span>(<span class="number">2</span>)</span><br><span class="line">     <span class="keyword">CONSTRAINT</span> C4 <span class="keyword">CHECK</span> (Ssex <span class="keyword">IN</span> (<span class="string">&#x27;male&#x27;</span>,<span class="string">&#x27;female&#x27;</span>)),</span><br><span class="line">     <span class="keyword">CONSTRAINT</span> StudentKey <span class="keyword">PRIMARY</span> KEY(Sno)</span><br><span class="line">    );</span><br><span class="line"># <span class="keyword">ALTER</span> CONSTRAINTS</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">	<span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> C1;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">	<span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> C2 <span class="keyword">CHECK</span>(Sno<span class="operator">&gt;</span><span class="string">&#x27;000000000&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="5-断言"><a href="#5-断言" class="headerlink" title="5.断言"></a>5.断言</h2><p style="text-indent:2em">断言是更具一般性的约束，可以定义涉及多个表或聚集操作的比较复杂的完整性约束。使用CREATE ASSERTION语句来创建断言，且每个断言都有一个名字。</p>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 限制数据库课程最多<span class="number">60</span>名学生选修</span><br><span class="line"><span class="keyword">CREATE</span> ASSERTION ASSE_SC_DB_NUM</span><br><span class="line">	<span class="keyword">CHECK</span> (<span class="number">60</span><span class="operator">&gt;=</span>(</span><br><span class="line">        		<span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line">                <span class="keyword">FROM</span> Course,SC</span><br><span class="line">                <span class="keyword">WHERE</span> SC.CNO<span class="operator">=</span>COURSE.CNO <span class="keyword">AND</span> COURSE.CNAME<span class="operator">=</span>‘数据库’</span><br><span class="line">    			)</span><br><span class="line">          );</span><br><span class="line"># 限制每个学期每门课程最多<span class="number">60</span>名学生选修</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SC <span class="keyword">ADD</span> TERM <span class="type">DATE</span>;</span><br><span class="line"><span class="keyword">CREATE</span> ASSERTION ASSE_SC_CNUM2</span><br><span class="line">	<span class="keyword">CHECK</span>(</span><br><span class="line">        <span class="number">60</span><span class="operator">&gt;=</span><span class="keyword">ALL</span>(<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> SC <span class="keyword">GROUP</span> <span class="keyword">BY</span> Cno,TERM)</span><br><span class="line">    	);</span><br><span class="line"># 删除断言</span><br><span class="line"><span class="keyword">DROP</span> ASSERTION 断言名</span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">需要注意的是，如果断言很复杂，则系统在检测和维护断言上的开销较高，使用断言时需要注意。</p>

<h2 id="6-触发器"><a href="#6-触发器" class="headerlink" title="6.触发器"></a>6.触发器</h2><p style="text-indent:2em">触发器是用户定义在关系表上的一类由时间驱动的特殊过程。定义后，触发器将被保存在数据库服务器中，任何用户对表的增、删、查、改操作均由服务器自动激活相应的触发器。触发器类似约束，但更加灵活，可以实施更为复杂的检查和操作。关于触发器有以下几点：</p>

<ul>
<li>表的拥有者才可以创建触发器，而且可创建的触发器数量有限。</li>
<li>触发器只能定义在基本表上，不能定义在视图上。</li>
<li>触发事件可以是UPDATE/INSERT等的组合，AFTER/BEFORE是触发的时机。</li>
<li>触发器按照触发间隔可分为行级触发器FOR EACH ROW和语句级触发器FOR EACH STATEMENT。</li>
<li>触发器被激活时，只有当触发条件为真时才执行。</li>
</ul>
<p style="text-indent:2em">触发器的一般格式为：</p>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名</span><br><span class="line">BEFORE<span class="operator">|</span>AFTER 触发事件 <span class="keyword">ON</span> 表名</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span><span class="operator">|</span><span class="keyword">OLD</span> <span class="type">ROW</span> <span class="keyword">AS</span> 变量</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span><span class="operator">|</span>STATEMENT</span><br><span class="line"><span class="keyword">WHEN</span> 触发条件 触发动作体</span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">以下是触发器的几个例子：</p>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 将<span class="keyword">INSERT</span>语句增加的元组数记录到insertlog中</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Student_Count</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> Student</span><br><span class="line"><span class="keyword">REFERENCING</span></span><br><span class="line">	<span class="keyword">NEW</span> <span class="keyword">TABLE</span> <span class="keyword">AS</span> DELTA</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> STATEMENT</span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> StudentInsertLog(Numbers)</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> DELTA;</span><br><span class="line"># 将分数增加<span class="number">10</span><span class="operator">%</span>的操作添加到一个另一个表SC_U</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> SC_T</span><br><span class="line">AFTER <span class="keyword">UPDATE</span> <span class="keyword">OF</span> Grade <span class="keyword">ON</span> SC</span><br><span class="line"><span class="keyword">REFERENCING</span></span><br><span class="line">	OLDROW <span class="keyword">AS</span> OldTuple</span><br><span class="line">	NEWROW <span class="keyword">AS</span> NewTuple</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (NewTuple.Grade<span class="operator">&gt;=</span><span class="number">1.1</span><span class="operator">*</span>OldTuple.Grade)</span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC_U (Sno,Cno,OldGrade,NewGrade)</span><br><span class="line">	<span class="keyword">VALUES</span>(OldTuple.Sno,OldTuple.Cno,ldTuple.Grade,NewTuple.Grade);</span><br><span class="line"># 教授的工资不低于<span class="number">4000</span>，低于<span class="number">4000</span>则改为<span class="number">4000</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Insert_Or_Update_Sal</span><br><span class="line">BEFORE <span class="keyword">INSERT</span> <span class="keyword">OR</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> Teacher</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">row</span> <span class="keyword">AS</span> newtuple</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	IF(newtuple.Job<span class="operator">=</span>‘教授’) <span class="keyword">AND</span> newtuple.Sal<span class="operator">&lt;</span><span class="number">4000</span>)</span><br><span class="line">		<span class="keyword">THEN</span> newtuple.Sal:<span class="operator">=</span><span class="number">4000</span>;</span><br><span class="line">	<span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">一个表上可能有多个触发器，触发器激活时执行顺序是BEFORE触发器、激活触发器的SQL语句，该表上的AFTER触发器。对于同一个表上的多个触发器，遵循涉嫌创建谁先执行的原则，有的数据库管理系统按照触发器名字排序执行。</p>

<p style="text-indent:2em">删除触发器的语句如下：</p>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROP <span class="keyword">TRIGGER</span> 触发器名 <span class="keyword">ON</span> 表名</span><br></pre></td></tr></table></figure>
<h1 id="第六章-关系数据理论"><a href="#第六章-关系数据理论" class="headerlink" title="第六章 关系数据理论"></a>第六章 关系数据理论</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h2><p style="text-indent:2em">本章主要的内容为如何构造一个好的数据库模式，即应该构造几个关系模式，每个关系由哪些属性组成等。</p>

<p style="text-indent:2em">作为一个二维表，关系要满足的最基本的要求是每个分量必须是不可分的数据项。满足该条件的关系模式就属于<b>第一范式1NF</b>。</p>

<p style="text-indent:2em">数据依赖是关系内部属性与属性之间的约束关系，体现数据间的相关联系。数据依赖中最重要的是函数依赖和多值依赖。函数依赖是最为普遍的，但是如果函数依赖存在不好的性质，就会导致插入异常，删除异常，冗余等许多问题。</p>

<p style="text-indent:2em">函数依赖的一个例子：F={Sno->Sdept，Sdept->Mname，(Sno，Cno)->Grade}。</p>

<h2 id="2-规范化"><a href="#2-规范化" class="headerlink" title="2.规范化"></a>2.规范化</h2><h3 id="2-1-函数依赖"><a href="#2-1-函数依赖" class="headerlink" title="2.1 函数依赖"></a>2.1 函数依赖</h3><p style="text-indent:2em">函数依赖包括非平凡的函数依赖，平凡的函数依赖(X->X)。若X->Y，X称为函数的决定属性组，也称为决定因素。通常我们只讨论非平凡的函数依赖。</p>

<p style="text-indent:2em">函数依赖还可以分为完全函数依赖和部分函数依赖。对于完全函数依赖X->Y，Y不依赖于X的真子集，只有选取完整的X，才能选定唯一的Y，例如(Sno，Cno)->Grade。而不完全依赖是指X->Y，X的真子集和Y也能形成依赖关系，即X的真子集就可以确定唯一的Y，例如(Sno，Cno)->Sdept。</p>

<h3 id="2-2-码"><a href="#2-2-码" class="headerlink" title="2.2 码"></a>2.2 码</h3><p style="text-indent:2em">设K为关系R<U,F>中的属性或属性组，若U完全依赖于K，则K为R的候选码。若候选码多于一个，则其中一个被选定为主码。任何一个候选码中的属性为主属性，否则为非主属性或非码属性。</U,F></p>

<p style="text-indent:2em">关系R中的属性或属性组X非R的码，为另一个关系模式的码，则X是R的外码。</p>

<h3 id="2-3-范式"><a href="#2-3-范式" class="headerlink" title="2.3 范式"></a>2.3 范式</h3><p style="text-indent:2em">关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式。一个低一级范式的关系模式通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫做规范化。</p>

<h3 id="2-4-2NF"><a href="#2-4-2NF" class="headerlink" title="2.4 2NF"></a>2.4 2NF</h3><p style="text-indent:2em">若R为第一范式，且每一个非主属性完全函数依赖于任何一个候选码，则R为第二范式。第二范式保证了关系中的每一个属性，都是可以通过另一个候选码属性确定的，即关系中不存在和候选码无关的属性，这确保了表中只含有与候选码相关的一类信息。</p>

<h3 id="2-5-3NF"><a href="#2-5-3NF" class="headerlink" title="2.5 3NF"></a>2.5 3NF</h3><p style="text-indent:2em">若R中不存在码X，属性组Y及非主属性Z，使得X->Y,Y->Z成立，Y不完全依赖于X，则关系R满足第三范式。这条范式是指关系中不存在传递依赖，每一个属性都是和主码直接相关的。</p>

<p style="text-indent:2em">第三范式可以简单表述为：每一个非主属性既不传递依赖于码，也不部分依赖于码。</p>

<h3 id="2-6-BCNF-修正的第三范式"><a href="#2-6-BCNF-修正的第三范式" class="headerlink" title="2.6 BCNF(修正的第三范式)"></a>2.6 BCNF(修正的第三范式)</h3><p style="text-indent:2em">BCNF在第三范式的基础上，增加了要求：每一个决定因素都包含码。即所有属性都只完全函数依赖于码，不依赖于非码的一组属性。</p>

<h3 id="2-7-4NF"><a href="#2-7-4NF" class="headerlink" title="2.7 4NF"></a>2.7 4NF</h3><p style="text-indent:2em">4NF消除了属性之间的非平凡且非函数依赖的多值依赖。</p>

<h2 id="3-Armstrong公理系统"><a href="#3-Armstrong公理系统" class="headerlink" title="3.Armstrong公理系统"></a>3.Armstrong公理系统</h2><p style="text-indent:2em">Armstrong公理系统是讨论函数依赖的一个完备的公理系统，对于关系模式R<U，F>，有以下推理规则：</U，F></p>

<ul>
<li>自反律：若Y⊆X⊆U，则X→Y为F所蕴含。</li>
<li><p>传递律：若X→Y，Y→Z，则X→Z为F所蕴含。</p>
</li>
<li><p>增广律：若X→Y，Z⊆U，则XZ→YZ为F所蕴含。</p>
</li>
</ul>
<p style="text-indent:2em">在讨论函数依赖时，需要求出Armstrong公理能推导出的所有函数依赖的集合。因此引入以下定义：</p>

<ul>
<li>设F为属性集U上的一组函数依赖，$X_F^+$={A|X→A能由F根据Armstrong公理系统导出}，称其为属性集X关于函数依赖集F的闭包。</li>
</ul>
<p style="text-indent:2em">如果函数依赖集F满足一些条件，则F为一个最小依赖集。下面直接给出<font color="red">求解最小依赖集的方法</font>：</p>

<ul>
<li>使F中函数依赖的右部仅有一个属性(分解)</li>
<li>去掉冗余的函数依赖(先去掉X→Y，求X的闭包，若含Y，则X→Y可以去掉，否则保留)</li>
<li>去掉函数依赖左部冗余的属性(XY→A，求X的闭包，若含A，则X→A，Y可以去掉)</li>
</ul>
<h1 id="第七章-数据库设计"><a href="#第七章-数据库设计" class="headerlink" title="第七章 数据库设计"></a>第七章 数据库设计</h1><h2 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1.概述"></a>1.概述</h2><p style="text-indent:2em">数据库设计是指对于一个给定的应用环境，构造优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效存储和管理数据，满足用户应用需求。特点是重视技术、管理、基础数据的收集和整理；结构(数据)设计和行为(处理)设计相结合。数据库设计的基本步骤如下：</p>

<ul>
<li>需求分析：通过调查分析，获得用户对数据库的信息要求，处理要求，安全性与完整性要求。</li>
<li>概念结构设计：产生独立于数据库管理系统的概念模式(E-R图)。</li>
<li>逻辑结构设计：将E-R图转换为数据模型，如关系模型。并按照用户处理和安全的要求建立必要的视图。</li>
<li>物理结构设计：根据数据库管理系统特点和处理的需要，进行物理存储安排，建立索引，形成数据库内模式。</li>
<li>数据库实施</li>
<li>数据库运行和维护</li>
</ul>
<h2 id="2-需求分析"><a href="#2-需求分析" class="headerlink" title="2.需求分析"></a>2.需求分析</h2><ul>
<li>数据字典：数据字典是通过详细的数据收集和分析后的主要成果。是关于数据库中数据的描述，是元数据。在需求分析阶段建立，在设计过程中不断修改和完善。数据字典通常包含数据流，数据项，数据结构，数据存储和处理过程等。</li>
</ul>
<h2 id="3-概念结构设计"><a href="#3-概念结构设计" class="headerlink" title="3.概念结构设计"></a>3.概念结构设计</h2><p style="text-indent:2em">将需求分析得到的用户需求抽象为概念模型的过程就是概念结构设计。概念模型通常用E-R模型来表示和描述。</p>

<h3 id="3-1-E-R模型"><a href="#3-1-E-R模型" class="headerlink" title="3.1 E-R模型"></a>3.1 E-R模型</h3><p style="text-indent:2em">E-R模型由实体，属性，实体之间的联系等构成。实体型之间的联系包括一对一联系，一对多联系，多对多联系等，多个实体型之间也可以存在联系，单个实体型内也可以存在联系。这些实体与实体之间的联系用E-R图来表示。在E-R图中，对于实体，属性，联系的表示方法如下：</p>

<ul>
<li>实体型用矩形表示</li>
<li>属性用椭圆表示</li>
<li>联系用菱形表示</li>
</ul>
<p style="text-indent:2em">由于一个实体可能存在多个属性，为了表述清晰，可以不把属性在E-R图中画出，而是直接写出，例如：</p>
<p style="text-indent:2em">实体：</p>

<p style="text-indent:2em">实体名1(属性1，属性2，属性3...)</p>

<p style="text-indent:2em">然后再给出E-R图。</p>

<h3 id="3-2-概念结构设计"><a href="#3-2-概念结构设计" class="headerlink" title="3.2 概念结构设计"></a>3.2 概念结构设计</h3><p style="text-indent:2em">概念结构设计的第一步是对数据进行分类，确定实体，属性，联系。实体与属性划分时，能看作属性的尽量看作属性，并按照两条准则：</p>

<ul>
<li>属性不能和其他实体具有联系：例如人事管理系统中，如果职称与工资，补贴无关，就可以视作职工的属性。否则看作一个实体对待更合适。</li>
<li>作为属性，不能有再需要描述的性质。</li>
</ul>
<p style="text-indent:2em">概念结构设计时，通常自顶向下确定需求，自底向上设计概念结构。首先设计各子系统的分E-R图，然后再集成起来，得到全局E-R图。集成过程一般有两步：</p>

<ul>
<li>合并：解决各分E-R图之间的冲突，合并分E-R图产生初步E-R图，冲突有以下几种：<ul>
<li>属性冲突：域或取值单位冲突</li>
<li>命名冲突</li>
<li>结构冲突：同一对象有不同的抽象(在不同子系统分别看作实体，属性)，实体间的联系在不同系统中不同，同一实体有不同的属性等。</li>
</ul>
</li>
<li>消除不必要的冗余，设计基本E-R图</li>
</ul>
<h2 id="4-逻辑结构设计"><a href="#4-逻辑结构设计" class="headerlink" title="4.逻辑结构设计"></a>4.逻辑结构设计</h2><p style="text-indent:2em">逻辑结构设计的任务是把概念结构设计的基本E-R图转变为与选定数据库管理系统对应的数据模型的逻辑结构。下面以关系模型为例介绍转换过程。</p>

<p style="text-indent:2em">将E-R图转换为关系模型的逻辑结构。关系模型是一组关系模式的集合，转换实际上就是将E-R图转换为一些关系模式。其中，实体可以直接转换为关系模式，而联系则有以下情况：</p>

<ul>
<li>1;1联系可以转换为一个关系模式，也可以与任意一端的关系模式合并。</li>
<li>1:n联系可以转换为一个关系模式，或与n端关系模式合并。</li>
<li>m:n或多个实体间的联系可以转换为一个关系模式。</li>
<li>具有相同码的关系模式可以合并。</li>
</ul>
<p style="text-indent:2em">完成转换后，可以对得到的数据模型进行优化，具体的方法是合并与分解，以规范化理论为依据，但不一定要规范化到程度很高，要考虑使用情况。</p>

<p style="text-indent:2em">得到了全局的逻辑模型后，还应该根据局部应用的需求，为用户设计外模式，外模式使用应符合用户习惯的别名，且应该为不同用户设计不同的外模式，并简化用户对系统的使用。</p>

<h2 id="5-物理结构设计"><a href="#5-物理结构设计" class="headerlink" title="5.物理结构设计"></a>5.物理结构设计</h2><p style="text-indent:2em">物理结构设计的任务是为给定的逻辑数据模型选取一个最适合应用要求的物理结构。物理设计分为两步：</p>

<ul>
<li>确定数据库的物理结构，在关系数据库中主要指存取方法和存储结构</li>
<li>对物理结构进行评价，重点评价时间和空间效率</li>
</ul>
<p style="text-indent:2em">下面简要介绍关系型数据库的物理设计。</p>

<h3 id="5-1-存取方法选择"><a href="#5-1-存取方法选择" class="headerlink" title="5.1 存取方法选择"></a>5.1 存取方法选择</h3><p style="text-indent:2em">存取方法是快速存取数据库中数据的技术。数据库管理系统一般提供多种存取方法。常用的存取方法为索引方法和聚簇方法。</p>

<ul>
<li>B+树索引存取方法：对属性列或属性组建立索引。如果一个属性或属性组经常被查询，连接或作为聚集函数的参数，可以考虑建立索引。维护索引要付出代价，因此索引不是越多越好。</li>
<li>HASH索引存取方法：如果一个关系的属性主要出现在等值连接条件或等值比较选择条件中，并且关系大小不变，或数据库提供了动态HASH存取方法，则可以选择HASH存取方法。</li>
<li>聚簇存取方法：将某个属性上有连续或相同值的元组放在连续物理块中称为聚簇。该属性称为<strong>聚簇码</strong>。聚簇可以大大提高按聚簇码查询的效率，但开销也很大，一个关系只能使用一个聚簇码。应该尽量使用稳定的聚簇码，应用应该主要通过聚簇码进行连接或访问，否则聚簇码值总是改变，维护的开销会很大。</li>
</ul>
<h3 id="5-2-确定数据库的存储结构"><a href="#5-2-确定数据库的存储结构" class="headerlink" title="5.2 确定数据库的存储结构"></a>5.2 确定数据库的存储结构</h3><p style="text-indent:2em">数据库的存储结构主要指数据的存放位置，包括确定关系，索引，聚簇，日志，备份等的存储安排或存储结构。确定数据的存放位置，应该将数据的易变部分和稳定部分，经常存取和存取频率低的部分分开存放，提高I/O效率，也可以将日志文件和数据库对象放在不同的磁盘上，或是将较大的表放在两个磁盘上，有许多方法可以让存储结构和存放位置有利于数据库的性能。</p>

<p style="text-indent:2em">关系型数据库管理系统一般都提供了一些系统配置变量和存储分配参数，管理人员可以通过参数对数据库进行物理优化。系统配置变量有很多，例如并发用户数，同时打开的数据库对象数，缓冲区参数，物理块的大小，锁的数目等。</p>

<h2 id="6-数据库的实施和维护"><a href="#6-数据库的实施和维护" class="headerlink" title="6.数据库的实施和维护"></a>6.数据库的实施和维护</h2><p style="text-indent:2em">数据库设计完成后，就要进行数据库的实施，并且组织数据入库，然后就可以使用数据库应用了。数据库应用程序设计应该和数据库设计同时进行，当数据库设计完成后，就可以载入数据，进行应用程序的调试。数据库试运行时，先从小批量数据调试开始，再逐步增加数据；且开始时数据库系统可能还不稳定，操作人员还不熟悉，要做好数据库的转储和恢复，以免破坏数据库。</p>

<p style="text-indent:2em">数据库试运行合格后，就可以投入正式运行了，在运行阶段，维护工作主要包括数据库的转储和恢复，数据库的安全性和完整性控制，数据库性能的监督、分析和改造，数据库的重组织与重构造。这里就不一一介绍了。</p>

<h1 id="第八章-数据库编程"><a href="#第八章-数据库编程" class="headerlink" title="第八章 数据库编程"></a>第八章 数据库编程</h1><p style="text-indent:2em">本章主要介绍的内容是关于数据库编程的，包括嵌入式SQL，过程化SQL，存储过程以及函数。由于不同的数据库实际提供了不同的应用接口，不一定兼容嵌入式SQL，而存储过程以及函数主要在实验中学习，故本章内容不再介绍。</p>

<h1 id="第九章-关系查询处理和查询优化"><a href="#第九章-关系查询处理和查询优化" class="headerlink" title="第九章 关系查询处理和查询优化"></a>第九章 关系查询处理和查询优化</h1><p style="text-indent:2em">本章介绍关系数据库的<b>查询处理</b>和<b>查询优化</b>技术。首先介绍关系数据库管理系统的查询处理步骤，然后介绍查询优化技术。查询优化一般可分为<b>代数优化</b>和<b>物理优化</b>。代数优化是对关系代数表达式的优化，物理优化则是通过存取路径和底层操作算法的选择进行优化。</p>

<h2 id="1-关系数据库系统的查询处理"><a href="#1-关系数据库系统的查询处理" class="headerlink" title="1.关系数据库系统的查询处理"></a>1.关系数据库系统的查询处理</h2><p style="text-indent:2em">关系数据库管理系统的查询处理可以分为四个阶段：</p>

<ul>
<li>查询分析：对语句进行词法分析和语法分析，并进行检查。</li>
<li>查询检查：对语句进行语义检查，检查数据字典中是否有语句中的数据对象，用户是否有存取权限，是否是对视图的查询(需要进行消解)，是否违反完整性约束。检查通过后将语句转化为内部表示，即等价的<strong>关系代数表达式</strong>，并用查询树表示。</li>
<li>查询优化：对查询进行优化。一般包括代数优化和物理优化，代数优化是对关系代数表达式的优化，物理优化则是通过存取路径和底层操作算法的选择进行优化。</li>
<li>查询执行：由代码生成器生成执行查询的代码，执行后返回结果。</li>
</ul>
<h2 id="2-实现查询操作的算法示例"><a href="#2-实现查询操作的算法示例" class="headerlink" title="2.实现查询操作的算法示例"></a>2.实现查询操作的算法示例</h2><h3 id="2-1-选择操作的实现"><a href="#2-1-选择操作的实现" class="headerlink" title="2.1 选择操作的实现"></a>2.1 选择操作的实现</h3><p style="text-indent:2em">简单的选择操作的实现方法如下：</p>

<ul>
<li>简单全表扫描算法：按照次序读出物理块到内存并逐个元组扫描。</li>
<li>索引扫描算法：如果选择条件的属性存在索引，首先通过索引找到满足条件的元组指针，再通过元组指针找到元组。如果有多个选择条件并且都有索引，例如Sdept=CS AND Sage&gt;20，则可以求索引元组指针交集，也可以取出满足一个条件的所有元组，再选出符合第二个条件的。</li>
</ul>
<p style="text-indent:2em">当选择率较低时，索引扫描算法优于全表扫描算法，但选择率较高，或者要查找的元组均匀分布在表中的情况下，全表扫描可能性能更好，因为扫描索引也有开销，对每一个索引码，从B+树根节点到叶子节点的每个节点都要执行一次I/O。</p>

<h3 id="2-2-连接操作的实现"><a href="#2-2-连接操作的实现" class="headerlink" title="2.2 连接操作的实现"></a>2.2 连接操作的实现</h3><p style="text-indent:2em">连接操作是查询处理最常用也最耗时的操作之一，连接操作的一些算法实现如下：</p>

<ul>
<li>嵌套循环算法：对外层循环的元组，检查内层循环的每一个元组，在连接属性上是否相等。</li>
<li>排序-合并算法：先对两表按连接属性排序，取一个表A中的第一个元组，扫描另一个表B中具有相同连接属性的元组并连接，直到遇到了不相同的第一个元组，再返回表A取下一个元组，重复这个过程。对于大表，尽管没有排序时要先进行排序，执行时间仍然会比嵌套循环更少。</li>
<li>索引连接算法：若在表A已经建立了连接属性的索引，对表B的每一个元组，由连接属性值通过表A的索引查找相应的元组，找到后进行连接。</li>
<li>hash join算法：hash join也是处理等值连接的算法。它把连接属性作为hash码，用同一个hash函数把两表中的元组散列到hash表中。第一步划分阶段，创建hash表，对包含较少元组的表处理，把元组分散到hash表的桶中；第二步试探阶段，对另一个表进行一遍处理，把元组也按同一个hash函数散列，找到适当的hash桶，并将匹配的元组连接起来。</li>
</ul>
<h2 id="3-关系数据库系统的查询优化"><a href="#3-关系数据库系统的查询优化" class="headerlink" title="3.关系数据库系统的查询优化"></a>3.关系数据库系统的查询优化</h2><h3 id="3-1-代数优化"><a href="#3-1-代数优化" class="headerlink" title="3.1 代数优化"></a>3.1 代数优化</h3><p style="text-indent:2em">代数优化是基于关系代数等价变换规则的优化方法。关系代数的等价变换规则是一组基本的结合律，串接定律，交换律等。此处直接介绍查询树的启发式优化算法。在查询处理的第二步，查询检查后，会产生查询树，通常使用启发式算法对查询树进行优化，典型的启发式规则有：</p>

<ul>
<li>选择运算尽可能先做：减少计算中间结果。(<strong>最重要的规则</strong>，可以大大减少中间结果的大小)</li>
<li>投影运算和选择运算同时进行：扫描关系时同时完成。</li>
<li>投影和前或后的双目运算结合：没有必要为了去掉字段扫描关系。</li>
<li>把一些选择和笛卡尔积结合为连接运算：连接运算要比笛卡尔积节省很多时间。</li>
<li>找出公共子表达式：如果子表达式的结果重复出现且不太大，可以将该结果存入中间文件。当查询视图时，视图的定义就是公共子表达式。</li>
</ul>
<p style="text-indent:2em">以下是一个代数优化的例子：</p>

<p style="text-indent:2em">对学生-课程数据库，查询信息系学生选修了的所有课程名称。</p>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Cname</span><br><span class="line"><span class="keyword">FROM</span> Student,Course,SC</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno<span class="operator">=</span>SC.Sno </span><br><span class="line"><span class="keyword">AND</span> SC.Cno<span class="operator">=</span>Course.Cno </span><br><span class="line"><span class="keyword">AND</span> Student.Sdept<span class="operator">=</span>’<span class="keyword">IS</span>’;</span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">试画出用关系代数表示的语法树，并用关系代数表达式优化算法对原始的语法树进行优化处理，画出优化后的标准语法树。</p>

<p><img src="/2022/09/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%94%E8%AE%B0/image-20221215104442115.png" alt="image-20221215104442115" style="zoom:50%;"></p>
<p><img src="/2022/09/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%94%E8%AE%B0/image-20221215104459965.png" alt="image-20221215104459965" style="zoom:50%;"></p>
<p><img src="/2022/09/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%94%E8%AE%B0/image-20221215105503438.png" alt="image-20221215105503438" style="zoom: 80%;"></p>
<h3 id="3-2-物理优化"><a href="#3-2-物理优化" class="headerlink" title="3.2 物理优化"></a>3.2 物理优化</h3><p style="text-indent:2em">代数优化改变查询语句中操作的次序和组合，但不涉及底层操作路径。对每一种操作，可以有多种算法，多条存取路径，物理优化就是从多种算法和多条路径中选择高效合理的操作和算法进行查询。选择的方法可以是：</p>

<ul>
<li>基于规则的启发式优化</li>
<li>基于代价估算的优化</li>
<li>两者结合的优化</li>
</ul>
<p><strong>基于启发式规则的存取路径选择优化</strong></p>
<p style="text-indent:2em">对于选择操作，小关系直接使用全表顺序扫描，即使存在索引；大关系则使用以下启发式规则：</p>

<ul>
<li>选择条件为主码=值，选择主码索引</li>
<li>选择条件为非主属性=值，并且存在索引，估算查询结果的元组数目，如果比例较小，例如&lt;10%，可以使用索引扫描，否则还是采用全表顺序扫描</li>
<li>对于选择条件是属性的非等值查询或范围查询，同上，需要估算结果元组数目</li>
<li>对于AND连接的合取选择条件，如果有涉及这些属性的组合索引，优先采用组合索引扫描，某些列上有一般索引，也可以用索引扫描方法</li>
<li>对于OR连接的析取选择条件，一般使用全表顺序扫描</li>
</ul>
<h1 id="第十章-数据库恢复技术"><a href="#第十章-数据库恢复技术" class="headerlink" title="第十章 数据库恢复技术"></a>第十章 数据库恢复技术</h1><h2 id="1-事务的基本概念"><a href="#1-事务的基本概念" class="headerlink" title="1.事务的基本概念"></a>1.事务的基本概念</h2><p style="text-indent:2em">事务是用户定义的一个操作序列，这些操作只能全做或全不做，是不可分割的工作单位。事务开始与结束可以由用户显式控制，如果没有控制，数据库系统会自动划分事务。事务通常以BEGIN TRANSACTION开始，以COMMIT或ROLLBACK结束。COMMIT表示提交，将所有对数据库的更新写到磁盘上的物理数据库中。ROLLBACK表示回滚，当出现某些故障，事务不能继续执行，就撤销所有已完成的操作，回到事务开始时的状态。</p>

<p style="text-indent:2em">事务具有4个特性，原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)，这四个特性被称为事务的ACID特性。</p>

<ul>
<li>原子性：事务是数据库工作的逻辑单位，只能全做或全不做。</li>
<li>一致性：事务必须使数据库从一个一致性状态到另一个一致性状态。</li>
<li>隔离性：一个事务的执行不能被其他事务干扰。</li>
<li>持久性：一个事务一旦提交，对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不对其结果有影响。</li>
</ul>
<h2 id="2-数据库恢复概述"><a href="#2-数据库恢复概述" class="headerlink" title="2.数据库恢复概述"></a>2.数据库恢复概述</h2><p style="text-indent:2em">数据库管理系统必须具有把数据库从错误状态恢复到某一已知的正确状态的功能，这就是数据库的恢复。</p>

<h2 id="3-故障的种类"><a href="#3-故障的种类" class="headerlink" title="3.故障的种类"></a>3.故障的种类</h2><p style="text-indent:2em">数据库系统中可能发生的故障，大致可分为以下几类：</p>

<ul>
<li>事务内部的故障：事务内部的故障有些是事务程序本身可以发现的，有些是非预期的，不能由事务程序处理。事务故障表示事务没有达到预期终点，因此恢复程序要强行回滚该事务，撤销该事务已作出的对数据库的修改，这类恢复操作称为<strong>事务撤销</strong>。</li>
<li>系统故障：系统故障是造成系统停止运转的任何事件，使得系统要重新启动。恢复子系统必须在系统重新启动时进行事务撤销。系统故障时还可能有已完成的事务没有写到物理数据库中，还需要<strong>重做</strong>所有已提交的事务。</li>
<li>介质故障：外存故障，磁盘损坏，磁头碰撞等。这类故障发生概率小，但破坏最大。</li>
<li>计算机病毒：人为的故障或破坏。</li>
</ul>
<p style="text-indent:2em">各类故障对数据库的影响有两种可能，一是数据库本身被破坏，二是数据库没有被破坏，但数据可能不正确。恢复的基本原理是采用<b>冗余</b>。</p>

<h2 id="4-恢复的实现技术"><a href="#4-恢复的实现技术" class="headerlink" title="4.恢复的实现技术"></a>4.恢复的实现技术</h2><h3 id="4-1-数据转储"><a href="#4-1-数据转储" class="headerlink" title="4.1 数据转储"></a>4.1 数据转储</h3><p style="text-indent:2em">数据转储是数据库恢复的基本技术。转储即定期将整个数据库复制到存储介质上保存，作为后备副本。数据库遭到破坏后，可以装入后背副本，将数据库恢复到转储时的状态。为了将数据库恢复到故障发生时的状态，还需要重新运行转储以后的所有更新事务。</p>

<p style="text-indent:2em">转储可分为静态转储和动态转储。</p>

<ul>
<li>静态转储：在系统无运行事务时进行转储。</li>
<li>动态转储：转储期间允许对数据库进行存取和修改。此方式转储和事务可以并发执行，但不能保证转储结束的后备副本正确有效，还需要使用日志文件记录转储期间各事务对数据库的修改。</li>
</ul>
<p style="text-indent:2em">转储还可分为海量转储和增量转储。</p>

<ul>
<li>海量转储：每次转储全部数据库。</li>
<li>增量转储：每次只转储上一次转储后更新过的数据。</li>
</ul>
<p style="text-indent:2em">根据转储时期，转储内容，转储可分为静态海量转储，静态增量转储，动态海量转储，动态增量转储。</p>

<h3 id="4-2-登记日志文件"><a href="#4-2-登记日志文件" class="headerlink" title="4.2 登记日志文件"></a>4.2 登记日志文件</h3><p style="text-indent:2em">日志文件是用来记录事务对数据库的更新操作的文件。日志文件主要有两种格式，<b>以记录为单位的日志文件</b>和<b>以数据块为单位的日志文件</b>。对以记录为单位的日志文件，记录需要登记事务的开始和结束标记，以及所有更新操作，每一个开始和结束标记，更新操作都有一个日志记录，日志记录包含事务标识，操作对象，类型，修改前后的值等。</p>

<p style="text-indent:2em">日志文件的主要作用是：</p>

<ul>
<li>事务故障恢复和系统故障恢复必须用日志文件。</li>
<li>动态转储必须建立日志文件，和后备副本结合恢复数据库。</li>
<li>静态转储也可以建立日志文件，和后备副本结合恢复数据库到故障前某一刻的状态。</li>
</ul>
<p style="text-indent:2em">为保证数据库是可恢复的，登记日志文件时必须遵守两条原则：</p>

<ul>
<li>登记的次序严格按照并发事务执行的时间次序。</li>
<li>必须先写日志文件，后写数据库。</li>
</ul>
<h2 id="5-恢复策略"><a href="#5-恢复策略" class="headerlink" title="5.恢复策略"></a>5.恢复策略</h2><p style="text-indent:2em">不同故障使用不同的故障恢复方法和策略。</p>

<p style="text-indent:2em">事务故障的恢复由系统利用日志文件自动完成，撤销该事务对数据库进行的修改。方式是反向扫描日志文件，找到该事务的更新操作，就进行逆操作，直到读到事务的开始标记。</p>

<p style="text-indent:2em">系统故障的恢复由系统在重新启动时自动完成，不需要用户干预。方式是正向扫描日志文件，找出故障发生前已经提交的事务(存在BEGIN TRANSACTION 和 COMMIT记录)，将其事务标识加入REDO重做队列，将未完成的事务的事务标识记入UNDO撤销队列，然后撤销撤销队列中的事务，重做重做队列中的事务。</p>

<p style="text-indent:2em">介质故障的恢复首先要装入最新的数据库后备副本，使数据库恢复到最近一次转储的一致性状态。对于动态转储的数据库副本，还需要装入转储开始时刻的日志文件副本，进行REDO和UNDO，才能将数据库恢复到一致状态。然后装入转储结束时刻的日志文件副本，重做已经完成的事务，就可以恢复数据库了。</p>

<h2 id="6-具有检查点的恢复技术"><a href="#6-具有检查点的恢复技术" class="headerlink" title="6.具有检查点的恢复技术"></a>6.具有检查点的恢复技术</h2><p style="text-indent:2em">利用日志对数据库恢复时，需要检查所有日志记录，耗费大量时间，还可能将很多已经将更新写入数据库的事务进行了重做，浪费了大量时间。为了解决这些问题，产生了具有检查点的恢复技术。这类技术在日志文件中添加<b>检查点记录</b>，增加了一个<b>重新开始文件</b>，让恢复子系统动态维护日志。</p>

<p style="text-indent:2em">检查点记录的内容包括：</p>

<ul>
<li>建立检查点时刻正在执行的事务清单。</li>
<li>这些事务最近一个日志记录的地址。</li>
</ul>
<p style="text-indent:2em">重新开始文件则记录了各个检查点记录在日志文件中的地址。通过不断记录检查点，就可以只对检查点到故障发生时的事务进行处理，解决上述浪费时间的问题。系统使用检查点恢复的步骤是：</p>

<ul>
<li>从重新开始文件找到最后一个检查点记录在日志文件中的地址，在日志文件中找到最后一个检查点记录。</li>
<li>由检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST，并建立REDO-LIST和UNDO-LIST事务队列，将所有ACTIVE-LIST中的事务先添加到UNDO-LIST。</li>
<li>从检查点开始正向扫描日志文件，将完成的事务从UNDO-LIST转移到REDO-LIST。</li>
<li>重做REDO-LIST中的事务，撤销UNDO-LIST中的事务。</li>
</ul>
<h2 id="7-数据库镜像"><a href="#7-数据库镜像" class="headerlink" title="7.数据库镜像"></a>7.数据库镜像</h2><p style="text-indent:2em">随着存储介质的价格下降，为了应对介质故障，并避免周期性转储的负担，许多数据库管理系统提供了数据库镜像功能，自动将数据库或其中的关键数据复制到另一个磁盘，并自动保证一致性。数据库镜像也可以用于并发操作，让数据被修改时，其他用户可以读镜像数据库的数据，而不用等待。数据库镜像一般只对关键数据和日志文件进行镜像。</p>

<h1 id="第十一章-并发控制"><a href="#第十一章-并发控制" class="headerlink" title="第十一章 并发控制"></a>第十一章 并发控制</h1><h2 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1.概述"></a>1.概述</h2><p style="text-indent:2em">数据库是一个共享资源，供多个用户使用，同一个时刻并发运行的事务数很多。事务不是严格按照一个一个完成的串行顺序执行的，而是并行执行的，并行事务轮流交叉运行。在单处理器上，并行事务并不是真正并行运行的，但减少了处理器空闲时间，提高了系统效率。</p>

<p style="text-indent:2em">事务是并发控制的基本单位，保证事务的ACID特性是事务处理的重要任务。为了保证事务的隔离性和一致性，数据库系统需要对并发操作进行正确调度。并发操作带来的数据不一致性有以下三种：</p>

<ul>
<li>丢失修改：两个事务读入同一数据并修改，其中一个事务的修改丢失。</li>
<li>不可重复读：一个事务读取数据，另一个事务执行了更新操作(修改，删除，插入)，当读取数据的事务重新读取数据时，无法重现前一次读的结果。</li>
<li>读脏数据：一个事务修改某一数据，紧接着另一事务读取该数据，修改数据的事务接下来因为某些原因被撤销，读取数据的事务读到的数据为脏数据，与数据库的数据不一致。</li>
</ul>
<p style="text-indent:2em">并发控制机制就是使用正确的调度使一个用户的事务不受另一个用户的干扰，避免数据的不一致性。</p>

<p style="text-indent:2em">并发控制的主要技术有封锁，时间戳，乐观控制法和多版本并发控制等。</p>

<h2 id="2-封锁"><a href="#2-封锁" class="headerlink" title="2.封锁"></a>2.封锁</h2><p style="text-indent:2em">数据库对数据对象使用两种类型的基本封锁保证数据一致性。</p>

<ul>
<li>排他锁(X锁/写锁)：事务T对数据对象A加上排他锁，则只允许T读取修改A，其他事务不能对A加任何锁，直到T释放该锁。</li>
<li>共享锁(S锁/读锁)：事务T对数据对象A加上共享锁，T只能读取A，其他事务可以对A加共享锁，不可以加排他锁，直到T释放该锁。</li>
</ul>
<h2 id="3-封锁协议"><a href="#3-封锁协议" class="headerlink" title="3.封锁协议"></a>3.封锁协议</h2><p style="text-indent:2em">对数据加锁时，要约定一些规则，这些规则称为封锁协议。</p>

<div class="table-container">
<table>
<thead>
<tr>
<th>封锁协议</th>
<th>一致性保证</th>
<th>协议</th>
</tr>
</thead>
<tbody>
<tr>
<td>一级封锁协议</td>
<td>不丢失修改</td>
<td>事务T在修改数据之前必须加X锁，事务结束释放该锁。</td>
</tr>
<tr>
<td>二级封锁协议</td>
<td>不丢失修改，不读脏数据</td>
<td>在一级封锁协议基础上，事务T在读取数据之前必须<br>加S锁，<br><strong>读完</strong>后释放S锁</td>
</tr>
<tr>
<td>三级封锁协议</td>
<td>不丢失修改，不读脏数据，可重复读</td>
<td>在一级封锁协议基础上，事务T在读取数据之前必须<br>加S锁，<br><strong>事务结束</strong>后释放S锁</td>
</tr>
</tbody>
</table>
</div>
<h2 id="4-活锁和死锁"><a href="#4-活锁和死锁" class="headerlink" title="4.活锁和死锁"></a>4.活锁和死锁</h2><p style="text-indent:2em">和操作系统并发控制一样，封锁会引起活锁和死锁等问题。</p>

<p style="text-indent:2em">活锁是指一个事务等待锁，但是由于许多事务都在等待锁，而每次一个事务释放锁时，总是将锁交给其他等待锁的事务，导致这个事务永远等待锁的情况。避免活锁的方法是使用先来先服务的策略，按照次序让事务获取锁。</p>

<p style="text-indent:2em">死锁的情况是两个事务封锁了两个数据对象，而这两个事务又都需要使用对方当前上锁的数据对象，导致互相等待。在数据库中，解决死锁的问题有两类方法，一类是预防死锁，另一类是允许死锁发生，定期诊断并解除死锁。死锁的预防存在很大的困难，因此数据库普遍采用诊断并解除死锁的方法。</p>

<ul>
<li><p>死锁的预防：</p>
<ul>
<li>一次封锁法：每个事务必须一次将所有要使用的数据全部加锁，否则不能执行。这个方法能有效防止死锁，但一开始就封锁了所有数据，降低了并发度，而且如果要在一开始就封锁所有可能使用的数据对象，只能扩大封锁范围，进一步降低了并发度。</li>
<li>顺序封锁法：预先对数据对象规定一个封锁顺序，按顺序封锁。这种方法的问题为：事务中的数据对象很多且会变化，很难维护一个封锁顺序；封锁请求可以随事务执行动态决定，难以确定所有的封锁对象及顺序。</li>
</ul>
</li>
<li><p>死锁的诊断</p>
<ul>
<li>超时法：如果事务等待时间超过规定时限，就认为发生超时。这种方法时限的确定困难，时限短可能误判死锁，时限长则死锁不能及时发现。</li>
<li>等待图法：用事务等待图表示所有事务的等待情况。并发控制系统周期生成事务等待图，通过检测是否存在回路判断是否出现了死锁。</li>
</ul>
</li>
<li>死锁的解除：数据库通常采用的方法是选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有的锁，使其他事务可以正常运行。</li>
</ul>
<h2 id="5-并发调度的可串行性"><a href="#5-并发调度的可串行性" class="headerlink" title="5.并发调度的可串行性"></a>5.并发调度的可串行性</h2><p style="text-indent:2em">多个事务的并发执行是正确的，当且仅当其<b>结果与按某一次序串行的执行这些事务的结果相同</b>，成这种调度策略为<b>可串行化调度</b>。</p>

<p style="text-indent:2em">可串行性是并发事务正确调度的准则。一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。</p>

<p style="text-indent:2em">接下来介绍判断可串行化调度的<b>充分条件</b>，首先介绍冲突操作。</p>

<ul>
<li>冲突操作：不同的事务对同一个数据的读写操作和写写操作。例如：Ri(x)与Wj(x)，i≠j。</li>
</ul>
<p style="text-indent:2em">两事务的冲突操作或同一事务的两个操作一旦交换顺序，结果就会不同，因此考虑可串行化的调度时，不能交换冲突操作或同一事务的两个操作的顺序。一个调度在保证冲突操作次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度，如果新的调度是串行的，则原调度为<b>冲突可串行化的调度</b>。若一个调度是冲突可串行化的调度，则一定是可串行化的调度。需要注意冲突可串行化是可串行化调度的充分条件，不是必要条件。</p>

<p>例：</p>
<p style="text-indent:2em">有三个事务的一个调度r3(B)r1(A)w3(B)r2(B)r2(A)w2(B)r1(B)w1(A)，该调度是否为冲突可串行化的调度?</p>

<p style="text-indent:2em">该调度是冲突可串行化的调度。</p>

<p style="text-indent:2em">交换r1(A)和w3(B)，得到r3(B)w3(B)r1(A)r2(B)r2(A)w2(B)r1(B)w1(A)</p>

<p style="text-indent:2em">交换r1(A)和w2(B)，得到r3(B)w3(B)w2(B)r2(B)r2(A)r1(A)r1(B)w1(A)</p>

<p style="text-indent:2em">r3(B)w3(B)w2(B)r2(B)r2(A)r1(A)r1(B)w1(A)等价于一个串行调度T3T2T1，因此原调度为冲突可串行化的调度。</p>

<h2 id="6-两段锁协议"><a href="#6-两段锁协议" class="headerlink" title="6.两段锁协议"></a>6.两段锁协议</h2><p style="text-indent:2em">为了保证并发调度的正确性，数据库管理系统需要保证调度是可串行化的。目前数据库管理系统普遍采用<b>两段锁协议</b>实现并发调度的可串行性，从而保证调度的可串行性。</p>

<p style="text-indent:2em">两段锁指两个阶段对数据项加锁和解锁：</p>

<ul>
<li>对任何数据进行读，写操作之前，首先要申请并获得对数据的封锁</li>
<li>在释放一个封锁之后，事务不再申请和获得任何其他封锁</li>
</ul>
<p style="text-indent:2em">两段锁的两段的含义是，事务分为两个阶段，第一阶段获得锁，称为扩展阶段，该阶段只能获得锁，不能释放锁；第二阶段是释放锁，称为收缩阶段，该阶段只能释放锁，不能获得锁。</p>

<p style="text-indent:2em">若并发执行的所有事务都遵守两段锁协议，则这些事务的任何并发调度策略都是可串行化的。不过事务遵守两段锁协议也只是可串行化调度的充分条件，不是必要条件。需要注意，两段锁协议中，第一阶段没有要求一次对所有使用的数据对象加锁，因此不是一次封锁法，是可能产生死锁的。</p>

<p style="text-indent:2em">最后比较一下两段锁协议与三级封锁协议，这两种协议的目的不同，两段锁协议的目的是保证并发调度的正确性，而三级封锁协议的目的是保证数据的一致性。遵守三级封锁协议一定遵守两段锁协议。</p>

<h2 id="7-封锁的粒度"><a href="#7-封锁的粒度" class="headerlink" title="7.封锁的粒度"></a>7.封锁的粒度</h2><h3 id="7-1-多粒度封锁"><a href="#7-1-多粒度封锁" class="headerlink" title="7.1 多粒度封锁"></a>7.1 多粒度封锁</h3><p style="text-indent:2em">封锁对象的大小称为封锁粒度。封锁对象可以是逻辑单元(关系，索引，属性)，也可以是物理单元(页)。封锁粒度越大，并发度越小，系统开销越小。为了平衡开销与并发度，一个系统中应该同时支持多种封锁粒度供不同的事务选择，这种封锁称为<b>多粒度封锁</b>。需要封锁时，考虑封锁开销和并发度两个因素，适当选择合适的封锁粒度。例如处理一个关系的大量元组可以以关系为封锁粒度，处理少量元组的事务可以以元组为封锁粒度，处理多个关系的大量元组的事务可以以数据库为封锁粒度。</p>

<p style="text-indent:2em">多粒度封锁情况可以用多粒度树表示，多粒度树根节点是数据库，表示最大的数据粒度，叶子节点表示最小的数据粒度。多粒度封锁的协议允许多粒度树找那个的每个节点独立加锁，并且一个节点加锁，其后代子节点也被加同样的锁。因此多粒度封锁中的数据可能以两种方式封锁：</p>

<ul>
<li>显式封锁：直接加到数据对象的锁</li>
<li>隐式封锁：由于上级节点加锁导致当前节点加锁</li>
</ul>
<p style="text-indent:2em">显式封锁和隐式封锁的效果是一样的。在对数据对象加锁时，要检查有无显式封锁冲突，还要检查上级节点，检查是否与隐式封锁冲突，也要检查下级节点，判断下级节点的显式封锁是否与当前加锁带来的隐式封锁冲突，这样的检查效率很低，因此引入了一种新型锁提高效率，称为<b>意向锁</b>。</p>

<h3 id="7-2-意向锁"><a href="#7-2-意向锁" class="headerlink" title="7.2 意向锁"></a>7.2 意向锁</h3><p style="text-indent:2em">意向锁的含义是：如果对一个节点加意向锁，说明其下层后代节点正在被加锁；对任一节点加锁时，必须先对其上层节点加意向锁。以下是三种常见用的意向锁：</p>

<ul>
<li>IS锁：对一个数据对象加IS锁，表示其下层节点要加S锁。</li>
<li>IX锁：对一个数据对象加IX锁，表示其下层节点要加X锁。</li>
<li>SIX锁：对一个数据对象加IX锁，表示对其加S锁，再加IX锁。例如事务对某个表加SIX锁，表示事务要读整个表，同时更新个别元组。</li>
</ul>
<p style="text-indent:2em">数据锁的相容矩阵如下：</p>

<div class="table-container">
<table>
<thead>
<tr>
<th>T1/T2</th>
<th>S</th>
<th>X</th>
<th>IS</th>
<th>IX</th>
<th>SIX</th>
</tr>
</thead>
<tbody>
<tr>
<td>S</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>X</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>IS</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td><font color="red">Y</font></td>
<td><font color="red">Y</font></td>
</tr>
<tr>
<td>IX</td>
<td>N</td>
<td>N</td>
<td><font color="red">Y</font></td>
<td><font color="red">Y</font></td>
<td>N</td>
</tr>
<tr>
<td>SIX</td>
<td>N</td>
<td>N</td>
<td><font color="red">Y</font></td>
<td>N</td>
<td>N</td>
</tr>
</tbody>
</table>
</div>
<p style="text-indent:2em">有了意向锁之后，就可以只检查当前数据是否有不相容的锁，上层节点是否有不相容的锁，不需要检查下层后代节点是否有不相容的锁。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://a-y-1.github.io">橙</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://a-y-1.github.io/2022/09/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%94%E8%AE%B0/">https://a-y-1.github.io/2022/09/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://a-y-1.github.io" target="_blank">橙的Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></div><div class="post_share"><div class="social-share" data-image="/../cover/db.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/04/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95V1/" title="刷题记录V1"><img class="cover" src="/img/0105.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">刷题记录V1</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/30/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="git学习笔记"><img class="cover" src="/img/0105.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">git学习笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/a0.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">橙</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">第一章 绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">1.数据库系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%844%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1数据库的4个基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E7%9A%84%E4%BA%A7%E7%94%9F%E5%92%8C%E5%8F%91%E5%B1%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2数据管理技术的产生和发展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3数据库系统的特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">2.数据模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 概念模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%84%E6%88%90%E8%A6%81%E7%B4%A0"><span class="toc-number">1.2.2.</span> <span class="toc-text">*2.2 数据模型的组成要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 常用的数据模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84-%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">*3.数据库系统的结构(三级模式结构)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">2.</span> <span class="toc-text">第二章 关系数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%BD%A2%E5%BC%8F%E5%8C%96%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">1.关系数据结构及形式化定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E5%85%B3%E7%B3%BB"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.</span> <span class="toc-text">2.关系操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1基本的关系操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BB"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2关系数据语言分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">2.3.</span> <span class="toc-text">3.关系的完整性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">4.关系代数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%87%E5%87%86%E8%AF%AD%E8%A8%80SQL"><span class="toc-number">3.</span> <span class="toc-text">第三章 关系数据库标准语言SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">1.数据定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.1模式定义和删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.1.2.</span> <span class="toc-text">2.1 单表查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.1.3.</span> <span class="toc-text">2.2 连接查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.1.4.</span> <span class="toc-text">2.3 嵌套查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E9%9B%86%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.1.5.</span> <span class="toc-text">2.4 集合查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0"><span class="toc-number">3.2.</span> <span class="toc-text">3.数据更新</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%8F%92%E5%85%A5"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.1 插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2 修改数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.3 删除数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%A9%BA%E5%80%BC%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text">4.空值的处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%A7%86%E5%9B%BE"><span class="toc-number">3.4.</span> <span class="toc-text">5.视图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%88%A0%E9%99%A4%E8%A7%86%E5%9B%BE"><span class="toc-number">3.4.1.</span> <span class="toc-text">5.1 定义与删除视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%9F%A5%E8%AF%A2%E8%A7%86%E5%9B%BE"><span class="toc-number">3.4.2.</span> <span class="toc-text">5.2 查询视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE"><span class="toc-number">3.4.3.</span> <span class="toc-text">5.3 更新视图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">4.</span> <span class="toc-text">第四章 数据库安全性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">1.概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6"><span class="toc-number">4.2.</span> <span class="toc-text">2.数据库安全性控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E9%89%B4%E5%88%AB"><span class="toc-number">4.2.1.</span> <span class="toc-text">2.1 用户身份鉴别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6"><span class="toc-number">4.2.2.</span> <span class="toc-text">2.2 存取控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%87%AA%E4%B8%BB%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.3.</span> <span class="toc-text">2.3 自主存取控制方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%BC%BA%E5%88%B6%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.4.</span> <span class="toc-text">2.4 强制存取控制方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%A7%86%E5%9B%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">4.3.</span> <span class="toc-text">3.视图机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AE%A1%E8%AE%A1%E6%9C%BA%E5%88%B6"><span class="toc-number">4.4.</span> <span class="toc-text">4.审计机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86"><span class="toc-number">4.5.</span> <span class="toc-text">5.数据加密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%85%B6%E4%BB%96%E5%AE%89%E5%85%A8%E6%80%A7%E4%BF%9D%E6%8A%A4"><span class="toc-number">4.6.</span> <span class="toc-text">6.其他安全性保护</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">5.</span> <span class="toc-text">第五章 数据库完整性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9E%E4%BD%93%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">5.1.</span> <span class="toc-text">1.实体完整性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">5.2.</span> <span class="toc-text">2.参照完整性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">5.3.</span> <span class="toc-text">3.用户定义的完整性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F%E5%91%BD%E5%90%8D"><span class="toc-number">5.4.</span> <span class="toc-text">4.完整性约束命名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%96%AD%E8%A8%80"><span class="toc-number">5.5.</span> <span class="toc-text">5.断言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">5.6.</span> <span class="toc-text">6.触发器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA"><span class="toc-number">6.</span> <span class="toc-text">第六章 关系数据理论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-1"><span class="toc-number">6.1.</span> <span class="toc-text">1.概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%A7%84%E8%8C%83%E5%8C%96"><span class="toc-number">6.2.</span> <span class="toc-text">2.规范化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"><span class="toc-number">6.2.1.</span> <span class="toc-text">2.1 函数依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%A0%81"><span class="toc-number">6.2.2.</span> <span class="toc-text">2.2 码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%8C%83%E5%BC%8F"><span class="toc-number">6.2.3.</span> <span class="toc-text">2.3 范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2NF"><span class="toc-number">6.2.4.</span> <span class="toc-text">2.4 2NF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3NF"><span class="toc-number">6.2.5.</span> <span class="toc-text">2.5 3NF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-BCNF-%E4%BF%AE%E6%AD%A3%E7%9A%84%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="toc-number">6.2.6.</span> <span class="toc-text">2.6 BCNF(修正的第三范式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-4NF"><span class="toc-number">6.2.7.</span> <span class="toc-text">2.7 4NF</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Armstrong%E5%85%AC%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.3.</span> <span class="toc-text">3.Armstrong公理系统</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.</span> <span class="toc-text">第七章 数据库设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-2"><span class="toc-number">7.1.</span> <span class="toc-text">1.概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">7.2.</span> <span class="toc-text">2.需求分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.3.</span> <span class="toc-text">3.概念结构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-E-R%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.3.1.</span> <span class="toc-text">3.1 E-R模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.3.2.</span> <span class="toc-text">3.2 概念结构设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.4.</span> <span class="toc-text">4.逻辑结构设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.5.</span> <span class="toc-text">5.物理结构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%AD%98%E5%8F%96%E6%96%B9%E6%B3%95%E9%80%89%E6%8B%A9"><span class="toc-number">7.5.1.</span> <span class="toc-text">5.1 存取方法选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%A1%AE%E5%AE%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">7.5.2.</span> <span class="toc-text">5.2 确定数据库的存储结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E6%96%BD%E5%92%8C%E7%BB%B4%E6%8A%A4"><span class="toc-number">7.6.</span> <span class="toc-text">6.数据库的实施和维护</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text">第八章 数据库编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E5%92%8C%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">9.</span> <span class="toc-text">第九章 关系查询处理和查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86"><span class="toc-number">9.1.</span> <span class="toc-text">1.关系数据库系统的查询处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C%E7%9A%84%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">9.2.</span> <span class="toc-text">2.实现查询操作的算法示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%80%89%E6%8B%A9%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.2.1.</span> <span class="toc-text">2.1 选择操作的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.2.2.</span> <span class="toc-text">2.2 连接操作的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">9.3.</span> <span class="toc-text">3.关系数据库系统的查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%BB%A3%E6%95%B0%E4%BC%98%E5%8C%96"><span class="toc-number">9.3.1.</span> <span class="toc-text">3.1 代数优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%89%A9%E7%90%86%E4%BC%98%E5%8C%96"><span class="toc-number">9.3.2.</span> <span class="toc-text">3.2 物理优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF"><span class="toc-number">10.</span> <span class="toc-text">第十章 数据库恢复技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">10.1.</span> <span class="toc-text">1.事务的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%A6%82%E8%BF%B0"><span class="toc-number">10.2.</span> <span class="toc-text">2.数据库恢复概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%85%E9%9A%9C%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">10.3.</span> <span class="toc-text">3.故障的种类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%81%A2%E5%A4%8D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF"><span class="toc-number">10.4.</span> <span class="toc-text">4.恢复的实现技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%82%A8"><span class="toc-number">10.4.1.</span> <span class="toc-text">4.1 数据转储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%99%BB%E8%AE%B0%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="toc-number">10.4.2.</span> <span class="toc-text">4.2 登记日志文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%81%A2%E5%A4%8D%E7%AD%96%E7%95%A5"><span class="toc-number">10.5.</span> <span class="toc-text">5.恢复策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%85%B7%E6%9C%89%E6%A3%80%E6%9F%A5%E7%82%B9%E7%9A%84%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF"><span class="toc-number">10.6.</span> <span class="toc-text">6.具有检查点的恢复技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%95%9C%E5%83%8F"><span class="toc-number">10.7.</span> <span class="toc-text">7.数据库镜像</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">11.</span> <span class="toc-text">第十一章 并发控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-3"><span class="toc-number">11.1.</span> <span class="toc-text">1.概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B0%81%E9%94%81"><span class="toc-number">11.2.</span> <span class="toc-text">2.封锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">11.3.</span> <span class="toc-text">3.封锁协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%B4%BB%E9%94%81%E5%92%8C%E6%AD%BB%E9%94%81"><span class="toc-number">11.4.</span> <span class="toc-text">4.活锁和死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%B9%B6%E5%8F%91%E8%B0%83%E5%BA%A6%E7%9A%84%E5%8F%AF%E4%B8%B2%E8%A1%8C%E6%80%A7"><span class="toc-number">11.5.</span> <span class="toc-text">5.并发调度的可串行性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%B8%A4%E6%AE%B5%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">11.6.</span> <span class="toc-text">6.两段锁协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%B0%81%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6"><span class="toc-number">11.7.</span> <span class="toc-text">7.封锁的粒度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E5%A4%9A%E7%B2%92%E5%BA%A6%E5%B0%81%E9%94%81"><span class="toc-number">11.7.1.</span> <span class="toc-text">7.1 多粒度封锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">11.7.2.</span> <span class="toc-text">7.2 意向锁</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/23/CMU15-418notes(10-18)/" title="CMU15-418notes(10-18)">CMU15-418notes(10-18)</a><time datetime="2023-10-23T02:59:29.000Z" title="发表于 2023-10-23 10:59:29">2023-10-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/13/CMU15-418notes(1-9)/" title="CMU15-418notes(1-9)">CMU15-418notes(1-9)</a><time datetime="2023-10-13T08:34:29.000Z" title="发表于 2023-10-13 16:34:29">2023-10-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/13/Pthread/" title="Pthreads简记">Pthreads简记</a><time datetime="2023-10-13T08:34:29.000Z" title="发表于 2023-10-13 16:34:29">2023-10-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/11/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="高性能计算学习记录">高性能计算学习记录</a><time datetime="2023-09-11T08:50:29.000Z" title="发表于 2023-09-11 16:50:29">2023-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/" title="计算机体系结构：体系结构基础与流水线原理">计算机体系结构：体系结构基础与流水线原理</a><time datetime="2023-04-14T10:27:29.000Z" title="发表于 2023-04-14 18:27:29">2023-04-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/../cover/0105.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 橙</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>