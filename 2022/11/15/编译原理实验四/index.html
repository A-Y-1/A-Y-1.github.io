<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>编译原理实验四 | 橙的Blog</title><meta name="author" content="橙"><meta name="copyright" content="橙"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="实验要求cminus-f的词法分析和语法分析部分已经完成，最终得到的是语法分析树。而为了产生目标代码，还需要将语法分析树转为抽象语法树，通过抽象语法分析树生成中间代码(即IR)，最后使用中间代码来进行优化并生成目标代码。在本实验中，只要完成中间表示IR的生成，语法分析树到抽象语法树的转换已经在框架中提供了，而IR代码到目标代码的生成由clang来完成。  生成IR指令的过程为在访问者模式下访问抽象">
<meta property="og:type" content="article">
<meta property="og:title" content="编译原理实验四">
<meta property="og:url" content="https://a-y-1.github.io/2022/11/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E5%9B%9B/index.html">
<meta property="og:site_name" content="橙的Blog">
<meta property="og:description" content="实验要求cminus-f的词法分析和语法分析部分已经完成，最终得到的是语法分析树。而为了产生目标代码，还需要将语法分析树转为抽象语法树，通过抽象语法分析树生成中间代码(即IR)，最后使用中间代码来进行优化并生成目标代码。在本实验中，只要完成中间表示IR的生成，语法分析树到抽象语法树的转换已经在框架中提供了，而IR代码到目标代码的生成由clang来完成。  生成IR指令的过程为在访问者模式下访问抽象">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://a-y-1.github.io/img/0105.jpg">
<meta property="article:published_time" content="2022-11-15T04:30:29.000Z">
<meta property="article:modified_time" content="2023-09-26T02:29:48.008Z">
<meta property="article:author" content="橙">
<meta property="article:tag" content="编译原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://a-y-1.github.io/img/0105.jpg"><link rel="shortcut icon" href="/img/orange.png"><link rel="canonical" href="https://a-y-1.github.io/2022/11/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E5%9B%9B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '编译原理实验四',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-09-26 10:29:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/a0.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/../cover/0105.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="橙的Blog"><span class="site-name">橙的Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">编译原理实验四</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-15T04:30:29.000Z" title="发表于 2022-11-15 12:30:29">2022-11-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-26T02:29:48.008Z" title="更新于 2023-09-26 10:29:48">2023-09-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="编译原理实验四"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p style="text-indent:2em">cminus-f的词法分析和语法分析部分已经完成，最终得到的是语法分析树。而为了产生目标代码，还需要将语法分析树转为抽象语法树，通过抽象语法分析树生成中间代码(即IR)，最后使用中间代码来进行优化并生成目标代码。在本实验中，只要完成中间表示IR的生成，语法分析树到抽象语法树的转换已经在框架中提供了，而IR代码到目标代码的生成由clang来完成。</p>

<p style="text-indent:2em">生成IR指令的过程为在访问者模式下访问抽象语法树。本次实验要完成的就是访问抽象语法树的相关visit函数，在这些visit函数中要完成IR指令的生成。</p>

<h2 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h2><h3 id="1-使用AST和visit函数生成IR指令"><a href="#1-使用AST和visit函数生成IR指令" class="headerlink" title="1.使用AST和visit函数生成IR指令"></a>1.使用AST和visit函数生成IR指令</h3><p style="text-indent:2em">由于cminus-f的语法还是比lab3中计算器要复杂的多，供参考的抽象语法树的打印代码也还是和生成IR指令由很大差别，在开始编写时存在困难。通过阅读AST的头文件和lab3的visitor.cpp，首先确定了visit函数生成IR指令的过程：</p>

<ul>
<li>visit函数调用当前节点的子节点accept函数，即调用子节点的visit函数</li>
<li>处理当前节点，生成指令</li>
</ul>
<p style="text-indent:2em">若子节点需要向父节点传值，则通过全局变量来实现。在visit节点时还要加入语义分析的部分，判断语义是否正确。</p>

<p style="text-indent:2em">为了进一步弄清楚遍历AST生成IR的过程，在各个visit函数中加入logging信息，也为后续排查错误做好准备。然后首先完成较为简单的表达式处理等部分，通过这个过程逐渐熟悉IR转换和层次关系以及传值的过程，最后完成困难的visit函数。并在实现过程中逐步用简单的cminus程序测试，用logging找到出错的位置，完成逐个函数的设计。</p>

<p style="text-indent:2em">以第一个产生式program->declaration-list为例，首先找到节点的定义，program节点包含一个保存了declaration的vector，因此在visit中要逐个调用这些declaration节点的accept函数。Program只需要产生声明，不需要产生IR，只需要进行语义分析，在语义说明中给出了以下规则：</p>

<ul>
<li>一个程序由一系列声明组成，声明包括了函数声明与变量声明，它们可以以任意顺序排列。</li>
<li>一个程序中至少要有一个声明且最后一个声明必须是 void main(void)形式的函数声明。</li>
</ul>
<p style="text-indent:2em">只需要对第二条进行检查，判断至少有一个声明，且最后一个声明是否是void main(void)形式的函数声明。在Declaration类型的节点中有id和type，进行检查即可，其中type是CminusType类型，在hpp开头枚举。因此Program节点的visit函数如下：</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTProgram &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;Program\n&quot;</span>;</span><br><span class="line">    <span class="comment">//语义检查</span></span><br><span class="line">    <span class="keyword">if</span>(node.declarations.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR: 该程序中没有声明。\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(node.declarations.<span class="built_in">back</span>()-&gt;id==<span class="string">&quot;main&quot;</span>&amp;&amp; node.declarations.<span class="built_in">back</span>()-&gt;type==TYPE_VOID))&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR: 最后一个声明不是void main(void)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//访问declarations子节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> dec: node.declarations)</span><br><span class="line">        dec-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="2-函数参数的处理"><a href="#2-函数参数的处理" class="headerlink" title="2.函数参数的处理"></a>2.函数参数的处理</h3><p style="text-indent:2em">在编写FunDeclaration和Param的visit函数时，不明确参数具体的处理方法。找到lab3中由clang生成的.ll，对于参数的处理都是先分配空间，然后使用store指令将参数值存入分配好的空间。例如以下程序：</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define i32 @<span class="built_in">callee</span>(i32 %<span class="number">0</span>) #<span class="number">0</span> &#123;</span><br><span class="line">    %<span class="number">2</span> = alloca i32</span><br><span class="line">    store i32 %<span class="number">0</span>, i32* %<span class="number">2</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">但是Param的参数只有id，表示的是源程序中的参数名，对于如何找到这个参数产生了疑惑。重新找到lab3中编写的cpp传参的部分，传参是在函数创建以后，通过Function中的iterator获取得到的。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入callee的BasicBlock中的指令</span></span><br><span class="line">std::vector&lt;Value *&gt; args;                      <span class="comment">//获取函数的形参,通过Function中的iterator</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> arg = callee-&gt;<span class="built_in">arg_begin</span>(); arg != callee-&gt;<span class="built_in">arg_end</span>(); arg++) &#123;</span><br><span class="line">    args.<span class="built_in">push_back</span>(*arg);                       <span class="comment">//* 号运算符是从迭代器中取出迭代器当前指向的元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> mul = builder-&gt;<span class="built_in">create_imul</span>(args[<span class="number">0</span>], <span class="built_in">CONST_INT</span>(<span class="number">110</span>));             <span class="comment">//mul = a*2</span></span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">此处获取参数的部分，是直接按lab3提供的gcd_array.cpp仿照编写的，因为理解不够深入，所以在本实验处理参数时又产生了疑惑。回顾lab3此部分代码后，FunDeclaration中的参数存储的部分就没有问题了。与lab3不同的是，FunDeclaration是逐个调用Param的accept函数，完成存储空间分配的，所以需要一个全局变量在FunDeclaration和Param的visit函数之间传递arg。</p>

<h3 id="3-ASTVar的处理"><a href="#3-ASTVar的处理" class="headerlink" title="3.ASTVar的处理"></a>3.ASTVar的处理</h3><p style="text-indent:2em">根据cminus的语义说明，Var可以是整型变量，浮点变量或数组变量。如果是数组变量，需要判断下标是否为负，如果为负则添加neg_idx_except指令退出程序，否则计算对应元素的地址(gep指令)。如果是数组，则下标可能是个表达式，需要确保表达式的返回结果为整型，然后才能进行取元素的操作。</p>

<p style="text-indent:2em">从上面的语义说明可以理解Var是一种变量。但是下面的赋值语义说明：先找到var代表的变量地址（如果是数组，需要先对下标表达式求值），然后对右侧的表达式进行求值，求值结果将在转换成变量类型后存储在先前找到的地址中。同时，存储在var中的值将作为赋值表达式的求值结果。一开始结合Var节点中含有一个表达式，把这句话错误的理解为了在Var的visit函数内要完成找到地址，求表达式的值并赋值的指令。后来为了进一步理解Var变量的visit函数内要产生什么指令，继续阅读了剩下的产生式，最终找到Var出现的两种情况：</p>

<ul>
<li>expression→var = expression | simple-expression</li>
<li>factor→(expression) | var | call | integer | float</li>
</ul>
<p style="text-indent:2em">这两种情况下对于var的处理是不同的。对于第一种情况，var是赋值表达式的一个组成部分，在访问赋值表达式时，应该访问Var，在全局变量ret中保存Var的地址，然后进行赋值，产生store指令；而第二种情况，应该将Var的值取出保存到ret中，作为因子参与计算表达式的计算。因此访问Var节点时，需要知道是从哪种情况访问的，为此添加一个全局变量ifAssign，如果访问赋值语句，就将该变量置为true，访问Var时返回地址。</p>

<p style="text-indent:2em">解决了以上问题后，就可以根据是否有指向expression的指针判断是否为数组，然后取出相应的值或者地址了。如果是数组，还要对下标进行处理。如果下标为负则终止程序，这可以通过跳转到一个仅含终止指令的exitBasicBlock实现。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ifNegative = builder-&gt;<span class="built_in">create_icmp_lt</span>(idx, <span class="built_in">CONST_INT</span>(<span class="number">0</span>));</span><br><span class="line"><span class="comment">//创建exitBasicBlock和正常继续的BasicBlock</span></span><br><span class="line"><span class="keyword">auto</span> exitBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), node.id + <span class="string">&quot;exit&quot;</span>, func);</span><br><span class="line"><span class="keyword">auto</span> nextBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), node.id + <span class="string">&quot;next&quot;</span>, func);</span><br><span class="line"><span class="comment">//条件跳转指令</span></span><br><span class="line">builder-&gt;<span class="built_in">create_cond_br</span>(ifNegative, exitBB, nextBB);</span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">处理非数组变量比较简单，处理数组变量时又产生了问题，因为数组获取元素地址有两种方式，即lab3中的两种getelementptr，分别需要两个偏移和一个偏移。为了明确如何处理数组，得到数组元素的指针，重新比较两种数组的分配的IR形式：</p>

<ul>
<li>%1  = alloca [10 x i32]</li>
<li>%1 = alloca i32*</li>
</ul>
<p style="text-indent:2em">可以看出，第一种分配的是数组，得到的是指向数组的指针。第二种分配的是指针，这个指针是数组的首地址，返回的值是一个指向指针的指针。因此取元素地址时，使用第一种分配方式，直接对%1使用两个偏移的getelementptr，就得到了元素的地址；使用第二种分配方式，需要先使用load取出指针(数组首地址)，然后使用一个偏移获取元素地址。因此在Var的visit函数中，处理如下：</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> var = scope.<span class="built_in">find</span>(node.id);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	处理非数组，数组下标，检查下标不为负....</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//如果var的值是指向数组的指针，需要两个偏移取地址</span></span><br><span class="line"><span class="keyword">if</span>(var-&gt;<span class="built_in">get_type</span>()-&gt;<span class="built_in">get_pointer_element_type</span>()-&gt;<span class="built_in">is_array_type</span>())</span><br><span class="line">    builder-&gt;<span class="built_in">create_gep</span>(var, &#123; <span class="built_in">CONST_INT</span>(<span class="number">0</span>), idx &#125;);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(var-&gt;<span class="built_in">get_type</span>()-&gt;<span class="built_in">get_pointer_element_type</span>()-&gt;<span class="built_in">is_pointer_type</span>())&#123;</span><br><span class="line">    <span class="comment">//从var中取出数组的起始地址</span></span><br><span class="line">    var = builder-&gt;<span class="built_in">create_load</span>(var);          <span class="comment">//a[]的地址</span></span><br><span class="line">    var = builder-&gt;<span class="built_in">create_gep</span>(var, &#123; idx &#125;);  <span class="comment">//a[idx]的地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ERROR: 变量&quot;</span> &lt;&lt; node.id &lt;&lt; <span class="string">&quot;不是一个数组\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">处理好以上两个问题后，剩下的部分就比较简单了。最终完整的Var的visit函数如下：</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTVar &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;Var\n&quot;</span>;</span><br><span class="line">    <span class="comment">//先在作用域找到变量</span></span><br><span class="line">    <span class="keyword">auto</span> var = scope.<span class="built_in">find</span>(node.id);</span><br><span class="line">    <span class="keyword">if</span>(var==<span class="literal">nullptr</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR: 未声明的变量&quot;</span> &lt;&lt; node.id &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">//处理不是数组的情况</span></span><br><span class="line">    <span class="keyword">if</span>(node.expression==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ifAssign)&#123;                             <span class="comment">//直接返回地址</span></span><br><span class="line">            ret = var;</span><br><span class="line">            ifAssign = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//数组的指针即a[]类型就返回数组的起始地址，否则load取值</span></span><br><span class="line">            <span class="keyword">if</span>(var-&gt;<span class="built_in">get_type</span>()-&gt;<span class="built_in">get_pointer_element_type</span>()-&gt;<span class="built_in">is_array_type</span>())</span><br><span class="line">                ret = builder-&gt;<span class="built_in">create_gep</span>(var, &#123;<span class="built_in">CONST_INT</span>(<span class="number">0</span>), <span class="built_in">CONST_INT</span>(<span class="number">0</span>)&#125;);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ret = builder-&gt;<span class="built_in">create_load</span>(var);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理数组的情况</span></span><br><span class="line">    node.expression-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    Value *idx = ret;                             <span class="comment">//下标</span></span><br><span class="line">    <span class="keyword">if</span>(idx-&gt;<span class="built_in">get_type</span>()-&gt;<span class="built_in">is_float_type</span>())          <span class="comment">//如果为浮点类型，转换为整型</span></span><br><span class="line">        idx = builder-&gt;<span class="built_in">create_fptosi</span>(idx, INT32_Type);</span><br><span class="line">    <span class="keyword">auto</span> func = builder-&gt;<span class="built_in">get_insert_block</span>()-&gt;<span class="built_in">get_parent</span>();</span><br><span class="line">    <span class="keyword">auto</span> ifNegative = builder-&gt;<span class="built_in">create_icmp_lt</span>(idx, <span class="built_in">CONST_INT</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//创建exitBasicBlock和正常继续的BasicBlock</span></span><br><span class="line">    <span class="keyword">auto</span> exitBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), node.id + <span class="string">&quot; exit&quot;</span>, func);</span><br><span class="line">    <span class="keyword">auto</span> nextBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), node.id + <span class="string">&quot; next&quot;</span>, func);</span><br><span class="line">    <span class="comment">//条件跳转指令</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_cond_br</span>(ifNegative, exitBB, nextBB);</span><br><span class="line">    <span class="comment">//向exitBB插入退出程序的指令</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(exitBB);</span><br><span class="line">    <span class="keyword">auto</span> fail = scope.<span class="built_in">find</span>(<span class="string">&quot;neg_idx_except&quot;</span>);               </span><br><span class="line">    builder-&gt;<span class="built_in">create_call</span>(<span class="built_in">static_cast</span>&lt;Function*&gt;(fail), &#123;&#125;); </span><br><span class="line">    builder-&gt;<span class="built_in">create_br</span>(nextBB);</span><br><span class="line">    <span class="comment">//向nextBB插入正常执行的指令</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(nextBB);</span><br><span class="line">    <span class="comment">//如果var的值是指向数组的指针，需要两个偏移取地址</span></span><br><span class="line">    <span class="keyword">if</span>(var-&gt;<span class="built_in">get_type</span>()-&gt;<span class="built_in">get_pointer_element_type</span>()-&gt;<span class="built_in">is_array_type</span>())</span><br><span class="line">        builder-&gt;<span class="built_in">create_gep</span>(var, &#123; <span class="built_in">CONST_INT</span>(<span class="number">0</span>), idx &#125;);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(var-&gt;<span class="built_in">get_type</span>()-&gt;<span class="built_in">get_pointer_element_type</span>()-&gt;<span class="built_in">is_pointer_type</span>())&#123;</span><br><span class="line">        <span class="comment">//从var中取出数组的起始地址</span></span><br><span class="line">        var = builder-&gt;<span class="built_in">create_load</span>(var);          <span class="comment">//a[]的地址</span></span><br><span class="line">        var = builder-&gt;<span class="built_in">create_gep</span>(var, &#123; idx &#125;);  <span class="comment">//a[idx]的地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR: 变量&quot;</span> &lt;&lt; node.id &lt;&lt; <span class="string">&quot;不是一个数组\n&quot;</span>;</span><br><span class="line">    <span class="comment">//判断是赋值还是变量引用</span></span><br><span class="line">    <span class="keyword">if</span>(ifAssign)&#123;                             <span class="comment">//直接返回地址</span></span><br><span class="line">        ret = var;</span><br><span class="line">        ifAssign = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = builder-&gt;<span class="built_in">create_load</span>(var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-表达式顺序错误"><a href="#4-表达式顺序错误" class="headerlink" title="4.表达式顺序错误"></a>4.表达式顺序错误</h3><p style="text-indent:2em">在完成了整个实验后，进行测试，发现无法通过最后一个testcase。打开12.minus查看代码，其中有函数调用和一些基本运算，一开始不确定错误在什么位置，因为此时编译已经没有问题了，只可能是语义处理的问题。经过一些尝试后，改写了lab4_test.py，将运行的结果与正确的结果输出，分别为-39和39，通过这个结果将错误定位到函数调用，然后检查生成的.ll代码，发现函数gcd中有一个减法，操作数的顺序错误。因此找到了加法表达式中创建指令时，传值传反了的错误。additive-expression的产生式为：additive-expression -→ additive-expression addop term | term。生成运算指令时，加法表达式的结果应该在左边，编写时没有注意到这个问题，所以导致了结果的错误。修改后，testcases全部通过。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">if</span>(node.op==OP_PLUS)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ifInt)</span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_iadd</span>(addRes, mulRes);     <span class="comment">//addRes在左!</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_fadd</span>(addRes, mulRes);  </span><br><span class="line">    &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h2 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h2><h3 id="1-全局变量与宏定义"><a href="#1-全局变量与宏定义" class="headerlink" title="1.全局变量与宏定义"></a>1.全局变量与宏定义</h3><p style="text-indent:2em">补充了一个CONST_INT()宏定义获取常量值。INT32_Type和FLOAT_TYPE获取int32和float类型。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONST_INT(num) \</span></span><br><span class="line"><span class="meta">    ConstantInt::get((int)num, module.get())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT32_Type \</span></span><br><span class="line"><span class="meta"> Type::get_int32_type(module.get())      </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLOAT_Type \</span></span><br><span class="line"><span class="meta"> Type::get_float_type(module.get())</span></span><br></pre></td></tr></table></figure>
<p style="text-indent:2em">全局变量ret用于节点返回值。arg用于传递参数。ifAssign表示访问Var节点时，应该返回值还是变量地址。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Value* ret;</span><br><span class="line">Value* arg;</span><br><span class="line"><span class="type">bool</span> ifAssign = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-visit函数"><a href="#2-visit函数" class="headerlink" title="2.visit函数"></a>2.visit函数</h3><h4 id="Program"><a href="#Program" class="headerlink" title="Program"></a><strong>Program</strong></h4><p style="text-indent:2em">检查语义后，逐个访问declarations。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTProgram &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;Program\n&quot;</span>;</span><br><span class="line">    <span class="comment">//语义检查</span></span><br><span class="line">    <span class="keyword">if</span>(node.declarations.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR: 该程序中没有声明。\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(node.declarations.<span class="built_in">back</span>()-&gt;id==<span class="string">&quot;main&quot;</span>&amp;&amp; node.declarations.<span class="built_in">back</span>()-&gt;type==TYPE_VOID))&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ERROR: 最后一个声明不是void main(void)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//访问declarations子节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> dec: node.declarations)</span><br><span class="line">        dec-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Num"><a href="#Num" class="headerlink" title="Num"></a>Num</h4><p style="text-indent:2em">数值节点没有子节点，直接进行处理，根据type确认数值类型，然后将值保存到全局变量value中。根据语义规则，只能有整型和浮点数两个类型。但此处的检查是没有必要的，因为其他数据类型会在词法分析时被识别为标识符，在语法分析时就会产生错误。而VOID类型在变量声明时进行检查，保证变量声明只有整型和浮点型。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTNum &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;Num\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(node.type == TYPE_INT)</span><br><span class="line">        ret = <span class="built_in">CONST_INT</span>(node.i_val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node.type == TYPE_FLOAT)</span><br><span class="line">        ret = <span class="built_in">CONST_FP</span>(node.f_val);</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">//没有子节点，直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="VarDeclaration"><a href="#VarDeclaration" class="headerlink" title="VarDeclaration"></a><strong>VarDeclaration</strong></h4><p style="text-indent:2em">根据节点的定义，节点中包含一个类型和一个指针，还有继承自ASTDeclaration的id。对于变量声明节点的处理，需要产生分配空间的IR，在处理时还要区分数组与一般变量(根据节点的指针是否为空区分)，局部变量与全局变量。并且要把声明的变量放入当前作用域中，保证后续使用可以找到。根据语义规则，全局变量需要初始化为0，数组变量声明时，大小应该大于0。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTVarDeclaration &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;VarDeclaration\n&quot;</span>;</span><br><span class="line">    Type *varType;</span><br><span class="line">    <span class="keyword">if</span>(node.type==TYPE_INT)</span><br><span class="line">        varType = INT32_Type;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node.type==TYPE_FLOAT)</span><br><span class="line">        varType = FLOAT_Type;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        std::cout &lt;&lt;<span class="string">&quot;ERROR: 在变量声明中，只有整型和浮点型可以使用\n&quot;</span>;</span><br><span class="line">    <span class="comment">//对变量进行空间分配</span></span><br><span class="line">    <span class="keyword">if</span>(scope.<span class="built_in">in_global</span>())&#123;           <span class="comment">//全局变量</span></span><br><span class="line">        <span class="keyword">if</span>(node.num==<span class="literal">nullptr</span>)&#123;    <span class="comment">//非数组</span></span><br><span class="line">            <span class="keyword">auto</span> initializer = <span class="built_in">CONST_ZERO</span>(varType);</span><br><span class="line">            <span class="keyword">auto</span> globalVar = GlobalVariable::<span class="built_in">create</span>(node.id, <span class="keyword">module</span>.<span class="built_in">get</span>(), varType, <span class="literal">false</span>, initializer);</span><br><span class="line">            scope.<span class="built_in">push</span>(node.id, globalVar);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.num-&gt;i_val&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">auto</span> *array = ArrayType::<span class="built_in">get</span>(varType, node.num-&gt;i_val);</span><br><span class="line">                <span class="keyword">auto</span> initializer = <span class="built_in">CONST_ZERO</span>(array);</span><br><span class="line">                <span class="keyword">auto</span> globalVar = GlobalVariable::<span class="built_in">create</span>(node.id, <span class="keyword">module</span>.<span class="built_in">get</span>(), array, <span class="literal">false</span>, initializer);</span><br><span class="line">                scope.<span class="built_in">push</span>(node.id, globalVar);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;ERROR: 数组长度必须大于0\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;                          <span class="comment">//局部变量</span></span><br><span class="line">        <span class="keyword">if</span>(node.num==<span class="literal">nullptr</span>)&#123;     <span class="comment">//非数组</span></span><br><span class="line">             <span class="keyword">auto</span> localVar = builder-&gt;<span class="built_in">create_alloca</span>(varType);</span><br><span class="line">             scope.<span class="built_in">push</span>(node.id, localVar);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.num-&gt;i_val&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">auto</span> *array = ArrayType::<span class="built_in">get</span>(varType, node.num-&gt;i_val);</span><br><span class="line">                <span class="keyword">auto</span> localVar = builder-&gt;<span class="built_in">create_alloca</span>(array);</span><br><span class="line">                scope.<span class="built_in">push</span>(node.id, localVar);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;ERROR: 数组长度必须大于0\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FunDeclaration"><a href="#FunDeclaration" class="headerlink" title="FunDeclaration"></a><strong>FunDeclaration</strong></h4><p style="text-indent:2em">FunDeclaration节点包含一个形参列表param和复合语句compound-stmt。需要创建的IR是创建函数和创建函数的第一个BasicBlock的指令，然后处理复合语句。在进入函数时要进入函数作用域，创建函数时要处理参数与返回值。对于每个参数，用全局变量取出实参，调用accept函数进行处理，在Param的visit函数中完成存储空间的分配，并加入到函数作用域当中。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTFunDeclaration &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;FunDeclaration\n&quot;</span>;</span><br><span class="line">    Type *retType;                 <span class="comment">//函数返回类型</span></span><br><span class="line">    std::vector&lt;Type *&gt; paramType; <span class="comment">//参数类型</span></span><br><span class="line">    FunctionType *funType;         <span class="comment">//函数类型</span></span><br><span class="line">    <span class="comment">//语义检查</span></span><br><span class="line">    <span class="keyword">if</span>(node.id==<span class="string">&quot;main&quot;</span> &amp;&amp; node.params.<span class="built_in">size</span>()&gt;<span class="number">0</span>)</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;ERROR: main函数必须为void main(void)形式\n&quot;</span>;</span><br><span class="line">    <span class="comment">//确定函数的返回类型</span></span><br><span class="line">    <span class="keyword">if</span>(node.type==TYPE_INT)</span><br><span class="line">        retType = INT32_Type;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node.type==TYPE_FLOAT)</span><br><span class="line">        retType = FLOAT_Type;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node.type==TYPE_VOID)</span><br><span class="line">        retType = Type::<span class="built_in">get_void_type</span>(<span class="keyword">module</span>.<span class="built_in">get</span>());</span><br><span class="line">    <span class="comment">//确定函数的参数类型</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> param : node.params)&#123;</span><br><span class="line">        <span class="keyword">if</span>(param-&gt;isarray)&#123;       <span class="comment">//参数为数组，则参数为数组的首地址指针</span></span><br><span class="line">            <span class="keyword">if</span>(param-&gt;type==TYPE_INT)</span><br><span class="line">                paramType.<span class="built_in">push_back</span>(Type::<span class="built_in">get_int32_ptr_type</span>(<span class="keyword">module</span>.<span class="built_in">get</span>()));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(param-&gt;type==TYPE_FLOAT)</span><br><span class="line">                paramType.<span class="built_in">push_back</span>(Type::<span class="built_in">get_int32_ptr_type</span>(<span class="keyword">module</span>.<span class="built_in">get</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;                    <span class="comment">//参数为整型或浮点型</span></span><br><span class="line">            <span class="keyword">if</span> (param-&gt;type==TYPE_INT)       </span><br><span class="line">                paramType.<span class="built_in">push_back</span>(INT32_Type);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(param-&gt;type==TYPE_FLOAT)</span><br><span class="line">                paramType.<span class="built_in">push_back</span>(FLOAT_Type);     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建函数</span></span><br><span class="line">    funType = FunctionType::<span class="built_in">get</span>(retType, paramType);</span><br><span class="line">    <span class="keyword">auto</span> func = Function::<span class="built_in">create</span>(funType, node.id, <span class="keyword">module</span>.<span class="built_in">get</span>());</span><br><span class="line">    scope.<span class="built_in">push</span>(node.id, func);   <span class="comment">//将函数加入全局作用域</span></span><br><span class="line">    scope.<span class="built_in">enter</span>();               <span class="comment">//进入函数作用域</span></span><br><span class="line">    <span class="keyword">auto</span> entryBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), node.id + <span class="string">&quot;entry&quot;</span>, func);</span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(entryBB);     <span class="comment">//插入指令</span></span><br><span class="line">    <span class="comment">//visit参数节点</span></span><br><span class="line">    std::vector&lt;Value*&gt; args;    <span class="comment">//存储参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> arg = func-&gt;<span class="built_in">arg_begin</span>();arg != func-&gt;<span class="built_in">arg_end</span>();arg++) &#123;</span><br><span class="line">        args.<span class="built_in">push_back</span>(*arg);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; node.params.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> param = node.params[i];</span><br><span class="line">        arg = args[i];           </span><br><span class="line">        param-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理函数体内的语句</span></span><br><span class="line">    node.compound_stmt-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//如果BasicBlock最后没有终止指令，创建返回指令</span></span><br><span class="line">    <span class="keyword">if</span> (builder-&gt;<span class="built_in">get_insert_block</span>()-&gt;<span class="built_in">get_terminator</span>() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (func-&gt;<span class="built_in">get_return_type</span>()-&gt;<span class="built_in">is_void_type</span>())</span><br><span class="line">            builder-&gt;<span class="built_in">create_void_ret</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (func-&gt;<span class="built_in">get_return_type</span>()-&gt;<span class="built_in">is_float_type</span>())</span><br><span class="line">            builder-&gt;<span class="built_in">create_ret</span>(<span class="built_in">CONST_FP</span>(<span class="number">0.0</span>));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            builder-&gt;<span class="built_in">create_ret</span>(<span class="built_in">CONST_INT</span>(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    scope.<span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Param"><a href="#Param" class="headerlink" title="Param"></a><strong>Param</strong></h4><p style="text-indent:2em">在处理参数时，要为参数分配空间，使参数能够保留在函数的作用域内。在lab3中自行编写.ll文件时直接使用参数，不进行存储，直接使用就可以实现相同的逻辑。但在将cminus转换为IR时，cminus的语义规定了每次函数调用都会产生一组独立内存的参数，因此为参数分配空间，并存入作用域。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTParam &amp;node)</span> </span>&#123;     </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;Param\n&quot;</span>; </span><br><span class="line">    Value* paramP; </span><br><span class="line">    <span class="keyword">if</span> (node.isarray) &#123;          <span class="comment">//数组</span></span><br><span class="line">        <span class="keyword">if</span> (node.type==TYPE_INT)        </span><br><span class="line">            paramP = builder-&gt;<span class="built_in">create_alloca</span>(Type::<span class="built_in">get_int32_ptr_type</span>(<span class="keyword">module</span>.<span class="built_in">get</span>()));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node.type==TYPE_FLOAT) </span><br><span class="line">            paramP = builder-&gt;<span class="built_in">create_alloca</span>(Type::<span class="built_in">get_float_ptr_type</span>(<span class="keyword">module</span>.<span class="built_in">get</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                       <span class="comment">//非数组</span></span><br><span class="line">        <span class="keyword">if</span> (node.type==TYPE_INT)       </span><br><span class="line">            paramP = builder-&gt;<span class="built_in">create_alloca</span>(INT32_Type);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node.type==TYPE_FLOAT)</span><br><span class="line">            paramP = builder-&gt;<span class="built_in">create_alloca</span>(FLOAT_Type);</span><br><span class="line">    &#125;</span><br><span class="line">    builder-&gt;<span class="built_in">create_store</span>(arg, paramP);         <span class="comment">//存储参数</span></span><br><span class="line">    scope.<span class="built_in">push</span>(node.id, paramP);                <span class="comment">//加入作用域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CompoundStmt"><a href="#CompoundStmt" class="headerlink" title="CompoundStmt"></a><strong>CompoundStmt</strong></h4><p style="text-indent:2em">每个函数内部都有一个复合语句，根据ASTCompoundStmt的定义，复合语句由局部声明和一系列语句构成。只需要逐个调用相应的accept函数，不需要产生IR。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTCompoundStmt &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;CompoundStmt\n&quot;</span>;</span><br><span class="line">    <span class="comment">//访问局部声明的节点和语句节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> local_declaration: node.local_declarations)</span><br><span class="line">        local_declaration-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> statement: node.statement_list)</span><br><span class="line">        statement-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ExpressionStmt"><a href="#ExpressionStmt" class="headerlink" title="ExpressionStmt"></a><strong>ExpressionStmt</strong></h4><p style="text-indent:2em">ExpressionStmt对应一条表达式或空，只要表达式存在，就处理该表达式。</p>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CminusfBuilder::visit</span><span class="params">(ASTExpressionStmt &amp;node)</span> &#123; </span><br><span class="line">    LOG(DEBUG) &lt;&lt; <span class="string">&quot;ExpressionStmt\n&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (node.expression != nullptr)</span><br><span class="line">		node.expression-&gt;accept(*this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SelectionStmt"><a href="#SelectionStmt" class="headerlink" title="SelectionStmt"></a><strong>SelectionStmt</strong></h4><p style="text-indent:2em">SelectionStmt包含一个条件表达式，一个if语句块，还有可能存在的else语句块。先处理表达式，产生条件跳转语句。如果指向else语句块的指针为空，就说明只有if语句。考虑只有if的情况，在执行到if时，应该通过br指令条件跳转到if语句块或if后的部分。如果还有else语句，则通过br指令条件跳转到if语句块或else语句块，然后从这两个语句块的结尾返回或者跳转到ifelse语句之后的部分。因此在SelectionStmt的visit函数中应该至少生成三个BasicBlock，并生成br指令。根据else指针是否为空判断是否需要生成条件判断为false的BasicBlock。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTSelectionStmt &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;SelectionStmt\n&quot;</span>;</span><br><span class="line">    <span class="comment">//处理条件表达式</span></span><br><span class="line">    <span class="keyword">auto</span> func = builder-&gt;<span class="built_in">get_insert_block</span>()-&gt;<span class="built_in">get_parent</span>();</span><br><span class="line">    node.expression-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">auto</span> retType = ret-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    Value* ifExpression;                         <span class="comment">//条件表达式的结果             </span></span><br><span class="line">    <span class="comment">//根据返回类型处理, 生成比较语句</span></span><br><span class="line">    <span class="keyword">if</span>(retType-&gt;<span class="built_in">is_integer_type</span>())</span><br><span class="line">        ifExpression = builder-&gt;<span class="built_in">create_icmp_gt</span>(ret, <span class="built_in">CONST_ZERO</span>(INT32_Type));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ifExpression = builder-&gt;<span class="built_in">create_fcmp_gt</span>(ret, <span class="built_in">CONST_ZERO</span>(FLOAT_Type));</span><br><span class="line">    <span class="comment">//生成BasicBlock</span></span><br><span class="line">    <span class="keyword">auto</span> ifBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), <span class="string">&quot;ifBasicBlock&quot;</span>, func);</span><br><span class="line">    <span class="keyword">auto</span> elseBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), <span class="string">&quot;elseBasicBlock&quot;</span>, func);</span><br><span class="line">    <span class="keyword">auto</span> afterIfBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), <span class="string">&quot;afterIfBasicBlock&quot;</span>, func);</span><br><span class="line">    <span class="comment">//创建br指令</span></span><br><span class="line">    <span class="keyword">if</span>(node.else_statement==<span class="literal">nullptr</span>)             <span class="comment">//没有else</span></span><br><span class="line">        builder-&gt;<span class="built_in">create_cond_br</span>(ifExpression, ifBB, afterIfBB);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        builder-&gt;<span class="built_in">create_cond_br</span>(ifExpression, ifBB, elseBB);</span><br><span class="line">    <span class="comment">//为ifBB添加IR</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(ifBB);</span><br><span class="line">    node.if_statement-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">if</span> (builder-&gt;<span class="built_in">get_insert_block</span>()-&gt;<span class="built_in">get_terminator</span>() == <span class="literal">nullptr</span>)</span><br><span class="line">		builder-&gt;<span class="built_in">create_br</span>(afterIfBB);</span><br><span class="line">    <span class="comment">//为elseBB添加IR</span></span><br><span class="line">    <span class="keyword">if</span>(node.else_statement!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        builder-&gt;<span class="built_in">set_insert_point</span>(elseBB);</span><br><span class="line">        node.else_statement-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">	    <span class="keyword">if</span> (builder-&gt;<span class="built_in">get_insert_block</span>()-&gt;<span class="built_in">get_terminator</span>() == <span class="literal">nullptr</span>)</span><br><span class="line">		builder-&gt;<span class="built_in">create_br</span>(afterIfBB);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        elseBB-&gt;<span class="built_in">erase_from_parent</span>();</span><br><span class="line">    <span class="comment">//后面的语句块的IR在新的BasicBlock中</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(afterIfBB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="IterationStmt"><a href="#IterationStmt" class="headerlink" title="IterationStmt"></a><strong>IterationStmt</strong></h4><p style="text-indent:2em">与if语句类似，while迭代语句也有一个条件表达式，进行条件跳转。可以创建一个用于判断的ifBasicBlock，一个循环的loopBasicBlock，一个while语句后的afterWhileBasicBlock，添加相应的指令。当条件表达式为True时，进行ifBB->loopBB->ifBB的循环跳转。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTIterationStmt &amp;node)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;IterationStmt\n&quot;</span>;</span><br><span class="line">    <span class="comment">//创建BasicBlock</span></span><br><span class="line">    <span class="keyword">auto</span> func = builder-&gt;<span class="built_in">get_insert_block</span>()-&gt;<span class="built_in">get_parent</span>();</span><br><span class="line">    <span class="keyword">auto</span> ifBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), <span class="string">&quot;ifBasicBlock&quot;</span>, func);</span><br><span class="line">    <span class="keyword">auto</span> loopBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), <span class="string">&quot;loopBasicBlock&quot;</span>, func);</span><br><span class="line">    <span class="keyword">auto</span> afterWhileBB = BasicBlock::<span class="built_in">create</span>(<span class="keyword">module</span>.<span class="built_in">get</span>(), <span class="string">&quot;afterWhileBasicBlock&quot;</span>, func);</span><br><span class="line">    <span class="comment">//跳转到条件表达式判断的BasicBlock</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_br</span>(ifBB);</span><br><span class="line">    <span class="comment">//为ifBB添加IR, 判断条件表达式的结果</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(ifBB);</span><br><span class="line">    node.expression-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">auto</span> retType = ret-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    Value* ifExpression;                         <span class="comment">//条件表达式的结果             </span></span><br><span class="line">    <span class="comment">//根据返回类型处理, 生成比较语句</span></span><br><span class="line">    <span class="keyword">if</span>(retType-&gt;<span class="built_in">is_integer_type</span>())</span><br><span class="line">        ifExpression = builder-&gt;<span class="built_in">create_icmp_gt</span>(ret, <span class="built_in">CONST_ZERO</span>(INT32_Type));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ifExpression = builder-&gt;<span class="built_in">create_fcmp_gt</span>(ret, <span class="built_in">CONST_ZERO</span>(FLOAT_Type));</span><br><span class="line">    <span class="comment">//条件跳转</span></span><br><span class="line">    builder-&gt;<span class="built_in">create_cond_br</span>(ifExpression, loopBB, afterWhileBB);</span><br><span class="line">    <span class="comment">//为loopBB添加IR</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(loopBB);</span><br><span class="line">    node.statement-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (builder-&gt;<span class="built_in">get_insert_block</span>()-&gt;<span class="built_in">get_terminator</span>() == <span class="literal">nullptr</span>)</span><br><span class="line">        builder-&gt;<span class="built_in">create_br</span>(ifBB);</span><br><span class="line">    <span class="comment">//后面的语句块的IR在新的BasicBlock中</span></span><br><span class="line">    builder-&gt;<span class="built_in">set_insert_point</span>(afterWhileBB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ReturnStmt"><a href="#ReturnStmt" class="headerlink" title="ReturnStmt"></a><strong>ReturnStmt</strong></h4><p style="text-indent:2em">返回语句中有一个表达式计算返回值，如果指向该返回语句的指针为空，说明没有返回值，创建一个void返回IR，否则需要调用该表达式的accept函数，并检查返回类型是否和函数的返回类型相同。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTReturnStmt &amp;node)</span> </span>&#123; </span><br><span class="line">	<span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;ReturnStmt\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(node.expression==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        builder-&gt;<span class="built_in">create_void_ret</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node.expression-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//处理返回值，产生返回的IR</span></span><br><span class="line">    <span class="keyword">auto</span> func = builder-&gt;<span class="built_in">get_insert_block</span>()-&gt;<span class="built_in">get_parent</span>();</span><br><span class="line">    <span class="keyword">auto</span> retType = func-&gt;<span class="built_in">get_return_type</span>();</span><br><span class="line">    <span class="keyword">auto</span> resType = ret-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    <span class="keyword">if</span> (retType-&gt;<span class="built_in">is_integer_type</span>() &amp;&amp; resType-&gt;<span class="built_in">is_float_type</span>())</span><br><span class="line">        ret = builder-&gt;<span class="built_in">create_fptosi</span>(ret, INT32_Type);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(retType-&gt;<span class="built_in">is_float_type</span>() &amp;&amp; resType-&gt;<span class="built_in">is_integer_type</span>())</span><br><span class="line">        ret = builder-&gt;<span class="built_in">create_sitofp</span>(ret, FLOAT_Type);</span><br><span class="line">    builder-&gt;<span class="built_in">create_ret</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Var"><a href="#Var" class="headerlink" title="Var"></a><strong>Var</strong></h4><p style="text-indent:2em">在实验难点中已说明。</p>

<h4 id="AssignExpression"><a href="#AssignExpression" class="headerlink" title="AssignExpression"></a>AssignExpression</h4><p style="text-indent:2em">对于Assign语句，将全局变量ifAssign置为true，调用子节点var的accept函数得到变量的地址，然后计算表达式的值，创建store指令将值存入地址。需要确认表达式结果是否与变量类型相同，如果不同需要将表达式结果转换为和变量相同的类型。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTAssignExpression &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;AssignExpression\n&quot;</span>;</span><br><span class="line">    ifAssign = <span class="literal">true</span>;</span><br><span class="line">    node.var-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">auto</span> varAdd = ret;</span><br><span class="line">    node.expression-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//确认表达式结果类型与变量类型相同，不同则进行转换</span></span><br><span class="line">    <span class="keyword">auto</span> varType = varAdd-&gt;<span class="built_in">get_type</span>()-&gt;<span class="built_in">get_pointer_element_type</span>();</span><br><span class="line">    <span class="keyword">auto</span> valueType = ret-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    Value* value = ret;</span><br><span class="line">    <span class="keyword">if</span>(varType!=valueType)&#123;</span><br><span class="line">        <span class="keyword">if</span>(varType==INT32_Type)</span><br><span class="line">            value = builder-&gt;<span class="built_in">create_fptosi</span>(ret, INT32_Type);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            value = builder-&gt;<span class="built_in">create_sitofp</span>(ret, FLOAT_Type);</span><br><span class="line">    &#125;</span><br><span class="line">    builder-&gt;<span class="built_in">create_store</span>(value, varAdd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SimpleExpression"><a href="#SimpleExpression" class="headerlink" title="SimpleExpression"></a>SimpleExpression</h4><p style="text-indent:2em">简单表达式SimpleExpression是一个加法表达式或两个加法表达式的关系运算。在节点中有两个加法表达式的指针和一个运算符类型为RelOp的运算符op，RelOp是一个枚举类型，包含了所有比较运算符。根据语义，对于该节点的处理，应该先处理加法表达式，将表达式的值保存下来，如果两个表达式指针都不为空，说明为关系运算，再比较两个运算结果，根据结果将表达式的值赋为0或1。进行比较时需要注意两个值的类型，整型和浮点型比较时要将整型转换为浮点型。</p>

<p style="text-indent:2em">具体实现中，应该调用加法表达式的accept函数(如果指针不为空)，暂存结果，对于比较运算，根据op生成icmp或fcmp的指令，最后返回的值就是指令结果。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTSimpleExpression &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;SimpleExpression\n&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> ifInt = <span class="literal">true</span>;                      <span class="comment">//表达式结果类型</span></span><br><span class="line">    Value *resL, *resR;</span><br><span class="line">    Type *resLType, *resRType;</span><br><span class="line">    <span class="comment">//计算两个加法表达式</span></span><br><span class="line">    <span class="keyword">if</span>(node.additive_expression_l!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        node.additive_expression_l-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">        resL = ret;</span><br><span class="line">        resLType = ret-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.additive_expression_r!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        node.additive_expression_r-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">        resR = ret;</span><br><span class="line">        resRType = ret-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果只有一个加法表达式, 直接返回表达式的值</span></span><br><span class="line">    <span class="keyword">if</span>(!(node.additive_expression_l!=<span class="literal">nullptr</span> &amp;&amp; node.additive_expression_r!=<span class="literal">nullptr</span>))&#123;</span><br><span class="line">        ret = (node.additive_expression_l!=<span class="literal">nullptr</span>) ? resL : resR;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果有两个加法表达式, 为关系运算</span></span><br><span class="line">    <span class="comment">//先统一类型</span></span><br><span class="line">    <span class="keyword">if</span>(resLType!=resRType)&#123;</span><br><span class="line">        ifInt = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(resLType-&gt;<span class="built_in">is_float_type</span>())        <span class="comment">//左表达式为浮点型，则右表达式从整型转换为浮点型</span></span><br><span class="line">            resL = builder-&gt;<span class="built_in">create_sitofp</span>(resL, FLOAT_Type);</span><br><span class="line">        <span class="keyword">else</span>								 <span class="comment">//左表达式为整型，转换为浮点型</span></span><br><span class="line">            resR = builder-&gt;<span class="built_in">create_sitofp</span>(resR, FLOAT_Type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据关系运算类型，创建指令</span></span><br><span class="line">    <span class="keyword">switch</span> (node.op)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> OP_LE:</span><br><span class="line">        <span class="keyword">if</span>(ifInt)</span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_icmp_le</span>(resL, resR);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_fcmp_le</span>(resL, resR);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">/*其他运算符......*/</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结果为整型</span></span><br><span class="line">    ret = builder-&gt;<span class="built_in">create_zext</span>(ret, INT32_Type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AdditiveExpression"><a href="#AdditiveExpression" class="headerlink" title="AdditiveExpression"></a>AdditiveExpression</h4><p style="text-indent:2em">加法表达式中包含了一个乘法表达式，一个加法表达式和一个运算符。如果加法表达式指针为空，则表达式的值就是乘法表达式的值，否则分别计算两个表达式，调用相应的accept函数，然后进行根据运算符生成加或减指令。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTAdditiveExpression &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;AdditiveExpression\n&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> ifInt = <span class="literal">true</span>;                        <span class="comment">//两个表达式类型</span></span><br><span class="line">    <span class="comment">//如果只有乘法表达式</span></span><br><span class="line">    <span class="keyword">if</span>(node.additive_expression==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        node.term-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有乘法表达式和加法表达式，创建加法或减法指令</span></span><br><span class="line">    node.additive_expression-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);  <span class="comment">//处理加法表达式</span></span><br><span class="line">    <span class="keyword">auto</span> addRes = ret;</span><br><span class="line">    <span class="keyword">auto</span> addType = addRes-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    node.term-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);                 <span class="comment">//处理乘法表达式</span></span><br><span class="line">    <span class="keyword">auto</span> mulRes = ret;</span><br><span class="line">    <span class="keyword">auto</span> mulType = mulRes-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    <span class="comment">//确认类型相同</span></span><br><span class="line">    <span class="keyword">if</span>(addType!=mulType)&#123;</span><br><span class="line">        ifInt = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(addType-&gt;<span class="built_in">is_float_type</span>())</span><br><span class="line">            mulRes = builder-&gt;<span class="built_in">create_sitofp</span>(mulRes, FLOAT_Type);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            addRes = builder-&gt;<span class="built_in">create_sitofp</span>(addRes, INT32_Type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指令</span></span><br><span class="line">    <span class="keyword">if</span>(node.op==OP_PLUS)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ifInt)</span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_iadd</span>(addRes, mulRes);     <span class="comment">//addRes在左!</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_fadd</span>(addRes, mulRes);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ifInt)</span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_isub</span>(addRes, mulRes);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_fsub</span>(addRes, mulRes);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Term"><a href="#Term" class="headerlink" title="Term"></a>Term</h4><p style="text-indent:2em">乘法表达式由乘法表达式和因子或单独一个因子构成。与加法表达式的处理相同。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTTerm &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;Term\n&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> ifInt = <span class="literal">true</span>;                        <span class="comment">//因子和乘法表达式结果类型</span></span><br><span class="line">    <span class="comment">//如果只有因子</span></span><br><span class="line">    <span class="keyword">if</span>(node.term==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        node.factor-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有乘法表达式和因子，创建乘法或除法指令</span></span><br><span class="line">    node.term-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);                 <span class="comment">//处理乘法表达式</span></span><br><span class="line">    <span class="keyword">auto</span> mulRes = ret;</span><br><span class="line">    <span class="keyword">auto</span> mulType = mulRes-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    node.factor-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);               <span class="comment">//处理因子</span></span><br><span class="line">    <span class="keyword">auto</span> factorRes = ret;</span><br><span class="line">    <span class="keyword">auto</span> factorType = factorRes-&gt;<span class="built_in">get_type</span>();</span><br><span class="line">    <span class="comment">//确认类型相同</span></span><br><span class="line">    <span class="keyword">if</span>(factorType!=mulType)&#123;</span><br><span class="line">        ifInt = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(factorType-&gt;<span class="built_in">is_float_type</span>())</span><br><span class="line">            mulRes = builder-&gt;<span class="built_in">create_sitofp</span>(mulRes, FLOAT_Type);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            factorRes = builder-&gt;<span class="built_in">create_sitofp</span>(factorRes, INT32_Type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指令</span></span><br><span class="line">    <span class="keyword">if</span>(node.op==OP_MUL)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ifInt)</span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_imul</span>(mulRes, factorRes);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_fmul</span>(mulRes, factorRes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ifInt)</span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_isdiv</span>(mulRes, factorRes);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret = builder-&gt;<span class="built_in">create_fdiv</span>(mulRes, factorRes);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h4><p style="text-indent:2em">call节点需要创建一条函数调用call指令，从作用域中取出函数，然后根据函数的参数将节点的实参传入，并检查类型是否与函数参数的类型一致，不一致则需要转换为函数的形参类型。创建一个参数列表，将转换好的参数存入列表来调用函数。</p>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CminusfBuilder::visit</span><span class="params">(ASTCall &amp;node)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">LOG</span>(DEBUG) &lt;&lt; <span class="string">&quot;Call\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> func = <span class="built_in">static_cast</span>&lt;Function*&gt;(scope.<span class="built_in">find</span>(node.id));</span><br><span class="line">    <span class="keyword">auto</span> paramType = func-&gt;<span class="built_in">get_function_type</span>()-&gt;<span class="built_in">param_begin</span>();</span><br><span class="line">    <span class="keyword">if</span>(func==<span class="literal">nullptr</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR: 函数&quot;</span> &lt;&lt; node.id &lt;&lt; <span class="string">&quot;未定义\n&quot;</span>;</span><br><span class="line">    <span class="comment">//处理参数</span></span><br><span class="line">    Value *temp;</span><br><span class="line">    std::vector&lt;Value*&gt; args;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> arg: node.args)&#123;</span><br><span class="line">        arg-&gt;<span class="built_in">accept</span>(*<span class="keyword">this</span>);                   <span class="comment">//获取参数值</span></span><br><span class="line">        temp = ret;</span><br><span class="line">        <span class="keyword">auto</span> argType = ret-&gt;<span class="built_in">get_type</span>();       <span class="comment">//处理类型</span></span><br><span class="line">        <span class="keyword">if</span>(argType!=*paramType)</span><br><span class="line">            <span class="keyword">if</span>((*paramType)-&gt;<span class="built_in">is_integer_type</span>())</span><br><span class="line">                temp = builder-&gt;<span class="built_in">create_fptosi</span>(ret, INT32_Type);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp = builder-&gt;<span class="built_in">create_sitofp</span>(ret, FLOAT_Type);</span><br><span class="line">        args.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        paramType++;</span><br><span class="line">    &#125;</span><br><span class="line">    builder-&gt;<span class="built_in">create_call</span>(func, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><h3 id="1-结果验证"><a href="#1-结果验证" class="headerlink" title="1.结果验证"></a>1.结果验证</h3><p style="text-indent:2em">在进行测试，改正编写过程中的一些错误后，编译后运行测试程序，所有测试样例都通过。</p>

<p><img src="/2022/11/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E5%9B%9B/image-20221123173758944.png" alt="image-20221123173758944" style="zoom:50%;"></p>
<h3 id="2-总结"><a href="#2-总结" class="headerlink" title="2.总结"></a>2.总结</h3><p style="text-indent:2em">通过本次实验，理解了从抽象语法树产生中间IR的方法，并进行了实现。在实现过程中，对于IR的指令有了进一步的熟悉与理解，掌握了使用C++接口创建不同IR指令的方法，以及在访问者模式下遍历抽象语法树，完成IR生成的过程。在完成实现时阅读了相关的头文件，语义规则，通过整个实验的框架复习了C++中一些概念和方法。经过四次实验，结合课程所学的原理，理解了编译器的词法分析，语法分析，中间代码生成的过程，也学习了相关工具的使用并进行了实践，清楚了编译器工作的每一个部分的原理和相互之间的配合。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://a-y-1.github.io">橙</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://a-y-1.github.io/2022/11/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E5%9B%9B/">https://a-y-1.github.io/2022/11/15/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E5%9B%9B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://a-y-1.github.io" target="_blank">橙的Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a></div><div class="post_share"><div class="social-share" data-image="/img/0105.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B004/" title="计算机网络自顶向下方法笔记04"><img class="cover" src="/../cover/internet.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机网络自顶向下方法笔记04</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%89/" title="编译原理实验三"><img class="cover" src="/img/0105.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">编译原理实验三</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/10/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7Flex/" title="编译原理实验一：词法分析工具Flex"><img class="cover" src="/img/0105.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-08</div><div class="title">编译原理实验一：词法分析工具Flex</div></div></a></div><div><a href="/2022/11/08/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9ABison/" title="编译原理实验二：Bison"><img class="cover" src="/img/0105.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-08</div><div class="title">编译原理实验二：Bison</div></div></a></div><div><a href="/2022/11/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%89/" title="编译原理实验三"><img class="cover" src="/img/0105.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-13</div><div class="title">编译原理实验三</div></div></a></div><div><a href="/2022/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/" title="编译原理笔记"><img class="cover" src="/img/0105.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-07</div><div class="title">编译原理笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/a0.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">橙</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82"><span class="toc-number">1.</span> <span class="toc-text">实验要求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E9%9A%BE%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">实验难点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8AST%E5%92%8Cvisit%E5%87%BD%E6%95%B0%E7%94%9F%E6%88%90IR%E6%8C%87%E4%BB%A4"><span class="toc-number">2.1.</span> <span class="toc-text">1.使用AST和visit函数生成IR指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">2.函数参数的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-ASTVar%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">3.ASTVar的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%A1%BA%E5%BA%8F%E9%94%99%E8%AF%AF"><span class="toc-number">2.4.</span> <span class="toc-text">4.表达式顺序错误</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.</span> <span class="toc-text">实验设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">1.全局变量与宏定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-visit%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">2.visit函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Program"><span class="toc-number">3.2.1.</span> <span class="toc-text">Program</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Num"><span class="toc-number">3.2.2.</span> <span class="toc-text">Num</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VarDeclaration"><span class="toc-number">3.2.3.</span> <span class="toc-text">VarDeclaration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FunDeclaration"><span class="toc-number">3.2.4.</span> <span class="toc-text">FunDeclaration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Param"><span class="toc-number">3.2.5.</span> <span class="toc-text">Param</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CompoundStmt"><span class="toc-number">3.2.6.</span> <span class="toc-text">CompoundStmt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ExpressionStmt"><span class="toc-number">3.2.7.</span> <span class="toc-text">ExpressionStmt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SelectionStmt"><span class="toc-number">3.2.8.</span> <span class="toc-text">SelectionStmt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IterationStmt"><span class="toc-number">3.2.9.</span> <span class="toc-text">IterationStmt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReturnStmt"><span class="toc-number">3.2.10.</span> <span class="toc-text">ReturnStmt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Var"><span class="toc-number">3.2.11.</span> <span class="toc-text">Var</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AssignExpression"><span class="toc-number">3.2.12.</span> <span class="toc-text">AssignExpression</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SimpleExpression"><span class="toc-number">3.2.13.</span> <span class="toc-text">SimpleExpression</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AdditiveExpression"><span class="toc-number">3.2.14.</span> <span class="toc-text">AdditiveExpression</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Term"><span class="toc-number">3.2.15.</span> <span class="toc-text">Term</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Call"><span class="toc-number">3.2.16.</span> <span class="toc-text">Call</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">实验总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%93%E6%9E%9C%E9%AA%8C%E8%AF%81"><span class="toc-number">4.1.</span> <span class="toc-text">1.结果验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%80%BB%E7%BB%93"><span class="toc-number">4.2.</span> <span class="toc-text">2.总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/13/CMU15-418notes(1-9)/" title="CMU15-418notes(1-9)">CMU15-418notes(1-9)</a><time datetime="2023-10-13T08:34:29.000Z" title="发表于 2023-10-13 16:34:29">2023-10-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/13/Pthread/" title="Pthreads简记">Pthreads简记</a><time datetime="2023-10-13T08:34:29.000Z" title="发表于 2023-10-13 16:34:29">2023-10-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/11/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="高性能计算学习记录">高性能计算学习记录</a><time datetime="2023-09-11T08:50:29.000Z" title="发表于 2023-09-11 16:50:29">2023-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86/" title="计算机体系结构：体系结构基础与流水线原理">计算机体系结构：体系结构基础与流水线原理</a><time datetime="2023-04-14T10:27:29.000Z" title="发表于 2023-04-14 18:27:29">2023-04-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/" title="操作系统导论-并发">操作系统导论-并发</a><time datetime="2023-01-06T10:27:29.000Z" title="发表于 2023-01-06 18:27:29">2023-01-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/../cover/0105.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 橙</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>